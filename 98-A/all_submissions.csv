submission_id,username,problem_name,language,code,page,url
1388070358,01snehapandey01,unknown,unknown,"1
import sys
2
3
MOD = 10**9 + 7
4
5
def count_valid_partitions(n, k, scores):
6
    scores.sort()
7
    dp = {}  # Memoization
8
9
    def solve(index, current_partition, total_gap):
10
        if total_gap > k:
11
            return 0
12
        if index == n:
13
            return 1
14
15
        state = (index, tuple(tuple(sorted(team)) for team in sorted(current_partition)), total_gap)
16
        if state in dp:
17
            return dp[state]
18
19
        count = 0
20
        for i in range(len(current_partition)):
21
            new_team = current_partition[i] + (scores[index],)
22
            new_gap = max(new_team) - min(new_team) if len(new_team) > 1 else 0
23
            24
            # Crucial change: Calculate the difference in gap, not the absolute gap
25
            gap_diff = new_gap - (max(current_partition[i]) - min(current_partition[i]) if current_partition[i] else 0)
26
            27
            count = (count + solve(index + 1, current_partition[:i] + [new_team] + current_partition[i+1:], total_gap + gap_diff)) % MOD
28
29
        # Only create a new partition if there are already existing teams, otherwise it is the first team
30
        if current_partition:
31
            count = (count + solve(index + 1, current_partition + [(scores[index],)], total_gap)) % MOD
32
        else:
33
            count = (count + solve(index + 1, [(scores[index],)], total_gap)) % MOD # Correctly handle first team creation
34
35
        dp[state] = count
36
        return count
37
38
    return solve(0, [], 0)
39
40
def main():
41
    input_data = sys.stdin.read().splitlines()
42
    T = int(input_data[0].strip())
43
    index = 1
44
    results = []
45
46
    for _ in range(T):
47
        n, k = map(int, input_data[index].split())
48
        scores = list(map(int, input_data[index + 1].split()))
49
        results.append(str(count_valid_partitions(n, k, scores)))
50
        index += 2
51
52
    print(""\n"".join(results))
53
54
if __name__ == ""__main__"":
55
    main()",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1388070358
1388070399,01snehapandey01,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        7
        int T = sc.nextInt();
8
        9
        for (int t = 0; t < T; t++) {
10
            int n = sc.nextInt();
11
            int m = sc.nextInt();
12
            13
            int[] a = new int[n];
14
            for (int i = 0; i < n; i++) {
15
                a[i] = sc.nextInt();
16
            }
17
            18
            // Prefix sum array
19
            int[] A = new int[n + 1];
20
            for (int i = 0; i < n; i++) {
21
                A[i + 1] = A[i] + a[i];
22
            }
23
            24
            // Using a map to store the DP states
25
            Map<String, Integer> dp = new HashMap<>();
26
            dp.put(m + "","" + 0, 0);
27
            28
            for (int i = 0; i < n; i++) {
29
                Map<String, Integer> ndp = new HashMap<>();
30
                31
                for (Map.Entry<String, Integer> entry : dp.entrySet()) {
32
                    String[] key = entry.getKey().split("","");
33
                    int last = Integer.parseInt(key[0]);
34
                    int s = Integer.parseInt(key[1]);
35
                    int c = entry.getValue();
36
                    37
                    int mx = Math.min(last, m - s);
38
                    for (int b = 0; b <= mx; b++) {
39
                        int ns = s + b;
40
                        int nc = c + (i + 1 < n ? Math.abs(A[i + 1] - ns) : 0);
41
                        String newKey = b + "","" + ns;
42
                        43
                        if (!ndp.containsKey(newKey) || ndp.get(newKey) > nc) {
44
                            ndp.put(newKey, nc);
45
                        }
46
                    }
47
                }
48
                dp = ndp;
49
            }
50
            51
            // Find the minimum moves for the case where the sum of marbles is m
52
            int ans = Integer.MAX_VALUE;
53
            for (Map.Entry<String, Integer> entry : dp.entrySet()) {
54
                String[] key = entry.getKey().split("","");
55
                int s = Integer.parseInt(key[1]);
56
                57
                if (s == m) {
58
                    ans = Math.min(ans, entry.getValue());
59
                }
60
            }
61
            62
            System.out.println(ans);
63
        }
64
        65
        sc.close();
66
    }
67
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1388070399
1387888126,vasuverma063,unknown,unknown,"1
def max_abs_difference(nums):
2
    n = len(nums)
3
    total_sum = sum(nums)
4
    left_sum = 0
5
    max_diff = 0
6
    7
    for i in range(n - 1):
8
        left_sum += nums[i]
9
        right_sum = total_sum - left_sum
10
        max_diff = max(max_diff, abs(left_sum - right_sum))
11
    12
    return max_diff
13
14
T = int(input())
15
for _ in range(T):
16
    n = int(input())
17
    nums = list(map(int, input().split()))
18
    print(max_abs_difference(nums))",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387888126
1387837006,hkailkhuri,unknown,unknown,"1
def solve():
2
3
    import sys
4
5
    data = sys.stdin.read().strip().split()
6
7
    t = int(data[0])
8
9
    idx = 1
10
11
    for _ in range(t):
12
13
        n = int(data[idx]); idx += 1
14
15
        nums = list(map(int, data[idx:idx+n]))
16
17
        idx += n
18
19
        20
21
        total_sum = sum(nums)
22
23
        24
25
        prefix_sum = 0
26
27
        max_diff = 0
28
29
        for i in range(n - 1):
30
31
            prefix_sum += nums[i]
32
33
            diff = abs(2 * prefix_sum - total_sum)
34
35
            if diff > max_diff:
36
37
                max_diff = diff
38
39
        40
41
        print(max_diff)
42
43
solve()",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387837006
1387884166,vasuverma063,unknown,unknown,"1
def product_except_self(arr):
2
    n = len(arr)
3
    result = [1] * n
4
    5
    left_product = 1
6
    for i in range(n):
7
        result[i] = left_product
8
        left_product *= arr[i]
9
    10
    right_product = 1
11
    for i in range(n-1, -1, -1):
12
        result[i] *= right_product
13
        right_product *= arr[i]
14
    15
    return result
16
17
T = int(input())
18
for _ in range(T):
19
    n = int(input())
20
    arr = list(map(int, input().split()))
21
    print("" "".join(map(str, product_except_self(arr))))
22",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387884166
1387887902,vasuverma063,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    if total_energy % N != 0:
4
        return -1  # Impossible to equalize if total energy isn't divisible by N
5
    6
    target = total_energy // N
7
    operations = 0
8
    9
    for i in range(N):
10
        diff = energy[i] - target
11
        if diff % K != 0:
12
            return -1  # If difference is not a multiple of K, equalization isn't possible
13
        operations += abs(diff) // K
14
    15
    return operations // 2  # Each operation affects two stations, so divide by 2
16
17
T = int(input())
18
for _ in range(T):
19
    N, K = map(int, input().split())
20
    energy = list(map(int, input().split()))
21
    print(min_operations_to_equalize(N, K, energy))",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387887902
1387835749,fauzanmujawar971,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835749
1387835918,siddhibsawant221,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
9
        int T = scanner.nextInt(); // Read number of test cases
10
        while (T-- > 0) {
11
            int N = scanner.nextInt(); // Number of power stations
12
13
            int[] nums = new int[N];
14
            for (int i = 0; i < N; i++) {
15
                nums[i] = scanner.nextInt(); // Energy at each station
16
            }
17
18
            // Sort the array first
19
            Arrays.sort(nums);
20
21
            // Create leftPartition and rightPartition arrays
22
            int[] leftPartition = new int[N / 2];
23
            int[] rightPartition = new int[N - N / 2]; // Remainder of the array
24
25
            int sum1 = 0, sum2 = 0;
26
            27
            // Fill the leftPartition (first half)
28
            for (int i = 0; i < N / 2; i++) {
29
                leftPartition[i] = nums[i];
30
                sum1 += leftPartition[i];
31
            }
32
33
            // Fill the rightPartition (second half)
34
            for (int i = N / 2; i < N; i++) {
35
                rightPartition[i - N / 2] = nums[i]; // Correct indexing for rightPartition
36
                sum2 += rightPartition[i - N / 2];
37
            }
38
39
            // Output the difference between the sum of rightPartition and leftPartition
40
            System.out.println(sum2 - sum1);
41
        }
42
43
        scanner.close();
44
    }
45
}
46",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835918
1387835994,siddhibsawant221,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        9
        int t = scanner.nextInt(); // Number of test cases
10
        while (t-- > 0) {
11
            int n = scanner.nextInt(); // Size of the array
12
            int[] nums = new int[n];
13
            14
            for (int i = 0; i < n; i++) {
15
                nums[i] = scanner.nextInt(); // Array elements
16
            }
17
            18
            // Calculate the total sum of the array
19
            int totalSum = 0;
20
            for (int i = 0; i < n; i++) {
21
                totalSum += nums[i];
22
            }
23
            24
            // Calculate prefix sums and compute the maximum absolute difference
25
            int prefixSum = 0;
26
            int maxDiff = Integer.MIN_VALUE;
27
            28
            // Try every possible partition
29
            for (int i = 0; i < n - 1; i++) {
30
                prefixSum += nums[i];
31
                int suffixSum = totalSum - prefixSum;
32
                33
                // Compute the absolute difference for the current partition
34
                int diff = Math.abs(prefixSum - suffixSum);
35
                36
                // Update the maximum difference
37
                maxDiff = Math.max(maxDiff, diff);
38
            }
39
            40
            // Output the maximum absolute difference for this test case
41
            System.out.println(maxDiff);
42
        }
43
        44
        scanner.close();
45
    }
46
}
47",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835994
1387835714,fauzanmujawar971,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835714
1387835501,devanshudandeka1,unknown,unknown,"1
def max_partition_difference(nums):
2
    n = len(nums)
3
    4
    # Calculate the total sum of the array
5
    total_sum = sum(nums)
6
    7
    # Initialize variables to track the prefix sum and maximum difference
8
    left_sum = 0
9
    max_diff = float('-inf')
10
    11
    # Iterate through the array and compute the partition differences
12
    for i in range(n - 1):  # We avoid the last partition (whole array as one subarray)
13
        left_sum += nums[i]  # Sum of the left subarray
14
        right_sum = total_sum - left_sum  # Sum of the right subarray
15
        diff = abs(left_sum - right_sum)  # Absolute difference
16
        max_diff = max(max_diff, diff)  # Track the maximum absolute difference
17
    18
    return max_diff
19
20
# Reading input and running the test cases
21
t = int(input())  # Number of test cases
22
for _ in range(t):
23
    n = int(input())  # Size of the array
24
    nums = list(map(int, input().split()))  # The array of numbers
25
    print(max_partition_difference(nums))
26",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835501
1387835580,kharodnishad,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    ptr = 0
6
    T = int(input[ptr])
7
    ptr += 1
8
    for _ in range(T):
9
        N = int(input[ptr])
10
        K = int(input[ptr+1])
11
        ptr += 2
12
        energy = list(map(int, input[ptr:ptr+N]))
13
        ptr += N
14
        15
        total = sum(energy)
16
        if total % N != 0:
17
            print(-1)
18
            continue
19
        avg = total // N
20
        delta = [e - avg for e in energy]
21
        22
       23
        possible = True
24
        for d in delta:
25
            if d % K != 0:
26
                possible = False
27
                break
28
        if not possible:
29
            print(-1)
30
            continue
31
        32
    33
        s = []
34
        current = 0
35
        for d in delta:
36
            current += d // K
37
            s.append(current)
38
        39
       40
        max_neg_s = max(-si for si in s)
41
        sum_s = sum(s)
42
        total_ops = N * max_neg_s + sum_s
43
        print(total_ops)
44
45
if _name_ == '_main_':
46
    main()",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835580
1387835687,fauzanmujawar971,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387835687
1387835450,devanshudandeka1,unknown,unknown,"1
def max_partition_difference(arr):
2
    total_sum = sum(arr)
3
    left_sum = 0
4
    max_diff = float('-inf')  # Start with the smallest possible value
5
    6
    # Iterate through the array and calculate the partition differences
7
    for i in range(len(arr) - 1):  # We avoid the last partition (whole array as one subarray)
8
        left_sum += arr[i]
9
        right_sum = total_sum - left_sum
10
        diff = abs(left_sum - right_sum)
11
        max_diff = max(max_diff, diff)
12
    13
    return max_diff
14
15
# Example usage:
16
arr = [2, 3, 4]
17
print(max_partition_difference(arr))  # Output: 5
18",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835450
1387835476,abhig3340,unknown,unknown,"1
T = int(input())
2
3
for _ in range(T):
4
    N, K = map(int, input().split())
5
    energy_levels = list(map(int, input().split()))
6
7
    total_energy = sum(energy_levels)
8
9
    if total_energy % N != 0:
10
        print(-1)
11
        continue
12
    13
    target_energy = total_energy // N
14
    current_balance = 0
15
    total_operations = 0
16
17
    for i in range(N):
18
        difference = energy_levels[i] - target_energy
19
        current_balance += difference
20
21
        if current_balance % K != 0:
22
            print(-1)
23
            break
24
        25
        total_operations += abs(current_balance) // K
26
    else:
27
        print(total_operations)
28",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835476
1387835478,unborntadpole,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        n = int(input())
5
        l = list(map(int, input().split()))
6
        max_diff = 0
7
        dict = {
8
            9
        }
10
        for secondArr in range(1,n):
11
            diff = 0
12
            l1 = l[:secondArr]
13
            l2 = l[secondArr:]
14
            diff = abs(sum(l1) - sum(l2))
15
            max_diff = max(diff,max_diff)
16
        print(max_diff)
17
            18
            19
solve()",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835478
1387835363,swathiharish2349,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int solution(vector<int>& arr, int sum, int k){
9
    int n = arr.size();
10
    11
    if(sum%n!=0) return -1;
12
    13
    int avg=sum/n;
14
    15
    int flags=0;
16
    int op=0;
17
    int iteration=0;
18
    while(flags<n){
19
        iteration++;
20
        for(int i=0; i<n; i++){
21
            if(arr[i]>avg){
22
                arr[i]-=k;
23
24
                if(i+1<n) arr[i+1]+=k;
25
                else arr[0]+=k;
26
27
                op++;
28
            }
29
            if(arr[i]==avg) flags++;
30
            // cout<<i<<"" ""<<flags<<endl;
31
        }
32
        if(iteration>n) return -1;
33
    }
34
    35
    return op;
36
    37
}
38
39
int main() {
40
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
41
    int t;
42
    cin>>t;
43
    while(t--){
44
        int n,k;
45
        cin>>n>>k;
46
        vector<int> arr(n);
47
        long long sum=0;
48
        49
        for(int i=0; i<n ;i++){
50
            cin>>arr[i];
51
            sum+=arr[i];
52
        }
53
        54
        int ans=solution(arr, sum, k);
55
        cout<<ans<<endl;
56
    }
57
    return 0;
58
}
59",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835363
1387835421,siddhibsawant221,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
    Scanner scanner = new Scanner(System.in);
9
10
        int T = scanner.nextInt(); // Read number of test cases
11
        while (T-- > 0) {
12
            int N = scanner.nextInt(); // Number of power stations
13
            int K = scanner.nextInt(); // Energy transfer units per operation
14
15
            int[] energy = new int[N];
16
            long totalEnergy = 0;
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextInt(); // Energy at each station
19
                totalEnergy += energy[i];
20
            }
21
22
            // If the total energy is not divisible by N, return -1 (equalization is impossible)
23
            if (totalEnergy % N != 0) {
24
                System.out.println(-1);
25
                continue;
26
            }
27
28
            // Calculate the target energy for each station
29
            long targetEnergy = totalEnergy / N;
30
            long totalSurplus = 0;
31
            long totalDeficit = 0;
32
33
            // Calculate surplus and deficit
34
            for (int i = 0; i < N; i++) {
35
                long diff = energy[i] - targetEnergy;
36
                if (diff > 0) {
37
                    totalSurplus += diff;
38
                } else if (diff < 0) {
39
                    totalDeficit -= diff; // Deficit is positive when the value is negative
40
                }
41
            }
42
43
            // If total surplus or total deficit is not divisible by K, return -1
44
            if (totalSurplus % K != 0 || totalDeficit % K != 0) {
45
                System.out.println(-1);
46
            } else {
47
                // The minimum number of operations is the total surplus divided by K
48
                System.out.println(totalSurplus / K);
49
            }
50
        }
51
52
        scanner.close();
53
    }
54
}",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835421
1387835428,abhig3340,unknown,unknown,"1
T = int(input())
2
3
for _ in range(T):
4
    N, K = map(int, input().split())
5
    energy_levels = list(map(int, input().split()))
6
7
    total_energy = sum(energy_levels)
8
9
    if total_energy % N != 0:
10
        print(-1)
11
        continue
12
    13
    target_energy = total_energy // N
14
    total_operations = 0
15
    current_balance = 0
16
17
    for i in range(N):
18
        difference = energy_levels[i] - target_energy
19
        current_balance += difference
20
        total_operations += abs(current_balance) // K
21
22
    print(total_operations)
23",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835428
1387835361,1_ashwarya,unknown,unknown,"1
import sys
2
input = sys.stdin.read
3
4
def solve():
5
    data = input().splitlines()
6
    idx = 0  
7
    T = int(data[idx])  
8
    idx += 1  
9
    results = []
10
    11
    for _ in range(T):
12
        N, K = map(int, data[idx].split())  
13
        idx += 1
14
        energy = list(map(int, data[idx].split()))
15
        idx += 1
16
        17
        total_energy = sum(energy)
18
        19
        if total_energy % N != 0:
20
            results.append(-1)
21
            continue
22
        23
        target = total_energy // N
24
        operations = 0
25
        current_balance = 0
26
        27
        for i in range(N):
28
            diff = energy[i] - target
29
            current_balance += diff
30
            if current_balance % K != 0:
31
                operations = -1
32
                break
33
            operations += abs(current_balance // K)
34
        35
        results.append(operations)
36
    37
    sys.stdout.write(""\n"".join(map(str, results)) + ""\n"")
38
39
solve()",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835361
1387835314,mehtrevallabh24,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        8
        int t = sc.nextInt();  // Read number of test cases
9
        10
        while (t-- > 0) {
11
            int n = sc.nextInt();  // Read size of the array
12
            int[] nums = new int[n];
13
            14
            // Read the elements of the array
15
            for (int i = 0; i < n; i++) {
16
                nums[i] = sc.nextInt();
17
            }
18
            19
            // Calculate the total sum of the array
20
            int totalSum = 0;
21
            for (int num : nums) {
22
                totalSum += num;
23
            }
24
            25
            // Initialize prefix sum and calculate the max absolute difference
26
            int prefixSum = 0;
27
            int maxDifference = Integer.MIN_VALUE;
28
            29
            // Traverse the array and calculate the difference for each partition
30
            for (int i = 0; i < n - 1; i++) {  // We only partition from 1 to n-1
31
                prefixSum += nums[i];  // Update left sum
32
                int rightSum = totalSum - prefixSum;  // Calculate right sum
33
                int diff = Math.abs(prefixSum - rightSum);  // Calculate the absolute difference
34
                maxDifference = Math.max(maxDifference, diff);  // Track the maximum difference
35
            }
36
            37
            // Output the maximum absolute difference for the current test case
38
            System.out.println(maxDifference);
39
        }
40
        41
        sc.close();
42
    }
43
}
44",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835314
1387835306,swathiharish2349,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int solution(vector<int>& arr, int sum, int k){
9
    int n = arr.size();
10
    11
    if(sum%n!=0) return -1;
12
    13
    int avg=sum/n;
14
    15
    int flags=0;
16
    int op=0;
17
    while(flags<n){
18
        for(int i=0; i<n; i++){
19
            if(arr[i]>avg){
20
                arr[i]-=k;
21
22
                if(i+1<n) arr[i+1]+=k;
23
                else arr[0]+=k;
24
25
                op++;
26
            }
27
            if(arr[i]==avg) flags++;
28
            // cout<<i<<"" ""<<flags<<endl;
29
        }
30
    }
31
    32
    return op;
33
    34
}
35
36
int main() {
37
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
38
    int t;
39
    cin>>t;
40
    while(t--){
41
        int n,k;
42
        cin>>n>>k;
43
        vector<int> arr(n);
44
        long long sum=0;
45
        46
        for(int i=0; i<n ;i++){
47
            cin>>arr[i];
48
            sum+=arr[i];
49
        }
50
        51
        int ans=solution(arr, sum, k);
52
        cout<<ans<<endl;
53
    }
54
    return 0;
55
}
56",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835306
1387835285,baripushpak,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    max_diff = 0
4
    5
    # Compute prefix sums to optimize sum calculation
6
    prefix_sum = [0] * n
7
    prefix_sum[0] = nums[0]
8
    for i in range(1, n):
9
        prefix_sum[i] = prefix_sum[i - 1] + nums[i]
10
    11
    total_sum = prefix_sum[-1]
12
    13
    # Check all partitions
14
    for i in range(1, n):  # Partition point
15
        left_sum = prefix_sum[i - 1]
16
        right_sum = total_sum - left_sum
17
        max_diff = max(max_diff, abs(left_sum - right_sum))
18
    19
    return max_diff
20
21
# Input handling
22
t = int(input())  # Number of test cases
23
results = []
24
25
for _ in range(t):
26
    n = int(input())  # Size of the array
27
    nums = list(map(int, input().split()))  # Array elements
28
    results.append(max_absolute_difference(nums))
29
30
# Output results
31
for res in results:
32
    print(res)",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835285
1387835296,abhig3340,unknown,unknown,"1
def min_op(test_cases):
2
    results = []
3
    4
    for N, K, energs in test_cases:
5
        total_energy = sum(energs)
6
        7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target_energy = total_energy // N
12
        operations = 0
13
        curr_bal = 0
14
        15
        for energy in energs:
16
            curr_bal += energy - target_energy
17
            operations += (curr_bal + K - 1) // K  
18
        19
        results.append(operations)
20
    21
    return results
22
23
def main():
24
    T = int(input())
25
    test_cases = []
26
    27
    for _ in range(T):
28
        N, K = map(int, input().split())
29
        energs = list(map(int, input().split()))
30
        test_cases.append((N, K, energs))
31
    32
    results = min_op(test_cases)
33
    34
    for result in results:
35
        print(result)
36
37
if __name__ == ""__main__"":
38
    main()
39",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835296
1387835289,h1032220319,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <algorithm>
5
6
using namespace std;
7
8
int solve() {
9
    int n, k;
10
    cin >> n >> k;
11
    vector<long long> energy(n);
12
    for (int i = 0; i < n; ++i) {
13
        cin >> energy[i];
14
    }
15
16
    long long total_energy = accumulate(energy.begin(), energy.end(), 0LL);
17
18
    if (total_energy % n != 0) {
19
        return -1;
20
    }
21
22
    long long target_energy = total_energy / n;
23
24
    if (all_of(energy.begin(), energy.end(), [&](long long e){ return e == target_energy; })) {
25
        return 0;
26
    }
27
28
    long long operations = 0;
29
    for (int i = 0; i < n; ++i) {
30
        long long diff = energy[i] - target_energy;
31
        if (diff != 0) {
32
          if(abs(diff) % k != 0) return -1;
33
          operations += abs(diff) / k;
34
        }
35
    }
36
37
    return operations / 2;
38
}
39
40
int main() {
41
    int t;
42
    cin >> t;
43
    while (t--) {
44
        cout << solve() << endl;
45
    }
46
    return 0;
47
}
48",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835289
1387835251,adityagupta2791,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
    total_sum = sum(nums)
3
    left_sum = 0
4
    max_diff = float('-inf')
5
6
  7
    for i in range(n - 1):
8
        left_sum += nums[i]
9
        right_sum = total_sum - left_sum
10
        max_diff = max(max_diff, abs(left_sum - right_sum))
11
    12
    return max_diff
13
14
15
T = int(input())  
16
for _ in range(T):
17
    n = int(input()) 
18
    nums = list(map(int, input().split()))
19
20
21
    print(max_absolute_difference(n, nums))",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835251
1387835259,unborntadpole,unknown,unknown,"1
2
3
def solve():
4
    T = int(input())
5
    for _ in range(T):
6
        N, K = map(int, input().split())  
7
        energy = list(map(int, input().split()))
8
        9
        total_energy = sum(energy)
10
        11
        if total_energy % N != 0:
12
            print(-1)
13
            continue
14
        15
        target_energy = total_energy // N
16
        current_balance = 0
17
        operations = 0
18
        19
        for e in energy:
20
            current_balance += e - target_energy
21
            if current_balance % K != 0:
22
                print(-1)
23
                break
24
            operations += abs(current_balance) // K
25
        else:
26
            print(operations)
27
            28
solve()
29
30",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835259
1387835267,1_ashwarya,unknown,unknown,"1
def min_operations(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1 
6
    7
    target = total_energy // N
8
    operations = 0
9
    current_balance = 0
10
    11
    for i in range(N):
12
        diff = energy[i] - target 
13
        current_balance += diff   
14
        operations += abs(current_balance) // K  
15
        16
    return operations
17
18
T = int(input())  
19
20
for _ in range(T):
21
    N, K = map(int, input().split()) 
22
    energy = list(map(int, input().split()))  
23
24
    result = min_operations(N, K, energy)
25
    print(result)
26",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835267
1387835248,baripushpak,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K, energy = case
6
        total_energy = sum(energy)
7
        8
        # If total energy is not divisible by N, it's impossible to equalize
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target_energy = total_energy // N
14
        difference = [x - target_energy for x in energy]
15
        16
        # Check if it's possible to equalize using K
17
        if any(diff % K != 0 for diff in difference):
18
            results.append(-1)
19
            continue
20
        21
        # Simulate movement in a circular manner
22
        operations = 0
23
        balance = 0
24
        25
        for diff in difference:
26
            balance += diff
27
            operations += abs(balance) // K
28
        29
        results.append(operations)
30
    31
    return results
32
33
# Input handling
34
T = int(input())  # Number of test cases
35
test_cases = []
36
37
for _ in range(T):
38
    N, K = map(int, input().split())
39
    energy = list(map(int, input().split()))
40
    test_cases.append((N, K, energy))
41
42
# Get results
43
results = min_operations_to_equalize_energy(T, test_cases)
44
45
# Print results
46
for res in results:
47
    print(res)",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835248
1387835216,uditbhagat3001,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)
49",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835216
1387835218,mehtrevallabh24,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        8
        int T = sc.nextInt();  // Read number of test cases
9
        10
        for (int t = 0; t < T; t++) {
11
            int N = sc.nextInt();  // Read number of stations
12
            int K = sc.nextInt();  // Read energy units per operation
13
            14
            int[] energy = new int[N];
15
            long totalEnergy = 0;
16
            17
            // Read energy values and calculate total energy
18
            for (int i = 0; i < N; i++) {
19
                energy[i] = sc.nextInt();
20
                totalEnergy += energy[i];
21
            }
22
            23
            // Check if total energy is divisible by N
24
            if (totalEnergy % N != 0) {
25
                System.out.println(-1);  // Impossible to equalize
26
                continue;
27
            }
28
            29
            // Target energy for each station
30
            long targetEnergy = totalEnergy / N;
31
            32
            // Calculate the number of operations required
33
            long operations = 0;
34
            long balance = 0;
35
            36
            for (int i = 0; i < N; i++) {
37
                // Calculate the difference from the target energy
38
                balance += energy[i] - targetEnergy;
39
                40
                // If the balance is not a multiple of K, it's impossible
41
                if (balance % K != 0) {
42
                    operations = -1;
43
                    break;
44
                }
45
                46
                // Accumulate operations based on the absolute balance
47
                operations += Math.abs(balance / K);
48
            }
49
            50
            // Output the result for the current test case
51
            System.out.println(operations);
52
        }
53
        54
        sc.close();
55
    }
56
}
57",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835218
1387835220,anishakarkera737,unknown,unknown,"1
def solve():
2
    import sys
3
    data = sys.stdin.read().strip().split()
4
    t = int(data[0])
5
    idx = 1
6
7
    for _ in range(t):
8
        n = int(data[idx]); idx += 1
9
        nums = list(map(int, data[idx:idx+n]))
10
        idx += n
11
        12
        total_sum = sum(nums)
13
        14
        prefix_sum = 0
15
        max_diff = 0
16
17
        for i in range(n - 1):
18
            prefix_sum += nums[i]
19
            diff = abs(2 * prefix_sum - total_sum)
20
            if diff > max_diff:
21
                max_diff = diff
22
        23
        print(max_diff)
24
25
solve()",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835220
1387835194,siddhibsawant221,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
     Scanner scanner = new Scanner(System.in);
9
10
        int T = scanner.nextInt();  // Read number of test cases
11
        while (T-- > 0) {
12
            int n = scanner.nextInt();  // Read number of nodes
13
            int[] values = new int[n];
14
            for (int i = 0; i < n; i++) {
15
                values[i] = scanner.nextInt();  // Read values of nodes
16
            }
17
18
            // Result array to store the product of all elements except the current one
19
            int[] result = new int[n];
20
21
            // Create two auxiliary arrays to store the product of elements from left and right
22
            int[] leftProduct = new int[n];
23
            int[] rightProduct = new int[n];
24
25
            // Initialize the first element of leftProduct
26
            leftProduct[0] = 1;
27
            for (int i = 1; i < n; i++) {
28
                leftProduct[i] = leftProduct[i - 1] * values[i - 1];
29
            }
30
31
            // Initialize the last element of rightProduct
32
            rightProduct[n - 1] = 1;
33
            for (int i = n - 2; i >= 0; i--) {
34
                rightProduct[i] = rightProduct[i + 1] * values[i + 1];
35
            }
36
37
            // Calculate the result by multiplying corresponding elements of leftProduct and rightProduct
38
            for (int i = 0; i < n; i++) {
39
                result[i] = leftProduct[i] * rightProduct[i];
40
            }
41
42
            // Print the result array
43
            for (int i = 0; i < n; i++) {
44
                System.out.print(result[i] + "" "");
45
            }
46
            System.out.println();
47
        }
48
49
        scanner.close();
50
    }
51
}",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387835194
1387835214,adityagupta2791,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
   5
    if total_energy % N != 0:
6
        return -1
7
8
    target = total_energy // N  
9
    operations = 0
10
    balance = 0
11
12
    for i in range(N):
13
        diff = energy[i] - target 
14
        balance += diff 
15
        16
       17
        if balance % K != 0:
18
            return -1
19
20
        operations += abs(balance) // K  
21
    22
    return operations
23
24
25
T = int(input())  
26
for _ in range(T):
27
    N, K = map(int, input().split())  
28
    energy = list(map(int, input().split())) 
29
    30
   31
    print(min_operations_to_equalize(N, K, energy))",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835214
1387835215,mayureshbhandar1,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def max_absolute_difference(nums):
3
    total_sum = sum(nums)
4
    prefix_sum = 0
5
    max_diff = 0
6
    for i in range(len(nums) - 1):
7
        prefix_sum += nums[i]
8
        right_sum = total_sum - prefix_sum
9
        max_diff = max(max_diff, abs(prefix_sum - right_sum))
10
    return max_diff
11
12
def solve():
13
    t = int(raw_input())
14
    for _ in range(t):
15
        n = int(raw_input())
16
        nums = map(int, raw_input().split())
17
        print max_absolute_difference(nums)
18
19
if __name__ == ""__main__"":
20
    solve()
21",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835215
1387835184,uditbhagat3001,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)
36",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835184
1387835185,baripushpak,unknown,unknown,"1
def calculate_result(values):
2
    n = len(values)
3
    result = [1] * n
4
5
    # Compute the prefix product
6
    prefix = 1
7
    for i in range(n):
8
        result[i] = prefix
9
        prefix *= values[i]
10
11
    # Compute the suffix product and combine with prefix
12
    suffix = 1
13
    for i in range(n - 1, -1, -1):
14
        result[i] *= suffix
15
        suffix *= values[i]
16
17
    return result
18
19
# Input handling for multiple test cases
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n = int(input())  # Number of nodes
23
    values = list(map(int, input().split()))  # Node values
24
    result = calculate_result(values)
25
    print("" "".join(map(str, result)))",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387835185
1387835191,yrawal2004,unknown,unknown,"1
def max_absolute_difference(n, arr):
2
    prefix_sum = [0] * n
3
    prefix_sum[0] = arr[0]
4
5
    # Compute prefix sum
6
    for i in range(1, n):
7
        prefix_sum[i] = prefix_sum[i - 1] + arr[i]
8
9
    total_sum = prefix_sum[-1]  # Sum of entire array
10
    max_diff = 0
11
12
    # Iterate over all valid partition points
13
    for i in range(n - 1):
14
        left_sum = prefix_sum[i]
15
        right_sum = total_sum - left_sum
16
        max_diff = max(max_diff, abs(left_sum - right_sum))
17
18
    return max_diff
19
20
# Read number of test cases
21
t = int(input().strip())
22
23
for _ in range(t):
24
    n = int(input().strip())  # Read array size
25
    arr = list(map(int, input().strip().split()))  # Read array elements
26
    print(max_absolute_difference(n, arr))  # Compute and print result
27",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835191
1387835179,1_ashwarya,unknown,unknown,"1
def min_operations(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K = case[0]
6
        energy = case[1]
7
        8
        total_energy = sum(energy)
9
        10
        11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target = total_energy // N
16
        surplus = 0 
17
        deficit = 0 
18
        19
        for e in energy:
20
            if e > target:
21
                surplus += (e - target)  
22
            elif e < target:
23
                deficit += (target - e)  
24
        25
        if surplus % K != 0 or deficit % K != 0:
26
            results.append(-1)
27
        else:
28
            29
            results.append(surplus // K)  
30
    31
    return results
32
33
T = int(input())  
34
test_cases = []
35
36
for _ in range(T):
37
    N, K = map(int, input().split()) 
38
    energy = list(map(int, input().split()))
39
    test_cases.append(((N, K), energy))  
40
41
results = min_operations(T, test_cases)
42
43
for result in results:
44
    print(result)",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835179
1387835165,mayureshbhandar1,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def compute_node_products(test_cases):
3
    results = []
4
    for n, values in test_cases:
5
        if n < 2:
6
            results.append([0])
7
            continue
8
        prefix = [1] * n
9
        suffix = [1] * n
10
        result = [1] * n
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        for i in range(n - 2, -1, -1):
14
            suffix[i] = suffix[i + 1] * values[i + 1]
15
        for i in range(n):
16
            result[i] = prefix[i] * suffix[i]
17
        results.append(result)
18
    return results
19
20
def main():
21
    import sys
22
    input = sys.stdin.read().strip().split(""\n"")
23
    idx = 0
24
    T = int(input[idx])
25
    idx += 1
26
    test_cases = []
27
    for _ in range(T):
28
        n = int(input[idx])
29
        idx += 1
30
        values = map(int, input[idx].split())
31
        idx += 1
32
        test_cases.append((n, values))
33
    results = compute_node_products(test_cases)
34
    for result in results:
35
        print "" "".join(map(str, result))
36
37
if __name__ == ""__main__"":
38
    main()
39",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387835165
1387835172,suryampandey5942,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <bits/stdc++.h>
6
using namespace std;
7
8
9
int main() {
10
    int t;
11
    cin>>t;
12
    13
    while(t--)
14
    {   
15
        int n;
16
        cin>>n;
17
        18
        vector<int> v(n);
19
        20
        for(int i=0;i<n;i++)
21
        {
22
            int val;
23
            cin>>val;
24
            25
            v[i]=val;
26
        }
27
        28
        long long allSum=accumulate(v.begin(),v.end(),0);
29
        long long preSum=0;
30
        long long maxAns=0;
31
        32
        for(int val=0;val<n-1;val++)
33
        {   
34
            35
            preSum+=v[val];
36
            37
            maxAns=max(maxAns,abs(preSum-(allSum-preSum)));
38
            39
            40
        }
41
        cout<<maxAns<<endl;
42
        43
        44
    }
45
    return 0;
46
}
47",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835172
1387835173,h1032220371,unknown,unknown,"1
t=int(input())
2
for i in range(t):
3
    n=int(input())
4
    nums=list(map(int,input().split()))
5
    left_sum=[0]*n
6
    right_sum=[0]*n
7
    left_sum[0]=nums[0]
8
    right_sum[-1]=nums[-1]
9
    for i in range(1,n):
10
        left_sum[i]=left_sum[i-1]+nums[i]
11
    for i in range(n-2,-1,-1):
12
        right_sum[i]=right_sum[i+1]+nums[i]
13
    max_diff=0
14
    for i in range(n-1):
15
        max_diff=max(max_diff,abs(left_sum[i]-right_sum[i + 1]))
16
    print(max_diff)
17",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835173
1387835154,adityagupta2791,unknown,unknown,"1
def compute_product_excluding_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        total_product = 1
6
        zero_count = values.count(0)
7
8
        if zero_count > 1:
9
            results.append([0] * n)
10
        elif zero_count == 1:
11
            zero_index = values.index(0)
12
            product_except_zero = 1
13
            for i in range(n):
14
                if i != zero_index:
15
                    product_except_zero *= values[i]
16
            result = [0] * n
17
            result[zero_index] = product_except_zero
18
            results.append(result)
19
        else:
20
            for value in values:
21
                total_product *= value
22
            results.append([total_product // value for value in values])
23
24
    return results
25
26
T = int(input())
27
test_cases = [(int(input()), list(map(int, input().split()))) for _ in range(T)]
28
results = compute_product_excluding_self(test_cases)
29
for result in results:
30
    print(*result)",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387835154
1387835158,mahakantsingh113,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # If total energy is not divisible by N, it's impossible to equalize
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target = total_energy // N
9
    operations = 0
10
    diff = 0  # Keeps track of how much energy has been transferred so far
11
    12
    for i in range(N):
13
        # Calculate the difference between the current energy and the target
14
        energy_diff = energy[i] - target
15
        16
        # If the energy_diff is not a multiple of K, it's impossible to balance
17
        if energy_diff % K != 0:
18
            return -1
19
        20
        # Update the difference and count operations
21
        diff += energy_diff
22
        operations += abs(diff) // K
23
    24
    return operations
25
26
def main():
27
    T = int(input())  # Number of test cases
28
    for _ in range(T):
29
        N, K = map(int, input().split())  # Read N and K
30
        energy = list(map(int, input().split()))  # Read the energy values
31
        print(min_operations_to_equalize(N, K, energy))
32
33
# Run the solution for multiple test cases
34
if __name__ == ""__main__"":
35
    main()
36",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835158
1387835152,h1032220866,unknown,unknown,"1
print(5)",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835152
1387835119,1_ashwarya,unknown,unknown,"1
def min_operations(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K = case[0]
6
        energy = case[1]
7
        8
        total_energy = sum(energy)
9
        10
        if total_energy % N != 0:
11
            results.append(-1)
12
            continue
13
        14
        target = total_energy // N
15
        s = 0  
16
        d = 0  
17
        18
        for e in energy:
19
            if e > target:
20
                s += (e - target) // K
21
            elif e < target:
22
                d += (target - e) // K
23
   24
        if s != d:
25
            results.append(-1)
26
        else:
27
            results.append(s)  
28
    29
    return results
30
31
T = int(input())  
32
test_cases = []
33
34
for _ in range(T):
35
    N, K = map(int, input().split()) 
36
    energy = list(map(int, input().split()))
37
    test_cases.append(((N, K), energy))  
38
39
results = min_operations(T, test_cases)
40
for result in results:
41
    print(result)",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835119
1387835139,baripushpak,unknown,unknown,"1
def calculate_result(values):
2
    n = len(values)
3
    result = [1] * n
4
5
    # Compute prefix product for each element
6
    prefix = 1
7
    for i in range(n):
8
        result[i] = prefix
9
        prefix *= values[i]
10
11
    # Compute suffix product and multiply with prefix product
12
    suffix = 1
13
    for i in range(n - 1, -1, -1):
14
        result[i] *= suffix
15
        suffix *= values[i]
16
17
    return result
18
19
# Input handling
20
T = int(input(""Enter the number of test cases: ""))
21
for _ in range(T):
22
    n = int(input(""Enter the number of nodes: ""))
23
    values = list(map(int, input(""Enter the node values: "").split()))
24
    result = calculate_result(values)
25
    print("" "".join(map(str, result)))",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387835139
1387835148,h1032220299,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
9
int main() {
10
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
11
    int a;
12
    cin >>a;
13
    while (a--) {
14
        int n;
15
        cin >> n;
16
        vector<int> nums(n);
17
        for (int i = 0; i < n; ++i) {
18
            cin >> nums[i];
19
        }
20
        vector<long long> prefix_sum(n), suffix_sum(n);
21
        prefix_sum[0] = nums[0];
22
        suffix_sum[n - 1] = nums[n - 1];
23
        for (int i = 1; i < n; ++i) {
24
            prefix_sum[i] = prefix_sum[i - 1] + nums[i];
25
        }
26
        for (int i = n - 2; i >= 0; --i) {
27
            suffix_sum[i] = suffix_sum[i + 1] + nums[i];
28
        }
29
        long long max_diff = 0;
30
        for (int i = 0; i < n - 1; ++i) {
31
            max_diff = max(max_diff, abs(prefix_sum[i] - suffix_sum[i + 1]));
32
        }
33
        cout << max_diff << endl;
34
    }
35
    return 0;
36
}
37",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835148
1387835115,gupta_aniket0408,unknown,unknown,"1
T =  int(input())
2
3
for _ in range(T):
4
    5
    n = int(input())
6
    arr = list(map(int,input().split()))
7
    8
    total = sum(arr)
9
    left = 0
10
    max_diff = 0
11
12
    for i in range(n - 1):
13
        left += arr[i]
14
        right = total - left
15
        max_diff = max(max_diff, abs(left - right))
16
17
    print(max_diff)
18",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835115
1387835107,mayureshbhandar1,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to 
2
def min_operations_to_equalize(N, K, energy):
3
    total_energy = sum(energy)
4
    if total_energy % N != 0:
5
        return -1
6
    target = total_energy // N
7
    operations = 0
8
    balance = 0
9
    for i in range(N):
10
        balance += energy[i] - target
11
        if balance % K != 0:
12
            return -1
13
        operations += abs(balance // K)
14
    return operations
15
16
def solve():
17
    T = int(raw_input())
18
    for _ in range(T):
19
        N, K = map(int, raw_input().split())
20
        energy = map(int, raw_input().split())
21
        print min_operations_to_equalize(N, K, energy)
22
23
if __name__ == ""__main__"":
24
    solve()
25",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835107
1387835108,mehtrevallabh24,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        8
        int T = sc.nextInt();  // Read number of test cases
9
        10
        for (int t = 0; t < T; t++) {
11
            int n = sc.nextInt();  // Read the size of the array
12
            int[] values = new int[n];
13
            for (int i = 0; i < n; i++) {
14
                values[i] = sc.nextInt();  // Read the node values
15
            }
16
            17
            // Step 1: Compute the result array
18
            int[] result = new int[n];
19
            20
            // Step 1.1: Calculate left products and store in result
21
            result[0] = 1;  // There's no element to the left of index 0
22
            for (int i = 1; i < n; i++) {
23
                result[i] = result[i - 1] * values[i - 1];
24
            }
25
            26
            // Step 1.2: Calculate right products and update result
27
            int rightProduct = 1;  // There's no element to the right of the last element
28
            for (int i = n - 1; i >= 0; i--) {
29
                result[i] *= rightProduct;  // Multiply the current result by right product
30
                rightProduct *= values[i];  // Update right product for the next iteration
31
            }
32
            33
            // Output the result array for this test case
34
            for (int i = 0; i < n; i++) {
35
                System.out.print(result[i] + "" "");
36
            }
37
            System.out.println();  // Newline after each test case
38
        }
39
        40
        sc.close();
41
    }
42
}
43",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387835108
1387835106,shivangichouhan1,unknown,unknown,"1
def find_max_subarray_difference(nums, n):
2
3
    """"""
4
5
    Find the maximum absolute difference between sums of two contiguous subarrays
6
7
    """"""
8
9
    # Calculate total sum for reference
10
11
    total_sum = sum(nums)
12
13
    14
15
    # Initialize maximum difference
16
17
    max_diff = float('-inf')
18
19
    20
21
    # Calculate prefix sum up to each index and find maximum difference
22
23
    curr_sum = 0
24
25
    for i in range(n-1):  # We stop at n-1 as we need at least one element in second subarray
26
27
        curr_sum += nums[i]
28
29
        # First subarray sum is curr_sum
30
31
        # Second subarray sum is (total_sum - curr_sum)
32
33
        diff = abs(curr_sum - (total_sum - curr_sum))
34
35
        max_diff = max(max_diff, diff)
36
37
    38
39
    return max_diff
40
41
def solve_test_cases():
42
43
    # Read number of test cases
44
45
    t = int(input())
46
47
    48
49
    # Process each test case
50
51
    for _ in range(t):
52
53
        # Read array size
54
55
        n = int(input())
56
57
        58
59
        # Read array elements
60
61
        nums = list(map(int, input().split()))
62
63
        64
65
        # Find and print maximum difference
66
67
        result = find_max_subarray_difference(nums, n)
68
69
        print(result)
70
71
# Run the solution
72
73
if __name__ == ""__main__"":
74
75
    solve_test_cases()",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835106
1387835099,sushanttiwari074,unknown,unknown,"1
def find_max_subarray_difference(n, nums):
2
    if n < 2:
3
        return 0
4
    prefix_sums = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_sums[i + 1] = prefix_sums[i] + nums[i]
7
    8
    max_difference = 0
9
    total_sum = prefix_sums[n]
10
    for i in range(n - 1):
11
        left_sum = prefix_sums[i + 1]
12
        right_sum = total_sum - left_sum
13
        current_difference = abs(left_sum - right_sum)
14
        max_difference = max(max_difference, current_difference)
15
    16
    return max_difference
17
18
t = int(input())
19
for _ in range(t):
20
    n = int(input())
21
    nums = list(map(int, input().split()))
22
    result = find_max_subarray_difference(n, nums)
23
    print(result)",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835099
1387835102,uditbhagat3001,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835102
1387835083,h1032220319,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
void helper(){
9
    int n; cin>>n;
10
    11
    vector<int> nums(n);
12
    for(int i=0;i<n;i++) cin>>nums[i];
13
    14
    vector<long long> prefixSum(n+1,0);
15
    for(int i=1;i<=n;i++){
16
        prefixSum[i]=prefixSum[i-1]+nums[i-1];
17
    }
18
    long long totalSum=prefixSum[n];
19
    long long maxD=0;
20
    21
    for(int i=1;i<n;++i){
22
        long long sumL=prefixSum[i];
23
        long long sumR=totalSum-sumL;
24
        maxD=max(maxD,abs(sumL-sumR));
25
    }
26
    cout<<maxD<<""\n"";
27
}
28
29
int main() {
30
31
    int in;
32
    cin >>in;
33
    while(in--) helper();
34
    35
    36
    return 0;
37
}
38",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835083
1387835063,suryampandey5942,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
#include <algorithm>
5
using namespace std;
6
7
vector<int> max_absolute_difference(vector<pair<int, vector<int>>>& test_cases) {
8
    vector<int> results;
9
    10
    for (auto& t : test_cases) {
11
        int n = t.first;
12
        vector<int>& nums = t.second;
13
        14
        int total_sum = 0;
15
        for (int num : nums) {
16
            total_sum += num;
17
        }
18
        19
        int prefix_sum = 0;
20
        int max_diff = 0;
21
        22
        // Iterate through possible partitions
23
        for (int i = 0; i < n - 1; i++) {  // Last partition is invalid (requires two non-empty subarrays)
24
            prefix_sum += nums[i];
25
            int suffix_sum = total_sum - prefix_sum;
26
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum));
27
        }
28
        29
        results.push_back(max_diff);
30
    }
31
    32
    return results;
33
}
34
35
int main() {
36
    int t;
37
    cin >> t;
38
    39
    vector<pair<int, vector<int>>> test_cases;
40
    41
    for (int i = 0; i < t; i++) {
42
        int n;
43
        cin >> n;
44
        45
        vector<int> nums(n);
46
        for (int j = 0; j < n; j++) {
47
            cin >> nums[j];
48
        }
49
        50
        test_cases.push_back({n, nums});
51
    }
52
    53
    vector<int> results = max_absolute_difference(test_cases);
54
    55
    for (int res : results) {
56
        cout << res << endl;
57
    }
58
    59
    return 0;
60
}",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835063
1387835078,vishwakarmakara2,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for cs in test_cases:
5
        n, nums = cs
6
        total_sum = sum(nums)
7
        prefix = [0] * n
8
        prefix[0] = nums[0]
9
        10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] + nums[i]
12
        13
        max_diff = 0
14
        for i in range(n - 1):  
15
            left_sum = prefix[i]
16
            right_sum = total_sum - left_sum
17
            max_diff = max(max_diff, abs(left_sum - right_sum))
18
        19
        results.append(max_diff)
20
    21
    return results
22
23
t = int(input())
24
test_cases = []
25
26
for _ in range(t):
27
    n = int(input())
28
    nums = list(map(int, input().split()))
29
    test_cases.append((n, nums))
30
31
results = max_absolute_difference(t, test_cases)
32
for result in results:
33
    print(result)
34",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835078
1387835081,HarshShrivastava,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for test in test_cases:
4
        n, nums = test
5
        prefix = [0] * n
6
        suffix = [0] * n
7
        prefix[0] = nums[0]
8
        for i in range(1, n):
9
            prefix[i] = prefix[i - 1] + nums[i]
10
        suffix[-1] = nums[-1]
11
        for i in range(n - 2, -1, -1):
12
            suffix[i] = suffix[i + 1] + nums[i]
13
14
        max_diff = 0
15
        for i in range(n - 1):
16
            left_sum = prefix[i]
17
            right_sum = suffix[i + 1]
18
            max_diff = max(max_diff, abs(left_sum - right_sum))
19
20
        results.append(max_diff)
21
22
    return results
23
24
t = int(input())
25
test_cases = []
26
for _ in range(t):
27
    n = int(input())
28
    nums = list(map(int, input().split()))
29
    test_cases.append((n, nums))
30
31
results = max_absolute_difference(t, test_cases)
32
for res in results:
33
    print(res)",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835081
1387835045,suryampandey5942,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <bits/stdc++.h>
6
using namespace std;
7
8
9
int main() {
10
    int t;
11
    cin>>t;
12
    13
    while(t--)
14
    {   
15
        int n;
16
        cin>>n;
17
        18
        vector<int> v(n);
19
        20
        for(int i=0;i<n;i++)
21
        {
22
            int val;
23
            cin>>val;
24
            25
            v[i]=val;
26
        }
27
        28
        long long allSum=accumulate(v.begin(),v.end(),0);
29
        long long preSum=0;
30
        long long maxAns=0;
31
        32
        for(auto &val:v)
33
        {   
34
            if(val==v.back()) break;
35
            preSum+=val;
36
            37
            maxAns=max(maxAns,abs(preSum-(allSum-preSum)));
38
            39
            40
        }
41
        cout<<maxAns<<endl;
42
        43
        44
    }
45
    return 0;
46
}
47",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835045
1387835030,HarshShrivastava,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner sc=new Scanner(System.in);
8
        int t=sc.nextInt();
9
        while(t>0){
10
            int n=sc.nextInt();
11
            int i;
12
            int a[]=new int[n];
13
            long sump=0;
14
            long sumn=0;
15
            for(i=0;i<n;i++){
16
                a[i]=sc.nextInt();
17
                if(a[i]>=0)
18
                    sump+=a[i];
19
                else
20
                    sumn+=a[i];
21
            }
22
            if(sumn!=0)
23
                System.out.println(Math.abs(sump-sumn));
24
            else{
25
                Arrays.sort(a);
26
                System.out.println(Math.abs(sump-a[0]-a[0]));
27
            }
28
            t--;
29
        }
30
    }
31
}",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835030
1387835039,shivangichouhan1,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
3
    total_energy = sum(energy)
4
5
    6
7
    # If total energy is not divisible by N, equalization is impossible
8
9
    if total_energy % N != 0:
10
11
        return -1
12
13
    target = total_energy // N  # Each station should have this amount
14
15
    operations = 0
16
17
    diff = 0  # To track energy imbalance
18
19
    for i in range(N):
20
21
        diff += energy[i] - target  # Calculate running difference
22
23
        # If the difference is not a multiple of K, balancing is impossible
24
25
        if diff % K != 0:
26
27
            return -1
28
29
        operations += abs(diff) // K  # Count number of transfers
30
31
    return operations
32
33
# Read input
34
35
T = int(input())  # Number of test cases
36
37
for _ in range(T):
38
39
    N, K = map(int, input().split())
40
41
    energy = list(map(int, input().split()))
42
43
    print(min_operations_to_equalize(N, K, energy))",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835039
1387835044,swathiharish2349,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include<bits/stdc++.h>
7
using namespace std;
8
9
int operation(vector<int>& arr, int s, int k, int avg){
10
    int n = arr.size();
11
    12
    int op=0;
13
    14
    for(int i=s; i<n; i++){
15
        if(arr[i]>avg){
16
            arr[i]-=k;
17
            op++;
18
            if(i+1<n) arr[i+1]+=k;
19
            else arr[0]+=k;
20
        }
21
    }
22
    23
    for(int i=0; i<s; i++){
24
        if(arr[i]>avg){
25
            arr[i]-=k;
26
            op++;
27
            if(i+1<n) arr[i+1]+=k;
28
            else arr[0]+=k;
29
        }
30
    }
31
    return op;
32
}
33
34
int findStart(vector<int>& arr, int avg, int k){
35
    int n = arr.size();
36
    int maxi=INT_MIN;
37
    int strt=0;
38
    39
    for(int i=0; i<n; i++){
40
        if(arr[i]>maxi){
41
            strt=i;
42
            maxi=arr[i];
43
        }
44
    }
45
    if(maxi==avg) return -1;
46
    47
    return strt;
48
    49
}
50
51
int solution(vector<int>& arr, long long sum, int k){
52
    int n = arr.size();
53
    if(sum%n!=0) return -1;
54
    55
    int avg=sum/n;
56
    57
    58
    int op=0;
59
    // bool flag=true;
60
    while(true){
61
        int strt = findStart(arr, avg, k);
62
        if(strt==-1) return op;
63
        op+=operation(arr,strt,k,avg);
64
    }
65
    return -1; //syntax
66
}
67
68
69
int main() {
70
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
71
    int t;
72
    cin>>t;
73
    while(t--){
74
        int n,k;
75
        cin>>n>>k;
76
        vector<int> arr(n);
77
        long long sum=0;
78
        for(int i=0; i<n; i++){
79
            cin>>arr[i];
80
            sum+=arr[i];
81
        }
82
        83
        int ans = solution(arr, sum, k);
84
        cout<<ans<<endl;
85
    }
86
}
87",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835044
1387835008,jeettrivedi2004,unknown,unknown,"1
test=int(input())
2
for z in range(test):
3
    n,k=map(int,input().split())
4
    l1=list(map(int,input().split()))
5
    sum1=sum(l1)
6
    if sum1%n!=0:
7
        print(-1)
8
    else:
9
        res,total=0,0
10
        avg=sum1//n
11
        l1=[i-avg for i in l1]
12
        for i in l1:
13
            total+=i
14
            if total%k !=0:
15
                print(-1)
16
                break
17
            res+=abs(total)//k
18
        else:
19
            print(res)",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387835008
1387835026,ambujbaranwal,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
3
4
import sys
5
input = sys.stdin.read().split()
6
ptr = 0
7
T = int(input[ptr])
8
ptr += 1
9
for _ in range(T):
10
    n = int(input[ptr])
11
    ptr += 1
12
    values = list(map(int, input[ptr:ptr + n]))
13
    ptr += n
14
15
    prefix = [1] * n
16
    for i in range(1, n):
17
        prefix[i] = prefix[i - 1] * values[i - 1]
18
19
    suffix = [1] * n
20
    for i in range(n - 2, -1, -1):
21
        suffix[i] = suffix[i + 1] * values[i + 1]
22
23
    result = [prefix[i] * suffix[i] for i in range(n)]
24
    print(' '.join(map(str, result)))
25
26",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387835026
1387835000,imharsh1910,unknown,unknown,"1
def maximum_diff(arr):
2
    total_sum = sum(arr)
3
    left_sum = 0
4
    max_diff = 0
5
    6
    for i in range(len(arr) - 1):  
7
        left_sum += arr[i]
8
        right_sum = total_sum - left_sum
9
        max_diff = max(max_diff, abs(left_sum - right_sum))
10
    11
    return max_diff
12
13
14
t = int(input()) 
15
for _ in range(t):
16
    n = int(input())  
17
    arr = list(map(int, input().split())) 
18
    print(maximum_diff(arr))  
19",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387835000
1387834986,h1032220371,unknown,unknown,"1
t=int(input())
2
for i in range(t):
3
    n=int(input())
4
    nums=list(map(int,input().split()))
5
    6
    nums_1=min(nums)
7
    nums_2=sum(nums)-nums_1  
8
    result=abs(nums_1-nums_2)
9
    10
    print(result)",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834986
1387834994,mahakantsingh113,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
int min_operations_to_equalize_energy(int N, int K, vector<int>& energy) {
7
    long long total_energy = 0;
8
    9
    // Calculate total energy
10
    for (int i = 0; i < N; i++) {
11
        total_energy += energy[i];
12
    }
13
    14
    // If total energy is not divisible by N, it's impossible to equalize
15
    if (total_energy % N != 0) {
16
        return -1;
17
    }
18
    19
    long long target = total_energy / N;  // The energy each station should have
20
    long long operations = 0;
21
    long long balance = 0;  // Tracks the cumulative balance of energy
22
    23
    // Traverse through each station to calculate the necessary transfers
24
    for (int i = 0; i < N; i++) {
25
        long long diff = energy[i] - target; // Difference from target energy
26
        balance += diff;  // Update the balance
27
        28
        // If at any point the balance is not divisible by K, it's impossible to balance
29
        if (balance % K != 0) {
30
            return -1;  // Impossible to balance if balance is not divisible by K
31
        }
32
        33
        // Add the absolute number of K-sized moves required
34
        operations += abs(balance / K);
35
    }
36
    37
    return operations;  // Return the total number of operations required
38
}
39
40
int main() {
41
    int T;
42
    cin >> T;  // Number of test cases
43
    44
    while (T--) {
45
        int N, K;
46
        cin >> N >> K;  // Number of stations and the units that can be transferred
47
        48
        vector<int> energy(N);
49
        for (int i = 0; i < N; i++) {
50
            cin >> energy[i];  // Energy at each station
51
        }
52
        53
        // Call the function to get the minimum operations
54
        int result = min_operations_to_equalize_energy(N, K, energy);
55
        cout << result << endl;  // Output the result for each test case
56
    }
57
    58
    return 0;
59
}
60",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834994
1387834999,tanishqsatote369,unknown,unknown,"1
def moe(test_cases):
2
3
    results = []
4
5
    for t in range(len(test_cases)):
6
7
        N, K, energy = test_cases[t]
8
9
        total_energy = sum(energy)
10
11
        if total_energy % N != 0:
12
13
            results.append(-1)
14
15
            continue
16
17
        18
19
        target = total_energy // N
20
21
        operations = 0
22
23
        balance = 0  
24
25
        for i in range(N):
26
27
            balance += energy[i] - target
28
29
            if balance % K != 0:
30
31
                operations = -1
32
33
                break
34
35
            operations += abs(balance) // K
36
37
        38
39
        results.append(operations if operations != -1 else -1)
40
41
    42
43
    return results
44
45
T = int(input())
46
47
test_cases = []
48
49
for _ in range(T):
50
51
    N, K = map(int, input().split())
52
53
    energy = list(map(int, input().split()))
54
55
    test_cases.append((N, K, energy))
56
57
results = moe(test_cases)
58
59
for res in results:
60
61
    print(res)",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834999
1387834982,h1032221631,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for test in test_cases:
4
        n, nums = test
5
        prefix = [0] * n
6
        suffix = [0] * n
7
        prefix[0] = nums[0]
8
        for i in range(1, n):
9
            prefix[i] = prefix[i - 1] + nums[i]
10
        suffix[-1] = nums[-1]
11
        for i in range(n - 2, -1, -1):
12
            suffix[i] = suffix[i + 1] + nums[i]
13
14
        max_diff = 0
15
        for i in range(n - 1):  # Partition at i
16
            left_sum = prefix[i]
17
            right_sum = suffix[i + 1]
18
            max_diff = max(max_diff, abs(left_sum - right_sum))
19
20
        results.append(max_diff)
21
22
    return results
23
24
t = int(input())
25
test_cases = []
26
for _ in range(t):
27
    n = int(input())
28
    nums = list(map(int, input().split()))
29
    test_cases.append((n, nums))
30
31
results = max_absolute_difference(t, test_cases)
32
for res in results:
33
    print(res)",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834982
1387834958,mahakantsingh113,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
int min_operations_to_equalize_energy(int N, int K, vector<int>& energy) {
7
    long long total_energy = 0;
8
    9
    // Calculate total energy
10
    for (int i = 0; i < N; i++) {
11
        total_energy += energy[i];
12
    }
13
    14
    // If total energy is not divisible by N, it's impossible to equalize
15
    if (total_energy % N != 0) {
16
        return -1;
17
    }
18
    19
    long long target = total_energy / N;  // The energy each station should have
20
    long long operations = 0;
21
    long long balance = 0;  // Tracks the cumulative balance of energy
22
    23
    // Traverse through each station to calculate the necessary transfers
24
    for (int i = 0; i < N; i++) {
25
        long long diff = energy[i] - target; // Difference from target energy
26
        balance += diff;  // Update the balance
27
        28
        // If at any point the balance is not divisible by K, it's impossible to balance
29
        if (balance % K != 0) {
30
            return -1;  // Impossible to balance if balance is not divisible by K
31
        }
32
        33
        // Add the absolute number of K-sized moves required
34
        operations += abs(balance / K);
35
    }
36
    37
    return operations;  // Return the total number of operations required
38
}
39
40
int main() {
41
    int T;
42
    cin >> T;  // Number of test cases
43
    44
    while (T--) {
45
        int N, K;
46
        cin >> N >> K;  // Number of stations and the units that can be transferred
47
        48
        vector<int> energy(N);
49
        for (int i = 0; i < N; i++) {
50
            cin >> energy[i];  // Energy at each station
51
        }
52
        53
        // Call the function to get the minimum operations
54
        int result = min_operations_to_equalize_energy(N, K, energy);
55
        cout << result << endl;  // Output the result for each test case
56
    }
57
    58
    return 0;
59
}
60",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834958
1387834977,shivanshu121004,unknown,unknown,"1
def find_max_subarray_difference(n, nums):
2
3
    if n < 2:
4
5
        return 0
6
7
    prefix_sums = [0] * (n + 1)
8
9
    for i in range(n):
10
11
        prefix_sums[i + 1] = prefix_sums[i] + nums[i]
12
13
    14
15
    max_difference = 0
16
17
    total_sum = prefix_sums[n]
18
19
    for i in range(n - 1):
20
21
        left_sum = prefix_sums[i + 1]
22
23
        right_sum = total_sum - left_sum
24
25
        current_difference = abs(left_sum - right_sum)
26
27
        max_difference = max(max_difference, current_difference)
28
29
    30
31
    return max_difference
32
33
t = int(input())
34
35
for _ in range(t):
36
37
    n = int(input())
38
39
    nums = list(map(int, input().split()))
40
41
    result = find_max_subarray_difference(n, nums)
42
43
    print(result)",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834977
1387834965,veerchauhan6161,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
int main() {
7
    int T;
8
    cin >> T;  // Read number of test cases
9
    10
    while (T--) {
11
        int N, K;
12
        cin >> N >> K;  // Read N (number of stations) and K (units of energy that can be transferred)
13
        14
        vector<long long> energy(N);
15
        long long totalEnergy = 0;
16
        17
        // Read energy values and calculate total energy
18
        for (int i = 0; i < N; ++i) {
19
            cin >> energy[i];
20
            totalEnergy += energy[i];
21
        }
22
        23
        // Step 1: Check if equal distribution is possible
24
        if (totalEnergy % N != 0) {
25
            cout << -1 << endl;  // It's impossible to equalize the energy
26
            continue;
27
        }
28
        29
        long long target = totalEnergy / N;  // The target energy each station should have
30
        31
        // Step 2: Track the number of operations needed
32
        long long operations = 0;
33
        long long balance = 0;  // This will track the balance of energy
34
        35
        for (int i = 0; i < N; ++i) {
36
            balance += energy[i] - target;  // Difference from target
37
            if (balance % K != 0) {
38
                operations = -1;  // If balance isn't a multiple of K, it's impossible
39
                break;
40
            }
41
            operations += abs(balance) / K;  // Accumulate the number of operations needed
42
        }
43
        44
        // Output the result for this test case
45
        cout << operations << endl;
46
    }
47
48
    return 0;
49
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834965
1387834952,shravanimargaj02,unknown,unknown,"1
def calculate_result(arr):
2
    # Calculate the result by summing the array and subtracting the smallest element
3
    return sum(arr) - min(arr)
4
5
# Input reading
6
t = int(input())  # Number of test cases
7
for _ in range(t):
8
    n = int(input())  # Size of the array
9
    arr = list(map(int, input().split()))
10
    print(calculate_result(arr))
11",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834952
1387834955,shivanshu121004,unknown,unknown,"1
def can_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
        7
    target_energy = total_energy // N
8
    operations = 0
9
    10
    differences = [energy[i] - target_energy for i in range(N)]
11
    12
    for diff in differences:
13
        if diff % K != 0:
14
            return -1
15
    16
    curr_transfer = 0
17
    for i in range(N-1):
18
        curr_transfer += differences[i]
19
        if curr_transfer != 0:
20
            operations += abs(curr_transfer) // K
21
    22
    curr_transfer += differences[N-1]
23
    if curr_transfer != 0:
24
        return -1
25
        26
    return operations
27
28
T = int(input())
29
for _ in range(T):
30
    N, K = map(int, input().split())
31
    energy = list(map(int, input().split()))
32
    result = can_equalize(N, K, energy)
33
    print(result)",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834955
1387834957,h1032220278,unknown,unknown,"1
def readValues():
2
    return list(map(int, input().split()))
3
4
def calculateProduct(values):
5
    res = []
6
    totalProduct = 1
7
    for value in values:
8
        totalProduct *= value
9
    for value in values:
10
        res.append(totalProduct // value)
11
    return res
12
13
testcases = int(input())
14
for t in range(testcases):
15
    n = int(input())
16
    values = readValues()
17
    result = calculateProduct(values)
18
    print("" "".join(map(str, result)))
19",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834957
1387834929,dhruvsingh1604,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834929
1387834942,imharsh1910,unknown,unknown,"1
def maximum_diff(arr):
2
    total_sum = sum(arr)
3
    min_diff = float('-inf')
4
    for i in range(len(arr) - 1):
5
        left_sum = sum(arr[:i+1])
6
        right_sum = total_sum - left_sum
7
        min_diff = max(min_diff, abs(left_sum - right_sum))
8
    return min_diff
9
10
t = int(input())
11
for _ in range(t):
12
    n = int(input())
13
    arr = list(map(int, input().split()))
14
    print(maximum_diff(arr))
15",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834942
1387834951,dhruvsingh1604,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834951
1387834921,veerchauhan6161,unknown,unknown,"1
2
#include <iostream>
3
#include <vector>
4
#include <cmath>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    int t;
10
    cin >> t;  // Read number of test cases
11
    12
    while (t--) {
13
        int n;
14
        cin >> n;  // Read size of array
15
        16
        vector<int> nums(n);
17
        for (int i = 0; i < n; ++i) {
18
            cin >> nums[i];  // Read array elements
19
        }
20
        21
        // Step 1: Compute the total sum of the array
22
        int totalSum = 0;
23
        for (int num : nums) {
24
            totalSum += num;
25
        }
26
        27
        // Step 2: Initialize variables for the prefix sum and the maximum absolute difference
28
        int prefixSum = 0;
29
        int maxAbsDifference = 0;
30
        31
        // Step 3: Traverse the array and compute prefix sums and suffix sums
32
        for (int i = 0; i < n - 1; ++i) {
33
            prefixSum += nums[i];
34
            int suffixSum = totalSum - prefixSum;
35
            36
            // Compute the absolute difference between prefix and suffix sums
37
            maxAbsDifference = max(maxAbsDifference, abs(prefixSum - suffixSum));
38
        }
39
        40
        // Step 4: Output the result for this test case
41
        cout << maxAbsDifference << endl;
42
    }
43
44
    return 0;
45
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834921
1387834903,dhruvsingh1604,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834903
1387834915,karanmakan2250,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <cmath>
5
using namespace std;
6
7
vector<int> minimum_operations_to_equalize(int T, vector<pair<int, pair<int, vector<int>>>>& test_cases) {
8
    vector<int> results;
9
10
    for (auto& case_data : test_cases) {
11
        int N = case_data.first;
12
        int K = case_data.second.first;
13
        vector<int>& energy = case_data.second.second;
14
15
        // Calculate total energy and check if it's divisible by N
16
        long long total_energy = accumulate(energy.begin(), energy.end(), 0LL);
17
        if (total_energy % N != 0) {
18
            results.push_back(-1);
19
            continue;
20
        }
21
22
        int target = total_energy / N;
23
        vector<long long> diffs(N);
24
        for (int i = 0; i < N; ++i) {
25
            diffs[i] = energy[i] - target;
26
        }
27
28
        // Calculate prefix sums of diffs to determine feasibility
29
        long long prefix_sum = 0;
30
        long long operations = 0;
31
        bool possible = true;
32
33
        for (int i = 0; i < N; ++i) {
34
            prefix_sum += diffs[i];
35
            // If prefix_sum is not divisible by K, balancing is impossible
36
            if (prefix_sum % K != 0) {
37
                possible = false;
38
                break;
39
            }
40
            operations += abs(prefix_sum) / K;
41
        }
42
43
        results.push_back(possible ? operations : -1);
44
    }
45
46
    return results;
47
}
48
49
int main() {
50
    int T;
51
    cin >> T;
52
    vector<pair<int, pair<int, vector<int>>>> test_cases;
53
54
    for (int t = 0; t < T; ++t) {
55
        int N, K;
56
        cin >> N >> K;
57
        vector<int> energy(N);
58
        for (int i = 0; i < N; ++i) {
59
            cin >> energy[i];
60
        }
61
        test_cases.push_back({N, {K, energy}});
62
    }
63
64
    vector<int> results = minimum_operations_to_equalize(T, test_cases);
65
    for (int result : results) {
66
        cout << result << endl;
67
    }
68
69
    return 0;
70
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834915
1387834918,h1032221029,unknown,unknown,"1
T = int(input())
2
3
for _ in range(T):
4
    N, K = map(int, input().split())
5
    energy = list(map(int, input().split()))
6
7
    total_energy = sum(energy)
8
9
    if total_energy % N != 0:
10
        print(-1)
11
        continue
12
    13
    target = total_energy // N
14
    balance = 0
15
    operations = 0
16
17
    for i in range(N):
18
        diff = energy[i] - target
19
        balance += diff
20
21
        if balance % K != 0:
22
            print(-1)
23
            break
24
        25
        operations += abs(balance) // K
26
    else:
27
        print(operations)",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834918
1387834888,mahakantsingh113,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
int min_operations_to_equalize_energy(int T, vector<vector<int>>& test_cases) {
7
    for (int t = 0; t < T; t++) {
8
        int N = test_cases[t][0];
9
        int K = test_cases[t][1];
10
        vector<int> energy(test_cases[t].begin() + 2, test_cases[t].end()); // energy array
11
        12
        long long total_energy = 0;
13
        for (int i = 0; i < N; i++) {
14
            total_energy += energy[i];
15
        }
16
        17
        // If total energy is not divisible by N, it's impossible to equalize
18
        if (total_energy % N != 0) {
19
            cout << -1 << endl;
20
            continue;
21
        }
22
        23
        long long target = total_energy / N;  // The energy each station should have
24
        long long operations = 0;
25
        long long balance = 0;
26
        27
        for (int i = 0; i < N; i++) {
28
            long long diff = energy[i] - target;
29
            balance += diff;
30
            31
            // If balance is not divisible by K, it's impossible to balance
32
            if (balance % K != 0) {
33
                operations = -1;
34
                break;
35
            }
36
            37
            operations += abs(balance / K);
38
        }
39
        40
        cout << operations << endl;
41
    }
42
    return 0;
43
}
44
45
int main() {
46
    int T;
47
    cin >> T;
48
    49
    vector<vector<int>> test_cases;
50
    51
    for (int t = 0; t < T; t++) {
52
        int N, K;
53
        cin >> N >> K;
54
        55
        vector<int> energy(N);
56
        for (int i = 0; i < N; i++) {
57
            cin >> energy[i];
58
        }
59
        60
        test_cases.push_back({N, K});
61
        test_cases[t].insert(test_cases[t].end(), energy.begin(), energy.end());
62
    }
63
    64
    min_operations_to_equalize_energy(T, test_cases);
65
    return 0;
66
}
67",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834888
1387834890,uditbhagat3001,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
4
using namespace std;
5
6
vector<int> productArray(const vector<int>& nums) {
7
    int n = nums.size();
8
    vector<int> result(n, 1); // Initialize the result array with 1s
9
10
    // Calculate the left product and store it in result
11
    int leftProduct = 1;
12
    for (int i = 0; i < n; ++i) {
13
        result[i] = leftProduct;
14
        leftProduct *= nums[i];
15
    }
16
17
    // Calculate the right product and update result
18
    int rightProduct = 1;
19
    for (int i = n - 1; i >= 0; --i) {
20
        result[i] *= rightProduct;
21
        rightProduct *= nums[i];
22
    }
23
24
    return result;
25
}
26
27
int main() {
28
    int t;
29
    cin >> t; // Number of test cases
30
31
    while (t--) {
32
        int n;
33
        cin >> n; // Size of the array
34
35
        vector<int> nums(n);
36
        for (int i = 0; i < n; ++i) {
37
            cin >> nums[i]; // Input array elements
38
        }
39
40
        vector<int> result = productArray(nums);
41
42
        for (int i = 0; i < n; ++i) {
43
            cout << result[i] << "" "";
44
        }
45
        cout << endl;
46
    }
47
48
    return 0;
49
}
50",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834890
1387834893,gupta_aniket0408,unknown,unknown,"1
T = int(input())
2
3
for _ in range(T):
4
    N, K = map(int, input().split())
5
    energy = list(map(int, input().split()))
6
7
    total_energy = sum(energy)
8
9
    if total_energy % N != 0:
10
        print(-1)
11
        continue
12
    13
    target = total_energy // N
14
    balance = 0
15
    operations = 0
16
17
    for i in range(N):
18
        diff = energy[i] - target
19
        balance += diff
20
21
        if balance % K != 0:
22
            print(-1)
23
            break
24
        25
        operations += abs(balance) // K
26
    else:
27
        print(operations)
28",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834893
1387834881,snehstorage,unknown,unknown,"1
with Ada.Text_IO, Ada.Integer_Text_IO;
2
use Ada;
3
4
procedure Solution is
5
-- Enter your code here. Read input from STDIN. Print output to STDOUT
6
7
def max_abs_diff(nums):
8
    total_sum = sum(nums)
9
    max_diff = 0
10
    left_sum = 0
11
12
    for i in range(len(nums) - 1):
13
        left_sum += nums[i]
14
        right_sum = total_sum - left_sum
15
        max_diff = max(max_diff, abs(left_sum - right_sum))
16
17
    return max_diff
18
19
t = int(input())
20
21
for _ in range(t):
22
    n = int(input())
23
    nums = list(map(int, input().split()))
24
    print(max_abs_diff(nums))
25
26",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834881
1387834884,vighnesh97531,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834884
1387834879,h1032221359,unknown,unknown,"1
import sys
2
3
def max_absolute_difference(n, nums):
4
    total_sum = sum(nums)
5
    max_diff = 0
6
    left_sum = 0
7
    8
    for i in range(n - 1):
9
        left_sum += nums[i]
10
        right_sum = total_sum - left_sum
11
        max_diff = max(max_diff, abs(left_sum - right_sum))
12
    13
    return max_diff
14
15
def main():
16
    input = sys.stdin.read
17
    data = input().split()
18
    index = 0
19
    20
    t = int(data[index])
21
    index += 1
22
    results = []
23
    24
    for _ in range(t):
25
        n = int(data[index])
26
        index += 1
27
        nums = list(map(int, data[index:index + n]))
28
        index += n
29
        30
        results.append(str(max_absolute_difference(n, nums)))
31
    32
    sys.stdout.write(""\n"".join(results) + ""\n"")
33
34
if __name__ == ""__main__"":
35
    main()",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834879
1387834876,shivangichouhan1,unknown,unknown,"1
def solve_product_distribution():
2
3
    # Read number of test cases
4
5
    T = int(input())
6
7
    8
9
    # Process each test case
10
11
    for _ in range(T):
12
13
        # Read number of nodes
14
15
        n = int(input())
16
17
        18
19
        # Read values array
20
21
        values = list(map(int, input().split()))
22
23
        24
25
        # Calculate result array
26
27
        result = []
28
29
        30
31
        # Calculate total product of all elements
32
33
        total_product = 1
34
35
        for val in values:
36
37
            total_product *= val
38
39
        40
41
        # For each position, divide total product by the value at that position
42
43
        for i in range(n):
44
45
            # Avoid division by zero
46
47
            if values[i] != 0:
48
49
                result.append(total_product // values[i])
50
51
            else:
52
53
                # If current value is 0, multiply all other values
54
55
                product = 1
56
57
                for j in range(n):
58
59
                    if j != i:
60
61
                        product *= values[j]
62
63
                result.append(product)
64
65
        66
67
        # Print result array elements in a single line
68
69
        print("" "".join(map(str, result)))
70
71
# Run the solution
72
73
if __name__ == ""__main__"":
74
75
    solve_product_distribution()",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834876
1387834864,h1032220866,unknown,unknown,"1
T = int(input())
2
for i in range(T):
3
    N, K = map(int, input().split())
4
    energy = list(map(int, input().split()))
5
    6
    total_energy = sum(energy)
7
    8
    if total_energy % N != 0:
9
        print(-1)
10
        continue
11
    12
    target_energy = total_energy // N
13
    operations = 0
14
    15
    for a in range(N):
16
        diff = energy[a] - target_energy
17
        18
        if diff % K != 0:
19
            print(-1)
20
            break
21
        22
        operations += abs(diff) // K
23
        energy[(a + 1) % N] += diff  
24
    else:
25
        print(operations)
26",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834864
1387834868,codedot,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energies = case
5
        total_energy = sum(energies)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        10
        target_energy = total_energy // N
11
        operations = 0
12
        current_balance = 0
13
        14
        for energy in energies:
15
            current_balance += energy - target_energy
16
            if current_balance % K != 0:
17
                operations = -1
18
                break
19
            operations += abs(current_balance) // K
20
        21
        results.append(operations if operations != -1 else -1)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
for _ in range(T):
28
    N, K = map(int, input().split())
29
    energies = list(map(int, input().split()))
30
    test_cases.append((N, K, energies))
31
32
results = equalize_energy(test_cases)
33
for result in results:
34
    print(result)
35",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834868
1387834874,vighnesh97531,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834874
1387834855,ambujbaranwal,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
3
def min_operations(test_cases):
4
    results = []
5
    for case in test_cases:
6
        N, K, energy = case
7
        total = sum(energy)
8
        if total % N != 0:
9
            results.append(-1)
10
            continue
11
        target = total // N
12
        operations = 0
13
        surplus = 0
14
        for i in range(N):
15
            diff = energy[i] - target
16
            surplus += diff
17
            if surplus % K != 0:
18
                results.append(-1)
19
                break
20
            operations += abs(surplus // K)
21
        else:
22
            results.append(operations)
23
    return results
24
25
T = int(input())
26
test_cases = []
27
for _ in range(T):
28
    N, K = map(int, input().split())
29
    energy = list(map(int, input().split()))
30
    test_cases.append((N, K, energy))
31
32
results = min_operations(test_cases)
33
for res in results:
34
    print(res)
35
36
37
38",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834855
1387834862,snehstorage,unknown,unknown,"1
with Ada.Text_IO, Ada.Integer_Text_IO;
2
use Ada;
3
4
procedure Solution is
5
-- Enter your code here. Read input from STDIN. Print output to STDOUT
6
7
def max_abs_diff(nums):
8
    total_sum = sum(nums)
9
    max_diff = 0
10
    left_sum = 0
11
12
    for i in range(len(nums) - 1):
13
        left_sum += nums[i]
14
        right_sum = total_sum - left_sum
15
        max_diff = max(max_diff, abs(left_sum - right_sum))
16
17
    return max_diff
18
19
t = int(input())
20
21
for _ in range(t):
22
    n = int(input())
23
    nums = list(map(int, input().split()))
24
    print(max_abs_diff(nums))
25",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834862
1387834863,vighnesh97531,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834863
1387834851,gupta_aniket0408,unknown,unknown,"1
T = int(input())
2
3
for _ in range(T):
4
    N, K = map(int, input().split())
5
    energy = list(map(int, input().split()))
6
7
    total_energy = sum(energy)
8
9
    if total_energy % N != 0:
10
        print(-1)
11
        continue
12
    13
    target = total_energy // N
14
    operations = 0
15
    balance = 0
16
17
    for i in range(N):
18
        diff = energy[i] - target
19
        balance += diff
20
        operations += abs(balance) // K
21
22
    print(operations)
23
24
    25
    ",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834851
1387834852,1_ashwarya,unknown,unknown,"1
def min_operations(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target = total_energy // N
8
    operations = 0
9
    current_balance = 0
10
    11
    for i in range(N):
12
        diff = energy[i] - target
13
        current_balance += diff
14
        15
        operations += abs(current_balance) // K
16
    17
    return operations
18
19
T = int(input())  
20
21
for _ in range(T):
22
    N, K = map(int, input().split()) 
23
    energy = list(map(int, input().split()))  
24
25
    result = min_operations(N, K, energy)
26
    print(result)
27",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834852
1387834845,h1032220371,unknown,unknown,"1
t=int(input())
2
for i in range(t):
3
    n=int(input())
4
    nums=list(map(int,input().split()))
5
    6
    final_result=-1
7
    for i in range(n):
8
        nums_1=nums[i]  
9
        nums_2=nums.copy()
10
        nums_2.remove(nums_1)  
11
        nums_2_sum=sum(nums_2)    
12
        result=abs(nums_1-nums_2_sum)
13
        if result>final_result:
14
            final_result=result
15
    16
    print(final_result)
17",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834845
1387834844,yrawal2004,unknown,unknown,"1
import math
2
3
def max_diff(arr):
4
    arr.sort()
5
    num1 = arr[0]
6
    num2 = sum(arr[1:])
7
    return abs(num1 - num2)
8
9
10
11
t = int(input())
12
for _ in range(t):
13
    n = int(input().strip())  # Read the size of the array
14
    arr = list(map(int, input().strip().split()))  # Read array elements in one line
15
    print(max_diff(arr))  # Compute and print result
16",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834844
1387834838,oms989069,unknown,unknown,"1
def max_abs_diff(nums):
2
    total_sum = sum(nums)
3
    max_diff = 0
4
    left_sum = 0
5
6
    for i in range(len(nums) - 1):
7
        left_sum += nums[i]
8
        right_sum = total_sum - left_sum
9
        max_diff = max(max_diff, abs(left_sum - right_sum))
10
11
    return max_diff
12
13
t = int(input())
14
15
for _ in range(t):
16
    n = int(input())
17
    nums = list(map(int, input().split()))
18
    print(max_abs_diff(nums))",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834838
1387834841,anishakarkera737,unknown,unknown,"1
def minimum_operations_to_equalize(t, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K, energy = case
6
7
        8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target = total_energy // N
14
        diffs = [e - target for e in energy]
15
16
        17
        prefix_sum = 0
18
        operations = 0
19
        possible = True
20
21
        for i in range(N):
22
            prefix_sum += diffs[i]
23
            24
            if prefix_sum % K != 0:
25
                possible = False
26
                break
27
            operations += abs(prefix_sum) // K
28
29
        results.append(operations if possible else -1)
30
31
    return results
32
33
34
def main():
35
    T = int(input())
36
    test_cases = []
37
38
    for _ in range(T):
39
        N, K = map(int, input().split())
40
        energy = list(map(int, input().split()))
41
        test_cases.append((N, K, energy))
42
43
44
    results = minimum_operations_to_equalize(T, test_cases)
45
    for result in results:
46
        print(result)
47
48
if __name__ == ""__main__"":
49
    main()",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834841
1387834842,abhig3340,unknown,unknown,"1
def difference(test_cases):
2
    results = []
3
    4
    for nums in test_cases:
5
        n = len(nums)
6
        total_sum = sum(nums)
7
        max_diff = float('-inf')
8
        9
        l_sum = 0
10
        11
        for i in range(n - 1):
12
            l_sum += nums[i]
13
            r_sum = total_sum - l_sum
14
            max_diff = max(max_diff, abs(l_sum - r_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
def main():
21
    t = int(input())
22
    test_cases = []
23
    24
    for _ in range(t):
25
        n = int(input())
26
        nums = list(map(int, input().split()))
27
        test_cases.append(nums)
28
    29
    results = difference(test_cases)
30
    31
    for result in results:
32
        print(result)
33
34
if __name__ == ""__main__"":
35
    main()
36",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834842
1387834833,ansh_shetty_22,unknown,unknown,"1
with Ada.Text_IO; use Ada.Text_IO;
2
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
3
4
procedure Solution is
5
   T : Integer;
6
begin
7
   Get(T);
8
   for Testcase in 1 .. T loop
9
      declare
10
         N : Integer;
11
         Total_Sum, Prefix_Sum, Max_Diff : Integer;
12
         Num_Array : array (1 .. 100000) of Integer;
13
      begin
14
         Get(N);
15
         Total_Sum := 0;
16
         for I in 1 .. N loop
17
            Get(Num_Array(I));
18
            Total_Sum := Total_Sum + Num_Array(I);
19
         end loop;
20
21
         Prefix_Sum := 0;
22
         Max_Diff := 0;
23
24
         for I in 1 .. N - 1 loop
25
            Prefix_Sum := Prefix_Sum + Num_Array(I);
26
            if Abs(Prefix_Sum - (Total_Sum - Prefix_Sum)) > Max_Diff then
27
               Max_Diff := Abs(Prefix_Sum - (Total_Sum - Prefix_Sum));
28
            end if;
29
         end loop;
30
31
         Put(Integer'Image(Max_Diff));  -- Use Put to avoid extra newline
32
      end;
33
   end loop;
34
end Solution;
35",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834833
1387834835,sushanttiwari074,unknown,unknown,"1
def can_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
        7
    target_energy = total_energy // N
8
    operations = 0
9
    10
    differences = [energy[i] - target_energy for i in range(N)]
11
    12
    for diff in differences:
13
        if diff % K != 0:
14
            return -1
15
    16
    curr_transfer = 0
17
    for i in range(N-1):
18
        curr_transfer += differences[i]
19
        if curr_transfer != 0:
20
            operations += abs(curr_transfer) // K
21
    22
    curr_transfer += differences[N-1]
23
    if curr_transfer != 0:
24
        return -1
25
        26
    return operations
27
28
T = int(input())
29
for _ in range(T):
30
    N, K = map(int, input().split())
31
    energy = list(map(int, input().split()))
32
    result = can_equalize(N, K, energy)
33
    print(result)",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834835
1387834837,h1032221029,unknown,unknown,"1
T = int(input())
2
3
for _ in range(T):
4
    N, K = map(int, input().split())
5
    energy = list(map(int, input().split()))
6
7
    total_energy = sum(energy)
8
9
    if total_energy % N != 0:
10
        print(-1)
11
        continue
12
    13
    target = total_energy // N
14
    operations = 0
15
    balance = 0
16
17
    for i in range(N):
18
        diff = energy[i] - target
19
        balance += diff
20
        operations += abs(balance) // K
21
22
    print(operations)",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834837
1387834809,h1032220278,unknown,unknown,"1
def maxAbsoluteDifference(t, testCases):
2
    results = []
3
    for case in range(t):
4
        n = testCases[case][0]
5
        nums = testCases[case][1]
6
        totalSum = sum(nums)
7
        prefixSum = 0
8
        maxDiff = 0
9
        for i in range(n - 1):
10
            prefixSum += nums[i]
11
            suffixSum = totalSum - prefixSum
12
            maxDiff = max(maxDiff, abs(prefixSum - suffixSum))
13
        results.append(maxDiff)
14
    return results
15
16
t = int(input())
17
testCases = []
18
for i in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    testCases.append((n, nums))
22
results = maxAbsoluteDifference(t, testCases)
23
for res in results:
24
    print(res)
25",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834809
1387834818,sushanttiwari074,unknown,unknown,"1
def min_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for N, K, energies in test_cases:
5
        total_energy = sum(energies)
6
        7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // N
12
        operations = 0
13
        current_balance = 0
14
        15
        for energy in energies:
16
            current_balance += (energy - target)
17
            18
19
            if current_balance > 0:
20
                operations += (current_balance + K - 1) // K  
21
            elif current_balance < 0:
22
                operations += (-current_balance + K - 1) // K 
23
        24
        results.append(operations)
25
    26
    return results
27
28
import sys
29
30
input = sys.stdin.read
31
data = input().splitlines()
32
33
T = int(data[0])  
34
test_cases = []
35
36
index = 1
37
for _ in range(T):
38
    N, K = map(int, data[index].split())
39
    index += 1
40
    energies = list(map(int, data[index].split()))
41
    test_cases.append((N, K, energies))
42
    index += 1
43
44
results = min_operations_to_equalize(test_cases)
45
for res in results:
46
    print(res)
47",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834818
1387834820,shravanimargaj02,unknown,unknown,"1
def process_test_cases(test_cases):
2
    results = []
3
    for test in test_cases:
4
        n, k = test[0]  
5
        arr = test[1]   
6
7
        8
        if sum(arr) % k == 0:  
9
            results.append(0)
10
        elif sum(arr) > k:
11
            results.append(1)
12
        else:
13
            results.append(-1)
14
    return results
15
16
17
t = int(input())  
18
test_cases = []
19
for _ in range(t):
20
    n, k = map(int, input().split())
21
    arr = list(map(int, input().split()))
22
    test_cases.append(((n, k), arr))
23
24
25
results = process_test_cases(test_cases)
26
for res in results:
27
    print(res]
28",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834820
1387834798,h1032220299,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <bits/stdc++.h>
7
using namespace std;
8
int main() {
9
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
10
    int a;
11
    cin >> a;
12
    while (a--) {
13
        int N,K;
14
        cin >> N >> K;
15
        vector<int> energy(N);
16
        for (int i = 0; i < N; ++i) {
17
            cin >> energy[i];
18
        }
19
        long long total_eng = accumulate(energy.begin(), energy.end(), 0LL);
20
        if (total_eng % N != 0) {
21
            cout << -1 << endl;
22
            continue;
23
        }
24
25
        int target = total_eng / N;
26
        long long b = 0, op = 0;
27
        for (int i = 0; i < N; ++i) {
28
            b += energy[i] - target;
29
            if (b % K != 0) {
30
                cout << -1 << endl;
31
                goto pass_out;
32
            }
33
            op += abs(b) / K;
34
        }
35
        cout << op << endl;
36
37
    pass_out:
38
        continue;
39
    }
40
    41
    return 0;
42
}
43",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834798
1387834773,1_ashwarya,unknown,unknown,"1
def min_operations(N, K, energy):
2
    total_energy = sum(energy)
3
   4
    if total_energy % N != 0:
5
        return -1
6
    7
    target = total_energy // N
8
    operations = 0
9
    current_balance = 0
10
   11
    for i in range(N):
12
        diff = energy[i] - target
13
        current_balance += diff
14
        operations += abs(current_balance) // K  
15
    16
    return operations
17
18
T = int(input())  
19
20
for _ in range(T):
21
    N, K = map(int, input().split()) 
22
    energy = list(map(int, input().split()))  
23
24
    result = min_operations(N, K, energy)
25
    print(result)
26",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834773
1387834776,shubhamvirani33,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        prefix_sums = [0] * n
6
        prefix_sums[0] = nums[0]
7
        for i in range(1, n):
8
            prefix_sums[i] = prefix_sums[i - 1] + nums[i]
9
        total_sum = prefix_sums[-1]
10
        max_diff = 0
11
        for i in range(n - 1):
12
            left_sum = prefix_sums[i]
13
            right_sum = total_sum - left_sum
14
            max_diff = max(max_diff, abs(left_sum - right_sum))
15
        results.append(max_diff)
16
    return results
17
if __name__ == ""__main__"":
18
    T = int(input())
19
    test_cases = []
20
    for _ in range(T):
21
        n = int(input())
22
        nums = list(map(int, input().split()))
23
        test_cases.append((n, nums))
24
    output = max_absolute_difference(T, test_cases)
25
    for res in output:
26
        print(res)",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834776
1387834782,codedot,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
    for i in range(T):
4
        N, K = test_cases[i][0]
5
        energy = test_cases[i][1]
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        target = total_energy // N
11
        operations = 0
12
        for j in range(N):
13
            diff = energy[j] - target
14
            if diff % K != 0:
15
                results.append(-1)
16
                break
17
            if diff > 0:
18
                operations += diff // K
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append(((N, K), energy))
29
30
results = min_operations_to_equalize(T, test_cases)
31
for result in results:
32
    print(result)",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834782
1387834763,jeettrivedi2004,unknown,unknown,"1
test=int(input())
2
for i in range(test):
3
    num=int(input())
4
    l1=list(map(int,input().split()))
5
    s=sum(l1)
6
    res,total=0,0
7
    for i in l1[:-1]:
8
        total+=i
9
        cont=s-total
10
        res=max(res,abs(cont-total))
11
    print(res)
12
    ",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834763
1387834764,HarshShrivastava,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner sc=new Scanner(System.in);
8
        int t=sc.nextInt();
9
        while(t>0){
10
            int n=sc.nextInt();
11
            int i;
12
            int a[]=new int[n];
13
            long sum=0;
14
            for(i=0;i<n;i++)
15
                a[i]=sc.nextInt();
16
            Arrays.sort(a);
17
            for(i=1;i<n;i++)
18
                sum+=a[i];
19
            System.out.println(Math.abs(sum-a[0]));
20
            t--;
21
        }
22
    }
23
}",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834764
1387834766,h1032221029,unknown,unknown,"1
def can_equalize(N, K, energy):
2
   3
    total_energy = sum(energy)
4
    if total_energy % N != 0:
5
        return -1
6
    7
    target = total_energy // N
8
    9
   10
    for i in range(N):
11
        diff = abs(energy[i] - target)
12
        if diff % K != 0:
13
            return -1
14
    15
   16
    operations = 0
17
    curr_energy = energy.copy()
18
    19
  20
    while True:
21
        if all(e == target for e in curr_energy):
22
            return operations
23
        24
        25
        made_transfer = False
26
        for i in range(N):
27
            next_i = (i + 1) % N
28
            29
          30
            if curr_energy[i] > target and curr_energy[next_i] < target:
31
               32
                if curr_energy[i] - K >= target or curr_energy[next_i] + K <= target:
33
                    curr_energy[i] -= K
34
                    curr_energy[next_i] += K
35
                    operations += 1
36
                    made_transfer = True
37
                    break
38
        39
        40
        if not made_transfer:
41
            return -1
42
43
def solve_test_cases():
44
    T = int(input())
45
    results = []
46
    47
    for _ in range(T):
48
49
        N, K = map(int, input().split())
50
        51
      52
        energy = list(map(int, input().split()))
53
        54
     55
        result = can_equalize(N, K, energy)
56
        results.append(result)
57
    58
59
    for result in results:
60
        print(result)
61
62
63
if __name__ == ""__main__"":
64
    solve_test_cases()",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834766
1387834742,mithileshtandon1,unknown,unknown,"1
def find_max_subarray_difference(n, nums):
2
    if n < 2:
3
        return 0
4
    prefix_sums = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_sums[i + 1] = prefix_sums[i] + nums[i]
7
    8
    max_difference = 0
9
    total_sum = prefix_sums[n]
10
    for i in range(n - 1):
11
        left_sum = prefix_sums[i + 1]
12
        right_sum = total_sum - left_sum
13
        current_difference = abs(left_sum - right_sum)
14
        max_difference = max(max_difference, current_difference)
15
    16
    return max_difference
17
18
t = int(input())
19
for _ in range(t):
20
    n = int(input())
21
    nums = list(map(int, input().split()))
22
    result = find_max_subarray_difference(n, nums)
23
    print(result)",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834742
1387834753,adhvaynariya505,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834753
1387834759,sg7859298,unknown,unknown,"1
def solve():
2
    n = int(input())
3
    nums = list(map(int, input().split()))
4
5
    max_diff = 0
6
    total_sum = sum(nums)
7
    current_sum = 0
8
9
    for i in range(n - 1):
10
        current_sum += nums[i]
11
        sum1 = current_sum
12
        sum2 = total_sum - sum1
13
        diff = abs(sum1 - sum2)
14
        max_diff = max(max_diff, diff)
15
16
    print(max_diff)
17
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834759
1387834741,sg7859298,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    energies = list(map(int, input().split()))
4
5
    total_energy = sum(energies)
6
    if total_energy % n != 0:
7
        print(-1)
8
        return
9
10
    target_energy = total_energy // n
11
    diff = [energies[i] - target_energy for i in range(n)]
12
    c_diff = [0] * n
13
    c_diff[0] = 0
14
    for i in range(1, n):
15
        c_diff[i] = c_diff[i-1] + diff[i-1]
16
17
    operations = 0
18
    for i in range(1, n):
19
        if c_diff[i] % k != 0:
20
            print(-1)
21
            return
22
        operations += abs(c_diff[i]) // k
23
24
    print(operations)
25
26
27
t = int(input())
28
for _ in range(t):
29
    solve()",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834741
1387834729,adhvaynariya505,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834729
1387834737,h1032220278,unknown,unknown,"1
def maxAbsoluteDifference(t, testCases):
2
    results = []
3
    for case in range(t):
4
        n = testCases[case][0]
5
        nums = testCases[case][1]
6
        totalSum = sum(nums)
7
        prefixSum = 0
8
        maxDiff = 0
9
        for i in range(n - 1):
10
            prefixSum += nums[i]
11
            suffixSum = totalSum - prefixSum
12
            maxDiff = max(maxDiff, abs(prefixSum - suffixSum))
13
        results.append(maxDiff)
14
    return results
15
16
t = int(input())
17
testCases = []
18
for i in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    testCases.append((n, nums))
22
results = maxAbsoluteDifference(t, testCases)
23
for res in results:
24
    print(res)
25",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834737
1387834740,adhvaynariya505,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834740
1387834724,akashyadv7233,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n,k=map(int,input().split())
4
    arr=list(map(int,input().split()))
5
    summ=sum(arr)
6
    if summ%n!=0:
7
        print(-1)
8
    else:
9
        avg=summ//n
10
        bal=[]
11
        for i in arr:
12
            bal.append(i-avg)
13
        ans=0
14
        total=0
15
        for i in bal:
16
            total+=i
17
            if total%k!=0:
18
                print(-1)
19
                break
20
            ans+=abs(total)//k
21
        else:
22
            print(ans)",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834724
1387834726,codedot,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    energy = list(map(int, input().split()))
5
    6
    total_energy = sum(energy)
7
    8
    if total_energy % n != 0:
9
        print(-1)
10
        continue
11
    12
    target_energy = total_energy // n
13
    operations = 0
14
    current_balance = 0
15
    16
    for i in range(n):
17
        current_balance += energy[i] - target_energy
18
        19
        if current_balance > 0:
20
            operations += (current_balance + k - 1) // k
21
            22
    print(operations)
23",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834726
1387834727,kaushal80106,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n,k=map(int,input().split())
4
    arr=list(map(int,input().split()))
5
    summ=sum(arr)
6
    if summ%n!=0:
7
        print(-1)
8
    else:
9
        avg=summ//n
10
        bal=[]
11
        for i in arr:
12
            bal.append(i-avg)
13
        ans=0
14
        total=0
15
        for i in bal:
16
            total+=i
17
            if total%k!=0:
18
                print(-1)
19
                break
20
            ans+=abs(total)//k
21
        else:
22
            print(ans)",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834727
1387834716,pandeysneha3004,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt(); 
7
        8
        while (T-- > 0) {
9
            int N = scanner.nextInt(); 
10
            int K = scanner.nextInt(); 
11
            12
            long[] energy = new long[N];
13
            long totalEnergy = 0;
14
            15
            for (int i = 0; i < N; i++) {
16
                energy[i] = scanner.nextLong();
17
                totalEnergy += energy[i];
18
            }
19
            20
            System.out.println(minOperationsToEqualize(N, K, energy, totalEnergy));
21
        }
22
        23
        scanner.close();
24
    }
25
    26
    private static long minOperationsToEqualize(int N, int K, long[] energy, long totalEnergy) {
27
        if (totalEnergy % N != 0) {
28
            return -1;
29
        }
30
        31
        long targetEnergy = totalEnergy / N;
32
        boolean isEqual = true;
33
        34
        for (int i = 0; i < N; i++) {
35
            if (energy[i] != targetEnergy) {
36
                isEqual = false;
37
                break;
38
            }
39
        }
40
        41
        if (isEqual) {
42
            return 0;
43
        }
44
        45
        long operations = 0;
46
        long[] current = energy.clone();
47
        48
        for (int i = 0; i < N; i++) {
49
            if (Math.abs(current[i] - targetEnergy) % K != 0) {
50
                return -1;
51
            }
52
        }
53
        54
        for (int i = 0; i < N - 1; i++) {
55
            if (current[i] > targetEnergy) {
56
                long excess = current[i] - targetEnergy;
57
                long transfers = excess / K;
58
                current[i] -= transfers * K;
59
                current[i + 1] += transfers * K;
60
                operations += transfers;
61
            } else if (current[i] < targetEnergy) {
62
                long deficit = targetEnergy - current[i];
63
                long transfers = deficit / K;
64
                current[i] += transfers * K;
65
                current[i + 1] -= transfers * K;
66
                operations += transfers;
67
            }
68
        }
69
        70
        if (current[N - 1] != targetEnergy) {
71
            long diff = Math.abs(current[N - 1] - targetEnergy);
72
            operations += diff / K;
73
        }
74
        75
        return operations;
76
    }
77
}
78
79",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834716
1387834713,sg7859298,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int t = scanner.nextInt(); // Number of test cases
9
        10
        for (int k = 0; k < t; k++) {
11
            int n = scanner.nextInt(); // Number of stations
12
            int kVal = scanner.nextInt(); // Energy transfer unit
13
            int[] energies = new int[n];
14
15
            for (int i = 0; i < n; i++) {
16
                energies[i] = scanner.nextInt(); // Read energies
17
            }
18
19
            long totalEnergy = 0;
20
            for (int energy : energies) {
21
                totalEnergy += energy; // Calculate total energy
22
            }
23
24
            if (totalEnergy % n != 0) {
25
                System.out.println(-1); // Impossible to equalize
26
                continue;
27
            }
28
29
            long targetEnergy = totalEnergy / n; // Calculate target energy for each station
30
            long[] diff = new long[n];
31
32
            for (int i = 0; i < n; i++) {
33
                diff[i] = energies[i] - targetEnergy; // Calculate differences
34
            }
35
36
            long operations = 0;
37
            long cumulativeSum = 0;
38
            boolean isPossible = true;
39
40
            // Iterate through the stations to check the energy balance
41
            for (int i = 0; i < n; i++) {
42
                cumulativeSum += diff[i]; // Keep track of the cumulative difference
43
                // If the cumulative sum is not divisible by kVal, it's not possible to balance energy
44
                if (cumulativeSum % kVal != 0) {
45
                    isPossible = false;
46
                    break;
47
                }
48
                // Count the operations (absolute value of cumulativeSum / kVal)
49
                operations += Math.abs(cumulativeSum) / kVal;
50
            }
51
52
            // Output the result
53
            if (isPossible) {
54
                System.out.println(operations); // Output the number of operations
55
            } else {
56
                System.out.println(-1); // Impossible case
57
            }
58
        }
59
        scanner.close(); // Close scanner
60
    }
61
}
62",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834713
1387834717,h1032220371,unknown,unknown,"1
t=int(input())
2
for i in range(t):
3
    n=int(input())
4
    nums=list(map(int,input().split()))
5
    6
    nums_1=min(nums)
7
    8
    nums_2=nums.copy()
9
    nums_2.remove(nums_1)
10
    11
    nums_2_sum=sum(nums_2)
12
    13
    result=abs(nums_1-nums_2_sum)
14
    15
    print(result)",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834717
1387834702,vishwakarmakara2,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target = total_energy // N
8
    operations = 0
9
    balance = 0
10
    11
    for i in range(N):
12
        diff = energy[i] - target
13
        14
        balance += diff
15
        16
        if balance % K != 0:
17
            return -1
18
        19
        operations += abs(balance) // K
20
    21
    return operations
22
23
T = int(input())
24
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    28
    energy = list(map(int, input().split()))
29
    30
    print(min_operations_to_equalize(N, K, energy))
31",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834702
1387834695,1_ashwarya,unknown,unknown,"1
def min_operations(N, K, energy):
2
    total_energy = sum(energy)
3
   4
    if total_energy % N != 0:
5
        return -1
6
7
    target = total_energy // N  
8
    operations = 0
9
    current_balance = 0
10
  11
    for i in range(N):
12
        13
        diff = energy[i] - target
14
15
        current_balance += diff
16
    17
        operations += abs(current_balance) // K
18
        19
    return operations
20
21
T = int(input())  
22
23
for _ in range(T):
24
    N, K = map(int, input().split()) 
25
    energy = list(map(int, input().split()))  
26
27
    result = min_operations(N, K, energy)
28
    print(result)
29",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834695
1387834697,princesharma8050,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt(); // Number of test cases
8
        9
        while (T-- > 0) {
10
            int N = scanner.nextInt(); // Number of power stations
11
            int K = scanner.nextInt(); // Units of energy per transfer
12
            13
            long[] energy = new long[N];
14
            long totalEnergy = 0;
15
            16
            // Read energy values and calculate total
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextLong();
19
                totalEnergy += energy[i];
20
            }
21
            22
            System.out.println(minOperationsToEqualize(N, K, energy, totalEnergy));
23
        }
24
        25
        scanner.close();
26
    }
27
    28
    private static long minOperationsToEqualize(int N, int K, long[] energy, long totalEnergy) {
29
        // Check if equalization is possible
30
        if (totalEnergy % N != 0) {
31
            return -1;
32
        }
33
        34
        long targetEnergy = totalEnergy / N;
35
        36
        // Check if already equalized
37
        boolean isEqual = true;
38
        for (int i = 0; i < N; i++) {
39
            if (energy[i] != targetEnergy) {
40
                isEqual = false;
41
                break;
42
            }
43
        }
44
        if (isEqual) {
45
            return 0;
46
        }
47
        48
        // Count operations needed
49
        long operations = 0;
50
        long[] current = energy.clone();
51
        52
        // First check if it's possible to equalize
53
        for (int i = 0; i < N; i++) {
54
            if (Math.abs(current[i] - targetEnergy) % K != 0) {
55
                return -1;
56
            }
57
        }
58
        59
        // Try to equalize by transferring energy
60
        for (int i = 0; i < N - 1; i++) {
61
            if (current[i] > targetEnergy) {
62
                long excess = current[i] - targetEnergy;
63
                long transfers = excess / K;
64
                current[i] -= transfers * K;
65
                current[i + 1] += transfers * K;
66
                operations += transfers;
67
            } else if (current[i] < targetEnergy) {
68
                long deficit = targetEnergy - current[i];
69
                long transfers = deficit / K;
70
                current[i] += transfers * K;
71
                current[i + 1] -= transfers * K;
72
                operations += transfers;
73
            }
74
        }
75
        76
        // Check final station
77
        if (current[N - 1] != targetEnergy) {
78
            // Need to transfer to/from first station
79
            long diff = Math.abs(current[N - 1] - targetEnergy);
80
            operations += diff / K;
81
        }
82
        83
        return operations;
84
    }
85
}",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834697
1387834699,HarshShrivastava,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner sc=new Scanner(System.in);
8
        int t=sc.nextInt();
9
        while(t>0){
10
            int n=sc.nextInt();
11
            int i;
12
            int a[]=new int[n];
13
            long sum=0;
14
            for(i=0;i<n;i++)
15
                a[i]=sc.nextInt();
16
            Arrays.sort(a);
17
            for(i=1;i<n;i++)
18
                sum+=a[i];
19
            System.out.println(sum-a[0]);
20
            t--;
21
        }
22
    }
23
}",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834699
1387834689,abhaywadkar2004,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n,k=map(int,input().split())
4
    arr=list(map(int,input().split()))
5
    summ=sum(arr)
6
    if summ%n!=0:
7
        print(-1)
8
    else:
9
        avg=summ//n
10
        bal=[]
11
        for i in arr:
12
            bal.append(i-avg)
13
        ans=0
14
        total=0
15
        for i in bal:
16
            total+=i
17
            if total%k!=0:
18
                print(-1)
19
                break
20
            ans+=abs(total)//k
21
        else:
22
            print(ans)",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834689
1387834692,utsavsingh2826,unknown,unknown,"1
import java.util.Scanner;
2
3
public class EnergyEqualizer {
4
5
    // Function to calculate the minimum operations or return -1 if not possible
6
    public static int minOperations(int N, int K, int[] energy) {
7
        long totalEnergy = 0;
8
        9
        // Calculate the total energy in all stations
10
        for (int i = 0; i < N; i++) {
11
            totalEnergy += energy[i];
12
        }
13
14
        // If total energy is not divisible by N, return -1
15
        if (totalEnergy % N != 0) {
16
            return -1;
17
        }
18
19
        // Calculate the target energy for each station
20
        long targetEnergy = totalEnergy / N;
21
        long operations = 0;
22
        long currentBalance = 0;
23
24
        // Process each station
25
        for (int i = 0; i < N; i++) {
26
            // Calculate the difference from the target
27
            long energyDiff = energy[i] - targetEnergy;
28
            currentBalance += energyDiff;
29
30
            // Check if the balance at any station cannot be transferred in multiples of K
31
            if (Math.abs(currentBalance) % K != 0) {
32
                return -1;
33
            }
34
35
            // Add the number of operations required to balance the energy
36
            operations += Math.abs(currentBalance) / K;
37
        }
38
39
        return (int) operations;
40
    }
41
42
    public static void main(String[] args) {
43
        Scanner sc = new Scanner(System.in);
44
45
        // Read number of test cases
46
        int T = sc.nextInt();
47
        48
        // Process each test case
49
        for (int t = 0; t < T; t++) {
50
            // Read N and K
51
            int N = sc.nextInt();
52
            int K = sc.nextInt();
53
            54
            // Read the energy levels for each station
55
            int[] energy = new int[N];
56
            for (int i = 0; i < N; i++) {
57
                energy[i] = sc.nextInt();
58
            }
59
60
            // Call the minOperations function and print the result
61
            System.out.println(minOperations(N, K, energy));
62
        }
63
64
        sc.close();
65
    }
66
}
67",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834692
1387834690,snehstorage,unknown,unknown,"1
with Ada.Text_IO, Ada.Integer_Text_IO;
2
use Ada;
3
4
procedure Solution is
5
-- Enter your code here. Read input from STDIN. Print output to STDOUT
6
7
def equalize_energy(N, K, energy):
8
  total_energy = sum(energy)
9
  if total_energy % N != 0:
10
    return -1 
11
12
  target_energy = total_energy 
13
  operations = 0
14
15
  for i in range(N):
16
    diff = energy[i] - target_energy
17
    if diff % K != 0:
18
      return -1 
19
20
    operations += abs(diff) 
21
22
  return operations 
23
24
T = int(input())
25
for _ in range(T):
26
  N, K = map(int, input().split())
27
  energy = list(map(int, input().split()))
28
  print(equalize_energy(N, K, energy))
29",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834690
1387834684,akashyadv7233,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K = case[0], case[1]
6
        energy = case[2]
7
        8
        total_energy = sum(energy)
9
        10
        if total_energy % N != 0:
11
            results.append(-1)
12
            continue
13
        14
        target = total_energy // N
15
        operations = 0
16
        balance = 0
17
        18
        for i in range(N):
19
            balance += energy[i] - target
20
            if balance % K != 0:
21
                operations = -1
22
                break
23
            operations += abs(balance) // K
24
        25
        results.append(operations)
26
    27
    return results
28
29
T = 3
30
test_cases = [
31
    (3, 2, [4, 4, 4]),
32
    (3, 1, [5, 3, 4]),
33
    (4, 3, [5, 5, 5, 6])
34
]
35
36
results = min_operations_to_equalize(T, test_cases)
37
for result in results:
38
    print(result)
39",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834684
1387834687,codedot,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    energy = list(map(int, input().split()))
5
    6
    total_energy = sum(energy)
7
    8
    if total_energy % n != 0:
9
        print(-1)
10
        continue
11
    12
    target_energy = total_energy // n
13
    operations = 0
14
    current_balance = 0
15
    16
    for i in range(n):
17
        current_balance += energy[i] - target_energy
18
        if current_balance > 0:
19
            operations += (current_balance + k - 1) // k    
20
    print(operations)
21",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834687
1387834688,veerchauhan6161,unknown,unknown,"1
def solve():
2
    T = int(input())  # Read the number of test cases
3
    4
    for _ in range(T):
5
        n = int(input())  # Number of nodes
6
        values = list(map(int, input().split()))  # Read the values array
7
        8
        # Initialize the result array
9
        result = [1] * n
10
        11
        # Step 1: Compute the left product for each index and store it in result
12
        left_product = 1
13
        for i in range(n):
14
            result[i] = left_product
15
            left_product *= values[i]
16
        17
        # Step 2: Compute the right product and multiply it with the result
18
        right_product = 1
19
        for i in range(n - 1, -1, -1):
20
            result[i] *= right_product
21
            right_product *= values[i]
22
        23
        # Print the result for the current test case
24
        print("" "".join(map(str, result)))
25
26
# Calling solve function to read input and compute output
27
solve()",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834688
1387834681,thepandeysaurav,unknown,unknown,"1
def min_operations_to_equalize(n, k, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % n != 0:
5
        return -1
6
    7
    target = total_energy // n
8
    pos_moves = 0
9
    neg_moves = 0
10
    11
    for e in energy:
12
        diff = e - target
13
        if diff % k != 0:
14
            return -1
15
        if diff > 0:
16
            pos_moves += diff // k
17
        else:
18
            neg_moves += (-diff) // k
19
    20
    return pos_moves if pos_moves == neg_moves else -1
21
22
def main():
23
    import sys
24
    input = sys.stdin.read
25
    data = input().split()
26
    27
    index = 0
28
    T = int(data[index])
29
    index += 1
30
    31
    results = []
32
    for _ in range(T):
33
        N, K = map(int, data[index:index+2])
34
        index += 2
35
        energy = list(map(int, data[index:index+N]))
36
        index += N
37
        results.append(str(min_operations_to_equalize(N, K, energy)))
38
    39
    print(""\n"".join(results))
40
41
if __name__ == ""__main__"":
42
    main()
43",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834681
1387834673,h1032220278,unknown,unknown,"1
def equalizeEnergy(T, testCases):
2
    results = []
3
    for t in range(T):
4
        N, K = testCases[t][:2]
5
        energy = testCases[t][2]
6
        totalEnergy = sum(energy)
7
8
        if totalEnergy % N != 0:
9
            results.append(-1)
10
            continue
11
12
        target = totalEnergy // N
13
        cumulativeBalance = 0
14
        operations = 0
15
16
        for i in range(N):
17
            balance = energy[i] - target
18
            cumulativeBalance += balance
19
            operations += abs(cumulativeBalance)
20
21
        if operations % K != 0:
22
            results.append(-1)
23
        else:
24
            results.append(operations // K)
25
26
    return results
27
28
29
T = int(input())
30
testCases = []
31
32
for t in range(T):
33
    N, K = map(int, input().split())
34
    energy = list(map(int, input().split()))
35
    testCases.append((N, K, energy))
36
37
results = equalizeEnergy(T, testCases)
38
39
for res in results:
40
    print(res)
41",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834673
1387834675,dhananjaygaur04,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt(); // Number of test cases
8
        9
        while (T-- > 0) {
10
            int N = scanner.nextInt(); // Number of power stations
11
            int K = scanner.nextInt(); // Units of energy per transfer
12
            13
            long[] energy = new long[N];
14
            long totalEnergy = 0;
15
            16
            // Read energy values and calculate total
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextLong();
19
                totalEnergy += energy[i];
20
            }
21
            22
            System.out.println(minOperationsToEqualize(N, K, energy, totalEnergy));
23
        }
24
        25
        scanner.close();
26
    }
27
    28
    private static long minOperationsToEqualize(int N, int K, long[] energy, long totalEnergy) {
29
        // Check if equalization is possible
30
        if (totalEnergy % N != 0) {
31
            return -1;
32
        }
33
        34
        long targetEnergy = totalEnergy / N;
35
        36
        // Check if already equalized
37
        boolean isEqual = true;
38
        for (int i = 0; i < N; i++) {
39
            if (energy[i] != targetEnergy) {
40
                isEqual = false;
41
                break;
42
            }
43
        }
44
        if (isEqual) {
45
            return 0;
46
        }
47
        48
        // Count operations needed
49
        long operations = 0;
50
        long[] current = energy.clone();
51
        52
        // First check if it's possible to equalize
53
        for (int i = 0; i < N; i++) {
54
            if (Math.abs(current[i] - targetEnergy) % K != 0) {
55
                return -1;
56
            }
57
        }
58
        59
        // Try to equalize by transferring energy
60
        for (int i = 0; i < N - 1; i++) {
61
            if (current[i] > targetEnergy) {
62
                long excess = current[i] - targetEnergy;
63
                long transfers = excess / K;
64
                current[i] -= transfers * K;
65
                current[i + 1] += transfers * K;
66
                operations += transfers;
67
            } else if (current[i] < targetEnergy) {
68
                long deficit = targetEnergy - current[i];
69
                long transfers = deficit / K;
70
                current[i] += transfers * K;
71
                current[i + 1] -= transfers * K;
72
                operations += transfers;
73
            }
74
        }
75
        76
        // Check final station
77
        if (current[N - 1] != targetEnergy) {
78
            // Need to transfer to/from first station
79
            long diff = Math.abs(current[N - 1] - targetEnergy);
80
            operations += diff / K;
81
        }
82
        83
        return operations;
84
    }
85
}",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834675
1387834676,oms989069,unknown,unknown,"1
def equalize_energy(N, K, energy):
2
  total_energy = sum(energy)
3
  if total_energy % N != 0:
4
    return -1 
5
6
  target_energy = total_energy 
7
  operations = 0
8
9
  for i in range(N):
10
    diff = energy[i] - target_energy
11
    if diff % K != 0:
12
      return -1 
13
14
    operations += abs(diff) 
15
16
  return operations
17
18
T = int(input())
19
for _ in range(T):
20
  N, K = map(int, input().split())
21
  energy = list(map(int, input().split()))
22
  print(equalize_energy(N, K, energy))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834676
1387834661,sg7859298,unknown,unknown,"1
import java.io.*;  
2
import java.util.*;  
3
4
public class Solution {  
5
6
    public static void main(String[] args) {  
7
        Scanner scanner = new Scanner(System.in);  
8
        int t = scanner.nextInt(); // Number of test cases  
9
        for (int k = 0; k < t; k++) {  
10
            int n = scanner.nextInt(); // Number of stations  
11
            int kVal = scanner.nextInt(); // Energy transfer unit  
12
            int[] energies = new int[n];  
13
            14
            for (int i = 0; i < n; i++) {  
15
                energies[i] = scanner.nextInt(); // Read energies  
16
            }  
17
18
            long totalEnergy = 0;  
19
            for (int energy : energies) {  
20
                totalEnergy += energy; // Calculate total energy  
21
            }  
22
23
            if (totalEnergy % n != 0) {  
24
                System.out.println(-1); // Impossible to equalize  
25
                continue;  
26
            }  
27
28
            long targetEnergy = totalEnergy / n;  
29
            long[] diff = new long[n];  
30
31
            for (int i = 0; i < n; i++) {  
32
                diff[i] = energies[i] - targetEnergy; // Calculate differences  
33
            }  
34
35
            long operations = 0;  
36
            long cumulativeSum = 0;  
37
            boolean isPossible = true;  
38
39
            for (int i = 0; i < n; i++) {  
40
                cumulativeSum += diff[i];  
41
                if (cumulativeSum % kVal != 0) {  
42
                    isPossible = false; // Can't make equal distribution  
43
                    break;  
44
                }  
45
                operations += Math.abs(cumulativeSum) / kVal; // Count operations  
46
            }  
47
48
            if (isPossible) {  
49
                System.out.println(operations); // Output the number of operations  
50
            } else {  
51
                System.out.println(-1); // Impossible case  
52
            }  
53
        }  
54
        scanner.close(); // Close scanner  
55
    }  
56
}",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834661
1387834664,siddhinnaik05,unknown,unknown,"1
def minimum_operations_to_equalize(t, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K, energy = case
6
7
        # Calculate total energy and check if it's divisible by N
8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target = total_energy // N
14
        diffs = [e - target for e in energy]
15
16
        # Calculate prefix sums of diffs to determine feasibility
17
        prefix_sum = 0
18
        operations = 0
19
        possible = True
20
21
        for i in range(N):
22
            prefix_sum += diffs[i]
23
            # If prefix_sum is not divisible by K, balancing is impossible
24
            if prefix_sum % K != 0:
25
                possible = False
26
                break
27
            operations += abs(prefix_sum) // K
28
29
        results.append(operations if possible else -1)
30
31
    return results
32
33
# Read input
34
def main():
35
    T = int(input())
36
    test_cases = []
37
38
    for _ in range(T):
39
        N, K = map(int, input().split())
40
        energy = list(map(int, input().split()))
41
        test_cases.append((N, K, energy))
42
43
    # Get the results and print them
44
    results = minimum_operations_to_equalize(T, test_cases)
45
    for result in results:
46
        print(result)
47
48
if __name__ == ""__main__"":
49
    main()",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834664
1387834659,codedot,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    energy = list(map(int, input().split()))
5
    6
    total_energy = sum(energy)
7
    8
    if total_energy % n != 0:
9
        print(-1)
10
        continue
11
    12
    target_energy = total_energy // n
13
    operations = 0
14
    current_balance = 0
15
    16
    for i in range(n):
17
        current_balance += energy[i] - target_energy
18
        if current_balance > 0:
19
            operations += (current_balance + k - 1) // k
20
            21
    print(operations)
22",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834659
1387834642,h1032221720,unknown,unknown,"1
def minimum_operations_to_equalize(t, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K, energy = case
6
7
        # Calculate total energy and check if it's divisible by N
8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target = total_energy // N
14
        diffs = [e - target for e in energy]
15
16
        # Calculate prefix sums of diffs to determine feasibility
17
        prefix_sum = 0
18
        operations = 0
19
        possible = True
20
21
        for i in range(N):
22
            prefix_sum += diffs[i]
23
            # If prefix_sum is not divisible by K, balancing is impossible
24
            if prefix_sum % K != 0:
25
                possible = False
26
                break
27
            operations += abs(prefix_sum) // K
28
29
        results.append(operations if possible else -1)
30
31
    return results
32
33
# Read input
34
def main():
35
    T = int(input())
36
    test_cases = []
37
38
    for _ in range(T):
39
        N, K = map(int, input().split())
40
        energy = list(map(int, input().split()))
41
        test_cases.append((N, K, energy))
42
43
    # Get the results and print them
44
    results = minimum_operations_to_equalize(T, test_cases)
45
    for result in results:
46
        print(result)
47
48
if __name__ == ""__main__"":
49
    main()",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834642
1387834647,ansh_shetty_22,unknown,unknown,"1
with Ada.Text_IO; use Ada.Text_IO;
2
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
3
4
procedure Solution is
5
   T : Integer;
6
begin
7
   Get(T);
8
   for Testcase in 1 .. T loop
9
      declare
10
         N, K, Total_Energy, Target, Operations : Integer;
11
         Energy : array (1 .. 100000) of Integer;
12
         Valid : Boolean := True;
13
      begin
14
         Get(N);
15
         Get(K);
16
         Total_Energy := 0;
17
18
         for I in 1 .. N loop
19
            Get(Energy(I));
20
            Total_Energy := Total_Energy + Energy(I);
21
         end loop;
22
23
         if Total_Energy mod N /= 0 then
24
            Put_Line(""-1"");
25
            next Testcase;
26
         end if;
27
28
         Target := Total_Energy / N;
29
         Operations := 0;
30
31
         for I in 1 .. N loop
32
            declare
33
               Diff : Integer := Energy(I) - Target;
34
            begin
35
               if Diff mod K /= 0 then
36
                  Valid := False;
37
                  exit;
38
               end if;
39
               Operations := Operations + abs(Diff) / K;
40
            end;
41
         end loop;
42
43
         if Valid then
44
            Put_Line(Integer'Image(Operations / 2));
45
         else
46
            Put_Line(""-1"");
47
         end if;
48
      end;
49
   end loop;
50
end Solution;
51",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834647
1387834650,akashyadv7233,unknown,unknown,"1
function processData(input) {
2
    const lines = input.trim().split(""\n"");
3
    const T = parseInt(lines[0]);
4
    const results = [];
5
    let index = 1;
6
7
    for (let t = 0; t < T; t++) {
8
        // Read N and K
9
        const [N, K] = lines[index].split("" "").map(Number);
10
        const energy = lines[index + 1].split("" "").map(Number);
11
        index += 2;
12
13
        const totalEnergy = energy.reduce((sum, e) => sum + e, 0);
14
15
        if (totalEnergy % N !== 0) {
16
            results.push(-1);
17
            continue;
18
        }
19
20
        const target = totalEnergy / N; 
21
        const diff = energy.map(e => e - target); 
22
23
        let prefixSum = 0; 
24
        let totalOperations = 0; 
25
26
        for (let i = 0; i < N; i++) {
27
            prefixSum += diff[i];
28
            totalOperations += Math.abs(prefixSum);
29
        }
30
31
        results.push(totalOperations / K);
32
    }
33
    console.log(results.join(""\n""));
34
}
35
36
process.stdin.resume();
37
process.stdin.setEncoding(""ascii"");
38
let _input = """";
39
process.stdin.on(""data"", function (input) {
40
    _input += input;
41
});
42
43
process.stdin.on(""end"", function () {
44
    processData(_input);
45
});
46",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834650
1387834640,vishwakarmakara2,unknown,unknown,"1
def prdct(arr: list[int]):
2
    zeroCount = arr.count(0)
3
    ans = []
4
    all_prdct = 1
5
    6
    for n in arr:
7
        if n != 0:
8
            all_prdct *= n
9
10
    if zeroCount == 0:
11
        for num in arr:
12
            ans.append(all_prdct // num)
13
    elif zeroCount == 1:
14
        for i in range(len(arr)):
15
            if arr[i] == 0:
16
                ans.append(all_prdct)
17
            else:
18
                ans.append(0)
19
    elif zeroCount > 1:
20
        ans = [0] * len(arr)
21
22
    return ans
23
24
T = int(input())
25
results = []
26
for t in range(T):
27
    n = int(input())
28
    nums = list(map(int, input().split()))  
29
    res = prdct(nums)
30
    results.append(res)
31
32
for rs in results:
33
    for x in rs:
34
        print(x,end=' ')
35
    print()
36",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834640
1387834627,codedot,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    num_stations, transfer_amount=map(int,input().split())
4
    energy_levels=list(map(int,input().split()))
5
    total_energy=sum(energy_levels)
6
    if total_energy%num_stations!=0:
7
        print(-1)
8
        continue
9
    desired_energy=total_energy//num_stations
10
    operations_needed=0
11
    current_surplus=0
12
    for i in range(num_stations):
13
        current_surplus+=energy_levels[i]-desired_energy
14
        if current_surplus>0:
15
            operations_needed+=(current_surplus+transfer_amount-1)//transfer_amount
16
    print(operations_needed)
17",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834627
1387834630,sushanttiwari074,unknown,unknown,"1
def min_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K, energies = case
6
        total_energy = sum(energies)
7
        8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
        12
        target = total_energy // N
13
        operations = 0
14
        current_balance = 0
15
        16
        for energy in energies:
17
            current_balance += (energy - target)
18
            if current_balance > 0:
19
                operations += (current_balance + K - 1) // K  
20
            elif current_balance < 0:
21
                operations += (-current_balance + K - 1) // K  
22
        23
        results.append(operations)
24
    25
    return results
26
27
import sys
28
29
input = sys.stdin.read
30
data = input().splitlines()
31
32
T = int(data[0])  
33
test_cases = []
34
35
index = 1
36
for _ in range(T):
37
    N, K = map(int, data[index].split())
38
    index += 1
39
    energies = list(map(int, data[index].split()))
40
    test_cases.append((N, K, energies))
41
    index += 1
42
43
results = min_operations_to_equalize(test_cases)
44
for res in results:
45
    print(res)
46",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834630
1387834638,rajnishjha,unknown,unknown,"1
def solve():
2
    import sys
3
    data = sys.stdin.read().strip().split()
4
    t = int(data[0])
5
    idx = 1
6
7
    for _ in range(t):
8
        n = int(data[idx]); idx += 1
9
        nums = list(map(int, data[idx:idx+n]))
10
        idx += n
11
        12
        total_sum = sum(nums)
13
        14
        prefix_sum = 0
15
        max_diff = 0
16
17
        for i in range(n - 1):
18
            prefix_sum += nums[i]
19
            diff = abs(2 * prefix_sum - total_sum)
20
            if diff > max_diff:
21
                max_diff = diff
22
        23
        print(max_diff)
24
25
solve()",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834638
1387834619,sg7859298,unknown,unknown,"1
import java.io.*;  
2
import java.util.*;  
3
4
public class Solution {  
5
6
    public static void main(String[] args) {  
7
        Scanner scanner = new Scanner(System.in);  
8
        int t = scanner.nextInt();  
9
        for (int k = 0; k < t; k++) {  
10
            int n = scanner.nextInt();  
11
            int kVal = scanner.nextInt();  
12
            int[] energies = new int[n];  
13
            for (int i = 0; i < n; i++) {  
14
                energies[i] = scanner.nextInt();  
15
            }  
16
17
            long totalEnergy = 0;  
18
            for (int energy : energies) {  
19
                totalEnergy += energy;  
20
            }  
21
22
            if (totalEnergy % n != 0) {  
23
                System.out.println(-1);  
24
                continue;  
25
            }  
26
27
            long targetEnergy = totalEnergy / n;  
28
            long[] diff = new long[n];  
29
            for (int i = 0; i < n; i++) {  
30
                diff[i] = energies[i] - targetEnergy;  
31
            }  
32
33
            long[] cDiff = new long[n];  
34
            for (int i = 1; i < n; i++) {  
35
                cDiff[i] = cDiff[i - 1] + diff[i - 1];  
36
            }  
37
38
            long operations = 0;  
39
            boolean isPossible = true;  
40
            for (int i = 1; i < n; i++) {  
41
                if (cDiff[i] % kVal != 0) {  
42
                    isPossible = false;  
43
                    break;  
44
                }  
45
                operations += Math.abs(cDiff[i]) / kVal;  
46
            }  
47
48
            if (isPossible) {  
49
                System.out.println(operations);  
50
            } else {  
51
                System.out.println(-1);  
52
            }  
53
        }  
54
        scanner.close();  
55
    }  
56
}",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834619
1387834621,shravanimargaj02,unknown,unknown,"1
def product_except_self(arr):
2
    n = len(arr)
3
    result = [1] * n
4
    5
    # Prefix product
6
    prefix = 1
7
    for i in range(n):
8
        result[i] = prefix
9
        prefix *= arr[i]
10
    11
    # Suffix product
12
    suffix = 1
13
    for i in range(n - 1, -1, -1):
14
        result[i] *= suffix
15
        suffix *= arr[i]
16
    17
    return result
18
19
# Input reading
20
t = int(input())  # Number of test cases
21
for _ in range(t):
22
    n = int(input())  # Length of the array
23
    arr = list(map(int, input().split()))
24
    print(*product_except_self(arr))
25",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834621
1387834624,vivekbhandari101,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <algorithm>
5
6
using namespace std;
7
8
int maxAbsDiff(const vector<int>& nums) {
9
    int n = nums.size();
10
    vector<int> prefix_sum(n);
11
    prefix_sum[0] = nums[0];
12
    for (int i = 1; i < n; ++i) {
13
        prefix_sum[i] = prefix_sum[i - 1] + nums[i];
14
    }
15
16
    int max_diff = 0;
17
    for (int i = 1; i < n; ++i) {
18
        int left_sum = prefix_sum[i - 1];
19
        int right_sum = prefix_sum[n - 1] - left_sum;
20
        max_diff = max(max_diff, abs(left_sum - right_sum));
21
    }
22
23
    return max_diff;
24
}
25
26
int main() {
27
    int t;
28
    cin >> t;
29
30
    while (t--) {
31
        int n;
32
        cin >> n;
33
34
        vector<int> nums(n);
35
        for (int i = 0; i < n; ++i) {
36
            cin >> nums[i];
37
        }
38
39
        int result = maxAbsDiff(nums);
40
        cout << result << endl;
41
    }
42
43
    return 0;
44
}",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834624
1387834611,warangsmit,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n,k=map(int,input().split())
4
    arr=list(map(int,input().split()))
5
    summ=sum(arr)
6
    if summ%n:print(-1)
7
    else:
8
        avg=summ//n
9
        arr=[i-avg for i in arr]
10
        ans=0
11
        total=0
12
        for i in arr:
13
            total+=i
14
            if total%k:
15
                print(-1)
16
                break
17
            ans+=abs(total)//k
18
        else:print(ans)",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834611
1387834615,rajnishjha,unknown,unknown,"1
def equalize_energy(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target_energy = total_energy // N
14
        balance = 0
15
        operations = 0
16
17
        for e in energy:
18
            diff = e - target_energy
19
            if diff % K != 0:
20
                results.append(-1)
21
                break
22
            balance += diff // K
23
            operations += abs(diff // K)
24
        else:
25
            if balance != 0:
26
                results.append(-1)
27
            else:
28
                results.append(operations // 2)
29
30
    return results
31
32
33
# Input Handling
34
import sys
35
input = sys.stdin.read
36
data = input().splitlines()
37
38
T = int(data[0])
39
test_cases = []
40
line = 1
41
42
for _ in range(T):
43
    N, K = map(int, data[line].split())
44
    energy = list(map(int, data[line + 1].split()))
45
    test_cases.append(((N, K), energy))
46
    line += 2
47
48
# Compute results
49
results = equalize_energy(T, test_cases)
50
51
# Print results
52
for res in results:
53
    print(res)
54",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834615
1387834617,imharsh1910,unknown,unknown,"1
def equalize_energy(arr, k):
2
    n = len(arr)
3
    total_energy = sum(arr)
4
    5
   6
    if total_energy % n != 0:
7
        return -1
8
    9
    target = total_energy // n
10
    operations = 0
11
  12
    for i in range(n):
13
        diff = arr[i] - target
14
        if diff != 0:
15
            if diff % k != 0:
16
                return -1
17
            arr[i] -= diff
18
            arr[(i + 1) % n] += diff
19
            operations += abs(diff) // k
20
21
    return operations
22
23
T = int(input())
24
for _ in range(T):
25
    n, k = map(int, input().split())
26
    arr = list(map(int, input().split()))
27
    result = equalize_energy(arr, k)
28
    print(result)
29",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834617
1387834605,yrawal2004,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
4
    # If total energy cannot be evenly divided among stations, return -1
5
    if total_energy % N != 0:
6
        return -1
7
8
    target = total_energy // N  # Each station should have this much energy
9
    operations = 0
10
    balance = 0  # Keeps track of energy surplus/deficit as we move around
11
12
    for i in range(N):
13
        diff = energy[i] - target
14
        balance += diff
15
        16
        # If the transfer is not a multiple of K, it's impossible
17
        if balance % K != 0:
18
            return -1
19
20
        operations += abs(balance) // K  # Convert deficit/surplus into operations
21
22
    return operations
23
24
# Read number of test cases
25
T = int(input().strip())
26
27
for _ in range(T):
28
    N, K = map(int, input().strip().split())  # Read N and K
29
    energy = list(map(int, input().strip().split()))  # Read energy levels
30
    print(min_operations_to_equalize(N, K, energy))  # Compute and print result
31",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834605
1387834595,h1032220319,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <numeric>
6
using namespace std;
7
8
void helper(){
9
    int n,k;
10
    cin>>n>>k;
11
    12
    vector<int>energy(n);
13
    for(int i=0;i<n;i++){
14
        cin>>energy[i];
15
    }
16
    long long totalEnergy =accumulate(energy.begin(),energy.end(),0LL);
17
    18
    if(totalEnergy%n!=0){
19
        cout<<-1<<""\n""; return;
20
    }
21
    int targetEnergy=totalEnergy/n;
22
    long long operations=0;
23
    long long cumulativeDiff=0;
24
    25
    for(int i=0;i<n;i++){
26
        int diff=energy[i]-targetEnergy;
27
        cumulativeDiff+=diff;
28
        29
        if(diff%k!=0){
30
            cout<<-1 <<""\n"";
31
            return;
32
        }
33
    operations+=abs(cumulativeDiff/k);
34
    }  cout<<operations<<""\n"";
35
}
36
37
int main() {
38
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
39
   int input;
40
    cin>> input;
41
    while(input--){
42
        helper();
43
    }
44
    45
    return 0;
46
}
47",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834595
1387834599,h1032221631,unknown,unknown,"1
def moe(test_cases):
2
    results = []
3
4
    for t in range(len(test_cases)):
5
        N, K, energy = test_cases[t]
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // N
12
        operations = 0
13
        balance = 0  
14
        for i in range(N):
15
            balance += energy[i] - target
16
            if balance % K != 0:
17
                operations = -1
18
                break
19
            operations += abs(balance) // K
20
        21
        results.append(operations if operations != -1 else -1)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    N, K = map(int, input().split())
30
    energy = list(map(int, input().split()))
31
    test_cases.append((N, K, energy))
32
results = moe(test_cases)
33
for res in results:
34
    print(res)",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834599
1387834601,karanmakan2250,unknown,unknown,"1
def solve():
2
    import sys
3
    data = sys.stdin.read().strip().split()
4
    t = int(data[0])
5
    idx = 1
6
7
    for _ in range(t):
8
        n = int(data[idx]); idx += 1
9
        nums = list(map(int, data[idx:idx+n]))
10
        idx += n
11
        12
        total_sum = sum(nums)
13
        14
        prefix_sum = 0
15
        max_diff = 0
16
17
        for i in range(n - 1):
18
            prefix_sum += nums[i]
19
            diff = abs(2 * prefix_sum - total_sum)
20
            if diff > max_diff:
21
                max_diff = diff
22
        23
        print(max_diff)
24
25
solve()",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834601
1387834587,thepandeysaurav,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
    5
    left_product = 1
6
    for i in range(n):
7
        result[i] = left_product
8
        left_product *= values[i]
9
    10
    right_product = 1
11
    for i in range(n-1, -1, -1):
12
        result[i] *= right_product
13
        right_product *= values[i]
14
    15
    return result
16
17
def main():
18
    import sys
19
    input = sys.stdin.read
20
    data = input().split()
21
    22
    idx = 0
23
    T = int(data[idx])
24
    idx += 1
25
    26
    for _ in range(T):
27
        n = int(data[idx])
28
        idx += 1
29
        values = list(map(int, data[idx:idx+n]))
30
        idx += n
31
        32
        result = product_except_self(values)
33
        print(' '.join(map(str, result)))
34
35
if __name__ == ""__main__"":
36
    main()
37",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834587
1387834589,bhavikasingh1004,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        # Check if it's possible to equalize
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target = total_energy // N
16
        17
        # Calculate difference array
18
        diff = [energy[i] - target for i in range(N)]
19
20
        # To keep track of the cumulative imbalance
21
        imbalance = 0
22
        min_operations = 0
23
24
        for d in diff:
25
            imbalance += d
26
            # Since each operation involves K units, the imbalance should be a multiple of K
27
            if imbalance % K != 0:
28
                min_operations = -1
29
                break
30
31
            min_operations += abs(imbalance) // K
32
33
        results.append(min_operations)
34
35
    return results
36
37
def max_absolute_difference(T, test_cases):
38
    results = []
39
40
    for t in range(T):
41
        n = test_cases[t][0]
42
        nums = test_cases[t][1]
43
44
        # Calculate prefix and suffix sums
45
        prefix_sum = [0] * n
46
        suffix_sum = [0] * n
47
48
        prefix_sum[0] = nums[0]
49
        for i in range(1, n):
50
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
51
52
        suffix_sum[-1] = nums[-1]
53
        for i in range(n - 2, -1, -1):
54
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
55
56
        # Find the maximum absolute difference
57
        max_diff = 0
58
        for i in range(n - 1):
59
            left_sum = prefix_sum[i]
60
            right_sum = suffix_sum[i + 1]
61
            max_diff = max(max_diff, abs(left_sum - right_sum))
62
63
        results.append(max_diff)
64
65
    return results
66
67
# Input reading
68
T = int(input())
69
test_cases = []
70
for _ in range(T):
71
    n = int(input())
72
    nums = list(map(int, input().split()))
73
    test_cases.append((n, nums))
74
75
# Solve the problem
76
output = max_absolute_difference(T, test_cases)
77
78
# Print the results
79
for res in output:
80
    print(res)",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834589
1387834593,snehakumari2323,unknown,unknown,"1
def solve_testcase(n, k, energy):
2
    total_energy = sum(energy)
3
    4
    # Check if the total energy is divisible by n
5
    if total_energy % n != 0:
6
        return -1
7
    8
    target = total_energy // n
9
    operations = 0
10
    balance = 0
11
    12
    # Traverse through each power station
13
    for i in range(n):
14
        # Calculate the difference between the current energy and the target energy
15
        diff = energy[i] - target
16
        balance += diff
17
        18
        # If the difference is not divisible by k, it's impossible to transfer
19
        if balance % k != 0:
20
            return -1
21
        22
        # The number of operations is the absolute value of the number of full k transfers
23
        operations += abs(balance // k)
24
    25
    return operations
26
27
def main():
28
    t = int(input())  # Number of test cases
29
    for _ in range(t):
30
        n, k = map(int, input().split())  # N and K for each test case
31
        energy = list(map(int, input().split()))  # The energy levels of each station
32
        33
        result = solve_testcase(n, k, energy)  # Solve the test case
34
        print(result)
35
36
if __name__ == ""__main__"":
37
    main()
38",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834593
1387834570,h1032220829,unknown,unknown,"1
def minimum_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][0]
5
        energy = test_cases[t][1]
6
        7
        total_energy = sum(energy)
8
        9
        # If the total energy cannot be evenly distributed, return -1
10
        if total_energy % N != 0:
11
            results.append(-1)
12
            continue
13
        14
        target_energy = total_energy // N
15
        operations = 0
16
        balance = 0  # Tracks energy imbalance
17
        18
        # Traverse the array to compute the number of operations needed
19
        for i in range(N):
20
            balance += (energy[i] - target_energy)
21
            22
            # Only multiples of K can be transferred in one operation
23
            if balance % K != 0:
24
                operations = -1
25
                break
26
            27
            # Add the absolute imbalance to operations
28
            operations += abs(balance) // K
29
        30
        results.append(operations)
31
    32
    return results
33
34
35
# Input handling
36
if __name__ == ""__main__"":
37
    T = int(input())  # Number of test cases
38
    test_cases = []
39
    for _ in range(T):
40
        N, K = map(int, input().split())
41
        energy = list(map(int, input().split()))
42
        test_cases.append(((N, K), energy))
43
    44
    # Get results for all test cases
45
    results = minimum_operations_to_equalize_energy(T, test_cases)
46
    47
    # Print the results
48
    for result in results:
49
        print(result)
50",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834570
1387834581,rajnishjha,unknown,unknown,"1
def equalize_energy(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target_energy = total_energy // N
14
        balance = 0
15
        operations = 0
16
17
        for e in energy:
18
            diff = e - target_energy
19
            if diff % K != 0:
20
                results.append(-1)
21
                break
22
            balance += diff // K
23
            operations += abs(diff // K)
24
        else:
25
            if balance != 0:
26
                results.append(-1)
27
            else:
28
                results.append(operations // 2)
29
30
    return results
31
32
33
import sys
34
input = sys.stdin.read
35
data = input().splitlines()
36
37
T = int(data[0])
38
test_cases = []
39
line = 1
40
41
for _ in range(T):
42
    N, K = map(int, data[line].split())
43
    energy = list(map(int, data[line + 1].split()))
44
    test_cases.append(((N, K), energy))
45
    line += 2
46
47
results = equalize_energy(T, test_cases)
48
for res in results:
49
    print(res)
50",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834581
1387834585,sg7859298,unknown,unknown,"1
import java.io.*;  
2
import java.util.*;  
3
4
public class Solution {  
5
6
    public static void main(String[] args) {  
7
        Scanner scanner = new Scanner(System.in);  
8
        int t = scanner.nextInt();  
9
        for (int k = 0; k < t; k++) {  
10
            int n = scanner.nextInt();  
11
            int[] values = new int[n];  
12
            for (int i = 0; i < n; i++) {  
13
                values[i] = scanner.nextInt();  
14
            }  
15
            long[] result = new long[n];  
16
            for (int i = 0; i < n; i++) {  
17
                long product = 1;  
18
                for (int j = 0; j < n; j++) {  
19
                    if (i != j) {  
20
                        product *= values[j];  
21
                    }  
22
                }  
23
                result[i] = product;  
24
            }  
25
            for (long res : result) {  
26
                System.out.print(res + "" "");  
27
            }  
28
            System.out.println();  
29
        }  
30
        scanner.close();  
31
    }  
32
}",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834585
1387834562,siddhinnaik05,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <cmath>
5
using namespace std;
6
7
void solve() {
8
    int T;
9
    cin >> T; // Number of test cases
10
11
    while (T--) {
12
        int N, K;
13
        cin >> N >> K; // Number of stations and energy transfer units per operation
14
15
        vector<int> energy(N);
16
        long long totalEnergy = 0;
17
18
        for (int i = 0; i < N; i++) {
19
            cin >> energy[i];
20
            totalEnergy += energy[i];
21
        }
22
23
        // If total energy is not divisible by N, equal distribution is impossible
24
        if (totalEnergy % N != 0) {
25
            cout << -1 << endl;
26
            continue;
27
        }
28
29
        int target = totalEnergy / N; // Target energy for each station
30
        long long imbalance = 0, operations = 0;
31
32
        for (int i = 0; i < N; i++) {
33
            imbalance += (energy[i] - target); // Update imbalance
34
            if (imbalance % K != 0) {         // Check if imbalance can be resolved with K
35
                cout << -1 << endl;
36
                goto next_case;
37
            }
38
            operations += abs(imbalance) / K; // Add operations to resolve imbalance
39
        }
40
41
        cout << operations << endl;
42
    next_case:
43
        continue;
44
    }
45
}
46
47
int main() {
48
    solve();
49
    return 0;
50
}
51
52",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834562
1387834554,yashdubeyenter15,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt(); // Number of test cases
8
        9
        while (T-- > 0) {
10
            int N = scanner.nextInt(); // Number of power stations
11
            int K = scanner.nextInt(); // Units of energy per transfer
12
            13
            long[] energy = new long[N];
14
            long totalEnergy = 0;
15
            16
            // Read energy values and calculate total
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextLong();
19
                totalEnergy += energy[i];
20
            }
21
            22
            System.out.println(minOperationsToEqualize(N, K, energy, totalEnergy));
23
        }
24
        25
        scanner.close();
26
    }
27
    28
    private static long minOperationsToEqualize(int N, int K, long[] energy, long totalEnergy) {
29
        // Check if equalization is possible
30
        if (totalEnergy % N != 0) {
31
            return -1;
32
        }
33
        34
        long targetEnergy = totalEnergy / N;
35
        36
        // Check if already equalized
37
        boolean isEqual = true;
38
        for (int i = 0; i < N; i++) {
39
            if (energy[i] != targetEnergy) {
40
                isEqual = false;
41
                break;
42
            }
43
        }
44
        if (isEqual) {
45
            return 0;
46
        }
47
        48
        // Count operations needed
49
        long operations = 0;
50
        long[] current = energy.clone();
51
        52
        // First check if it's possible to equalize
53
        for (int i = 0; i < N; i++) {
54
            if (Math.abs(current[i] - targetEnergy) % K != 0) {
55
                return -1;
56
            }
57
        }
58
        59
        // Try to equalize by transferring energy
60
        for (int i = 0; i < N - 1; i++) {
61
            if (current[i] > targetEnergy) {
62
                long excess = current[i] - targetEnergy;
63
                long transfers = excess / K;
64
                current[i] -= transfers * K;
65
                current[i + 1] += transfers * K;
66
                operations += transfers;
67
            } else if (current[i] < targetEnergy) {
68
                long deficit = targetEnergy - current[i];
69
                long transfers = deficit / K;
70
                current[i] += transfers * K;
71
                current[i + 1] -= transfers * K;
72
                operations += transfers;
73
            }
74
        }
75
        76
        // Check final station
77
        if (current[N - 1] != targetEnergy) {
78
            // Need to transfer to/from first station
79
            long diff = Math.abs(current[N - 1] - targetEnergy);
80
            operations += diff / K;
81
        }
82
        83
        return operations;
84
    }
85
}",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834554
1387834559,vivekbhandari101,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <algorithm>
4
using namespace std;
5
int main() {
6
    int t;
7
    cin >> t;
8
    while (t--) {
9
        int n, k;
10
        cin >> n >> k;
11
        vector<int> energy(n);
12
        int total_energy = 0;
13
        for (int i = 0; i < n; ++i) {
14
            cin >> energy[i];
15
            total_energy += energy[i];
16
        }
17
        if (total_energy % n != 0) {
18
            cout << -1 << endl;
19
            continue;
20
        }
21
        int target_energy = total_energy / n;
22
        int operations = 0;
23
        // Calculate the net energy difference for each station
24
        vector<int> net_diff(n);
25
        for (int i = 0; i < n; ++i) {
26
            net_diff[i] = energy[i] - target_energy;
27
        }
28
        // Calculate the cumulative sum of net differences
29
        for (int i = 1; i < n; ++i) {
30
            net_diff[i] += net_diff[i - 1];
31
        }
32
        // Find the minimum number of operations to equalize
33
        int min_ops = INT_MAX;
34
        for (int i = 0; i < n; ++i) {
35
            int current_ops = abs(net_diff[i]) / k;
36
            // Handle the case where net_diff[i] is not a multiple of k
37
            if (abs(net_diff[i]) % k != 0) {
38
                current_ops++;
39
            }
40
            min_ops = min(min_ops, current_ops);
41
        }
42
        cout << min_ops << endl;
43
    }
44
    return 0;
45
}
46",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834559
1387834560,codedot,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n = int(input())
4
    nums = list(map(int, input().split()))
5
    total_sum = sum(nums)
6
    max_diff = 0
7
    8
    left_sum = 0
9
    for i in range(n - 1):
10
        left_sum += nums[i]
11
        right_sum = total_sum - left_sum
12
        diff = abs(left_sum - right_sum)
13
        if diff > max_diff:
14
            max_diff = diff
15
                16
    print(max_diff)
17",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834560
1387834546,akashyadv7233,unknown,unknown,"1
function processData(input) {
2
    const lines = input.trim().split(""\n"");
3
    const t = parseInt(lines[0]); 
4
    const results = [];
5
    6
    let index = 1;
7
    for (let testCase = 0; testCase < t; testCase++) {
8
        const n = parseInt(lines[index]); 
9
        const nums = lines[index + 1].split("" "").map(Number);
10
        index += 2;
11
12
        const prefixSum = new Array(n + 1).fill(0);
13
        for (let i = 0; i < n; i++) {
14
            prefixSum[i + 1] = prefixSum[i] + nums[i];
15
        }
16
17
        const totalSum = prefixSum[n];
18
        let maxDiff = -Infinity; 
19
20
        for (let i = 1; i < n; i++) {
21
            const leftSum = prefixSum[i];
22
            const rightSum = totalSum - leftSum;
23
            maxDiff = Math.max(maxDiff, Math.abs(leftSum - rightSum));
24
        }
25
26
        results.push(maxDiff);
27
    }
28
29
    results.forEach(result => console.log(result));
30
}
31
32
process.stdin.resume();
33
process.stdin.setEncoding(""ascii"");
34
let _input = """";
35
process.stdin.on(""data"", function (input) {
36
    _input += input;
37
});
38
39
process.stdin.on(""end"", function () {
40
    processData(_input);
41
});
42",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834546
1387834552,1_ashwarya,unknown,unknown,"1
def max_difference(t, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, nums = case
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        11
        for i in range(n - 1): 
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
t = int(input())
21
test_cases = []
22
for _ in range(t):
23
    n = int(input())
24
    nums = list(map(int, input().split()))
25
    test_cases.append((n, nums))
26
27
results = max_difference(t, test_cases)
28
29
for result in results:
30
    print(result)
31",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834552
1387834549,omg40787,unknown,unknown,"1
def max_abs_difference(nums):
2
    n = len(nums)
3
    left_sum = [0] * n
4
    right_sum = [0] * n
5
6
    left_sum[0] = nums[0]
7
    right_sum[-1] = nums[-1]
8
9
    for i in range(1, n):
10
        left_sum[i] = left_sum[i - 1] + nums[i]
11
12
    for i in range(n - 2, -1, -1):
13
        right_sum[i] = right_sum[i + 1] + nums[i]
14
15
    max_difference = 0
16
    for i in range(n - 1):
17
        difference = abs(left_sum[i] - right_sum[i + 1])
18
        max_difference = max(max_difference, difference)
19
20
    return max_difference
21
22
def main():
23
    import sys
24
    input = sys.stdin.read
25
    data = input().split()
26
27
    t = int(data[0])
28
    index = 1
29
    results = []
30
31
    for _ in range(t):
32
        n = int(data[index])
33
        nums = list(map(int, data[index + 1:index + 1 + n]))
34
        index += 1 + n
35
        result = max_abs_difference(nums)
36
        results.append(result)
37
38
    for result in results:
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834549
1387834533,swathiharish2349,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int solution(vector<int>& arr, int sum, int n){
9
    int ans=0;
10
    int prefixSum=0;
11
    int rem=sum;
12
    for(int i=0; i<n-1; i++){
13
        prefixSum+=arr[i];
14
        rem-=arr[i];
15
        ans=max(ans, abs(rem-prefixSum));
16
    }
17
    return ans;
18
}
19
20
int main() {
21
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
22
    int t;
23
    cin>>t;
24
    while(t--){
25
        int n;
26
        cin>>n;
27
        vector<int> arr(n);
28
        int sum=0;
29
        for(int i=0; i<n; i++){
30
            cin>>arr[i];
31
            sum+=arr[i];
32
        }
33
        34
        int ans = solution(arr, sum, n);
35
        cout<<ans<<endl;
36
    }
37
    return 0;
38
}
39",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834533
1387834538,h1032221720,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <cmath>
5
using namespace std;
6
7
void solve() {
8
    int T;
9
    cin >> T; 
10
11
    while (T--) {
12
        int N, K;
13
        cin >> N >> K; 
14
15
        vector<int> energy(N);
16
        long long totalEnergy = 0;
17
18
        for (int i = 0; i < N; i++) {
19
            cin >> energy[i];
20
            totalEnergy += energy[i];
21
        }
22
23
        if (totalEnergy % N != 0) {
24
            cout << -1 << endl;
25
            continue;
26
        }
27
28
        int target = totalEnergy / N; 
29
        long long operations = 0, imbalance = 0;
30
31
        for (int i = 0; i < N; i++) {
32
            imbalance += (energy[i] - target);
33
            if (imbalance % K != 0) {
34
                operations = -1;
35
                break;
36
            }
37
            operations += abs(imbalance) / K;
38
        }
39
40
        cout << operations << endl;
41
    }
42
}
43
44
int main() {
45
    solve();
46
    return 0;
47
}
48",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834538
1387834542,thepandeysaurav,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
    prefix_sum = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
7
    8
    max_diff = 0
9
    10
    for i in range(1, n):
11
        left_sum = prefix_sum[i]
12
        right_sum = prefix_sum[n] - prefix_sum[i]
13
        current_diff = abs(left_sum - right_sum)
14
15
        if current_diff > max_diff:
16
            max_diff = current_diff
17
    18
    return max_diff
19
20
def main():
21
    import sys
22
    input = sys.stdin.read
23
    data = input().split()
24
    25
    idx = 0
26
    t = int(data[idx])
27
    idx += 1
28
    29
    for _ in range(t):
30
        n = int(data[idx])
31
        idx += 1
32
        nums = list(map(int, data[idx:idx + n]))
33
        idx += n
34
        35
        result = max_absolute_difference(nums)
36
        print(result)
37
38
if __name__ == ""__main__"":
39
    main()",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834542
1387834528,pandeysneha3004,unknown,unknown,"1
def max_absolute_difference(nums):
2
    """"""
3
    Calculates the maximum absolute difference between sums of two contiguous subarrays.
4
5
    Args:
6
        nums: A list of integers.
7
8
    Returns:
9
        The maximum absolute difference between the sums of two subarrays.
10
    """"""
11
    n = len(nums)
12
    prefix_sum = [0] * (n + 1)
13
14
    # Calculate prefix sums
15
    for i in range(1, n + 1):
16
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
17
18
    max_diff = 0
19
    for i in range(1, n):
20
        left_sum = prefix_sum[i]
21
        right_sum = prefix_sum[n] - prefix_sum[i]
22
        max_diff = max(max_diff, abs(left_sum - right_sum))
23
24
    return max_diff
25
26
if __name__ == ""__main__"":  # Fixed the incorrect underscores
27
    t = int(input())
28
    for _ in range(t):
29
        n = int(input())
30
        nums = list(map(int, input().split()))
31
        result = max_absolute_difference(nums)
32
        print(result)  # Retyped this line to remove any non-ASCII characters
33",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834528
1387834518,karanmakan2250,unknown,unknown,"1
import sys
2
3
def product_except_self(test_cases):
4
    results = []
5
    6
    for values in test_cases:
7
        n = len(values)
8
        result = [1] * n
9
        10
        # Calculate the left products
11
        left_product = 1
12
        for i in range(n):
13
            result[i] = left_product
14
            left_product *= values[i]
15
        16
        # Calculate the right products and multiply with the left products
17
        right_product = 1
18
        for i in range(n - 1, -1, -1):
19
            result[i] *= right_product
20
            right_product *= values[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
# Input reading
27
input_data = sys.stdin.read().strip().splitlines()
28
T = int(input_data[0])
29
test_cases = []
30
31
index = 1
32
for _ in range(T):
33
    n = int(input_data[index])  # Read the number of nodes
34
    values = list(map(int, input_data[index + 1].split()))  # Read the values
35
    test_cases.append(values)
36
    index += 2  # Move to the next test case
37
38
# Get results
39
results = product_except_self(test_cases)
40
41
# Output results
42
for result in results:
43
    print("" "".join(map(str, result)))
44",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834518
1387834525,HarshShrivastava,unknown,unknown,"1
def moe(test_cases):
2
    results = []
3
4
    for t in range(len(test_cases)):
5
        N, K, energy = test_cases[t]
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // N
12
        operations = 0
13
        balance = 0
14
        for i in range(N):
15
            balance += energy[i] - target
16
            if balance % K != 0:
17
                operations = -1
18
                break
19
            operations += abs(balance) // K
20
        21
        results.append(operations if operations != -1 else -1)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    N, K = map(int, input().split())
30
    energy = list(map(int, input().split()))
31
    test_cases.append((N, K, energy))
32
results = moe(test_cases)
33
for res in results:
34
    print(res)
35",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834525
1387834521,kaushal80106,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n=int(input())
4
    arr=list(map(int,input().split()))
5
    summ=sum(arr)
6
    ans=0
7
    total=0
8
    for i in range(n-1):
9
        total+=arr[i]
10
        comp=summ-total
11
        ans=max(ans,abs(comp-total))
12
    print(ans)",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834521
1387834513,vishal986958,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
       11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target = total_energy // N
16
17
        18
        surplus = [0] * N
19
        for i in range(N):
20
            surplus[i] = energy[i] - target
21
22
      23
        operations = 0
24
        current_transfer = 0
25
26
        for i in range(N):
27
            current_transfer += surplus[i]
28
            if current_transfer % K != 0:
29
                results.append(-1)
30
                break
31
            operations += abs(current_transfer // K)
32
        else:
33
            results.append(operations)
34
35
    return results
36
37
38
if __name__ == ""__main__"":
39
    T = int(input())
40
    test_cases = []
41
42
    for _ in range(T):
43
        N, K = map(int, input().split())
44
        energy = list(map(int, input().split()))
45
        test_cases.append(((N, K), energy))
46
47
    results = min_operations_to_equalize(T, test_cases)
48
49
    for res in results:
50
        print(res)",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834513
1387834516,omg40787,unknown,unknown,"1
def min_operations_to_equalize_energy(N, K, energy):
2
3
    total_energy = sum(energy)
4
5
    if total_energy % N != 0:
6
7
        return -1
8
9
    10
11
    target_energy = total_energy // N
12
13
    operations = 0
14
15
    balance = 0
16
17
    18
19
    for i in range(N):
20
21
        balance += energy[i] - target_energy
22
23
        if balance % K != 0:
24
25
            return -1
26
27
        operations += abs(balance // K)
28
29
    30
31
    return operations
32
33
def main():
34
35
    import sys
36
37
    input = sys.stdin.read
38
39
    data = input().split()
40
41
    42
43
    T = int(data[0])
44
45
    index = 1
46
47
    results = []
48
49
    50
51
    for _ in range(T):
52
53
        N = int(data[index])
54
55
        K = int(data[index + 1])
56
57
        energy = list(map(int, data[index + 2:index + 2 + N]))
58
59
        index += 2 + N
60
61
        result = min_operations_to_equalize_energy(N, K, energy)
62
63
        results.append(result)
64
65
    66
67
    for result in results:
68
69
        print(result)
70
71
if __name__ == ""__main__"":
72
73
    main()",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834516
1387834517,dhananjaygaur04,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
4
    # If total energy is not divisible by N, equal distribution is impossible
5
    if total_energy % N != 0:
6
        return -1
7
8
    target = total_energy // N  # Each station should have this much energy
9
    balance = 0  # Tracks energy transfer balance
10
    operations = 0
11
12
    for i in range(N):
13
        diff = energy[i] - target
14
        balance += diff  # Update balance after distributing/receiving energy
15
        operations += abs(balance) // K  # Move energy in chunks of K
16
17
    # If the final balance is not zero, it's not possible to equalize
18
    if balance != 0:
19
        return -1
20
21
    return operations
22
23
# Read input
24
T = int(input())  # Number of test cases
25
for _ in range(T):
26
    N, K = map(int, input().split())  # Read N and K
27
    energy = list(map(int, input().split()))  # Read energy levels
28
    print(min_operations_to_equalize(N, K, energy))  # Compute and print result
29",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834517
1387834504,rajnishjha,unknown,unknown,"1
def minimum_operations(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        if total_energy % N != 0:
11
            results.append(-1)
12
            continue
13
14
        target_energy = total_energy // N
15
        balance = 0
16
        operations = 0
17
18
        for e in energy:
19
            diff = e - target_energy
20
            if diff % K != 0:
21
                results.append(-1)
22
                break
23
            balance += diff // K
24
            operations += abs(diff // K)
25
        else:
26
            if balance != 0:
27
                results.append(-1)
28
            else:
29
                results.append(operations // 2)
30
31
    return results
32
33
34
def main():
35
    import sys
36
    input = sys.stdin.read
37
    data = input().splitlines()
38
39
    T = int(data[0])
40
    test_cases = []
41
    line = 1
42
43
    for _ in range(T):
44
        N, K = map(int, data[line].split())
45
        energy = list(map(int, data[line + 1].split()))
46
        test_cases.append(((N, K), energy))
47
        line += 2
48
49
    results = minimum_operations(T, test_cases)
50
    for res in results:
51
        print(res)
52
53
54
if __name__ == ""__main__"":
55
    main()
56",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834504
1387834508,yashd1soni,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
    # Calculate left product array
7
    for i in range(1, n):
8
        left[i] = left[i-1] * arr[i-1]
9
10
    # Calculate right product array
11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * arr[i+1]
13
14
    # Calculate result array
15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
# Get number of test cases
20
t = int(input())
21
22
for _ in range(t):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result)",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834508
1387834509,krunalparab777,unknown,unknown,"1
import sys
2
3
def max_absolute_difference(nums, n):
4
    prefix_sum = [0] * n
5
    prefix_sum[0] = nums[0]
6
    7
    # Compute prefix sums
8
    for i in range(1, n):
9
        prefix_sum[i] = prefix_sum[i - 1] + nums[i]
10
    11
    total_sum = prefix_sum[-1]
12
    max_diff = 0
13
    14
    # Compute maximum absolute difference
15
    for i in range(n - 1):
16
        left_sum = prefix_sum[i]
17
        right_sum = total_sum - left_sum
18
        max_diff = max(max_diff, abs(left_sum - right_sum))
19
    20
    return max_diff
21
22
def main():
23
    input = sys.stdin.read
24
    data = input().split()
25
    26
    index = 0
27
    t = int(data[index])
28
    index += 1
29
    results = []
30
    31
    for _ in range(t):
32
        n = int(data[index])
33
        index += 1
34
        nums = list(map(int, data[index:index + n]))
35
        index += n
36
        results.append(str(max_absolute_difference(nums, n)))
37
    38
    sys.stdout.write(""\n"".join(results) + ""\n"")
39
40
if __name__ == ""__main__"":
41
    main()
42",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834509
1387834501,panoop2005_ap,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
        Scanner sc = new Scanner(System.in);
9
        int t = sc.nextInt();
10
        11
        while (t-- > 0) {
12
            int n = sc.nextInt();
13
            int[] nums = new int[n];
14
            int totalSum = 0;
15
            16
            for (int i = 0; i < n; i++) {
17
                nums[i] = sc.nextInt();
18
                totalSum += nums[i];
19
            }
20
21
            int leftSum = 0, maxDiff = 0;
22
            for (int i = 0; i < n - 1; i++) {
23
                leftSum += nums[i];
24
                int rightSum = totalSum - leftSum;
25
                maxDiff = Math.max(maxDiff, Math.abs(leftSum - rightSum));
26
            }
27
28
            System.out.println(maxDiff);
29
        }
30
        sc.close();
31
    }
32
}",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834501
1387834495,meetshah1785,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner in = new Scanner(System.in);
6
        int T = in.nextInt();  
7
8
        while (T-- > 0) {
9
            int N = in.nextInt();
10
            long K = in.nextLong();
11
            long[] energy = new long[N];
12
13
            long total = 0;
14
            for (int i = 0; i < N; i++) {
15
                energy[i] = in.nextLong();
16
                total += energy[i];
17
            }
18
19
            if (total % N != 0) {
20
                System.out.println(-1);
21
                continue;
22
            }
23
            long M = total / N;  
24
25
            long carry = 0;
26
            long operations = 0;
27
            boolean possible = true;
28
29
            for (int i = 0; i < N; i++) {
30
       31
                long net = energy[i] + carry - M;
32
33
                if (net % K != 0) {
34
                    possible = false;
35
                    break;
36
                }
37
38
                operations += Math.abs(net / K);
39
40
              41
                carry = net;
42
            }
43
44
           45
            if (!possible || carry != 0) {
46
                System.out.println(-1);
47
            } else {
48
                System.out.println(operations);
49
            }
50
        }
51
52
        in.close();
53
    }
54
}
55",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834495
1387834496,bhavikasingh1004,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        # Check if it's possible to equalize
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target = total_energy // N
16
        17
        # Calculate difference array
18
        diff = [energy[i] - target for i in range(N)]
19
20
        # To keep track of the cumulative imbalance
21
        imbalance = 0
22
        min_operations = 0
23
24
        for d in diff:
25
            imbalance += d
26
            # Since each operation involves K units, the imbalance should be a multiple of K
27
            if imbalance % K != 0:
28
                min_operations = -1
29
                break
30
31
            min_operations += abs(imbalance) // K
32
33
        results.append(min_operations)
34
35
    return results
36
37
# Input reading
38
T = int(input())
39
test_cases = []
40
for _ in range(T):
41
    N, K = map(int, input().split())
42
    energy = list(map(int, input().split()))
43
    test_cases.append(((N, K), energy))
44
45
# Solve the problem
46
output = min_operations_to_equalize(T, test_cases)
47
48
# Print the results
49
for res in output:
50
    print(res)",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834496
1387834499,ysaurabh_abd,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n=int(input())
4
    arr=list(map(int,input().split()))
5
    summ=sum(arr)
6
    ans=0
7
    total=0
8
    for i in range(n-1):
9
        total+=arr[i]
10
        comp=summ-total
11
        ans=max(ans,abs(comp-total))
12
    print(ans)",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834499
1387834479,utsavsingh2826,unknown,unknown,"1
import java.util.Scanner;
2
3
public class MinOperations {
4
5
    // Method to calculate the minimum number of operations required to equalize energy
6
7
    public static int minOperations(int n, int k, int[] energy) {
8
9
        // Calculate the total energy
10
11
        int totalEnergy = 0;
12
13
        for (int i = 0; i < n; i++) {
14
15
            totalEnergy += energy[i];
16
17
        }
18
19
        20
21
        // If total energy is not divisible by n, return -1
22
23
        if (totalEnergy % n != 0) {
24
25
            return -1;
26
27
        }
28
29
        30
31
        // Calculate the target energy for each station
32
33
        int targetEnergy = totalEnergy / n;
34
35
        int operations = 0;
36
37
        // Calculate the number of operations required
38
39
        for (int i = 0; i < n; i++) {
40
41
            int diff = energy[i] - targetEnergy;
42
43
            if (diff > 0) {
44
45
                // Ceiling division to calculate the number of operations
46
47
                operations += (diff + k - 1) / k;
48
49
            }
50
51
        }
52
53
        return operations;
54
55
    }
56
57
    public static void main(String[] args) {
58
59
        Scanner scanner = new Scanner(System.in);
60
61
        62
63
        // Get number of test cases
64
65
        int t = scanner.nextInt();
66
67
        68
69
        for (int i = 0; i < t; i++) {
70
71
            // Read n and k
72
73
            int n = scanner.nextInt();
74
75
            int k = scanner.nextInt();
76
77
            78
79
            // Read the energy array
80
81
            int[] energy = new int[n];
82
83
            for (int j = 0; j < n; j++) {
84
85
                energy[j] = scanner.nextInt();
86
87
            }
88
89
            90
91
            // Get the minimum operations
92
93
            int result = minOperations(n, k, energy);
94
95
            96
97
            // Print the result
98
99
            System.out.println(result);
100
101
        }
102
103
        104
105
        scanner.close();
106
107
    }
108
109
}
110
111
112
113
    ",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834479
1387834484,h1032220829,unknown,unknown,"1
def max_absolute_difference(nums):
2
    """"""
3
    Calculates the maximum absolute difference between sums of two contiguous subarrays.
4
5
    Args:
6
        nums: A list of integers.
7
8
    Returns:
9
        The maximum absolute difference between the sums of two subarrays.
10
    """"""
11
12
    n = len(nums)
13
    prefix_sum = [0] * (n + 1)
14
15
    # Calculate prefix sums
16
    for i in range(1, n + 1):
17
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
18
19
    max_diff = 0
20
    for i in range(1, n):
21
        left_sum = prefix_sum[i]
22
        right_sum = prefix_sum[n] - prefix_sum[i]
23
        max_diff = max(max_diff, abs(left_sum - right_sum))
24
25
    return max_diff
26
27
28
if __name__ == ""__main__"":
29
    t = int(input())  # Number of test cases
30
    for _ in range(t):
31
        n = int(input())  # Length of the array
32
        nums = list(map(int, input().split()))  # Input array
33
        result = max_absolute_difference(nums)
34
        print(result)  # Print the result
35",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834484
1387834493,paragchaudhary_1,unknown,unknown,"1
def solve():
2
    import sys
3
    data = sys.stdin.read().strip().split()
4
    t = int(data[0])
5
    idx = 1
6
7
    for _ in range(t):
8
        n = int(data[idx]); idx += 1
9
        nums = list(map(int, data[idx:idx+n]))
10
        idx += n
11
        12
        total_sum = sum(nums)
13
        14
        prefix_sum = 0
15
        max_diff = 0
16
17
        for i in range(n - 1):
18
            prefix_sum += nums[i]
19
            diff = abs(2 * prefix_sum - total_sum)
20
            if diff > max_diff:
21
                max_diff = diff
22
        23
        print(max_diff)
24
25
solve()",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834493
1387834471,dhananjaygaur04,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
4
    # If total energy is not divisible by N, equal distribution is impossible
5
    if total_energy % N != 0:
6
        return -1
7
8
    target = total_energy // N  # Each station should have this much energy
9
    balance = 0  # Tracks surplus or deficit
10
    operations = 0
11
12
    for i in range(N):
13
        diff = energy[i] - target
14
        balance += diff  # Track the energy flow
15
16
        # If the current balance cannot be divided evenly in K-unit transfers, return -1
17
        if balance % K != 0:
18
            return -1
19
20
        # Every transfer counts as an operation
21
        operations += abs(diff) // K
22
23
    # The total operations calculated include both sending and receiving, so divide by 2
24
    return operations // 2
25
26
# Read input
27
T = int(input())  # Number of test cases
28
for _ in range(T):
29
    N, K = map(int, input().split())  # Read N and K
30
    energy = list(map(int, input().split()))  # Read energy levels
31
    print(min_operations_to_equalize(N, K, energy))  # Compute and print result
32",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834471
1387834472,yashd1soni,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][0]
5
        energy = test_cases[t][1]
6
        7
        # Step 1: Check if total energy is divisible by N
8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        # Step 2: Calculate target energy per station
14
        target_energy = total_energy // N
15
        16
        # Step 3: Calculate the prefix sum of energy differences
17
        prefix_sum = 0
18
        operations = 0
19
        possible = True
20
        for i in range(N):
21
            diff = energy[i] - target_energy
22
            prefix_sum += diff
23
            if abs(prefix_sum) % K != 0:  # If prefix_sum cannot be redistributed in multiples of K
24
                possible = False
25
                break
26
            operations += abs(prefix_sum) // K  # Count operations required to balance prefix_sum
27
        28
        # Step 4: Check if redistribution was possible
29
        if possible:
30
            results.append(operations)
31
        else:
32
            results.append(-1)
33
    34
    return results
35
36
# Read Input
37
import sys
38
input = sys.stdin.read
39
data = input().splitlines()
40
41
T = int(data[0])  # Number of test cases
42
test_cases = []
43
44
line_index = 1
45
for _ in range(T):
46
    N, K = map(int, data[line_index].split())
47
    line_index += 1
48
    energy = list(map(int, data[line_index].split()))
49
    line_index += 1
50
    test_cases.append(((N, K), energy))
51
52
# Process and Output Results
53
results = minimum_operations_to_equalize(T, test_cases)
54
for res in results:
55
    print(res)",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834472
1387834475,chirayugiri149,unknown,unknown,"1
def solve():
2
    n = int(input())
3
    nums = list(map(int, input().split()))
4
5
    max_diff = 0
6
    total_sum = sum(nums)
7
    current_sum = 0
8
9
    for i in range(n - 1):
10
        current_sum += nums[i]
11
        sum1 = current_sum
12
        sum2 = total_sum - sum1
13
        diff = abs(sum1 - sum2)
14
        max_diff = max(max_diff, diff)
15
16
    print(max_diff)
17
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834475
1387834464,omg40787,unknown,unknown,"1
def product_distribution(values):
2
3
    n = len(values)
4
5
    if n == 0:
6
7
        return []
8
9
    10
11
    total_product = 1
12
13
    zero_count = 0
14
15
    16
17
    for value in values:
18
19
        if value != 0:
20
21
            total_product *= value
22
23
        else:
24
25
            zero_count += 1
26
27
    28
29
    result = []
30
31
    for value in values:
32
33
        if zero_count > 1:
34
35
            result.append(0)
36
37
        elif zero_count == 1:
38
39
            if value == 0:
40
41
                result.append(total_product)
42
43
            else:
44
45
                result.append(0)
46
47
        else:
48
49
            result.append(total_product // value)
50
51
    52
53
    return result
54
55
def main():
56
57
    import sys
58
59
    input = sys.stdin.read
60
61
    data = input().split()
62
63
    64
65
    T = int(data[0])
66
67
    index = 1
68
69
    results = []
70
71
    72
73
    for _ in range(T):
74
75
        n = int(data[index])
76
77
        values = list(map(int, data[index + 1:index + 1 + n]))
78
79
        index += 1 + n
80
81
        result = product_distribution(values)
82
83
        results.append("" "".join(map(str, result)))
84
85
    86
87
    for result in results:
88
89
        print(result)
90
91
if __name__ == ""__main__"":
92
93
    main()",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834464
1387834456,shubhamvirani33,unknown,unknown,"1
def min_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % n != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // n
10
        operations = 0
11
        balance = 0
12
        for i in range(n):
13
            diff = energy[i] - target
14
            balance += diff
15
            if balance % k != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(balance // k)
19
        else:
20
            results.append(operations)
21
    return results
22
T = int(input())
23
test_cases = []
24
for _ in range(T):
25
    n, k = map(int, input().split())
26
    energy = list(map(int, input().split()))
27
    test_cases.append((n, k, energy))
28
output = min_operations_to_equalize_energy(T, test_cases)
29
for res in output:
30
    print(res)
31",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834456
1387834458,jaidevgupta2004,unknown,unknown,"1
def solve():
2
    import sys
3
    data = sys.stdin.read().strip().split()
4
    t = int(data[0])
5
    idx = 1
6
7
    for _ in range(t):
8
        n = int(data[idx]); idx += 1
9
        nums = list(map(int, data[idx:idx+n]))
10
        idx += n
11
        12
        total_sum = sum(nums)
13
        14
        prefix_sum = 0
15
        max_diff = 0
16
17
        for i in range(n - 1):
18
            prefix_sum += nums[i]
19
            diff = abs(2 * prefix_sum - total_sum)
20
            if diff > max_diff:
21
                max_diff = diff
22
        23
        print(max_diff)
24
25
solve()",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834458
1387834457,jeettrivedi2004,unknown,unknown,"1
test=int(input())
2
for i in range(test):
3
    num=int(input())
4
    val=list(map(int,input().split()))
5
    product=1
6
    for i in val:
7
        product*=i
8
    for i in range(num):
9
        print(product//val[i],end=' ')
10
    print()",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834457
1387834446,meetshah1785,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt(); 
11
            int[] arr = new int[n];
12
            13
         14
            for(int i = 0; i < n; i++) {
15
                arr[i] = sc.nextInt();
16
            }
17
            18
          19
            productArray(arr, n);
20
        }
21
    }
22
    23
    static void productArray(int[] arr, int n) {
24
      25
        if (n == 1) {
26
            System.out.println(0);
27
            return;
28
        }
29
        30
        long[] result = new long[n];
31
        32
       33
        for(int i = 0; i < n; i++) {
34
            result[i] = 1;
35
        }
36
    37
        long leftProduct = 1;
38
        for(int i = 0; i < n; i++) {
39
            result[i] = leftProduct;
40
            leftProduct *= arr[i];
41
        }
42
43
        long rightProduct = 1;
44
        for(int i = n-1; i >= 0; i--) {
45
            result[i] *= rightProduct;
46
            rightProduct *= arr[i];
47
        }
48
        49
      50
        for(int i = 0; i < n; i++) {
51
            System.out.print(result[i] + "" "");
52
        }
53
        System.out.println();
54
    }
55
}
56",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834446
1387834449,chirayugiri149,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    energies = list(map(int, input().split()))
4
5
    total_energy = sum(energies)
6
    if total_energy % n != 0:
7
        print(-1)
8
        return
9
10
    target_energy = total_energy // n
11
    diff = [energies[i] - target_energy for i in range(n)]
12
    c_diff = [0] * n
13
    c_diff[0] = 0
14
    for i in range(1, n):
15
        c_diff[i] = c_diff[i-1] + diff[i-1]
16
17
    operations = 0
18
    for i in range(1, n):
19
        if c_diff[i] % k != 0:
20
            print(-1)
21
            return
22
        operations += abs(c_diff[i]) // k
23
24
    print(operations)
25
26
27
t = int(input())
28
for _ in range(t):
29
    solve()",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834449
1387834453,oms989069,unknown,unknown,"1
def product_except_self(values):
2
3
   result =[]
4
   n= len(values)
5
   6
   for i in range(n):
7
      product = 1
8
      for j in range (n):
9
         if j !=i:
10
               product *= values[j]
11
        result.append(product)
12
    13
    return result
14
t= int(input())
15
values = list(map(int,input().split))
16
result = product_except_self(values)
17
print(*result)",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834453
1387834439,rajnishjha,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            print(-1)
11
            continue
12
        13
        target_energy = total_energy // N
14
        operations = 0
15
        current_balance = 0
16
        17
        for i in range(N):
18
            current_balance += energy[i] - target_energy
19
            operations += abs(current_balance) // K
20
            21
            if abs(current_balance) % K != 0:
22
                operations = -1
23
                break
24
        25
        print(operations)
26
27
solve()",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834439
1387834441,panoop2005_ap,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
        Scanner scanner = new Scanner(System.in);
9
        int T = scanner.nextInt();
10
11
        while (T-- > 0) {
12
            int N = scanner.nextInt();
13
            int K = scanner.nextInt();
14
            long[] energy = new long[N]; 
15
            long sum = 0;
16
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextLong();
19
                sum += energy[i];
20
            }
21
22
            if (sum % N != 0) {
23
                System.out.println(-1);
24
                continue;
25
            }
26
27
            long target = sum / N;
28
            long imbalance = 0;
29
            long operations = 0;
30
            boolean possible = true;
31
32
            for (int i = 0; i < N; i++) {
33
                imbalance += energy[i] - target;
34
35
                if (imbalance % K != 0) { 
36
                    possible = false;
37
                    break;
38
                }
39
40
                operations += Math.abs(imbalance) / K;
41
            }
42
43
            System.out.println(possible ? operations : -1);
44
        }
45
        scanner.close();
46
    }
47
}",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834441
1387834445,1_ashwarya,unknown,unknown,"1
def min_operations(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target = total_energy // N  
8
    operations = 0
9
    current_balance = 0
10
   11
    for i in range(N):
12
        13
        diff = energy[i] - target
14
        current_balance += diff
15
  16
        operations += abs(current_balance) // K
17
        18
    return operations
19
20
T = int(input())  
21
22
for _ in range(T):
23
    N, K = map(int, input().split()) 
24
    energy = list(map(int, input().split()))  
25
26
    result = min_operations(N, K, energy)
27
    print(result)
28",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834445
1387834434,siddhinnaik05,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int maxAbsDifference(const vector<int>& nums) {
9
    int n = nums.size();
10
    11
    // Compute the prefix sum array
12
    vector<int> prefixSum(n);
13
    prefixSum[0] = nums[0];
14
    for (int i = 1; i < n; i++) {
15
        prefixSum[i] = prefixSum[i - 1] + nums[i];
16
    }
17
    18
    int totalSum = prefixSum[n - 1];
19
    int maxDiff = 0;
20
    21
    // Try partitioning the array at every index and calculate the absolute difference
22
    for (int i = 0; i < n - 1; i++) {
23
        int leftSum = prefixSum[i];  // sum of elements from 0 to i
24
        int rightSum = totalSum - leftSum;  // sum of elements from i+1 to n-1
25
        maxDiff = max(maxDiff, abs(leftSum - rightSum));
26
    }
27
    28
    return maxDiff;
29
}
30
int main() {
31
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
32
     int t;
33
    cin >> t;  // Number of test cases
34
    35
    while (t--) {
36
        int n;
37
        cin >> n;  // Size of the array
38
        vector<int> nums(n);
39
        for (int i = 0; i < n; i++) {
40
            cin >> nums[i];  // Array elements
41
        }
42
        43
        cout << maxAbsDifference(nums) << endl;  // Output the result for this test case
44
    }
45
    return 0;
46
}",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834434
1387834425,parmesh214,unknown,unknown,"1
def max_absolute_difference(nums):
2
    total_sum = sum(nums)
3
    prefix_sum = 0
4
    max_diff = 0
5
    6
    for i in range(len(nums) - 1):
7
        prefix_sum += nums[i]
8
        right_sum = total_sum - prefix_sum
9
        max_diff = max(max_diff, abs(prefix_sum - right_sum))
10
    11
    return max_diff
12
13
def solve():
14
    t = int(input())
15
    for _ in range(t):
16
        n = int(input())
17
        nums = list(map(int, input().split()))
18
        print(max_absolute_difference(nums))
19
20
if __name__ == ""__main__"":
21
    solve()
22",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834425
1387834428,ankushchaudhary5,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        left_sum = 0
7
        max_diff = 0
8
        for i in range(n - 1):
9
            left_sum += nums[i]
10
            right_sum = total_sum - left_sum
11
            max_diff = max(max_diff, abs(left_sum - right_sum))
12
        results.append(max_diff)
13
    return results
14
15
16
t = int(input())
17
test_cases = []
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    test_cases.append((n, nums))
22
23
results = max_absolute_difference(test_cases)
24
for res in results:
25
    print(res)",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834428
1387834430,dhruvppaste20,unknown,unknown,"1
def moe(test_cases):
2
    results = []
3
4
    for t in range(len(test_cases)):
5
        N, K, energy = test_cases[t]
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // N
12
        operations = 0
13
        balance = 0  
14
        for i in range(N):
15
            balance += energy[i] - target
16
            if balance % K != 0:
17
                operations = -1
18
                break
19
            operations += abs(balance) // K
20
        21
        results.append(operations if operations != -1 else -1)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    N, K = map(int, input().split())
30
    energy = list(map(int, input().split()))
31
    test_cases.append((N, K, energy))
32
results = moe(test_cases)
33
for res in results:
34
    print(res)",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834430
1387834415,yashdubeyenter15,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
        9
        while (t-- > 0) {
10
            int n = scanner.nextInt(); 
11
            int[] nums = new int[n];
12
            13
            14
            for (int i = 0; i < n; i++) {
15
                nums[i] = scanner.nextInt();
16
            }
17
            18
            System.out.println(maxSubArrayDifference(nums));
19
        }
20
        21
        scanner.close();
22
    }
23
    24
    private static long maxSubArrayDifference(int[] nums) {
25
        int n = nums.length;
26
        27
        28
        long[] prefixSum = new long[n + 1];
29
        prefixSum[0] = 0;
30
        for (int i = 0; i < n; i++) {
31
            prefixSum[i + 1] = prefixSum[i] + nums[i];
32
        }
33
        34
        long maxDiff = 0;
35
        36
        37
        for (int i = 1; i < n; i++) {
38
            39
            long leftSum = prefixSum[i] - prefixSum[0];
40
            41
            42
            long rightSum = prefixSum[n] - prefixSum[i];
43
            44
            45
            long currentDiff = Math.abs(leftSum - rightSum);
46
            47
            48
            maxDiff = Math.max(maxDiff, currentDiff);
49
        }
50
        51
        return maxDiff;
52
    }
53
}",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834415
1387834419,h1032221359,unknown,unknown,"1
def equalize_energy():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
    results = []
10
11
    for _ in range(T):
12
        N, K = map(int, data[idx].split())
13
        idx += 1
14
        energy = list(map(int, data[idx].split()))
15
        idx += 1
16
17
        total_energy = sum(energy)
18
19
        if total_energy % N != 0:
20
            results.append(""-1"")
21
            continue
22
23
        target_energy = total_energy // N
24
        operations, balance, possible = 0, 0, True
25
26
        for e in energy:
27
            balance += e - target_energy
28
            if balance % K != 0:
29
                possible = False
30
                break
31
            operations += abs(balance // K)
32
33
        results.append(str(operations) if possible else ""-1"")
34
35
    sys.stdout.write(""\n"".join(results) + ""\n"")
36
37
if __name__ == ""__main__"":
38
    equalize_energy()",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834419
1387834421,chirayugiri149,unknown,unknown,"1
def solve():
2
    n = int(input())
3
    values = list(map(int, input().split()))
4
5
    result = [0] * n
6
7
    for i in range(n):
8
        product = 1
9
        for j in range(n):
10
            if i != j:
11
                product *= values[j]
12
        result[i] = product
13
14
    print(*result)
15
16
17
t = int(input())
18
for _ in range(t):
19
    solve()",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834421
1387834406,bhavikasingh1004,unknown,unknown,"1
def product_except_self(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
8
        # Initialize arrays for prefix and suffix products
9
        prefix = [1] * n
10
        suffix = [1] * n
11
        result = [0] * n
12
13
        # Calculate prefix products
14
        for i in range(1, n):
15
            prefix[i] = prefix[i - 1] * values[i - 1]
16
17
        # Calculate suffix products
18
        for i in range(n - 2, -1, -1):
19
            suffix[i] = suffix[i + 1] * values[i + 1]
20
21
        # Calculate the result array
22
        for i in range(n):
23
            result[i] = prefix[i] * suffix[i]
24
25
        results.append(result)
26
27
    return results
28
29
# Input reading
30
T = int(input())
31
test_cases = []
32
for _ in range(T):
33
    n = int(input())
34
    values = list(map(int, input().split()))
35
    test_cases.append((n, values))
36
37
# Solve the problem
38
output = product_except_self(T, test_cases)
39
40
# Print the results
41
for res in output:
42
    print("" "".join(map(str, res)))",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834406
1387834413,jaidevgupta2004,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            print(-1)
11
            continue
12
        13
        target_energy = total_energy // N
14
        operations = 0
15
        current_balance = 0
16
        17
        for i in range(N):
18
            current_balance += energy[i] - target_energy
19
            operations += abs(current_balance) // K
20
            21
            if abs(current_balance) % K != 0:
22
                operations = -1
23
                break
24
        25
        print(operations)
26
27
solve()",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834413
1387834403,anishakarkera737,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    10
    int T;
11
    cin >> T;  
12
13
    while (T--) {
14
        int n;
15
        cin >> n;
16
        17
        vector<int> values(n), result(n, 1);
18
19
        20
        for (int i = 0; i < n; ++i) {
21
            cin >> values[i];
22
        }
23
24
        25
        int prefix_product = 1;
26
        for (int i = 0; i < n; ++i) {
27
            result[i] *= prefix_product;
28
            prefix_product *= values[i];
29
        }
30
31
        32
        int suffix_product = 1;
33
        for (int i = n - 1; i >= 0; --i) {
34
            result[i] *= suffix_product;
35
            suffix_product *= values[i];
36
        }
37
38
        39
        for (int i = 0; i < n; ++i) {
40
            cout << result[i] << "" "";
41
        }
42
        cout << endl;
43
    }
44
    return 0;
45
}
46",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834403
1387834400,ysaurabh_abd,unknown,unknown,"1
def solve():
2
    T = int(input()) 
3
    4
    for _ in range(T):
5
        N, K = map(int, input().split()) 
6
        energy = list(map(int, input().split()))  
7
        8
        total_energy = sum(energy)
9
        10
        11
        if total_energy % N != 0:
12
            print(-1)
13
            continue
14
        15
        target = total_energy // N
16
        operations = 0
17
        excess = 0
18
        19
       20
        for i in range(N):
21
            diff = energy[i] - target
22
            23
            excess += diff
24
           25
            if diff % K != 0:
26
                operations = -1
27
                break
28
            operations += abs(excess) // K  
29
        30
        print(operations)
31
32
33
solve()
34",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834400
1387834393,goswamyashutosh9,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        prefix = [1] * n
6
        suffix = [1] * n
7
        result = [1] * n
8
        9
        # Compute prefix products
10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] * values[i - 1]
12
        13
        # Compute suffix products
14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] * values[i + 1]
16
        17
        # Compute result array
18
        for i in range(n):
19
            result[i] = prefix[i] * suffix[i]
20
        21
        results.append(result)
22
    23
    return results
24
25
# Input Reading
26
T = int(input())
27
test_cases = []
28
for _ in range(T):
29
    n = int(input())
30
    values = list(map(int, input().split()))
31
    test_cases.append((n, values))
32
33
# Compute and Output Results
34
results = product_except_self(test_cases)
35
for res in results:
36
    print(' '.join(map(str, res)))",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834393
1387834392,jaidevgupta2004,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
    # Calculate left product array
7
    for i in range(1, n):
8
        left[i] = left[i-1] * arr[i-1]
9
10
    # Calculate right product array
11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * arr[i+1]
13
14
    # Calculate result array
15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
# Get number of test cases
20
t = int(input())
21
22
for _ in range(t):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result)",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834392
1387834399,utsavsingh2826,unknown,unknown,"1
2
3
4
import java.util.Scanner;
5
6
public class MinOperations {
7
8
    // Method to calculate the minimum number of operations required to equalize energy
9
    public static int minOperations(int n, int k, int[] energy) {
10
        // Calculate the total energy
11
        int totalEnergy = 0;
12
        for (int i = 0; i < n; i++) {
13
            totalEnergy += energy[i];
14
        }
15
        16
        // If total energy is not divisible by n, return -1
17
        if (totalEnergy % n != 0) {
18
            return -1;
19
        }
20
        21
        // Calculate the target energy for each station
22
        int targetEnergy = totalEnergy / n;
23
        int operations = 0;
24
25
        // Calculate the number of operations required
26
        for (int i = 0; i < n; i++) {
27
            int diff = energy[i] - targetEnergy;
28
            if (diff > 0) {
29
                // Ceiling division to calculate the number of operations
30
                operations += (diff + k - 1) / k;
31
            }
32
        }
33
34
        return operations;
35
    }
36
37
    public static void main(String[] args) {
38
        Scanner scanner = new Scanner(System.in);
39
        40
        // Get number of test cases
41
        int t = scanner.nextInt();
42
        43
        for (int i = 0; i < t; i++) {
44
            // Read n and k
45
            int n = scanner.nextInt();
46
            int k = scanner.nextInt();
47
            48
            // Read energy array
49
            int[] energy = new int[n];
50
            for (int j = 0; j < n; j++) {
51
                energy[j] = scanner.nextInt();
52
            }
53
            54
            // Get the minimum operations
55
            int result = minOperations(n, k, energy);
56
            57
            // Print the result
58
            System.out.println(result);
59
        }
60
        61
        scanner.close();
62
    }
63
}
64
65
66",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834399
1387834382,h1032221062,unknown,unknown,"1
def maxAbsoluteDifference(t, test_cases):
2
    for nums in test_cases:
3
        n = len(nums)
4
        total_sum = sum(nums)
5
        prefix_sum = 0
6
        max_diff = 0
7
        8
        # Loop through possible partitions
9
        for i in range(1, n):
10
            prefix_sum += nums[i-1]
11
            subarray1_sum = prefix_sum
12
            subarray2_sum = total_sum - subarray1_sum
13
            max_diff = max(max_diff, abs(subarray1_sum - subarray2_sum))
14
        15
        print(max_diff)
16
17
# Input Parsing
18
t = int(input())  # Number of test cases
19
test_cases = []
20
for _ in range(t):
21
    n = int(input())  # Size of the array
22
    nums = list(map(int, input().split()))  # The array itself
23
    test_cases.append(nums)
24
25
maxAbsoluteDifference(t, test_cases)
26",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834382
1387834384,ansh_shetty_22,unknown,unknown,"1
with Ada.Text_IO; use Ada.Text_IO;
2
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
3
4
procedure Solution is
5
   T : Integer;
6
begin
7
   Get(T);
8
   for Testcase in 1 .. T loop
9
      declare
10
         N : Integer;
11
         Values : array (1 .. 100000) of Integer;
12
         Total_Product : Integer := 1;
13
         Zero_Count : Integer := 0;
14
         Results : array (1 .. 100000) of Integer;
15
      begin
16
         Get(N);
17
         for I in 1 .. N loop
18
            Get(Values(I));
19
            if Values(I) = 0 then
20
               Zero_Count := Zero_Count + 1;
21
            else
22
               Total_Product := Total_Product * Values(I);
23
            end if;
24
         end loop;
25
26
         for I in 1 .. N loop
27
            if Zero_Count > 1 then
28
               Results(I) := 0;
29
            elsif Zero_Count = 1 then
30
               if Values(I) = 0 then
31
                  Results(I) := Total_Product;
32
               else
33
                  Results(I) := 0;
34
               end if;
35
            else
36
               Results(I) := Total_Product / Values(I);
37
            end if;
38
         end loop;
39
40
         for I in 1 .. N loop
41
            Put(Results(I), 0);
42
            if I < N then
43
               Put("" "");
44
            else
45
               New_Line;
46
            end if;
47
         end loop;
48
      end;
49
   end loop;
50
end Solution;
51
52",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834384
1387834388,saurabhshuklaaa1,unknown,unknown,"1
def solve():
2
3
    t = int(input())
4
5
    for _ in range(t):
6
7
        n = int(input())
8
9
        nums = list(map(int, input().split()))
10
11
        12
13
        total_sum = sum(nums)
14
15
        left_sum = 0
16
17
        max_difference = 0
18
19
        20
21
        for i in range(n - 1):
22
23
            left_sum += nums[i]
24
25
            right_sum = total_sum - left_sum
26
27
            max_difference = max(max_difference, abs(left_sum - right_sum))
28
29
        30
31
        print(max_difference)
32
33
solve()",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834388
1387834373,maurya_anjali061,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        n = int(input())
5
        values = list(map(int, input().split()))
6
        product = 1
7
        zero_count = 0
8
        9
        for value in values:
10
            if value != 0:
11
                product *= value
12
            else:
13
                zero_count += 1
14
        15
        result = []
16
        17
        if zero_count > 1:
18
            result = [0] * n
19
        elif zero_count == 1:
20
            for value in values:
21
                if value == 0:
22
                    result.append(product)
23
                else:
24
                    result.append(0)
25
        else:
26
            for value in values:
27
                result.append(product // value)
28
        29
        print("" "".join(map(str, result)))
30
31
solve()  
32",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834373
1387834374,h1032221532,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] * values[i - 1]
12
        13
        for i in range(n - 2, -1, -1):
14
            suffix[i] = suffix[i + 1] * values[i + 1]
15
        16
        17
        for i in range(n):
18
            result[i] = prefix[i] * suffix[i]
19
        20
        results.append(result)
21
    22
    return results
23
24
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    n = int(input())
30
    values = list(map(int, input().split()))
31
    test_cases.append((n, values))
32
33
results = product_except_self(test_cases)
34
35
for res in results:
36
    print("" "".join(map(str, res)))",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834374
1387834372,panoop2005_ap,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
        Scanner scanner = new Scanner(System.in);
9
        int T = scanner.nextInt();
10
11
        while (T-- > 0) {
12
            int N = scanner.nextInt();
13
            int K = scanner.nextInt();
14
            int[] energy = new int[N];
15
            long sum = 0;
16
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextInt();
19
                sum += energy[i];
20
            }
21
22
            if (sum % N != 0) {
23
                System.out.println(-1);
24
                continue;
25
            }
26
27
            long target = sum / N;
28
            long imbalance = 0;
29
            long operations = 0;
30
31
            for (int i = 0; i < N; i++) {
32
                imbalance += energy[i] - target;
33
34
                if (Math.abs(imbalance) % K != 0) { 
35
                    operations = -1;
36
                    break;
37
                }
38
39
                operations += Math.abs(imbalance) / K;
40
            }
41
42
            System.out.println(operations);
43
        }
44
        scanner.close();
45
    }
46
}",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834372
1387834371,vivekbhandari101,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
4
using namespace std;
5
6
vector<int> productArray(const vector<int>& nums) {
7
    int n = nums.size();
8
    vector<int> left(n, 1);
9
    vector<int> right(n, 1);
10
    vector<int> result(n);
11
12
    // Calculate left product
13
    for (int i = 1; i < n; ++i) {
14
        left[i] = left[i - 1] * nums[i - 1];
15
    }
16
17
    // Calculate right product
18
    for (int i = n - 2; i >= 0; --i) {
19
        right[i] = right[i + 1] * nums[i + 1];
20
    }
21
22
    // Calculate result
23
    for (int i = 0; i < n; ++i) {
24
        result[i] = left[i] * right[i];
25
    }
26
27
    return result;
28
}
29
30
int main() {
31
    int t;
32
    cin >> t;
33
34
    while (t--) {
35
        int n;
36
        cin >> n;
37
38
        vector<int> nums(n);
39
        for (int i = 0; i < n; ++i) {
40
            cin >> nums[i];
41
        }
42
43
        vector<int> result = productArray(nums);
44
45
        for (int i = 0; i < n; ++i) {
46
            cout << result[i] << "" "";
47
        }
48
        cout << endl;
49
    }
50
51
    return 0;
52
}",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834371
1387834366,rahulyadav2005a1,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
3
    results = []
4
5
    for test in test_cases:
6
7
        n, nums = test
8
9
        prefix = [0] * n
10
11
        suffix = [0] * n
12
13
        prefix[0] = nums[0]
14
15
        for i in range(1, n):
16
17
            prefix[i] = prefix[i - 1] + nums[i]
18
19
        suffix[-1] = nums[-1]
20
21
        for i in range(n - 2, -1, -1):
22
23
            suffix[i] = suffix[i + 1] + nums[i]
24
25
        max_diff = 0
26
27
        for i in range(n - 1):  # Partition at i
28
29
            left_sum = prefix[i]
30
31
            right_sum = suffix[i + 1]
32
33
            max_diff = max(max_diff, abs(left_sum - right_sum))
34
35
        results.append(max_diff)
36
37
    return results
38
39
t = int(input())
40
41
test_cases = []
42
43
for _ in range(t):
44
45
    n = int(input())
46
47
    nums = list(map(int, input().split()))
48
49
    test_cases.append((n, nums))
50
51
results = max_absolute_difference(t, test_cases)
52
53
for res in results:
54
55
    print(res)",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834366
1387834367,1_ashwarya,unknown,unknown,"1
def min_operations(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1  
6
    7
    target = total_energy // N
8
    operations = 0
9
    current_balance = 0
10
    11
    for i in range(N):
12
        diff = energy[i] - target
13
        current_balance += diff
14
       15
        operations += abs(current_balance) // K
16
        17
    return operations
18
19
T = int(input())
20
21
for _ in range(T):
22
    N, K = map(int, input().split())
23
    energy = list(map(int, input().split()))
24
 25
    result = min_operations(N, K, energy)
26
    print(result)
27",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834367
1387834369,h1032221720,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int maxAbsDifference(const vector<int>& nums) {
9
    int n = nums.size();
10
    11
    12
    vector<int> prefixSum(n);
13
    prefixSum[0] = nums[0];
14
    for (int i = 1; i < n; i++) {
15
        prefixSum[i] = prefixSum[i - 1] + nums[i];
16
    }
17
    18
    int totalSum = prefixSum[n - 1];
19
    int maxDiff = 0;
20
    21
    for (int i = 0; i < n - 1; i++) {
22
        int leftSum = prefixSum[i];  
23
        int rightSum = totalSum - leftSum;  
24
        maxDiff = max(maxDiff, abs(leftSum - rightSum));
25
    }
26
    27
    return maxDiff;
28
}
29
int main() {
30
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
31
     int t;
32
    cin >> t; 
33
    34
    while (t--) {
35
        int n;
36
        cin >> n;  
37
        vector<int> nums(n);
38
        for (int i = 0; i < n; i++) {
39
            cin >> nums[i];  
40
        }
41
        42
        cout << maxAbsDifference(nums) << endl; 
43
    }
44
    return 0;
45
}
46",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834369
1387834358,h1032220278,unknown,unknown,"1
def minoperations(n,k,energies):
2
    totalenergy=sum(energies)
3
    if(totalenergy%n!=0):
4
        return -1
5
    target=totalenergy//n
6
    operations=0
7
    balance=0
8
    for i in range(n):
9
        diff=energies[i]-target
10
        balance+=diff
11
        12
        if(balance%k!=0):
13
            return -1
14
        operations+=abs(balance//k)
15
        return operations
16
T=int(input())
17
for i in range(T):
18
    n,k=map(int,input().split())
19
    energies=list(map(int,input().split()))
20
    print(minoperations(n,k,energies))",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834358
1387834360,abhaywadkar2004,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n=int(input())
4
    arr=list(map(int,input().split()))
5
    summ=sum(arr)
6
    ans=0
7
    total=0
8
    for i in range(n-1):
9
        total+=arr[i]
10
        comp=summ-total
11
        ans=max(ans,abs(comp-total))
12
    print(ans)",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834360
1387834363,h1032220829,unknown,unknown,"1
def product_array(values):
2
    """"""
3
    Calculates the product of all elements in the array except the element at the current index.
4
5
    Args:
6
        values: A list of integers.
7
8
    Returns:
9
        A list of integers, where each element is the product of all other elements in the original list.
10
    """"""
11
12
    n = len(values)
13
    result = [1] * n
14
15
    # Calculate left product
16
    left_product = 1
17
    for i in range(n):
18
        result[i] = left_product
19
        left_product *= values[i]
20
21
    # Calculate right product
22
    right_product = 1
23
    for i in range(n - 1, -1, -1):
24
        result[i] *= right_product
25
        right_product *= values[i]
26
27
    return result
28
29
30
if __name__ == ""__main__"":
31
    T = int(input())  # Number of test cases
32
33
    for _ in range(T):
34
        n = int(input())  # Length of the array
35
        values = list(map(int, input().split()))  # Input array
36
37
        result = product_array(values)
38
        print(*result)  # Print the result as space-separated values
39",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834363
1387834350,HarshShrivastava,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner sc=new Scanner(System.in);
8
        int t=sc.nextInt();
9
        while(t>0){
10
            int n=sc.nextInt();
11
            long a[]=new long[n];
12
            int k=sc.nextInt();
13
            int i;
14
            long total=0;
15
            for(i=0;i<n;i++){
16
                a[i]=sc.nextLong();
17
                total+=a[i];
18
            }
19
            if(total%n!=0)
20
                System.out.println(-1);
21
            else{
22
                i=0;
23
                int count=0;
24
                int steps=0;
25
                while(true){
26
                    i%=n;
27
                    if(a[(i+1)%n]==a[i]){
28
                        count+=1;
29
                    }
30
                    if(a[(i+1)%n]<a[i]&&a[i]-a[(i+1)%n]>=k){
31
                        a[(i+1)%n]+=k;
32
                        a[i]-=k;
33
                        steps+=1;
34
                        count=0;
35
                    }
36
                    if(count==n){
37
                        System.out.println(steps);
38
                        break;
39
                    }
40
                    i++;
41
                }
42
            }
43
            t--;
44
        }
45
    }
46
}",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834350
1387834352,pandeysneha3004,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt(); 
8
        9
        while (T-- > 0) {
10
            int n = scanner.nextInt();
11
            int[] values = new int[n];
12
            13
            for (int i = 0; i < n; i++) {
14
                values[i] = scanner.nextInt();
15
            }
16
            17
            int[] result = productExceptSelf(values);
18
            printArray(result);
19
        }
20
        21
        scanner.close();
22
    }
23
    24
    private static int[] productExceptSelf(int[] nums) {
25
        int n = nums.length;
26
        int[] result = new int[n];
27
        28
        result[0] = 1;
29
        for (int i = 1; i < n; i++) {
30
            result[i] = result[i - 1] * nums[i - 1];
31
        }
32
        33
        int rightProduct = 1;
34
        for (int i = n - 1; i >= 0; i--) {
35
            result[i] = result[i] * rightProduct;
36
            rightProduct *= nums[i];
37
        }
38
        39
        return result;
40
    }
41
    42
    private static void printArray(int[] arr) {
43
        for (int i = 0; i < arr.length; i++) {
44
            System.out.print(arr[i]);
45
            if (i < arr.length - 1) {
46
                System.out.print("" "");
47
            }
48
        }
49
        System.out.println(); // Re-typed this line to avoid non-ASCII characters
50
    }
51
}
52",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834352
1387834356,swayam_prajapat1,unknown,unknown,"1
def solve():
2
    n = int(input())
3
    nums = list(map(int, input().split()))
4
5
    max_diff = 0
6
    total_sum = sum(nums)
7
    current_sum = 0
8
9
    for i in range(n - 1):
10
        current_sum += nums[i]
11
        sum1 = current_sum
12
        sum2 = total_sum - sum1
13
        diff = abs(sum1 - sum2)
14
        max_diff = max(max_diff, diff)
15
16
    print(max_diff)
17
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834356
1387834346,utsavsingh2826,unknown,unknown,"1
import java.util.Scanner;
2
3
public class MaxDifference {
4
5
    // Method to solve the problem
6
7
    public static void solve() {
8
9
        Scanner scanner = new Scanner(System.in);
10
11
        12
13
        // Get number of test cases
14
15
        int t = scanner.nextInt();
16
17
        18
19
        for (int _ = 0; _ < t; _++) {
20
21
            // Read n (number of elements in the array)
22
23
            int n = scanner.nextInt();
24
25
            int[] nums = new int[n];
26
27
            28
29
            // Read the array
30
31
            for (int i = 0; i < n; i++) {
32
33
                nums[i] = scanner.nextInt();
34
35
            }
36
37
            38
39
            // Calculate the total sum
40
41
            int totalSum = 0;
42
43
            for (int i = 0; i < n; i++) {
44
45
                totalSum += nums[i];
46
47
            }
48
49
            50
51
            // Initialize left sum and max difference
52
53
            int leftSum = 0;
54
55
            int maxDifference = 0;
56
57
            58
59
            // Iterate through the array and calculate max difference
60
61
            for (int i = 0; i < n - 1; i++) {
62
63
                leftSum += nums[i];
64
65
                int rightSum = totalSum - leftSum;
66
67
                maxDifference = Math.max(maxDifference, Math.abs(leftSum - rightSum));
68
69
            }
70
71
            72
73
            // Print the result for this test case
74
75
            System.out.println(maxDifference);
76
77
        }
78
79
        80
81
        scanner.close();
82
83
    }
84
85
    public static void main(String[] args) {
86
87
        // Call the solve method to run the solution
88
89
        solve();
90
91
    }
92
93
}
94
95
96
97
98
99
    ",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834346
1387834332,h1032220720,unknown,unknown,"1
def solve():
2
    t = int(input())  # Number of test cases
3
    for _ in range(t):
4
        n = int(input())  # Size of the array
5
        nums = list(map(int, input().split()))  # Array of integers
6
        7
        # Compute the total sum of the array
8
        total_sum = sum(nums)
9
        10
        # Initialize the prefix sum
11
        prefix_sum = 0
12
        max_diff = 0
13
        14
        # Iterate over all possible partitions (from 1 to n-1)
15
        for i in range(n - 1):
16
            prefix_sum += nums[i]
17
            # Calculate the absolute difference between the two subarrays
18
            max_diff = max(max_diff, abs(prefix_sum - (total_sum - prefix_sum)))
19
        20
        print(max_diff)
21
22
# Run the function
23
solve()
24",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834332
1387834336,rahulyadav2005a1,unknown,unknown,"1
def moe(test_cases):
2
3
    results = []
4
5
    for t in range(len(test_cases)):
6
7
        N, K, energy = test_cases[t]
8
9
        total_energy = sum(energy)
10
11
        if total_energy % N != 0:
12
13
            results.append(-1)
14
15
            continue
16
17
        18
19
        target = total_energy // N
20
21
        operations = 0
22
23
        balance = 0  
24
25
        for i in range(N):
26
27
            balance += energy[i] - target
28
29
            if balance % K != 0:
30
31
                operations = -1
32
33
                break
34
35
            operations += abs(balance) // K
36
37
        38
39
        results.append(operations if operations != -1 else -1)
40
41
    42
43
    return results
44
45
T = int(input())
46
47
test_cases = []
48
49
for _ in range(T):
50
51
    N, K = map(int, input().split())
52
53
    energy = list(map(int, input().split()))
54
55
    test_cases.append((N, K, energy))
56
57
results = moe(test_cases)
58
59
for res in results:
60
61
    print(res)",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834336
1387834344,saurabhshuklaaa1,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            print(-1)
11
            continue
12
        13
        target_energy = total_energy // N
14
        operations = 0
15
        current_balance = 0
16
        17
        for i in range(N):
18
            current_balance += energy[i] - target_energy
19
            operations += abs(current_balance) // K
20
            21
            if abs(current_balance) % K != 0:
22
                operations = -1
23
                break
24
        25
        print(operations)
26
27
solve()",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834344
1387834323,codedot,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    energy = list(map(int, input().split()))
5
    6
    total_energy = sum(energy)
7
    8
    if total_energy % n != 0:
9
        print(-1)
10
        continue
11
    12
    target = total_energy // n
13
    operations = 0
14
    current_balance = 0
15
    16
    for i in range(n):
17
        current_balance += energy[i] - target
18
        19
        if current_balance > 0:
20
            operations += (current_balance + k - 1) // k
21
            22
    print(operations)
23",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834323
1387834325,rajnishjha,unknown,unknown,"1
def minimum_operations(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
        8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target_energy = total_energy // N
14
        operations = 0
15
        16
        for e in energy:
17
            diff = e - target_energy
18
            if diff % K != 0:
19
                results.append(-1)
20
                break
21
            operations += abs(diff) // K
22
        else:
23
            results.append(operations // 2)
24
    25
    return results
26
27
import sys
28
input = sys.stdin.read
29
data = input().splitlines()
30
31
T = int(data[0])
32
test_cases = []
33
line = 1
34
35
for _ in range(T):
36
    N, K = map(int, data[line].split())
37
    energy = list(map(int, data[line + 1].split()))
38
    test_cases.append(((N, K), energy))
39
    line += 2
40
41
results = minimum_operations(T, test_cases)
42
for res in results:
43
    print(res)
44",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834325
1387834326,snehstorage,unknown,unknown,"1
with Ada.Text_IO, Ada.Integer_Text_IO;
2
use Ada;
3
4
procedure Solution is
5
-- Enter your code here. Read input from STDIN. Print output to STDOUT
6
7
8
def product_except_self(values):
9
result = []
10
n= len(values)
11
12
for i in range(n):
13
product = 1
14
for j in range(n):
15
if j != i :
16
product *= values[j]
17
result.append(product)
18
19
return result
20
21
t= int(input())
22
23
for _in range(t):
24
n = int(input())
25
values= list(map(int,input().split()))
26
result= product_except_self(values)
27
print(*result)",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834326
1387834314,panoop2005_ap,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
        Scanner scanner = new Scanner(System.in);
9
        int T = scanner.nextInt();
10
11
        while (T-- > 0) {
12
            int N = scanner.nextInt();
13
            int K = scanner.nextInt();
14
            int[] energy = new int[N];
15
            long sum = 0;
16
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextInt();
19
                sum += energy[i];
20
            }
21
22
            if (sum % N != 0) {
23
                System.out.println(-1);
24
                continue;
25
            }
26
27
            int target = (int) (sum / N);
28
            long imbalance = 0;
29
            long operations = 0;
30
31
            for (int i = 0; i < N; i++) {
32
                imbalance += energy[i] - target;
33
                if (imbalance % K != 0) {
34
                    operations = -1;
35
                    break;
36
                }
37
                operations += Math.abs(imbalance) / K;
38
            }
39
40
            System.out.println(operations);
41
        }
42
        scanner.close();
43
    }
44
}",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834314
1387834309,1_ashwarya,unknown,unknown,"1
def min_operations(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target = total_energy // N
8
    operations = 0
9
    current_balance = 0
10
    11
    for i in range(N):
12
        diff = energy[i] - target
13
        current_balance += diff
14
  15
        operations += abs(current_balance) // K
16
    17
    return operations
18
19
T = int(input())  
20
21
for _ in range(T):
22
    N, K = map(int, input().split())
23
    energy = list(map(int, input().split()))
24
    25
    result = min_operations(N, K, energy)
26
    print(result)
27",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834309
1387834317,meetshah1785,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
         Scanner in = new Scanner(System.in);
8
        int T = in.nextInt(); 
9
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
10
        while (T-- > 0) {
11
        int N = in.nextInt();
12
        long K = in.nextLong();
13
        14
        long[] energy = new long[N];
15
        long total = 0;
16
        for (int i = 0; i < N; i++) {
17
            energy[i] = in.nextLong();
18
            total += energy[i];
19
        }
20
        21
       22
        if (total % N != 0) {
23
           24
            System.out.println(-1);
25
            continue;
26
        }
27
        long M = total / N;  
28
        29
  30
        long[] p = new long[N + 1];
31
        p[0] = 0;
32
        for (int i = 1; i <= N; i++) {
33
            p[i] = p[i - 1] + (energy[i - 1] - M);
34
        }
35
        long r = ((p[0] % K) + K) % K; 
36
        boolean feasible = true;
37
        for (int i = 1; i <= N; i++) {
38
            long remainder = ((p[i] % K) + K) % K;
39
            if (remainder != r) {
40
                feasible = false;
41
                break;
42
            }
43
        }
44
        if (!feasible) {
45
            System.out.println(-1);
46
            continue;
47
        }
48
        49
        50
        Arrays.sort(p);
51
        long median = p[(N) / 2]; 
52
        53
  54
        long modK = (median % K + K) % K;
55
        long diffToR = (r - modK + K) % K;  
56
        57
58
        long x1 = median + diffToR;  
59
      60
        long x2 = x1 - K;  
61
        62
        long cost1 = totalCost(p, x1, K);
63
        long cost2 = totalCost(p, x2, K);
64
        65
      66
        System.out.println(Math.min(cost1, cost2));
67
    }
68
    69
    in.close();
70
}
71
72
73
private static long totalCost(long[] p, long x, long K) {
74
    long cost = 0;
75
    for (long val : p) {
76
       77
        cost += Math.abs((val - x) / K);
78
    }
79
    return cost;
80
}
81
82
}",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834317
1387834306,h1032220319,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <numeric>
6
using namespace std;
7
8
void helper(){
9
    int n,k;
10
    cin>>n>>k;
11
    12
    vector<int>energy(n);
13
    for(int i=0;i<n;i++){
14
        cin>>energy[i];
15
    }
16
    long long totalEnergy =accumulate(energy.begin(),energy.end(),0LL);
17
    18
    if(totalEnergy%n!=0){
19
        cout<<-1<<""\n""; return;
20
    }
21
    int targetEnergy=totalEnergy/n;
22
    long long operations=0;
23
    24
    for(int i=0;i<n;i++){
25
        int diff=energy[i]-targetEnergy;
26
        if(diff%k!=0){
27
            cout<<-1 <<""\n"";
28
            return;
29
        }
30
        operations+=abs(diff/k);
31
    }  cout<<operations/2<<""\n"";
32
}
33
34
int main() {
35
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
36
   int input;
37
    cin>> input;
38
    while(input--){
39
        helper();
40
    }
41
    42
    return 0;
43
}
44",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834306
1387834298,hkailkhuri,unknown,unknown,"1
def solve():
2
3
    T = int(input())
4
5
    for _ in range(T):
6
7
        N, K = map(int, input().split())
8
9
        energy = list(map(int, input().split()))
10
11
        12
13
        total_energy = sum(energy)
14
15
        16
17
        if total_energy % N != 0:
18
19
            print(-1)
20
21
            continue
22
23
        24
25
        target_energy = total_energy // N
26
27
        operations = 0
28
29
        current_balance = 0
30
31
        32
33
        for i in range(N):
34
35
            current_balance += energy[i] - target_energy
36
37
            operations += abs(current_balance) // K
38
39
            40
41
            if abs(current_balance) % K != 0:
42
43
                operations = -1
44
45
                break
46
47
        48
49
        print(operations)
50
51
solve()",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834298
1387834299,h1032231291,unknown,unknown,"1
 import java.util.*;
2
3
public class MaxAbsoluteDifference {
4
5
    public static int findMaxAbsDifference(int[] nums) {
6
        int n = nums.length;
7
8
        int[] prefixSum = new int[n];
9
        prefixSum[0] = nums[0];
10
        for (int i = 1; i < n; i++) {
11
            prefixSum[i] = prefixSum[i - 1] + nums[i];
12
        }
13
14
        int totalSum = prefixSum[n - 1];
15
        int maxAbsDifference = 0;
16
17
        for (int i = 0; i < n - 1; i++) {
18
            int sumLeft = prefixSum[i];
19
            int sumRight = totalSum - sumLeft;
20
            maxAbsDifference = Math.max(maxAbsDifference, Math.abs(sumLeft - sumRight));
21
        }
22
23
        return maxAbsDifference;
24
    }
25
26
    public static void main(String[] args) {
27
        Scanner scanner = new Scanner(System.in);
28
        int t = scanner.nextInt();
29
        30
        while (t-- > 0) {
31
            int n = scanner.nextInt();
32
            int[] nums = new int[n];
33
34
            for (int i = 0; i < n; i++) {
35
                nums[i] = scanner.nextInt();
36
            }
37
38
            int result = findMaxAbsDifference(nums);
39
            System.out.println(result);
40
        }
41
42
        scanner.close();
43
    }
44
}",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834299
1387834302,angelaanindyajo1,unknown,unknown,"1
def minimum_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
4
    for i in range(t):
5
        # Access test case elements directly using index i
6
        n, k = test_cases[i]['n'], test_cases[i]['k']
7
        energy = test_cases[i]['energy']
8
9
        total_energy = sum(energy)
10
11
        if total_energy % n != 0:
12
            results.append(-1)
13
            continue
14
15
        target_energy = total_energy // n
16
        operations = 0
17
        current_transfer = 0
18
19
        for j in range(n):
20
            current_transfer += energy[j] - target_energy
21
            if current_transfer % k != 0:
22
                results.append(-1)
23
                break
24
            operations += abs(current_transfer) // k
25
        else:
26
            results.append(operations)
27
28
    return results
29
30
31
# Read input
32
T = int(input().strip())
33
test_cases = []
34
for _ in range(T):
35
    n, k = map(int, input().strip().split())
36
    energy = list(map(int, input().strip().split()))
37
    test_cases.append({""n"": n, ""k"": k, ""energy"": energy})
38
39
# Process and output results
40
results = minimum_operations_to_equalize_energy(T, test_cases)
41
for result in results:
42
    print(result)",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834302
1387834293,kaminiprasad32,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834293
1387834296,saurabhshuklaaa1,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
    # Calculate left product array
7
    for i in range(1, n):
8
        left[i] = left[i-1] * arr[i-1]
9
10
    # Calculate right product array
11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * arr[i+1]
13
14
    # Calculate result array
15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
# Get number of test cases
20
t = int(input())
21
22
for _ in range(t):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result)",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834296
1387834297,utsavsingh2826,unknown,unknown,"1
import java.util.Scanner;
2
3
public class MinOperations {
4
5
    // Method to calculate the minimum number of operations required to equalize energy
6
7
    public static int minOperations(int n, int k, int[] energy) {
8
9
        // Calculate the total energy
10
11
        int totalEnergy = 0;
12
13
        for (int i = 0; i < n; i++) {
14
15
            totalEnergy += energy[i];
16
17
        }
18
19
        20
21
        // If total energy is not divisible by n, return -1
22
23
        if (totalEnergy % n != 0) {
24
25
            return -1;
26
27
        }
28
29
        30
31
        // Calculate the target energy for each station
32
33
        int targetEnergy = totalEnergy / n;
34
35
        int operations = 0;
36
37
        // Calculate the number of operations required
38
39
        for (int i = 0; i < n; i++) {
40
41
            int diff = energy[i] - targetEnergy;
42
43
            if (diff > 0) {
44
45
                // Ceiling division to calculate the number of operations
46
47
                operations += (diff + k - 1) / k;
48
49
            }
50
51
        }
52
53
        return operations;
54
55
    }
56
57
    public static void main(String[] args) {
58
59
        Scanner scanner = new Scanner(System.in);
60
61
        62
63
        // Get number of test cases
64
65
        int t = scanner.nextInt();
66
67
        68
69
        for (int i = 0; i < t; i++) {
70
71
            // Read n and k
72
73
            int n = scanner.nextInt();
74
75
            int k = scanner.nextInt();
76
77
            78
79
            // Read energy array
80
81
            int[] energy = new int[n];
82
83
            for (int j = 0; j < n; j++) {
84
85
                energy[j] = scanner.nextInt();
86
87
            }
88
89
            90
91
            // Get the minimum operations
92
93
            int result = minOperations(n, k, energy);
94
95
            96
97
            // Print the result
98
99
            System.out.println(result);
100
101
        }
102
103
        104
105
        scanner.close();
106
107
    }
108
109
}
110
111
112
113
114
115
116",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834297
1387834277,yashd1soni,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for test in test_cases:
5
        n, nums = test
6
        prefix_sum = [0] * n
7
        prefix_sum[0] = nums[0]
8
        9
        # Calculate prefix sum
10
        for i in range(1, n):
11
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
12
        13
        # Initialize max difference
14
        max_diff = 0
15
        16
        # Iterate through possible partition points
17
        for i in range(n - 1):
18
            sum_left = prefix_sum[i]
19
            sum_right = prefix_sum[-1] - sum_left
20
            max_diff = max(max_diff, abs(sum_left - sum_right))
21
        22
        results.append(max_diff)
23
    24
    return results
25
26
# Input Parsing
27
t = int(input())
28
test_cases = []
29
for _ in range(t):
30
    n = int(input())
31
    nums = list(map(int, input().split()))
32
    test_cases.append((n, nums))
33
34
# Output Results
35
results = max_absolute_difference(t, test_cases)
36
for res in results:
37
    print(res)",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834277
1387834289,samadshaikh22005,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
void solve() {
7
    int t;
8
    cin >> t;
9
    10
    while (t--) {
11
        int n;
12
        cin >> n;
13
        14
        vector<int> nums(n);
15
        int totalSum = 0;
16
        17
        // Read the array and calculate the total sum
18
        for (int i = 0; i < n; i++) {
19
            cin >> nums[i];
20
            totalSum += nums[i];
21
        }
22
        23
        // Compute the prefix sum and calculate the maximum absolute difference
24
        int prefixSum = 0;
25
        int maxDifference = 0;
26
        27
        for (int i = 0; i < n - 1; i++) {
28
            prefixSum += nums[i];
29
            int difference = abs(2 * prefixSum - totalSum);
30
            maxDifference = max(maxDifference, difference);
31
        }
32
        33
        cout << maxDifference << endl;
34
    }
35
}
36
37
int main() {
38
    solve();
39
    return 0;
40
}
41",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834289
1387834286,rahulyadav2005a1,unknown,unknown,"1
def solve_product_excluding_self(test_cases):
2
    results = []
3
    for t in range(test_cases):
4
        n = int(input())
5
        values = list(map(int, input().split()))
6
        if n == 1:
7
            results.append([1])
8
            continue
9
10
        prefix = [1] * n
11
        suffix = [1] * n
12
        result = [0] * n
13
        for i in range(1, n):
14
            prefix[i] = prefix[i - 1] * values[i - 1]
15
16
        for i in range(n - 2, -1, -1):
17
            suffix[i] = suffix[i + 1] * values[i + 1]
18
        for i in range(n):
19
            result[i] = prefix[i] * suffix[i]
20
21
        results.append(result)
22
    for res in results:
23
        print("" "".join(map(str, res)))
24
T = int(input())
25
solve_product_excluding_self(T)",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834286
1387834270,h1032220720,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    for _ in range(T):
4
        N, K = map(int, input().split())  # Read N and K
5
        energy = list(map(int, input().split()))  # Read energy array
6
        7
        total_energy = sum(energy)
8
        9
        # If total energy is not divisible by N, it's impossible to equalize
10
        if total_energy % N != 0:
11
            print(-1)
12
            continue
13
        14
        target_energy = total_energy // N  # Desired energy for each station
15
        imbalance = 0
16
        operations = 0
17
        18
        for i in range(N):
19
            # Calculate the difference between the current energy and the target energy
20
            imbalance += energy[i] - target_energy
21
            22
            # If imbalance is not a multiple of K, it's impossible to fix
23
            if imbalance % K != 0:
24
                print(-1)
25
                break
26
            # We add the number of operations required to fix the imbalance at the current station
27
            operations += abs(imbalance) // K
28
        29
        else:
30
            # If we completed the loop without breaking, print the result
31
            print(operations)
32
33
# Run the function
34
solve()
35",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834270
1387834267,pranaytiwariprpk,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for nums in test_cases:
4
        n = len(nums)
5
        total_sum = sum(nums)
6
        7
        max_left_sum = float('-inf')
8
        min_left_sum = float('inf')
9
        current_sum = 0
10
        11
        for i in range(n - 1):  # We stop at n-1 to ensure both parts are non-empty
12
            current_sum += nums[i]
13
            max_left_sum = max(max_left_sum, current_sum)
14
            min_left_sum = min(min_left_sum, current_sum)
15
16
        max_difference = max(abs(total_sum - 2 * max_left_sum), abs(total_sum - 2 * min_left_sum))
17
        results.append(max_difference)
18
    19
    return results
20
21
try:
22
    t = int(input())
23
except EOFError:
24
    print(""No input provided."")
25
    t = 0
26
27
test_cases = []
28
for _ in range(t):
29
    n = int(input())
30
    nums = list(map(int, input().split()))
31
    test_cases.append(nums)
32
33
results = max_absolute_difference(test_cases)
34
for result in results:
35
    print(result)",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834267
1387834268,h1032221701,unknown,unknown,"1
import sys
2
3
def product_except_self(test_cases):
4
    results = []
5
    for case in test_cases:
6
        n, values = case
7
        prefix = [1] * n
8
        suffix = [1] * n
9
        result = [1] * n
10
        11
        # Compute prefix products
12
        for i in range(1, n):
13
            prefix[i] = prefix[i - 1] * values[i - 1]
14
        15
        # Compute suffix products
16
        for i in range(n - 2, -1, -1):
17
            suffix[i] = suffix[i + 1] * values[i + 1]
18
        19
        # Compute result array
20
        for i in range(n):
21
            result[i] = prefix[i] * suffix[i]
22
        23
        results.append(result)
24
    25
    return results
26
27
# Input Reading
28
input_data = sys.stdin.read().strip()  # Read all input at once
29
if input_data:
30
    lines = input_data.splitlines()  # Split input into lines
31
    T = int(lines[0])  # Number of test cases
32
    test_cases = []
33
34
    idx = 1
35
    for _ in range(T):
36
        n = int(lines[idx])  # Size of the array
37
        values = list(map(int, lines[idx + 1].split()))  # Array elements
38
        test_cases.append((n, values))
39
        idx += 2
40
41
    # Compute and Output Results
42
    results = product_except_self(test_cases)
43
    for res in results:
44
        print(' '.join(map(str, res)))
45
else:
46
    print(""No input provided."")
47",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834268
1387834269,jkinsuk760,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        prefix_sum = [0] * n
6
        suffix_sum = [0] * n
7
8
        prefix_sum[0] = nums[0]
9
        for i in range(1, n):
10
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
11
12
        suffix_sum[n - 1] = nums[n - 1]
13
        for i in range(n - 2, -1, -1):
14
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
15
16
        max_diff = 0
17
        for i in range(n - 1):
18
            left_sum = prefix_sum[i]
19
            right_sum = suffix_sum[i + 1]
20
            max_diff = max(max_diff, abs(left_sum - right_sum))
21
22
        results.append(max_diff)
23
    return results
24
25
t = int(input())
26
test_cases = []
27
for _ in range(t):
28
    n = int(input())
29
    nums = list(map(int, input().split()))
30
    test_cases.append((n, nums))
31
32
outputs = max_absolute_difference(test_cases)
33
for output in outputs:
34
    print(output)
35",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834269
1387834259,HarshShrivastava,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner sc=new Scanner(System.in);
8
        int t=sc.nextInt();
9
        while(t>0){
10
            int n=sc.nextInt();
11
            long a[]=new long[n];
12
            int k=sc.nextInt();
13
            int i;
14
            long total=0;
15
            for(i=0;i<n;i++){
16
                a[i]=sc.nextLong();
17
                total+=a[i];
18
            }
19
            if(total%n!=0)
20
                System.out.println(-1);
21
            else{
22
                i=0;
23
                int count=0;
24
                int steps=0;
25
                while(true){
26
                    i%=n;
27
                    if(a[(i+1)%n]==a[i]){
28
                        count+=1;
29
                    }
30
                    if(a[(i+1)%n]<a[i]&&a[i]-a[(i+1)%n]>=k){
31
                        a[i+1]+=k;
32
                        a[i]-=k;
33
                        steps+=1;
34
                        count=0;
35
                    }
36
                    if(count==n){
37
                        System.out.println(steps);
38
                        break;
39
                    }
40
                    i++;
41
                }
42
            }
43
            t--;
44
        }
45
    }
46
}",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834259
1387834260,h1032221515,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
4
    for _ in range(test_cases):
5
        n = int(input())  # Changed raw_input() to input()
6
        nums = list(map(int, input().split()))  # Converted map to list
7
        max_diff = 0
8
        prefix_sum = 0
9
        total_sum = sum(nums)  # Calculate total sum once
10
        for i in range(n - 1):
11
            prefix_sum += nums[i]
12
            suffix_sum = total_sum - prefix_sum
13
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
14
15
        results.append(max_diff)
16
    17
    for res in results:
18
        print(res)
19
20
21
T = int(input())  # Changed raw_input() to input()
22
max_absolute_difference(T)",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834260
1387834261,vishal986958,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    left_sum = 0
4
    total_sum = sum(nums)
5
    max_diff = 0
6
7
    for i in range(n - 1):
8
        left_sum += nums[i]
9
        right_sum = total_sum - left_sum
10
        max_diff = max(max_diff, abs(left_sum - right_sum))
11
    12
    return max_diff
13
14
# Read number of test cases
15
t = int(input())
16
for _ in range(t):
17
    n = int(input())
18
    nums = list(map(int, input().split()))
19
    result = max_absolute_difference(nums)
20
    print(result)
21",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834261
1387834254,rajnishjha,unknown,unknown,"1
def compute_result(T, test_cases):
2
    results = []
3
    for case in range(T):
4
        n = test_cases[case][0]
5
        values = test_cases[case][1]
6
7
        result = [1] * n
8
9
        prefix_product = 1
10
        for i in range(n):
11
            result[i] = prefix_product
12
            prefix_product *= values[i]
13
14
        suffix_product = 1
15
        for i in range(n - 1, -1, -1):
16
            result[i] *= suffix_product
17
            suffix_product *= values[i]
18
19
        results.append(result)
20
21
    return results
22
23
import sys
24
input = sys.stdin.read
25
data = input().splitlines()
26
27
T = int(data[0])
28
test_cases = []
29
line = 1
30
31
for _ in range(T):
32
    n = int(data[line])
33
    values = list(map(int, data[line + 1].split()))
34
    test_cases.append((n, values))
35
    line += 2
36
37
output = compute_result(T, test_cases)
38
39
for res in output:
40
    print("" "".join(map(str, res)))
41",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834254
1387834255,h1032220685,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, values = case
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [1] * n
9
10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result array
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Process and print the output
37
output = product_except_self(test_cases)
38
for res in output:
39
    print("" "".join(map(str, res)))
40",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834255
1387834256,codedot,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    energy = list(map(int, input().split()))
5
    total_energy = sum(energy)
6
    7
    if total_energy % n != 0:
8
        print(-1)
9
        continue
10
    11
    target = total_energy // n
12
    operations = 0
13
    current_balance = 0
14
    15
    for i in range(n):
16
        current_balance += energy[i] - target
17
        if current_balance > 0:
18
            operations += (current_balance + k - 1) // k  # ceil(current_balance / k)
19
    20
    print(operations)
21",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834256
1387834246,sanika_wani,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, nums = case
6
        prefix = [0] * n
7
        suffix = [0] * n
8
        9
        prefix[0] = nums[0]
10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] + nums[i]
12
        13
        suffix[-1] = nums[-1]
14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] + nums[i]
16
        17
        max_diff = 0
18
        for i in range(n - 1):
19
            left_sum = prefix[i]
20
            right_sum = suffix[i + 1]
21
            max_diff = max(max_diff, abs(left_sum - right_sum))
22
        23
        results.append(max_diff)
24
    25
    return results
26
27
if __name__ == ""__main__"":
28
    t = int(input()) 
29
    test_cases = []
30
    for _ in range(t):
31
        n = int(input())
32
        nums = list(map(int, input().split()))
33
        test_cases.append((n, nums))
34
    35
    results = max_absolute_difference(t, test_cases)
36
    for res in results:
37
        print(res)
38",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834246
1387834243,kaminiprasad32,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834243
1387834244,yashkchaudhari1,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    ptr = 0
6
    t = int(input[ptr])
7
    ptr += 1
8
    for _ in range(t):
9
        n = int(input[ptr])
10
        ptr += 1
11
        arr = list(map(int, input[ptr:ptr+n]))
12
        ptr += n
13
        total = sum(arr)
14
        left_sum = 0
15
        s_max = -float('inf')
16
        s_min = float('inf')
17
        for i in range(n-1):
18
            left_sum += arr[i]
19
            if left_sum > s_max:
20
                s_max = left_sum
21
            if left_sum < s_min:
22
                s_min = left_sum
23
        option1 = abs(2 * s_max - total)
24
        option2 = abs(2 * s_min - total)
25
        max_diff = max(option1, option2)
26
        print(max_diff)
27
28
if __name__ == ""__main__"":
29
    main()",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834244
1387834245,krunalparab777,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    results = []
4
    5
    for _ in range(T):
6
        # Read N, K
7
        N, K = map(int, input().split())
8
        # Read energy array
9
        energy = list(map(int, input().split()))
10
        11
        # Total energy in the system
12
        total_energy = sum(energy)
13
        14
        # Check if equalizing is possible
15
        if total_energy % N != 0:
16
            results.append(-1)
17
            continue
18
        19
        target_energy = total_energy // N
20
        balance = 0
21
        operations = 0
22
        23
        for i in range(N):
24
            balance += energy[i] - target_energy
25
            if balance % K != 0:
26
                results.append(-1)
27
                break
28
            operations += abs(balance) // K
29
        else:
30
            results.append(operations)
31
    32
    # Print results
33
    for res in results:
34
        print(res)
35
36
# Example usage
37
solve()
38",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834245
1387834236,abhaywadkar2004,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    4
    for _ in range(T):
5
        # Input values
6
        N, K = map(int, input().split())
7
        energy = list(map(int, input().split()))
8
        9
        # Total energy of all stations
10
        total_energy = sum(energy)
11
        12
        # If total energy is not divisible by N, equalization is impossible
13
        if total_energy % N != 0:
14
            print(-1)
15
            continue
16
        17
        # Target energy for each station
18
        target_energy = total_energy // N
19
        surplus = 0
20
        21
        # Check surplus and deficit
22
        possible = True
23
        for e in energy:
24
            diff = e - target_energy
25
            if diff % K != 0:  # If difference is not divisible by K, equalization is impossible
26
                possible = False
27
                break
28
            surplus += diff // K
29
        30
        # If possible, the number of operations is the total surplus (or deficit, since they balance out)
31
        print(surplus if possible and surplus == 0 else -1)
32
33
# Driver code
34
if __name__ == ""__main__"":
35
    solve()
36",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834236
1387834239,vinayakdasari201,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
    total_sum = sum(nums)
3
    left_sum = 0
4
    max_diff = float('-inf')
5
6
    # Iterate through the array to find the max absolute difference
7
    for i in range(n - 1):  # Partition at each index
8
        left_sum += nums[i]
9
        right_sum = total_sum - left_sum
10
        max_diff = max(max_diff, abs(left_sum - right_sum))
11
    12
    return max_diff
13
14
# Read input
15
T = int(input())  # Number of test cases
16
for _ in range(T):
17
    n = int(input())  # Size of array
18
    nums = list(map(int, input().split()))  # Input array
19
20
    # Compute and print result
21
    print(max_absolute_difference(n, nums))",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834239
1387834235,princesharma8050,unknown,unknown,"1
def max_absolute_difference(nums):
2
3
    n = len(nums)
4
    prefix_sum = [0] * (n + 1)
5
6
    # Calculate prefix sums
7
    for i in range(1, n + 1):
8
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
9
10
    max_diff = 0
11
    for i in range(1, n):
12
        left_sum = prefix_sum[i]
13
        right_sum = prefix_sum[n] - prefix_sum[i]
14
        max_diff = max(max_diff, abs(left_sum - right_sum))
15
16
    return max_diff
17
18
if __name__ == ""__main__"":
19
    t = int(input())
20
    for _ in range(t):
21
        n = int(input())
22
        nums = list(map(int, input().split()))
23
        result = max_absolute_difference(nums)
24
        print(result)",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834235
1387834230,goswamyashutosh9,unknown,unknown,"1
import sys
2
3
def minimum_operations_to_equalize_energy(test_cases):
4
    results = []
5
    for n, k, energy in test_cases:
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % n != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // n
14
        balance = 0
15
        operations = 0
16
        possible = True
17
        18
        # Calculate the number of operations
19
        for e in energy:
20
            diff = e - target
21
            if diff % k != 0:
22
                possible = False
23
                break
24
            balance += diff // k
25
            operations += abs(balance)
26
        27
        # Check if balancing is possible
28
        results.append(operations if possible else -1)
29
    30
    return results
31
32
# Input Reading
33
input_data = sys.stdin.read().strip()  # Read all input at once
34
35
if input_data:  # Check if input is provided
36
    lines = input_data.splitlines()  # Split input into lines
37
38
    T = int(lines[0])  # Number of test cases
39
    test_cases = []
40
    index = 1
41
42
    for _ in range(T):
43
        n, k = map(int, lines[index].split())
44
        energy = list(map(int, lines[index + 1].split()))
45
        test_cases.append((n, k, energy))
46
        index += 2
47
48
    # Compute and Output Results
49
    results = minimum_operations_to_equalize_energy(test_cases)
50
    print(""\n"".join(map(str, results)))
51
else:
52
    print(""No input provided."")",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834230
1387834234,mahakantsingh113,unknown,unknown,"1
def maxAbsDifference(nums):
2
    n = len(nums)
3
    prefix = [0] * n
4
    suffix = [0] * n
5
    6
    # Compute prefix sum
7
    prefix[0] = nums[0]
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] + nums[i]
10
    11
    # Compute suffix sum
12
    suffix[n - 1] = nums[n - 1]
13
    for i in range(n - 2, -1, -1):
14
        suffix[i] = suffix[i + 1] + nums[i]
15
    16
    max_diff = float('-inf')
17
    18
    # Calculate the absolute differences for each partition
19
    for i in range(n - 1):
20
        sum1 = prefix[i]
21
        sum2 = suffix[i + 1]
22
        max_diff = max(max_diff, abs(sum1 - sum2))
23
    24
    return max_diff
25
26
# Read input
27
t = int(input())
28
for _ in range(t):
29
    n = int(input())
30
    nums = list(map(int, input().split()))
31
    print(maxAbsDifference(nums))
32",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834234
1387834231,akshitha_ssays,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
    prefix_sum = [0] * n
3
    suffix_sum = [0] * n
4
    5
    prefix_sum[0] = nums[0]
6
    suffix_sum[n-1] = nums[n-1]
7
    8
    for i in range(1, n):
9
        prefix_sum[i] = prefix_sum[i-1] + nums[i]
10
    11
    for i in range(n-2, -1, -1):
12
        suffix_sum[i] = suffix_sum[i+1] + nums[i]
13
    14
    max_diff = 0
15
    16
    for i in range(n-1):
17
        left_sum = prefix_sum[i]
18
        right_sum = suffix_sum[i+1]
19
        max_diff = max(max_diff, abs(left_sum - right_sum))
20
    21
    return max_diff
22
23
# Reading input
24
t = int(input().strip())
25
results = []
26
27
for _ in range(t):
28
    n = int(input().strip())
29
    nums = list(map(int, input().strip().split()))
30
    result = max_absolute_difference(n, nums)
31
    results.append(result)
32
33
# Output the results
34
for result in results:
35
    print(result)",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834231
1387834228,codedot,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
 n,k=map(int,input().split())
4
 energy=list(map(int,input().split()))
5
 total_energy=sum(energy)
6
 if total_energy%n!=0:
7
  print(-1)
8
  continue
9
 target=total_energy//n
10
 operations=0
11
 for i in range(n):
12
  diff=energy[i]-target
13
  if diff>0:
14
   operations+=diff//k
15
 print(operations)
16",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834228
1387834222,h1032221739,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        result = [1] * n
6
        prefix = 1
7
        for i in range(n):
8
            result[i] = prefix
9
            prefix *= values[i]
10
        suffix = 1
11
        for i in range(n - 1, -1, -1):
12
            result[i] *= suffix
13
            suffix *= values[i]
14
        results.append(result)
15
    return results
16
17
t = int(input())
18
test_cases = []
19
for _ in range(t):
20
    n = int(input())
21
    values = list(map(int, input().split()))
22
    test_cases.append((n, values))
23
24
results = product_except_self(test_cases)
25
for result in results:
26
    print("" "".join(map(str, result)))",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834222
1387834227,mlal42239,unknown,unknown,"1
def solve():
2
    t = int(input())  
3
    for _ in range(t):
4
        n = int(input())  
5
        nums = list(map(int, input().split()))  
6
        7
        8
        total_sum = sum(nums)
9
        10
       11
        left_sum = 0
12
        max_difference = 0
13
        14
       15
        for i in range(n - 1): 
16
            left_sum += nums[i]
17
            right_sum = total_sum - left_sum
18
            max_difference = max(max_difference, abs(left_sum - right_sum))
19
        20
        print(max_difference)
21
22
23
solve()",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834227
1387834217,h1032221495,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
4
    for _ in range(t):
5
        n = test_cases[_][0]
6
        nums = test_cases[_][1]
7
8
        # Prefix and suffix sums
9
        prefix_sum = [0] * n
10
        suffix_sum = [0] * n
11
12
        # Compute prefix sum
13
        prefix_sum[0] = nums[0]
14
        for i in range(1, n):
15
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
16
17
        # Compute suffix sum
18
        suffix_sum[n - 1] = nums[n - 1]
19
        for i in range(n - 2, -1, -1):
20
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
21
22
        # Calculate the maximum absolute difference
23
        max_diff = 0
24
        for i in range(n - 1):
25
            left_sum = prefix_sum[i]
26
            right_sum = suffix_sum[i + 1]
27
            max_diff = max(max_diff, abs(left_sum - right_sum))
28
29
        results.append(max_diff)
30
31
    return results
32
33
# Input reading
34
t = int(input())
35
test_cases = []
36
for _ in range(t):
37
    n = int(input())
38
    nums = list(map(int, input().split()))
39
    test_cases.append((n, nums))
40
41
# Solve and output results
42
results = max_absolute_difference(t, test_cases)
43
for result in results:
44
    print(result)",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834217
1387834218,h1032220352,unknown,unknown,"1
import sys
2
input = sys.stdin.read
3
4
def solve():
5
    data = input().splitlines()
6
    idx = 0  
7
    T = int(data[idx])  
8
    idx += 1  
9
    results = []
10
    11
    for _ in range(T):
12
        num_stations, transfer_units = map(int, data[idx].split())  
13
        idx += 1
14
        station_energies = list(map(int, data[idx].split()))
15
        idx += 1
16
        17
        total_energy = sum(station_energies)
18
        19
        if total_energy % num_stations != 0:
20
            results.append(-1)
21
            continue
22
        23
        target_energy = total_energy // num_stations
24
        num_operations = 0
25
        balance = 0
26
        27
        for i in range(num_stations):
28
            diff = station_energies[i] - target_energy
29
            balance += diff
30
            if balance % transfer_units != 0:
31
                num_operations = -1
32
                break
33
            num_operations += abs(balance // transfer_units)
34
        35
        results.append(num_operations)
36
    37
    sys.stdout.write(""\n"".join(map(str, results)) + ""\n"")
38
39
solve()
40",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834218
1387834221,parmesh214,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    if total_energy % N != 0:
4
        return -1
5
    target = total_energy // N
6
    operations = 0
7
    balance = 0
8
    for i in range(N):
9
        balance += energy[i] - target
10
        if balance % K != 0:
11
            return -1
12
        operations += abs(balance // K)
13
    return operations
14
15
def solve():
16
    T = int(input())
17
    for _ in range(T):
18
        N, K = map(int, input().split())
19
        energy = list(map(int, input().split()))
20
        print(min_operations_to_equalize(N, K, energy))
21
22
if __name__ == ""__main__"":
23
    solve()
24",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834221
1387834212,siddhinnaik05,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <cmath>
5
using namespace std;
6
7
void solve() {
8
    int T;
9
    cin >> T; // Number of test cases
10
11
    while (T--) {
12
        int N, K;
13
        cin >> N >> K; // Number of stations and energy transfer units per operation
14
15
        vector<int> energy(N);
16
        long long totalEnergy = 0;
17
18
        for (int i = 0; i < N; i++) {
19
            cin >> energy[i];
20
            totalEnergy += energy[i];
21
        }
22
23
        // If total energy is not divisible by N, equal distribution is impossible
24
        if (totalEnergy % N != 0) {
25
            cout << -1 << endl;
26
            continue;
27
        }
28
29
        int target = totalEnergy / N; // Target energy for each station
30
        long long operations = 0, imbalance = 0;
31
32
        for (int i = 0; i < N; i++) {
33
            // Calculate imbalance at this station
34
            imbalance += (energy[i] - target);
35
            // Operations required to equalize this imbalance
36
            operations += abs(imbalance) / K;
37
38
            // If K does not perfectly divide the imbalance, equalization is impossible
39
            if (imbalance % K != 0) {
40
                operations = -1;
41
                break;
42
            }
43
        }
44
45
        cout << (operations == -1 ? -1 : operations) << endl;
46
    }
47
}
48
49
int main() {
50
    solve();
51
    return 0;
52
}
53
54",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834212
1387834211,panoop2005_ap,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
        Scanner scanner = new Scanner(System.in);
9
        int T = scanner.nextInt();
10
11
        while (T-- > 0) {
12
            int N = scanner.nextInt();
13
            int K = scanner.nextInt();
14
            int[] energy = new int[N];
15
            int sum = 0;
16
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextInt();
19
                sum += energy[i];
20
            }
21
22
            if (sum % N != 0) {
23
                System.out.println(-1);
24
                continue;
25
            }
26
27
            int target = sum / N;
28
            int operations = 0;
29
            int imbalance = 0;
30
31
            for (int i = 0; i < N; i++) {
32
                imbalance += energy[i] - target;
33
                if (imbalance % K != 0) {
34
                    operations = -1;
35
                    break;
36
                }
37
                operations += Math.abs(imbalance) / K;
38
            }
39
40
            System.out.println(operations);
41
        }
42
        scanner.close();
43
    }
44
}",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834211
1387834213,vinayakdasari201,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # If total energy cannot be evenly distributed among stations, return -1
5
    if total_energy % N != 0:
6
        return -1
7
8
    target = total_energy // N  # Each station should have this amount of energy
9
    operations = 0
10
    balance = 0
11
12
    # Check if we can equalize using only K transfers
13
    for i in range(N):
14
        diff = energy[i] - target  # Difference from required energy
15
        balance += diff  # Track excess/deficit energy
16
        17
        # If balance cannot be fixed using K moves, it's impossible
18
        if balance % K != 0:
19
            return -1
20
21
        operations += abs(balance) // K  # Count moves required
22
    23
    return operations
24
25
# Read input
26
T = int(input())  # Number of test cases
27
for _ in range(T):
28
    N, K = map(int, input().split())  # Read N and K
29
    energy = list(map(int, input().split()))  # Read energy levels
30
    31
    # Compute and print result
32
    print(min_operations_to_equalize(N, K, energy))",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834213
1387834210,smeetadeshra,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for test in test_cases:
4
        n, nums = test
5
        prefix_sum = [0] * n
6
        prefix_sum[0] = nums[0]
7
        for i in range(1, n):
8
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
9
        total_sum = prefix_sum[-1]
10
        max_diff1 = 0
11
        for i in range(n - 1):
12
            sum1 = prefix_sum[i] 
13
            sum2 = total_sum - sum1 
14
            max_diff1 = max(max_diff1, abs(sum1 - sum2))
15
        results.append(max_diff1)
16
    return results
17
t = int(input())
18
test_cases = []
19
for _ in range(t):
20
    n = int(input())
21
    nums = list(map(int, input().split()))
22
    test_cases.append((n, nums))
23
output1 = max_absolute_difference(t, test_cases)
24
for res in output1:
25
    print(res)",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834210
1387834205,h1032221532,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
     17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
results = minimum_operations_to_equalize(test_cases)
44
45
for res in results:
46
    print(res)",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834205
1387834206,utsavsingh2826,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ProductArray {
4
5
    6
7
    // Method to calculate the product array
8
9
    public static int[] productArray(int[] arr) {
10
11
        int n = arr.length;
12
13
        int[] left = new int[n];
14
15
        int[] right = new int[n];
16
17
        int[] result = new int[n];
18
19
        20
21
        // Initialize left and right product arrays
22
23
        left[0] = 1;
24
25
        right[n-1] = 1;
26
27
        28
29
        // Calculate left product array
30
31
        for (int i = 1; i < n; i++) {
32
33
            left[i] = left[i - 1] * arr[i - 1];
34
35
        }
36
37
        38
39
        // Calculate right product array
40
41
        for (int i = n - 2; i >= 0; i--) {
42
43
            right[i] = right[i + 1] * arr[i + 1];
44
45
        }
46
47
        48
49
        // Calculate result array
50
51
        for (int i = 0; i < n; i++) {
52
53
            result[i] = left[i] * right[i];
54
55
        }
56
57
        58
59
        return result;
60
61
    }
62
63
    public static void main(String[] args) {
64
65
        Scanner scanner = new Scanner(System.in);
66
67
        68
69
        // Get number of test cases
70
71
        int t = scanner.nextInt();
72
73
        74
75
        for (int i = 0; i < t; i++) {
76
77
            int n = scanner.nextInt();
78
79
            int[] arr = new int[n];
80
81
            82
83
            // Read array
84
85
            for (int j = 0; j < n; j++) {
86
87
                arr[j] = scanner.nextInt();
88
89
            }
90
91
            92
93
            // Get the product array
94
95
            int[] result = productArray(arr);
96
97
            98
99
            // Print the result array
100
101
            for (int j = 0; j < n; j++) {
102
103
                System.out.print(result[j] + "" "");
104
105
            }
106
107
            System.out.println();
108
109
        }
110
111
        112
113
        scanner.close();
114
115
    }
116
117
}
118
119
120
121
122
123",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834206
1387834208,h1032221348,unknown,unknown,"1
def minimum_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
    4
    for i in range(t):
5
        n, k = test_cases[i][0]
6
        energy = test_cases[i][1]
7
        8
        total_energy = sum(energy)
9
        if total_energy % n != 0:
10
            results.append(-1)
11
            continue
12
        13
        target_energy = total_energy // n
14
        operations = 0
15
        balance = 0
16
        17
        for e in energy:
18
            balance += e - target_energy
19
            if balance % k != 0:
20
                results.append(-1)
21
                break
22
            operations += abs(balance) // k
23
        else:
24
            results.append(operations)
25
    26
    return results
27
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    energy = list(map(int, input().split()))
34
    test_cases.append(((n, k), energy))
35
36
37
output = minimum_operations_to_equalize_energy(T, test_cases)
38
for res in output:
39
    print(res)",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834208
1387834199,jheelj86,unknown,unknown,"1
def solve_testcase(n, nums):
2
3
    if n == 2:
4
        return abs(nums[0] - nums[1])
5
    6
   7
    total_sum = sum(nums)
8
    9
    max_diff = 0
10
    left_sum = 0
11
    12
  13
    for i in range(n-1):
14
       15
        left_sum += nums[i]
16
    17
        right_sum = total_sum - left_sum
18
 19
        curr_diff = abs(left_sum - right_sum)
20
21
        max_diff = max(max_diff, curr_diff)
22
    23
    return max_diff
24
25
def main():
26
  27
    t = int(input())
28
    29
30
    for _ in range(t):
31
     32
        n = int(input())
33
    34
        nums = list(map(int, input().split()))
35
        36
       37
        result = solve_testcase(n, nums)
38
        39
      40
        print(result)
41
42
if __name__ == ""__main__"":
43
    main()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834199
1387834198,vinayakdasari201,unknown,unknown,"1
def compute_product_excluding_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        total_product = 1
6
        zero_count = values.count(0)
7
8
        if zero_count > 1:
9
            results.append([0] * n)
10
        elif zero_count == 1:
11
            zero_index = values.index(0)
12
            product_except_zero = 1
13
            for i in range(n):
14
                if i != zero_index:
15
                    product_except_zero *= values[i]
16
            result = [0] * n
17
            result[zero_index] = product_except_zero
18
            results.append(result)
19
        else:
20
            for value in values:
21
                total_product *= value
22
            results.append([total_product // value for value in values])
23
24
    return results
25
26
T = int(input())
27
test_cases = [(int(input()), list(map(int, input().split()))) for _ in range(T)]
28
results = compute_product_excluding_self(test_cases)
29
for result in results:
30
    print(*result)",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834198
1387834204,suryampandey5942,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
#include <algorithm>
5
using namespace std;
6
7
vector<int> max_absolute_difference(vector<pair<int, vector<int>>>& test_cases) {
8
    vector<int> results;
9
    10
    for (auto& t : test_cases) {
11
        int n = t.first;
12
        vector<int>& nums = t.second;
13
        14
        int total_sum = 0;
15
        for (int num : nums) {
16
            total_sum += num;
17
        }
18
        19
        int prefix_sum = 0;
20
        int max_diff = 0;
21
        22
        // Iterate through possible partitions
23
        for (int i = 0; i < n - 1; i++) {  // Last partition is invalid (requires two non-empty subarrays)
24
            prefix_sum += nums[i];
25
            int suffix_sum = total_sum - prefix_sum;
26
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum));
27
        }
28
        29
        results.push_back(max_diff);
30
    }
31
    32
    return results;
33
}
34
35
int main() {
36
    int t;
37
    cin >> t;
38
    39
    vector<pair<int, vector<int>>> test_cases;
40
    41
    for (int i = 0; i < t; i++) {
42
        int n;
43
        cin >> n;
44
        45
        vector<int> nums(n);
46
        for (int j = 0; j < n; j++) {
47
            cin >> nums[j];
48
        }
49
        50
        test_cases.push_back({n, nums});
51
    }
52
    53
    vector<int> results = max_absolute_difference(test_cases);
54
    55
    for (int res : results) {
56
        cout << res << endl;
57
    }
58
    59
    return 0;
60
}
61",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834204
1387834185,kaminiprasad32,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834185
1387834188,h1032220872,unknown,unknown,"1
def moe(test_cases):
2
    results = []
3
4
    for t in range(len(test_cases)):
5
        N, K, energy = test_cases[t]
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // N
12
        operations = 0
13
        balance = 0  
14
        for i in range(N):
15
            balance += energy[i] - target
16
            if balance % K != 0:
17
                operations = -1
18
                break
19
            operations += abs(balance) // K
20
        21
        results.append(operations if operations != -1 else -1)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    N, K = map(int, input().split())
30
    energy = list(map(int, input().split()))
31
    test_cases.append((N, K, energy))
32
results = moe(test_cases)
33
for res in results:
34
    print(res)",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834188
1387834186,h1032221739,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        left_sum = 0
7
        max_diff = 0
8
        for i in range(n - 1):
9
            left_sum += nums[i]
10
            right_sum = total_sum - left_sum
11
            max_diff = max(max_diff, abs(left_sum - right_sum))
12
        results.append(max_diff)
13
    return results
14
15
16
t = int(input())
17
test_cases = []
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    test_cases.append((n, nums))
22
23
results = max_absolute_difference(test_cases)
24
for res in results:
25
    print(res)",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834186
1387834183,h1032221495,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        # Check if equalization is possible
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target_energy = total_energy // N
16
        operations = 0
17
        current_diff = 0
18
19
        for i in range(N):
20
            diff = energy[i] - target_energy
21
            current_diff += diff
22
23
            # If the current difference is not divisible by K, it's impossible to equalize
24
            if current_diff % K != 0:
25
                results.append(-1)
26
                break
27
28
            # Increment operations by the absolute value of current difference divided by K
29
            operations += abs(current_diff) // K
30
        else:
31
            results.append(operations)
32
33
    return results
34
35
# Input reading
36
T = int(input())
37
test_cases = []
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append(((N, K), energy))
42
43
# Solve and output results
44
results = minimum_operations_to_equalize(T, test_cases)
45
for result in results:
46
    print(result)",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834183
1387834179,h1032221701,unknown,unknown,"1
import sys
2
3
def max_absolute_difference(nums):
4
    """"""
5
    Calculates the maximum absolute difference between the sums of two contiguous subarrays.
6
7
    Args:
8
      nums: A list of integers.
9
10
    Returns:
11
      The maximum absolute difference.
12
    """"""
13
14
    n = len(nums)
15
    prefix_sum = [0] * (n + 1)
16
17
    # Calculate prefix sum
18
    for i in range(1, n + 1):
19
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
20
21
    max_diff = 0
22
    for i in range(1, n):
23
        left_sum = prefix_sum[i]
24
        right_sum = prefix_sum[n] - left_sum
25
        max_diff = max(max_diff, abs(left_sum - right_sum))
26
27
    return max_diff
28
29
# Get input using sys.stdin.read()
30
input_data = sys.stdin.read().strip()
31
32
if input_data:  # Ensure input is not empty
33
    lines = input_data.splitlines()
34
    t = int(lines[0])  # Number of test cases
35
    results = []
36
37
    idx = 1
38
    for _ in range(t):
39
        n = int(lines[idx])  # Array size
40
        nums = list(map(int, lines[idx + 1].split()))  # Array elements
41
        results.append(max_absolute_difference(nums))
42
        idx += 2
43
44
    # Output all results
45
    for res in results:
46
        print(res)
47",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834179
1387834180,gupta_aniket0408,unknown,unknown,"1
T = int(input())
2
3
for _ in range(T):
4
    5
    n = int(input())
6
    arr = list(map(int,input().split()))
7
    8
    9
10
    prefix = [1] * n
11
    suffix = [1] * n
12
    result = [1] * n
13
14
    for i in range(1, n):
15
        prefix[i] = prefix[i - 1] * arr[i - 1]
16
17
    for i in range(n - 2, -1, -1):
18
        suffix[i] = suffix[i + 1] * arr[i + 1]
19
20
    for i in range(n):
21
        result[i] = prefix[i] * suffix[i]
22
23
    print(*result)
24",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834180
1387834181,goswamyashutosh9,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
    for i in range(T):
4
        N, K = test_cases[i][0]
5
        energy = test_cases[i][1]
6
        7
        total_energy = sum(energy)
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
        12
        target_energy = total_energy // N
13
        operations = 0
14
        for j in range(N):
15
            if energy[j] > target_energy:
16
                operations += (energy[j] - target_energy) // K
17
        18
        results.append(operations)
19
    20
    return results
21
22
# Sample Input
23
T = 3
24
test_cases = [
25
    [(3, 2), [4, 4, 4]],
26
    [(3, 1), [5, 3, 4]],
27
    [(4, 3), [5, 5, 5, 6]]
28
]
29
30
# Function Call
31
results = min_operations_to_equalize_energy(T, test_cases)
32
for result in results:
33
    print(result)
34",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834181
1387834176,singhark94,unknown,unknown,"1
def moe(test_cases):
2
    results = []
3
4
    for t in range(len(test_cases)):
5
        N, K, energy = test_cases[t]
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // N
12
        operations = 0
13
        balance = 0  
14
        for i in range(N):
15
            balance += energy[i] - target
16
            if balance % K != 0:
17
                operations = -1
18
                break
19
            operations += abs(balance) // K
20
        21
        results.append(operations if operations != -1 else -1)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    N, K = map(int, input().split())
30
    energy = list(map(int, input().split()))
31
    test_cases.append((N, K, energy))
32
results = moe(test_cases)
33
for res in results:
34
    print(res)",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834176
1387834178,h1032221013,unknown,unknown,"1
def max_subarray_difference(n, nums):
2
    max_diff = float('-inf')
3
    prefix_sum = [0] * (n + 1)
4
    for i in range(n):
5
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
6
    for i in range(1, n):
7
        left_sum = prefix_sum[i]
8
        right_sum = prefix_sum[n] - prefix_sum[i]
9
        curr_diff = abs(left_sum - right_sum)
10
        max_diff = max(max_diff, curr_diff)
11
    return max_diff
12
13
def main():
14
    t = int(input())
15
    for _ in range(t):
16
        n = int(input())
17
        nums = list(map(int, input().split()))
18
        result = max_subarray_difference(n, nums)
19
        print(result)
20
21
if __name__ == ""__main__"":
22
    main()
23",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834178
1387834177,smeetadeshra,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for test in test_cases:
4
        n, nums = test
5
        prefix_sum = [0] * n
6
        prefix_sum[0] = nums[0]
7
        for i in range(1, n):
8
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
9
        10
        total_sum = prefix_sum[-1]
11
        max_diff = 0
12
        for i in range(n - 1):
13
            sum1 = prefix_sum[i]  # Sum of the first subarray
14
            sum2 = total_sum - sum1  # Sum of the second subarray
15
            max_diff = max(max_diff, abs(sum1 - sum2))
16
        17
        results.append(max_diff)
18
    19
    return results
20
t = int(input())
21
test_cases = []
22
for _ in range(t):
23
    n = int(input())
24
    nums = list(map(int, input().split()))
25
    test_cases.append((n, nums))
26
output1 = max_absolute_difference(t, test_cases)
27
for res in output1:
28
    print(res)
29",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834177
1387834171,ag9867603762,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
4
    for _ in range(test_cases):
5
        n = int(raw_input())
6
        nums = list(map(int, raw_input().split()))
7
        max_diff = 0
8
        prefix_sum = 0
9
        total_sum = sum(nums)
10
        for i in range(n - 1):
11
            prefix_sum += nums[i]
12
            suffix_sum = total_sum - prefix_sum
13
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
14
15
        results.append(max_diff)
16
    for res in results:
17
        print(res)
18
T = int(raw_input())
19
max_absolute_difference(T)
20",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834171
1387834174,ranegayatri625,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        left_sum = 0
7
        max_diff = 0
8
        for i in range(n - 1):
9
            left_sum += nums[i]
10
            right_sum = total_sum - left_sum
11
            max_diff = max(max_diff, abs(left_sum - right_sum))
12
        results.append(max_diff)
13
    return results
14
15
16
t = int(input())
17
test_cases = []
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    test_cases.append((n, nums))
22
23
results = max_absolute_difference(test_cases)
24
for res in results:
25
    print(res)",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834174
1387834175,akshitha_ssays,unknown,unknown,"1
def min_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
    4
    for test_case in test_cases:
5
        N, K = test_case[0], test_case[1]
6
        energies = test_case[2]
7
        8
        total_energy = sum(energies)
9
        10
        # Check if total energy is divisible by N
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target_energy = total_energy // N
16
        operations = 0
17
        balance = 0
18
        19
        # Process each station
20
        for i in range(N):
21
            # Calculate the current difference from the target
22
            diff = energies[i] - target_energy
23
            balance += diff
24
            25
            # We need to balance this difference by transferring multiples of K
26
            if balance % K != 0:
27
                results.append(-1)
28
                break
29
            operations += abs(balance) // K
30
        31
        else:
32
            results.append(operations)
33
    34
    return results
35
36
# Input processing
37
t = int(input())  # number of test cases
38
test_cases = []
39
for _ in range(t):
40
    N, K = map(int, input().split())  # number of stations and units of energy that can be transferred in one operation
41
    energies = list(map(int, input().split()))  # energy at each station
42
    test_cases.append((N, K, energies))
43
44
# Call function and print results
45
results = min_operations_to_equalize_energy(t, test_cases)
46
for result in results:
47
    print(result)",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834175
1387834169,gusingevivek,unknown,unknown,"1
def max_subarray_difference(n, nums):
2
    """"""
3
    Calculate maximum absolute difference between sums of two contiguous subarrays
4
    5
    Args:
6
        n (int): Length of array
7
        nums (list): Input array of integers
8
        9
    Returns:
10
        int: Maximum absolute difference possible
11
    """"""
12
    # We need to try all possible partitions
13
    # For each index i, we'll compare sum of elements before and after i
14
    max_diff = float('-inf')
15
    16
    # Calculate prefix sums for efficient subarray sum calculation
17
    prefix_sum = [0] * (n + 1)
18
    for i in range(n):
19
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
20
    21
    # Try all possible partitions
22
    # We need at least one element in each partition
23
    for i in range(1, n):
24
        # Left subarray sum: from index 0 to i-1
25
        left_sum = prefix_sum[i]
26
        27
        # Right subarray sum: from index i to n-1
28
        right_sum = prefix_sum[n] - prefix_sum[i]
29
        30
        # Calculate absolute difference
31
        curr_diff = abs(left_sum - right_sum)
32
        33
        # Update maximum difference if current difference is larger
34
        max_diff = max(max_diff, curr_diff)
35
    36
    return max_diff
37
38
def main():
39
    # Read number of test cases
40
    t = int(input())
41
    42
    # Process each test case
43
    for _ in range(t):
44
        # Read array size
45
        n = int(input())
46
        47
        # Read array elements
48
        nums = list(map(int, input().split()))
49
        50
        # Calculate and print result
51
        result = max_subarray_difference(n, nums)
52
        print(result)
53
54
if __name__ == ""__main__"":
55
    main()",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834169
1387834167,tejasvikhairnar,unknown,unknown,"1
def max_absolute_difference(nums,n):
2
    total_sum = sum(nums)
3
    left_sum = 0
4
    max_diff = 0
5
    6
    for i in range(n - 1):
7
        left_sum += nums[i]
8
        right_sum = total_sum - left_sum
9
        10
        max_diff = max(max_diff,abs(left_sum - right_sum))
11
    return max_diff
12
t = int(input())
13
14
for _ in range(t):
15
    n = int(input())
16
    nums = list(map(int,input().split()))
17
    result = max_absolute_difference(nums,n)
18
    print(result)",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834167
1387834168,snehimehta02,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    prefix_sum = [0] * n
4
    prefix_sum[0] = nums[0]
5
    for i in range(1, n):
6
        prefix_sum[i] = prefix_sum[i - 1] + nums[i]
7
8
    total_sum = prefix_sum[-1] 
9
    max_diff = 0
10
11
    for i in range(n - 1):  
12
        left_sum = prefix_sum[i]
13
        right_sum = total_sum - left_sum
14
        max_diff = max(max_diff, abs(left_sum - right_sum))
15
16
    return max_diff
17
18
def main():
19
    t = int(input())  
20
    results = []
21
22
    for _ in range(t):
23
        n = int(input())  
24
        nums = list(map(int, input().split()))  
25
        result = max_absolute_difference(nums)
26
        results.append(result)
27
28
    for result in results:
29
        print(result)
30
31
if __name__ == ""__main__"":
32
    main()
33",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834168
1387834158,h1032221515,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
4
    for _ in range(test_cases):
5
        n, k = map(int, input().split())  # Changed raw_input() to input()
6
        energy = list(map(int, input().split()))  # Converted map to list
7
        total_energy = sum(energy)
8
9
        if total_energy % n != 0:
10
            results.append(-1)
11
            continue
12
13
        target_energy = total_energy // n
14
        imbalance = 0
15
        operations = 0
16
        possible = True
17
        18
        for i in range(n):
19
            imbalance += energy[i] - target_energy
20
            if imbalance % k != 0:  # If imbalance isn't a multiple of k, it isn't possible
21
                results.append(-1)
22
                possible = False
23
                break
24
            operations += abs(imbalance // k)
25
26
        if possible:
27
            results.append(operations)
28
    29
    for res in results:
30
        print(res)
31
32
33
T = int(input())  # Changed raw_input() to input()
34
equalize_energy(T)",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834158
1387834150,pranaytiwariprpk,unknown,unknown,"1
def min_operations_to_equalize_energy(test_cases):
2
    results = []
3
    for N, K, energies in test_cases:
4
        total_energy = sum(energies)
5
        if total_energy % N != 0:
6
            results.append(-1)
7
            continue
8
        9
        target_energy = total_energy // N
10
        operations = 0
11
        current_balance = 0
12
        13
        for energy in energies:
14
            current_balance += (energy - target_energy)
15
            if current_balance % K != 0:
16
                operations = -1
17
                break
18
            operations += abs(current_balance) // K
19
        20
        results.append(operations if operations != -1 else -1)
21
    22
    return results
23
24
try:
25
    T = int(input())
26
except EOFError:
27
    print(""No input provided."")
28
    T = 0
29
30
test_cases = []
31
for _ in range(T):
32
    N, K = map(int, input().split())
33
    energies = list(map(int, input().split()))
34
    test_cases.append((N, K, energies))
35
36
results = min_operations_to_equalize_energy(test_cases)
37
for result in results:
38
    print(result)",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834150
1387834154,kaushal80106,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
void solve() {
6
    int T; // Number of test cases
7
    cin >> T;
8
9
    while (T--) {
10
        int n; // Number of nodes
11
        cin >> n;
12
        13
        vector<int> values(n), result(n);
14
        for (int i = 0; i < n; ++i) {
15
            cin >> values[i];
16
        }
17
        18
        long long ans = 1; // Initialize to 1 for product calculation
19
        for (int i = 0; i < n; i++) {
20
            ans *= values[i];
21
        }
22
        23
        for (int i = 0; i < n; i++) {
24
            result[i] = ans / values[i];
25
        }
26
27
        // Output the result array
28
        for (int i = 0; i < n; i++) {
29
            cout << result[i] << "" "";
30
        }
31
        cout << endl;
32
    }
33
}
34
35
int main() {
36
    ios::sync_with_stdio(false);
37
    cin.tie(nullptr);
38
    solve();
39
    return 0;
40
}",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834154
1387834157,krunalparab777,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    results = []
4
    5
    for _ in range(T):
6
        n = int(input())
7
        values = list(map(int, input().split()))
8
        9
        # Arrays to store prefix and suffix products
10
        prefix = [1] * n
11
        suffix = [1] * n
12
        result = [1] * n
13
        14
        # Calculate prefix products
15
        for i in range(1, n):
16
            prefix[i] = prefix[i - 1] * values[i - 1]
17
        18
        # Calculate suffix products
19
        for i in range(n - 2, -1, -1):
20
            suffix[i] = suffix[i + 1] * values[i + 1]
21
        22
        # Calculate result by multiplying prefix and suffix products
23
        for i in range(n):
24
            result[i] = prefix[i] * suffix[i]
25
        26
        results.append(result)
27
    28
    # Print all results
29
    for res in results:
30
        print("" "".join(map(str, res)))
31
32
# Example usage
33
solve()
34",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834157
1387834143,akashyadv7233,unknown,unknown,"1
function processData(input) {
2
    const lines = input.trim().split(""\n"");
3
    const T = parseInt(lines[0]);
4
    const results = [];
5
    let index = 1;
6
7
    for (let t = 0; t < T; t++) {
8
        const [N, K] = lines[index].split("" "").map(Number);
9
        const energy = lines[index + 1].split("" "").map(Number);
10
        index += 2;
11
12
        const totalEnergy = energy.reduce((sum, e) => sum + e, 0);
13
        if (totalEnergy % N !== 0) {
14
            results.push(-1);
15
            continue;
16
        }
17
18
        const target = totalEnergy / N;
19
        const diff = energy.map(e => e - target);
20
21
        let prefixSum = 0;
22
        let totalOperations = 0;
23
24
        for (let i = 0; i < N; i++) {
25
            prefixSum += diff[i];
26
            totalOperations += Math.abs(prefixSum);
27
        }
28
29
        results.push(totalOperations / K);
30
    }
31
32
    console.log(results.join(""\n""));
33
} 
34
35
process.stdin.resume();
36
process.stdin.setEncoding(""ascii"");
37
_input = """";
38
process.stdin.on(""data"", function (input) {
39
    _input += input;
40
});
41
42
process.stdin.on(""end"", function () {
43
   processData(_input);
44
});
45",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834143
1387834145,h1032221495,unknown,unknown,"1
def product_except_self(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
8
        # Initialize prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
        result = [0] * n
12
13
        # Compute prefix products
14
        for i in range(1, n):
15
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
16
17
        # Compute suffix products
18
        for i in range(n - 2, -1, -1):
19
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
20
21
        # Compute result array
22
        for i in range(n):
23
            result[i] = prefix_products[i] * suffix_products[i]
24
25
        results.append(result)
26
27
    return results
28
29
# Input reading
30
T = int(input())
31
test_cases = []
32
for _ in range(T):
33
    n = int(input())
34
    values = list(map(int, input().split()))
35
    test_cases.append((n, values))
36
37
# Solve and output results
38
results = product_except_self(T, test_cases)
39
for result in results:
40
    print("" "".join(map(str, result)))",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834145
1387834146,ranegayatri625,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        surplus = 0
12
        for i in range(N):
13
            diff = energy[i] - target
14
            surplus += diff
15
            if surplus % K != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(surplus // K)
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
results = minimum_operations(test_cases)
31
for res in results:
32
    print(res)",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834146
1387834140,rugvedkatkade66,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for test in test_cases:
5
        n, nums = test
6
        prefix_sum = [0] * n
7
        prefix_sum[0] = nums[0]
8
        9
        # Calculate prefix sum
10
        for i in range(1, n):
11
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
12
        13
        # Initialize max difference
14
        max_diff = 0
15
        16
        # Iterate through possible partition points
17
        for i in range(n - 1):
18
            sum_left = prefix_sum[i]
19
            sum_right = prefix_sum[-1] - sum_left
20
            max_diff = max(max_diff, abs(sum_left - sum_right))
21
        22
        results.append(max_diff)
23
    24
    return results
25
26
# Input Parsing
27
t = int(input())
28
test_cases = []
29
for _ in range(t):
30
    n = int(input())
31
    nums = list(map(int, input().split()))
32
    test_cases.append((n, nums))
33
34
# Output Results
35
results = max_absolute_difference(t, test_cases)
36
for res in results:
37
    print(res)
38",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834140
1387834138,panoop2005_ap,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */       
8
        Scanner scanner = new Scanner(System.in);
9
        int T = scanner.nextInt(); // Number of test cases
10
11
        while (T-- > 0) {
12
            int n = scanner.nextInt();
13
            int[] values = new int[n];
14
            for (int i = 0; i < n; i++) {
15
                values[i] = scanner.nextInt();
16
            }
17
18
            int[] result = new int[n];
19
20
            int[] prefix = new int[n];
21
            prefix[0] = 1;
22
            for (int i = 1; i < n; i++) {
23
                prefix[i] = prefix[i - 1] * values[i - 1];
24
            }
25
26
            int suffix = 1;
27
            for (int i = n - 1; i >= 0; i--) {
28
                result[i] = prefix[i] * suffix;
29
                suffix *= values[i];
30
            }
31
32
            for (int num : result) {
33
                System.out.print(num + "" "");
34
            }
35
            System.out.println();
36
        }
37
38
        scanner.close();
39
    }
40
}",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834138
1387834139,abhaywadkar2004,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    4
    for _ in range(T):
5
        N, K = map(int, input().split())  # Number of stations and energy transfer units
6
        energy = list(map(int, input().split()))  # Energy levels of stations
7
        8
        total_energy = sum(energy)
9
        10
        # If total energy is not divisible by N, equalization is impossible
11
        if total_energy % N != 0:
12
            print(-1)
13
            continue
14
        15
        target_energy = total_energy // N
16
        surplus = 0
17
        deficit = 0
18
        possible = True
19
        20
        for e in energy:
21
            diff = e - target_energy
22
            if diff % K != 0:  # If the difference is not divisible by K, it's impossible
23
                possible = False
24
                break
25
            if diff > 0:
26
                surplus += diff // K  # Accumulate surplus units
27
            elif diff < 0:
28
                deficit -= diff // K  # Accumulate deficit units
29
        30
        # Check if it's possible to balance surplus and deficit
31
        if not possible or surplus != deficit:
32
            print(-1)
33
        else:
34
            print(surplus)  # Minimum operations needed
35
36
# Input and execution
37
if __name__ == ""__main__"":
38
    solve()
39",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834139
1387834137,h1032220720,unknown,unknown,"1
def solve():
2
    T = int(input())  # Read number of test cases
3
    4
    for _ in range(T):
5
        n = int(input())  # Read the number of nodes (size of array)
6
        values = list(map(int, input().split()))  # Read the array values
7
        8
        result = [1] * n  # Initialize result array with 1s
9
        10
        # Calculate the prefix product
11
        prefix_product = 1
12
        for i in range(n):
13
            result[i] *= prefix_product
14
            prefix_product *= values[i]
15
        16
        # Calculate the suffix product and update the result array
17
        suffix_product = 1
18
        for i in range(n - 1, -1, -1):
19
            result[i] *= suffix_product
20
            suffix_product *= values[i]
21
        22
        # Output the result for this test case
23
        print("" "".join(map(str, result)))
24
25
# Run the function
26
solve()
27
28",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834137
1387834133,dhananjaygaur04,unknown,unknown,"1
def max_absolute_difference(nums):
2
    """"""
3
    Calculates the maximum absolute difference between sums of two contiguous subarrays.
4
5
    Args:
6
        nums: A list of integers.
7
8
    Returns:
9
        The maximum absolute difference between the sums of two subarrays.
10
    """"""
11
12
    n = len(nums)
13
    prefix_sum = [0] * (n + 1)
14
15
    # Calculate prefix sums
16
    for i in range(1, n + 1):
17
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
18
19
    max_diff = 0
20
    for i in range(1, n):
21
        left_sum = prefix_sum[i]
22
        right_sum = prefix_sum[n] - prefix_sum[i]
23
        max_diff = max(max_diff, abs(left_sum - right_sum))
24
25
    return max_diff
26
27
if __name__ == ""__main__"":
28
    t = int(input())
29
    for _ in range(t):
30
        n = int(input())
31
        nums = list(map(int, input().split()))
32
        result = max_absolute_difference(nums)
33
        print(result)",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834133
1387834136,syedtahami123,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834136
1387834134,Amanpal3546,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
5
using namespace std;
6
7
void maxAbsoluteDifference(vector<int>& nums) {
8
    int n = nums.size();
9
    vector<int> prefixSum(n, 0);
10
11
    // Compute prefix sum
12
    prefixSum[0] = nums[0];
13
    for (int i = 1; i < n; i++) {
14
        prefixSum[i] = prefixSum[i - 1] + nums[i];
15
    }
16
17
    int totalSum = prefixSum[n - 1];
18
    int maxDiff = 0;
19
20
    // Iterate through possible partitions
21
    for (int i = 0; i < n - 1; i++) {
22
        int sumLeft = prefixSum[i];
23
        int sumRight = totalSum - sumLeft;
24
        maxDiff = max(maxDiff, abs(sumLeft - sumRight));
25
    }
26
27
    cout << maxDiff << endl;
28
}
29
30
int main() {
31
    int t;
32
    cin >> t;
33
    while (t--) {
34
        int n;
35
        cin >> n;
36
        vector<int> nums(n);
37
        for (int i = 0; i < n; i++) {
38
            cin >> nums[i];
39
        }
40
        maxAbsoluteDifference(nums);
41
    }
42
    return 0;
43
}",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834134
1387834127,yashdubeyenter15,unknown,unknown,"1
2
def min_operations_to_equalize(N, K, energy):
3
    # Calculate total energy and target energy per station
4
    total_energy = sum(energy)
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target = total_energy // N
9
    10
    # If already equalized
11
    if all(x == target for x in energy):
12
        return 0
13
    14
    # Check if equalization is possible and count required operations
15
    operations = 0
16
    curr_energy = energy.copy()  # Work with a copy to simulate transfers
17
    18
    # First check if it's possible
19
    for i in range(N):
20
        diff = curr_energy[i] - target
21
        if abs(diff) % K != 0:
22
            return -1
23
            24
    # Count operations
25
    for i in range(N):
26
        if curr_energy[i] != target:
27
            diff = curr_energy[i] - target
28
            if diff > 0:
29
                # Transfer excess to next station
30
                next_station = (i + 1) % N
31
                curr_energy[next_station] += diff
32
                curr_energy[i] = target
33
                operations += diff // K
34
    35
    return operations
36
37
def main():
38
    T = int(input().strip())
39
    for _ in range(T):
40
        N, K = map(int, input().strip().split())
41
        energy = list(map(int, input().strip().split()))
42
        print(min_operations_to_equalize(N, K, energy))
43
44
if __name__ == ""__main__"":
45
    main()",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834127
1387834129,h1032220685,unknown,unknown,"1
def maximum_absolute_difference(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, nums = case['n'], case['nums']
6
7
        # Compute the prefix sum array
8
        prefix_sum = [0] * n
9
        prefix_sum[0] = nums[0]
10
        for i in range(1, n):
11
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
12
13
        # Total sum of the array
14
        total_sum = prefix_sum[-1]
15
16
        # Find the maximum absolute difference
17
        max_abs_diff = 0
18
        for i in range(1, n):
19
            sum_left = prefix_sum[i - 1]
20
            sum_right = total_sum - sum_left
21
            max_abs_diff = max(max_abs_diff, abs(sum_left - sum_right))
22
23
        results.append(max_abs_diff)
24
25
    return results
26
27
# Input parsing
28
def parse_input():
29
    t = int(input())
30
    test_cases = []
31
32
    for _ in range(t):
33
        n = int(input())
34
        nums = list(map(int, input().split()))
35
        test_cases.append({""n"": n, ""nums"": nums})
36
37
    return test_cases
38
39
# Output results
40
def main():
41
    test_cases = parse_input()
42
    results = maximum_absolute_difference(test_cases)
43
    for res in results:
44
        print(res)
45
46
if __name__ == ""__main__"":
47
    main()
48",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834129
1387834131,nikhiljaiswal061,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for n, nums in test_cases:
4
        left_sum = [0] * n
5
        right_sum = [0] * n
6
7
        left_sum[0] = nums[0]
8
        for i in range(1, n):
9
            left_sum[i] = left_sum[i - 1] + nums[i]
10
11
        right_sum[n - 1] = nums[n - 1]
12
        for i in range(n - 2, -1, -1):
13
            right_sum[i] = right_sum[i + 1] + nums[i]
14
15
        max_diff = 0
16
        for i in range(n - 1):
17
            max_diff = max(max_diff, abs(left_sum[i] - right_sum[i + 1]))
18
19
        results.append(max_diff)
20
21
    return results
22
23
t = int(input())
24
test_cases = [(int(input()), list(map(int, input().split()))) for _ in range(t)]
25
results = max_absolute_difference(test_cases)
26
for result in results:
27
    print(result)",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834131
1387834126,ritikalath2004,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def max_absolute_difference(test_cases):
3
4
    results = []
5
6
    for n, nums in test_cases:
7
8
        prefix_sum = 0
9
10
        total_sum = sum(nums)
11
12
        max_diff = 0
13
14
        for i in range(n - 1):
15
16
            prefix_sum += nums[i]
17
18
            suffix_sum = total_sum - prefix_sum
19
20
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
21
22
        results.append(max_diff)
23
24
    return results
25
26
# Main function to handle input and output
27
28
def main():
29
30
    T = int(input())
31
32
    test_cases = []
33
34
    for _ in range(T):
35
36
        n = int(input())
37
38
        nums = list(map(int, input().split()))
39
40
        test_cases.append((n, nums))
41
42
    results = max_absolute_difference(test_cases)
43
44
    for res in results:
45
46
        print(res)
47
48
if __name__ == ""__main__"":
49
50
    main()
51
52
53
54
55
56
57
58
59",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834126
1387834117,ravislprajapati,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K, energy = case
6
        total_energy = sum(energy)
7
        8
        # If total energy cannot be evenly distributed
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        balance = 0  # Track energy flow
15
        operations = 0
16
        17
        for i in range(N):
18
            diff = energy[i] - target  # Calculate excess or deficit
19
            balance += diff  # Track the running balance
20
            21
            # Since we can only transfer exactly K units
22
            if balance % K != 0:
23
                results.append(-1)
24
                break
25
            26
            operations += abs(balance) // K  # Count required moves
27
        else:
28
            results.append(operations)
29
    30
    return results
31
32
# Taking input from user
33
T = int(input())
34
test_cases = []
35
for _ in range(T):
36
    N, K = map(int, input().split())
37
    energy = list(map(int, input().split()))
38
    test_cases.append((N, K, energy))
39
40
# Printing results
41
for result in min_operations_to_equalize_energy(T, test_cases):
42
    print(result)
43",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834117
1387834120,ambujbaranwal,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
3
import sys
4
5
input = sys.stdin.read
6
data = input().split()
7
idx = 0
8
T = int(data[idx])
9
idx += 1
10
for _ in range(T):
11
    N = int(data[idx])
12
    K = int(data[idx + 1])
13
    idx += 2
14
15
    arr = list(map(int, data[idx:idx + N]))
16
    idx += N
17
18
    sum_energy = sum(arr)
19
    if sum_energy % N != 0:
20
        print(-1)
21
        continue
22
    target = sum_energy // N
23
24
    possible = True
25
    delta = []
26
    for num in arr:
27
        diff = num - target
28
        if diff % K != 0:
29
            possible = False
30
        delta.append(diff // K)
31
32
    if not possible:
33
        print(-1)
34
        continue
35
36
37
    s = [0]
38
    current_sum = 0
39
    for i in range(1, N):
40
        current_sum += delta[i]
41
        s.append(current_sum)
42
43
    s.sort()
44
    median = s[len(s) // 2]
45
46
47
    total = 0
48
    for num in s:
49
        total += abs(num - median)
50
    print(total)
51
52
53
54",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834120
1387834122,samadshaikh22005,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
void solve() {
7
    int T;
8
    cin >> T;
9
    10
    while (T--) {
11
        int N, K;
12
        cin >> N >> K;
13
        vector<int> energy(N);
14
        15
        int sum = 0;
16
        for (int i = 0; i < N; i++) {
17
            cin >> energy[i];
18
            sum += energy[i];
19
        }
20
        21
        if (sum % N != 0) {
22
            cout << -1 << endl;
23
            continue;
24
        }
25
        26
        int target = sum / N;
27
        int operations = 0;
28
        int balance = 0;
29
        30
        for (int i = 0; i < N; i++) {
31
            balance += energy[i] - target;
32
            // Only add to operations if the balance is not zero
33
            if (abs(balance) % K != 0) {
34
                operations = -1;
35
                break;
36
            }
37
            operations += abs(balance) / K;
38
        }
39
        40
        // If no operations needed (all stations already have the same energy)
41
        if (operations == 0 && balance == 0) {
42
            cout << 0 << endl;
43
        } else {
44
            cout << operations << endl;
45
        }
46
    }
47
}
48
49
int main() {
50
    solve();
51
    return 0;
52
}
53",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834122
1387834115,67_harshit_pras1,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
using namespace std;
5
6
int main() {
7
    int t;
8
    cin >> t;
9
    10
    while (t--) {
11
        int n, k;
12
        cin >> n >> k;
13
        14
        vector<long long> energy(n);
15
        long long total = 0;
16
        17
        for(int i = 0; i < n; i++) {
18
            cin >> energy[i];
19
            total += energy[i];
20
        }
21
        22
        if (total % n != 0) {
23
            cout << -1 << endl;
24
            continue;
25
        }
26
        27
        long long target = total / n;
28
        long long operations = 0;
29
        bool possible = true;
30
        31
        for(int i = 0; i < n && possible; i++) {
32
            long long diff = energy[i] - target;
33
            34
            if (diff == 0) continue;
35
            36
            if (abs(diff) % k != 0) {
37
                possible = false;
38
                break;
39
            }
40
            41
            operations += abs(diff) / k;
42
            43
            if (i == n-1) {
44
                if (diff != 0) possible = false;
45
            } else {
46
                energy[i+1] += diff;
47
            }
48
        }
49
        50
        if (!possible) {
51
            cout << -1 << endl;
52
        } else {
53
            cout << operations << endl;
54
        }
55
    }
56
    57
    return 0;
58
}",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834115
1387834113,3277kunaljain,unknown,unknown,"1
t = int(input())  
2
for _ in range(t):
3
    n = int(input()) 
4
    nums = list(map(int, input().split()))  
5
    total_sum = sum(nums)  
6
    prefix_sum = 0 
7
    max_diff = 0 
8
    for i in range(n - 1):
9
        prefix_sum += nums[i]  
10
        suffix_sum = total_sum - prefix_sum 
11
        max_diff = max(max_diff, abs(prefix_sum - suffix_sum)) 
12
    print(max_diff)",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834113
1387834116,siddhantpal9082,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        prefix_sum = [0] * n
6
        prefix_sum[0] = nums[0]
7
        for i in range(1, n):
8
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
9
        10
        total_sum = prefix_sum[-1]
11
        max_diff = 0
12
13
        for i in range(n - 1):
14
            left_sum = prefix_sum[i]
15
            right_sum = total_sum - left_sum
16
            max_diff = max(max_diff, abs(left_sum - right_sum))
17
        18
        results.append(max_diff)
19
    20
    return results
21
22
23
if __name__ == ""__main__"":
24
    t = int(input())
25
    test_cases = []
26
    for _ in range(t):
27
        n = int(input())
28
        nums = list(map(int, input().split()))
29
        test_cases.append((n, nums))
30
    31
    results = max_absolute_difference(t, test_cases)
32
    for res in results:
33
        print(res)
34",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834116
1387834106,h1032221029,unknown,unknown,"1
def max_subarray_difference(nums):
2
    n = len(nums)
3
   4
    prefix_sum = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
7
    8
    max_diff = float('-inf')
9
 10
    for i in range(1, n):
11
     12
        left_sum = prefix_sum[i] 
13
        right_sum = prefix_sum[n] - prefix_sum[i]
14
        curr_diff = abs(left_sum - right_sum)
15
        max_diff = max(max_diff, curr_diff)
16
    17
    return max_diff
18
19
20
t = int(input())
21
22
23
for _ in range(t):
24
  25
    n = int(input())
26
    27
  28
    nums = list(map(int, input().split()))
29
    30
   31
    result = max_subarray_difference(nums)
32
    print(result)",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834106
1387834109,ranegayatri625,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        result = [1] * n
6
        prefix = 1
7
        for i in range(n):
8
            result[i] = prefix
9
            prefix *= values[i]
10
        suffix = 1
11
        for i in range(n - 1, -1, -1):
12
            result[i] *= suffix
13
            suffix *= values[i]
14
        results.append(result)
15
    return results
16
17
t = int(input())
18
test_cases = []
19
for _ in range(t):
20
    n = int(input())
21
    values = list(map(int, input().split()))
22
    test_cases.append((n, values))
23
24
results = product_except_self(test_cases)
25
for result in results:
26
    print("" "".join(map(str, result)))",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834109
1387834111,codedot,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
 n,k=map(int,input().split())
4
 energy=list(map(int,input().split()))
5
 total_energy=sum(energy)
6
 if total_energy%n!=0:
7
  print(-1)
8
  continue
9
 target=total_energy//n
10
 operations=0
11
 for i in range(n):
12
  diff=energy[i]-target
13
  if diff>0:
14
   operations+=diff//k
15
 print(operations)
16",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834111
1387834104,parmesh214,unknown,unknown,"1
def min_operations(n, k, energy):
2
    total_energy = sum(energy)
3
    if total_energy % n != 0:
4
        return -1
5
6
    target_energy = total_energy // n
7
    operations = 0
8
9
    for i in range(n):
10
        diff = energy[i] - target_energy
11
        if diff > 0:
12
            operations += (diff + k - 1) // k
13
14
    return operations
15
16
t = int(input())
17
for _ in range(t):
18
    n, k = map(int, input().split())
19
    energy = list(map(int, input().split()))
20
    result = min_operations(n, k, energy)
21
    print(result)
22",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834104
1387834099,syedtahami123,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834099
1387834098,23jyotigaud,unknown,unknown,"1
def solve():
2
    t = int(input())
3
    for _ in range(t):
4
        n = int(input())
5
        nums = list(map(int, input().split()))
6
        7
        total_sum = sum(nums)
8
        left_sum = 0
9
        max_difference = 0
10
        11
        for i in range(n - 1):
12
            left_sum += nums[i]
13
            right_sum = total_sum - left_sum
14
            max_difference = max(max_difference, abs(left_sum - right_sum))
15
        16
        print(max_difference)
17
18
if __name__ == ""__main__"":
19
    solve()",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834098
1387834102,kamblesamruddhi2,unknown,unknown,"1
t = int(input())  
2
3
for _ in range(t):
4
    n = int(input())  
5
    nums = list(map(int, input().split())) 
6
    total_sum = sum(nums)  
7
    prefix_sum = 0 
8
    max_difference = 0  
9
10
    11
    for i in range(n - 1):
12
        prefix_sum += nums[i]  
13
        suffix_sum = total_sum - prefix_sum  
14
        max_difference = max(max_difference, abs(prefix_sum - suffix_sum))  
15
16
    print(max_difference)
17",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834102
1387834095,h1032221013,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    if len(set(energy)) == 1:
3
        return 0
4
    total = sum(energy)
5
    if total % N != 0:
6
        return -1
7
    target = total // N
8
    diffs = [(x - target) for x in energy]
9
    if any(abs(d) % K != 0 for d in diffs):
10
        return -1
11
    operations = 0
12
    running_diff = 0
13
    for i in range(N-1):
14
        running_diff += diffs[i]
15
        if running_diff != 0:
16
            if abs(running_diff) % K != 0:
17
                return -1
18
            operations += abs(running_diff) // K
19
    running_diff += diffs[N-1]
20
    if running_diff != 0:
21
        return -1
22
    return operations
23
24
def main():
25
    T = int(input())
26
    for _ in range(T):
27
        N, K = map(int, input().split())
28
        energy = list(map(int, input().split()))
29
        result = min_operations_to_equalize(N, K, energy)
30
        print(result)
31
32
if __name__ == ""__main__"":
33
    main()
34",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834095
1387834097,vivaankotian1,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
    total_sum = sum(nums)
3
    left_sum = 0
4
    max_diff = float('-inf')
5
6
    # Iterate through the array to find the max absolute difference
7
    for i in range(n - 1):  # Partition at each index
8
        left_sum += nums[i]
9
        right_sum = total_sum - left_sum
10
        max_diff = max(max_diff, abs(left_sum - right_sum))
11
    12
    return max_diff
13
14
# Read input
15
T = int(input())  # Number of test cases
16
for _ in range(T):
17
    n = int(input())  # Size of array
18
    nums = list(map(int, input().split()))  # Input array
19
20
    # Compute and print result
21
    print(max_absolute_difference(n, nums))",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834097
1387834096,nikhiljaiswal061,unknown,unknown,"1
def min_operations_to_equalize_energy(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
11
        target_energy = total_energy // N
12
        balance = 0
13
        operations = 0
14
15
        for i in range(N):
16
            balance += energy[i] - target_energy
17
            if balance % K != 0:
18
                results.append(-1)
19
                break
20
            operations += abs(balance // K)
21
        else:
22
            results.append(operations)
23
24
    return results
25
26
T = int(input())
27
test_cases = [(tuple(map(int, input().split())), list(map(int, input().split()))) for _ in range(T)]
28
results = min_operations_to_equalize_energy([(N, K, energy) for (N, K), energy in test_cases])
29
for result in results:
30
    print(result)",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834096
1387834091,ysaurabh_abd,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
void solve() {
6
    int T; // Number of test cases
7
    cin >> T;
8
9
    while (T--) {
10
        int n; // Number of nodes
11
        cin >> n;
12
        13
        vector<int> values(n), result(n);
14
        for (int i = 0; i < n; ++i) {
15
            cin >> values[i];
16
        }
17
        18
        long long ans = 1; // Initialize to 1 for product calculation
19
        for (int i = 0; i < n; i++) {
20
            ans *= values[i];
21
        }
22
        23
        for (int i = 0; i < n; i++) {
24
            result[i] = ans / values[i];
25
        }
26
27
        // Output the result array
28
        for (int i = 0; i < n; i++) {
29
            cout << result[i] << "" "";
30
        }
31
        cout << endl;
32
    }
33
}
34
35
int main() {
36
    ios::sync_with_stdio(false);
37
    cin.tie(nullptr);
38
    solve();
39
    return 0;
40
}",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834091
1387834090,h1032220872,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <cmath>
5
using namespace std;
6
7
// Function to solve each test case
8
int min_operations_to_equalize(int N, int K, vector<int>& energy) {
9
    long long total_energy = accumulate(energy.begin(), energy.end(), 0LL);
10
11
    // Check if it's possible to equalize
12
    if (total_energy % N != 0) {
13
        return -1;
14
    }
15
16
    int target = total_energy / N;
17
    long long surplus = 0, deficit = 0;
18
19
    for (int i = 0; i < N; ++i) {
20
        if (energy[i] > target) {
21
            surplus += (energy[i] - target);
22
        } else {
23
            deficit += (target - energy[i]);
24
        }
25
    }
26
27
    // Check if surplus equals deficit and if it's divisible by K
28
    if (surplus != deficit || surplus % K != 0) {
29
        return -1;
30
    }
31
32
    return surplus / K;
33
}
34
35
int main() {
36
    int T;
37
    cin >> T;
38
39
    while (T--) {
40
        int N, K;
41
        cin >> N >> K;
42
        43
        vector<int> energy(N);
44
        for (int i = 0; i < N; ++i) {
45
            cin >> energy[i];
46
        }
47
48
        int result = min_operations_to_equalize(N, K, energy);
49
        cout << result << endl;
50
    }
51
52
    return 0;
53
}
54",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834090
1387834093,h1032221373,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt(); // Number of test cases
8
9
        while (t-- > 0) {
10
            int n = scanner.nextInt(); // Size of the array
11
            int[] nums = new int[n];
12
            13
            // Read the array
14
            for (int i = 0; i < n; i++) {
15
                nums[i] = scanner.nextInt();
16
            }
17
            18
            System.out.println(maxAbsoluteDifference(nums));
19
        }
20
        21
        scanner.close();
22
    }
23
24
    private static int maxAbsoluteDifference(int[] nums) {
25
        int n = nums.length;
26
        long totalSum = 0;
27
28
        // Calculate total sum of the array
29
        for (int num : nums) {
30
            totalSum += num;
31
        }
32
33
        long prefixSum = 0;
34
        long maxDiff = 0;
35
36
        // Iterate through the array to calculate prefix sums
37
        for (int i = 0; i < n - 1; i++) {
38
            prefixSum += nums[i];
39
            long leftSum = prefixSum;
40
            long rightSum = totalSum - prefixSum;
41
42
            // Calculate the absolute difference
43
            maxDiff = Math.max(maxDiff, Math.abs(leftSum - rightSum));
44
        }
45
46
        return (int) maxDiff;
47
    }
48
}
49",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834093
1387834089,mlal42239,unknown,unknown,"1
def product_array(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
        8
        prefix_product = [1] * n
9
        suffix_product = [1] * n
10
        result = [1] * n
11
        12
        prefix_product[0] = values[0]
13
        for i in range(1, n):
14
            prefix_product[i] = prefix_product[i-1] * values[i]
15
        16
        suffix_product[n-1] = values[n-1]
17
        for i in range(n-2, -1, -1):
18
            suffix_product[i] = suffix_product[i+1] * values[i]
19
        20
        for i in range(n):
21
            if i == 0:
22
                result[i] = suffix_product[1]
23
            elif i == n-1:
24
                result[i] = prefix_product[n-2]
25
            else:
26
                result[i] = prefix_product[i-1] * suffix_product[i+1]
27
        28
        results.append(result)
29
    30
    return results
31
32
T = int(input())
33
test_cases = []
34
35
for _ in range(T):
36
    n = int(input())
37
    values = list(map(int, input().split()))
38
    test_cases.append((n, values))
39
40
results = product_array(T, test_cases)
41
42
for result in results:
43
    print("" "".join(map(str, result)))
44",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834089
1387834082,ktiwari3215,unknown,unknown,"1
def solve():
2
    t = int(input())  # number of test cases
3
    for _ in range(t):
4
        n = int(input())  # size of the array
5
        nums = list(map(int, input().split()))  # the array
6
        7
        # Calculate the total sum of the array
8
        total_sum = sum(nums)
9
        10
        # Variables to track the left sum and maximum absolute difference
11
        left_sum = 0
12
        max_difference = 0
13
        14
        # Iterate to find the maximum absolute difference
15
        for i in range(n - 1):  # We stop at n-1 since we need non-empty right subarray
16
            left_sum += nums[i]
17
            right_sum = total_sum - left_sum
18
            max_difference = max(max_difference, abs(left_sum - right_sum))
19
        20
        print(max_difference)
21
22
# Call the function to solve the problem
23
solve()",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834082
1387834084,damodarryadav,unknown,unknown,"1
#include <iostream>
2
3
#include <vector>
4
5
#include <cmath>
6
7
using namespace std;
8
9
int main() {
10
11
    int T; // Number of test cases
12
13
    cin >> T;
14
15
    while (T--) {
16
17
        int N, K; // Number of stations and energy transfer per operation
18
19
        cin >> N >> K;
20
21
        vector<long long> energy(N);
22
23
        long long totalEnergy = 0;
24
25
        // Input energy of each station
26
27
        for (int i = 0; i < N; ++i) {
28
29
            cin >> energy[i];
30
31
            totalEnergy += energy[i];
32
33
        }
34
35
        // Check if equalization is possible
36
37
        if (totalEnergy % N != 0) {
38
39
            cout << -1 << endl; // Impossible to equalize
40
41
            continue;
42
43
        }
44
45
        long long targetEnergy = totalEnergy / N;
46
47
        long long balance = 0; // Cumulative balance
48
49
        long long operations = 0;
50
51
        bool possible = true;
52
53
        for (int i = 0; i < N; ++i) {
54
55
            // Difference between current energy and target
56
57
            long long diff = energy[i] - targetEnergy;
58
59
            balance += diff; // Maintain cumulative balance
60
61
            62
63
            // If balance cannot be resolved with K, it's impossible
64
65
            if (abs(balance) % K != 0) {
66
67
                possible = false;
68
69
                break;
70
71
            }
72
73
            // Accumulate total operations needed
74
75
            operations += abs(balance) / K;
76
77
        }
78
79
        if (possible) {
80
81
            cout << operations << endl;
82
83
        } else {
84
85
            cout << -1 << endl;
86
87
        }
88
89
    }
90
91
    return 0;
92
93
}",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834084
1387834083,gusingevivek,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    """"""
3
    Calculate minimum operations needed to equalize energy in circular power stations
4
    5
    Args:
6
        N (int): Number of power stations
7
        K (int): Units of energy that can be transferred in one operation
8
        energy (list): Array of energy values for each station
9
        10
    Returns:
11
        int: Minimum number of operations needed, or -1 if impossible
12
    """"""
13
    # Check if already equal
14
    if len(set(energy)) == 1:
15
        return 0
16
        17
    # Calculate total energy and target
18
    total = sum(energy)
19
    if total % N != 0:
20
        return -1
21
    target = total // N
22
    23
    # Compute differences from target
24
    diffs = [(x - target) for x in energy]
25
    26
    # Verify if equalization is possible with given K
27
    if any(abs(d) % K != 0 for d in diffs):
28
        return -1
29
    30
    # Count operations
31
    operations = 0
32
    running_diff = 0
33
    34
    # Count transfers needed for each position except last
35
    for i in range(N-1):
36
        running_diff += diffs[i]
37
        if running_diff != 0:
38
            if abs(running_diff) % K != 0:
39
                return -1
40
            operations += abs(running_diff) // K
41
    42
    # Check if final position balances out
43
    running_diff += diffs[N-1]
44
    if running_diff != 0:
45
        return -1
46
        47
    return operations
48
49
def main():
50
    T = int(input())
51
    for _ in range(T):
52
        N, K = map(int, input().split())
53
        energy = list(map(int, input().split()))
54
        result = min_operations_to_equalize(N, K, energy)
55
        print(result)
56
57
if __name__ == ""__main__"":
58
    main()",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834083
1387834078,singhark94,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <tuple>
4
#include <numeric>
5
#include <cmath>
6
using namespace std;
7
8
vector<int> minOperations(vector<tuple<int, int, vector<int>>>& test_cases) {
9
    vector<int> results;
10
11
    for (const auto& test_case : test_cases) {
12
        int N, K;
13
        vector<int> energy;
14
        tie(N, K, energy) = test_case;
15
16
        long long total_energy = accumulate(energy.begin(), energy.end(), 0LL);
17
        if (total_energy % N != 0) {
18
            results.push_back(-1);
19
            continue;
20
        }
21
22
        long long target = total_energy / N;
23
        long long operations = 0;
24
        long long balance = 0;
25
        bool possible = true;
26
27
        for (int i = 0; i < N; ++i) {
28
            balance += energy[i] - target;
29
            if (balance % K != 0) {
30
                possible = false;
31
                break;
32
            }
33
            operations += abs(balance) / K;
34
        }
35
36
        results.push_back(possible ? operations : -1);
37
    }
38
39
    return results;
40
}
41
42
int main() {
43
    int T;
44
    cin >> T;
45
    vector<tuple<int, int, vector<int>>> test_cases(T);
46
47
    for (int t = 0; t < T; ++t) {
48
        int N, K;
49
        cin >> N >> K;
50
        vector<int> energy(N);
51
        for (int i = 0; i < N; ++i) {
52
            cin >> energy[i];
53
        }
54
        test_cases[t] = make_tuple(N, K, energy);
55
    }
56
57
    vector<int> results = minOperations(test_cases);
58
    for (int res : results) {
59
        cout << res << endl;
60
    }
61
62
    return 0;
63
}
64
65",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834078
1387834079,ng873042,unknown,unknown,"1
def max_absolute_difference(nums):
2
3
    total_sum = sum(nums)
4
5
    left_sum = 0
6
7
    max_diff = 0
8
9
    # Iterate through possible partition points
10
11
    for i in range(len(nums) - 1):
12
13
        left_sum += nums[i]
14
15
        right_sum = total_sum - left_sum
16
17
        max_diff = max(max_diff, abs(left_sum - right_sum))
18
19
    return max_diff
20
21
# Read input
22
23
T = int(input())  # Number of test cases
24
25
for _ in range(T):
26
27
    N = int(input())  # Array size
28
29
    nums = list(map(int, input().split()))  # Read the array
30
31
    print(max_absolute_difference(nums))  # Print result",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834079
1387834070,h1032220866,unknown,unknown,"1
T = int(input())
2
for i in range(T):
3
    n = int(input())
4
    x = 0
5
    l = list(map(int, input().split()))  
6
    result = [1] * n
7
8
    left_prod = 1
9
    for i in range(n):
10
        result[i] = left_prod
11
        left_prod *= l[i]
12
13
    right_prod = 1
14
    for i in range(n - 1, -1, -1):
15
        result[i] *= right_prod
16
        right_prod *= l[i]
17
18
    print(*result)
19",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834070
1387834073,h1032220179,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
    # Compute the prefix sum array
5
    prefix_sum = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
8
    9
    max_diff = 0
10
    11
    # Iterate through all possible split points
12
    for i in range(1, n):
13
        left_sum = prefix_sum[i]
14
        right_sum = prefix_sum[n] - prefix_sum[i]
15
        current_diff = abs(left_sum - right_sum)
16
        17
        # Update the maximum difference
18
        if current_diff > max_diff:
19
            max_diff = current_diff
20
    21
    return max_diff
22
23
def main():
24
    import sys
25
    input = sys.stdin.read
26
    data = input().split()
27
    28
    idx = 0
29
    t = int(data[idx])  # Number of test cases
30
    idx += 1
31
    32
    for _ in range(t):
33
        n = int(data[idx])  # Size of the array
34
        idx += 1
35
        nums = list(map(int, data[idx:idx + n]))  # Array elements
36
        idx += n
37
        38
        result = max_absolute_difference(nums)
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834073
1387834075,h1032220176,unknown,unknown,"1
def solve():
2
    3
    T = int(raw_input())
4
    5
    for _ in range(T):
6
       7
        n = int(raw_input())
8
      9
        values = map(int, raw_input().split())
10
        11
        12
        result = [1] * n
13
        14
     15
        left_product = 1
16
        for i in range(n):
17
            result[i] *= left_product
18
            left_product *= values[i]
19
        20
        21
        right_product = 1
22
        for i in range(n-1, -1, -1):
23
            result[i] *= right_product
24
            right_product *= values[i]
25
        26
        print "" "".join(map(str, result))
27
28
29
solve()
30",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834075
1387834069,h1032221701,unknown,unknown,"1
import sys
2
3
def minimum_operations_to_equalize_energy(test_cases):
4
    results = []
5
    for n, k, energy in test_cases:
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % n != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // n
14
        balance = 0
15
        operations = 0
16
        possible = True
17
        18
        # Calculate the number of operations
19
        for e in energy:
20
            diff = e - target
21
            if diff % k != 0:
22
                possible = False
23
                break
24
            balance += diff // k
25
            operations += abs(balance)
26
        27
        # Check if balancing is possible
28
        results.append(operations if possible else -1)
29
    30
    return results
31
32
# Input Reading
33
input_data = sys.stdin.read().strip()  # Read all input at once
34
35
if input_data:  # Check if input is provided
36
    lines = input_data.splitlines()  # Split input into lines
37
38
    T = int(lines[0])  # Number of test cases
39
    test_cases = []
40
    index = 1
41
42
    for _ in range(T):
43
        n, k = map(int, lines[index].split())
44
        energy = list(map(int, lines[index + 1].split()))
45
        test_cases.append((n, k, energy))
46
        index += 2
47
48
    # Compute and Output Results
49
    results = minimum_operations_to_equalize_energy(test_cases)
50
    print(""\n"".join(map(str, results)))
51
else:
52
    print(""No input provided."")
53",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834069
1387834062,smeetadeshra,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K = case[0]  
6
        energy = case[1]
7
        total_energy = sum(energy)
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
        target_energy = total_energy // N
12
        operations = 0
13
        imbalance = 0  # Tracks cumulative imbalance
14
        for i in range(N):
15
            imbalance += (energy[i] - target_energy)
16
            if imbalance % K != 0:
17
                results.append(-1)
18
                break
19
            operations += abs(imbalance) // K
20
        else:
21
            results.append(operations)
22
    23
    return results
24
25
if __name__ == ""__main__"":
26
    T = int(input())  # Number of test cases
27
    test_cases = []
28
    29
    for _ in range(T):
30
        N, K = map(int, input().split())  # N = number of stations, K = energy transfer units
31
        energy = list(map(int, input().split()))  # Energy levels of the stations
32
        test_cases.append(((N, K), energy))
33
    34
    results1 = min_operations_to_equalize_energy(T, test_cases)
35
    for result in results1:
36
        print(result)
37",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834062
1387834063,rugvedkatkade66,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
    # Calculate left product array
7
    for i in range(1, n):
8
        left[i] = left[i-1] * arr[i-1]
9
10
    # Calculate right product array
11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * arr[i+1]
13
14
    # Calculate result array
15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
# Get number of test cases
20
t = int(input())
21
22
for _ in range(t):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result)",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834063
1387834064,mlal42239,unknown,unknown,"1
def solve():
2
    T = int(input())  
3
    for _ in range(T):
4
        N, K = map(int, input().split()) 
5
        energy = list(map(int, input().split())) 
6
        7
        total_energy = sum(energy)
8
        9
        10
        if total_energy % N != 0:
11
            print(-1)
12
            continue
13
        14
        target_energy = total_energy // N
15
        operations = 0
16
        current_balance = 0
17
        18
        for i in range(N):
19
            20
            current_balance += energy[i] - target_energy
21
           22
            operations += abs(current_balance) // K
23
            24
            25
            if abs(current_balance) % K != 0:
26
                operations = -1
27
                break
28
        29
        print(operations)
30
31
32
solve()",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834064
1387834053,shruthika2720,unknown,unknown,"1
def min_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
    4
    for test_case in test_cases:
5
        N, K = test_case[0], test_case[1]
6
        energies = test_case[2]
7
        8
        total_energy = sum(energies)
9
        10
        11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target_energy = total_energy // N
16
        operations = 0
17
        balance = 0
18
        19
        20
        for i in range(N):
21
            22
            diff = energies[i] - target_energy
23
            balance += diff
24
            25
           26
            if balance % K != 0:
27
                results.append(-1)
28
                break
29
            operations += abs(balance) // K
30
        31
        else:
32
            results.append(operations)
33
    34
    return results
35
36
37
t = int(input())  
38
test_cases = []
39
for _ in range(t):
40
    N, K = map(int, input().split()) 
41
    energies = list(map(int, input().split()))  
42
    test_cases.append((N, K, energies))
43
44
45
results = min_operations_to_equalize_energy(t, test_cases)
46
for result in results:
47
    print(result)
48",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834053
1387834055,h1032221056,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, nums = case
6
        7
        prefix = [0] * n
8
        suffix = [0] * n
9
        10
        prefix[0] = nums[0]
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] + nums[i]
13
        14
        suffix[-1] = nums[-1]
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] + nums[i]
17
        18
        19
        max_diff = 0
20
        for i in range(n - 1):
21
            left_sum = prefix[i]
22
            right_sum = suffix[i + 1]
23
            max_diff = max(max_diff, abs(left_sum - right_sum))
24
        25
        results.append(max_diff)
26
    27
    return results
28
29
30
31
if __name__ == ""__main__"":
32
    t = int(input())
33
    test_cases = []
34
    for _ in range(t):
35
        n = int(input())
36
        nums = list(map(int, input().split()))
37
        test_cases.append((n, nums))
38
    39
    results = max_absolute_difference(t, test_cases)
40
    for res in results:
41
        print(res)
42",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834055
1387834058,abhaywadkar2004,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
void solve() {
6
    int T;
7
    cin >> T;
8
9
    while (T--) {
10
        int N;
11
        long long K;
12
        cin >> N >> K;
13
14
        vector<long long> energy(N);
15
        long long total_energy = 0;
16
17
        for (auto &e : energy) {
18
            cin >> e;
19
            total_energy += e;
20
        }
21
22
        if (total_energy % N != 0) {
23
            cout << -1 << endl;
24
            continue;
25
        }
26
27
        long long target_energy = total_energy / N;
28
        long long surplus = 0, deficit = 0;
29
30
        bool possible = true;
31
        for (auto e : energy) {
32
            long long diff = e - target_energy;
33
            if (diff % K != 0) {
34
                possible = false;
35
                break;
36
            }
37
38
            if (diff > 0) {
39
                surplus += diff / K; 
40
            } else if (diff < 0) {
41
                deficit -= diff / K; 
42
            }
43
        }
44
45
        if (!possible || surplus != deficit) {
46
            cout << -1 << endl;
47
        } else {
48
            cout << surplus << endl; 
49
        }
50
    }
51
}
52
53
int main() {
54
    ios::sync_with_stdio(false);
55
    cin.tie(nullptr);
56
    solve();
57
    return 0;
58
}
59",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834058
1387834050,h1032221532,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
       11
        for i in range(n - 1):  
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
31
results = max_absolute_difference(test_cases)
32
33
34
for res in results:
35
    print(res)",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834050
1387834051,nikhiljaiswal061,unknown,unknown,"1
def compute_product_excluding_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        total_product = 1
6
        zero_count = values.count(0)
7
8
        if zero_count > 1:
9
            results.append([0] * n)
10
        elif zero_count == 1:
11
            zero_index = values.index(0)
12
            product_except_zero = 1
13
            for i in range(n):
14
                if i != zero_index:
15
                    product_except_zero *= values[i]
16
            result = [0] * n
17
            result[zero_index] = product_except_zero
18
            results.append(result)
19
        else:
20
            for value in values:
21
                total_product *= value
22
            results.append([total_product // value for value in values])
23
24
    return results
25
26
T = int(input())
27
test_cases = [(int(input()), list(map(int, input().split()))) for _ in range(T)]
28
results = compute_product_excluding_self(test_cases)
29
for result in results:
30
    print(*result)",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834051
1387834052,h1032231291,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        try {
7
            Scanner scanner = new Scanner(System.in);
8
            int T = scanner.nextInt();
9
            10
            for (int t = 0; t < T; t++) {
11
                int N = scanner.nextInt();
12
                long K = scanner.nextLong();
13
                14
                long[] energy = new long[N];
15
                for (int i = 0; i < N; i++) {
16
                    energy[i] = scanner.nextLong();
17
                }
18
                19
                System.out.println(minOperationsToEqualize(N, K, energy));
20
            }
21
            scanner.close();
22
        } catch (Exception e) {
23
            return;
24
        }
25
    }
26
    27
    private static long minOperationsToEqualize(int N, long K, long[] energy) {
28
        try {
29
            if (N == 1) return 0;
30
            31
            long total = 0;
32
            boolean allSame = true;
33
            34
            for (int i = 1; i < N; i++) {
35
                if (energy[i] != energy[0]) {
36
                    allSame = false;
37
                    break;
38
                }
39
            }
40
            41
            if (allSame) return 0;
42
            43
            for (long e : energy) {
44
                total += e;
45
            }
46
            47
            if (total % N != 0) {
48
                return -1;
49
            }
50
            51
            long target = total / N;
52
            long[] diffs = new long[N];
53
            54
            for (int i = 0; i < N; i++) {
55
                diffs[i] = energy[i] - target;
56
                if (Math.abs(diffs[i]) % K != 0) {
57
                    return -1;
58
                }
59
            }
60
            61
            long operations = 0;
62
            long runningDiff = 0;
63
            64
            for (int i = 0; i < N - 1; i++) {
65
                runningDiff += diffs[i];
66
                if (runningDiff != 0) {
67
                    if (Math.abs(runningDiff) % K != 0) {
68
                        return -1;
69
                    }
70
                    operations += Math.abs(runningDiff) / K;
71
                }
72
            }
73
            74
            runningDiff += diffs[N-1];
75
            if (runningDiff != 0) {
76
                return -1;
77
            }
78
            79
            return operations;
80
        } catch (Exception e) {
81
            return -1;
82
        }
83
    }
84
}",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834052
1387834049,syedtahami123,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834049
1387834046,amanpandey200521,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        6
        # Compute the total sum of the array
7
        total_sum = sum(nums)
8
        9
        # Initialize variables to track left sum and maximum absolute difference
10
        left_sum = 0
11
        max_diff = 0
12
        13
        # Iterate through the array to calculate maximum absolute difference
14
        for i in range(n - 1):  # We stop at n-1 to ensure non-empty subarrays
15
            left_sum += nums[i]
16
            right_sum = total_sum - left_sum
17
            max_diff = max(max_diff, abs(left_sum - right_sum))
18
        19
        # Store the result for the current test case
20
        results.append(max_diff)
21
    22
    return results
23
24
# Read input
25
t = int(input())
26
test_cases = []
27
for _ in range(t):
28
    n = int(input())
29
    nums = list(map(int, input().split()))
30
    test_cases.append((n, nums))
31
32
# Process test cases
33
results = max_absolute_difference(test_cases)
34
35
# Print output
36
for result in results:
37
    print(result)
38",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834046
1387834048,tiwarishashank14,unknown,unknown,"1
import java.util.Scanner;
2
3
public class MaxAbsDifference {
4
5
    public static void solve() {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();  // Read the number of test cases
8
9
        while (t-- > 0) {
10
            int n = scanner.nextInt();  // Size of the array
11
            int[] nums = new int[n];
12
            long totalSum = 0;
13
14
            // Read the array elements and calculate the total sum
15
            for (int i = 0; i < n; i++) {
16
                nums[i] = scanner.nextInt();
17
                totalSum += nums[i];
18
            }
19
20
            long prefixSum = 0;
21
            long maxDiff = 0;
22
            long minPrefixSum = 0;  // Minimum prefix sum encountered so far
23
            long maxPrefixSum = 0;  // Maximum prefix sum encountered so far
24
25
            // Traverse the array to calculate the maximum absolute difference
26
            for (int i = 0; i < n - 1; i++) {  // We go up to n-1 to ensure two subarrays
27
                prefixSum += nums[i];
28
29
                // Update the max and min prefix sums
30
                maxPrefixSum = Math.max(maxPrefixSum, prefixSum);
31
                minPrefixSum = Math.min(minPrefixSum, prefixSum);
32
33
                // Calculate the absolute difference for this partition
34
                long diff1 = Math.abs(prefixSum - (totalSum - prefixSum));  // Left subarray vs right subarray
35
                long diff2 = Math.abs(totalSum - 2 * prefixSum);  // Reverse the partition
36
37
                // Update the maximum absolute difference
38
                maxDiff = Math.max(maxDiff, Math.max(diff1, diff2));
39
            }
40
41
            // Print the result for this test case
42
            System.out.println(maxDiff);
43
        }
44
        scanner.close();
45
    }
46
47
    public static void main(String[] args) {
48
        solve();  // Call the solve function to process the input and solve the problem
49
    }
50
}
51
52",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834048
1387834047,siddhantpal9082,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][0]
5
        energy = test_cases[t][1]
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        operations = 0
15
        balance = 0
16
        17
        for i in range(N):
18
            balance += energy[i] - target
19
            if balance % K != 0:
20
                results.append(-1)
21
                break
22
            operations += abs(balance) // K
23
        else:
24
            results.append(operations)
25
    26
    return results
27
28
29
if __name__ == ""__main__"":
30
    T = int(input())
31
    test_cases = []
32
    for _ in range(T):
33
        N, K = map(int, input().split())
34
        energy = list(map(int, input().split()))
35
        test_cases.append(((N, K), energy))
36
    37
    results = min_operations_to_equalize(T, test_cases)
38
    for res in results:
39
        print(res)
40",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834047
1387834038,vivaankotian1,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # If total energy cannot be evenly distributed among stations, return -1
5
    if total_energy % N != 0:
6
        return -1
7
8
    target = total_energy // N  # Each station should have this amount of energy
9
    operations = 0
10
    balance = 0
11
12
    # Check if we can equalize using only K transfers
13
    for i in range(N):
14
        diff = energy[i] - target  # Difference from required energy
15
        balance += diff  # Track excess/deficit energy
16
        17
        # If balance cannot be fixed using K moves, it's impossible
18
        if balance % K != 0:
19
            return -1
20
21
        operations += abs(balance) // K  # Count moves required
22
    23
    return operations
24
25
# Read input
26
T = int(input())  # Number of test cases
27
for _ in range(T):
28
    N, K = map(int, input().split())  # Read N and K
29
    energy = list(map(int, input().split()))  # Read energy levels
30
    31
    # Compute and print result
32
    print(min_operations_to_equalize(N, K, energy))",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834038
1387834041,aadarshpandey931,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834041
1387834043,harsh_singh26011,unknown,unknown,"1
def moe(test_cases):
2
    results = []
3
4
    for t in range(len(test_cases)):
5
        N, K, energy = test_cases[t]
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // N
12
        operations = 0
13
        balance = 0  
14
        for i in range(N):
15
            balance += energy[i] - target
16
            if balance % K != 0:
17
                operations = -1
18
                break
19
            operations += abs(balance) // K
20
        21
        results.append(operations if operations != -1 else -1)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    N, K = map(int, input().split())
30
    energy = list(map(int, input().split()))
31
    test_cases.append((N, K, energy))
32
results = moe(test_cases)
33
for res in results:
34
    print(res)",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834043
1387834033,samadshaikh22005,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>  // for abs()
4
using namespace std;
5
6
void solve() {
7
    int T;
8
    cin >> T;
9
    10
    while (T--) {
11
        int N, K;
12
        cin >> N >> K;
13
        vector<int> energy(N);
14
        15
        int sum = 0;
16
        for (int i = 0; i < N; i++) {
17
            cin >> energy[i];
18
            sum += energy[i];
19
        }
20
        21
        if (sum % N != 0) {
22
            cout << -1 << endl;
23
            continue;
24
        }
25
        26
        int target = sum / N;
27
        int operations = 0;
28
        int balance = 0;
29
        30
        for (int i = 0; i < N; i++) {
31
            balance += energy[i] - target;
32
            if (abs(balance) % K != 0) {
33
                operations = -1;
34
                break;
35
            }
36
            operations += abs(balance) / K;
37
        }
38
        39
        cout << operations << endl;
40
    }
41
}
42
43
int main() {
44
    solve();
45
    return 0;
46
}
47",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834033
1387834034,dhruvppaste20,unknown,unknown,"1
def main():
2
    import sys
3
    input = sys.stdin.read().split()
4
    idx = 0
5
    T = int(input[idx])
6
    idx += 1
7
    for _ in range(T):
8
        N, K = int(input[idx]), int(input[idx+1])
9
        idx +=2
10
        arr = list(map(int, input[idx:idx+N]))
11
        idx +=N
12
        sum_arr = sum(arr)
13
        if sum_arr % N != 0:
14
            print(-1)
15
            continue
16
        T_val = sum_arr // N
17
        if K == 0:
18
            if all(a == T_val for a in arr):
19
                print(0)
20
            else:
21
                print(-1)
22
            continue
23
        possible = True
24
        c = []
25
        for a in arr:
26
            diff = T_val - a
27
            if diff % K != 0:
28
                possible = False
29
                break
30
            c.append(diff // K)
31
        if not possible:
32
            print(-1)
33
            continue
34
        # Compute suffix sums
35
        suffix_sums = [0] * (N + 1)
36
        for i in range(N-1, -1, -1):
37
            suffix_sums[i] = c[i] + suffix_sums[i+1]
38
        # Compute S_i for each i
39
        S = [suffix_sums[i+1] for i in range(N)]
40
        # Compute M
41
        M = max(-s for s in S)
42
        # Compute sum_S
43
        sum_S = 0
44
        for j in range(1, N):
45
            sum_S += j * c[j]
46
        total_ops = M * N + sum_S
47
        print(total_ops)
48
49
if __name__ == ""__main__"":
50
    main()",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834034
1387834032,Gayathripoojary1,unknown,unknown,"1
def min_operations_to_equalize_energy(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target_energy = total_energy // N
8
    prefix_sum = 0
9
    operations = 0
10
    11
    for i in range(N):
12
        prefix_sum += energy[i] - target_energy
13
        if prefix_sum % K != 0:
14
            return -1
15
        operations += abs(prefix_sum) // K
16
    17
    return operations
18
19
20
T = int(input().strip())
21
results = []
22
23
for _ in range(T):
24
    N, K = map(int, input().strip().split())
25
    energy = list(map(int, input().strip().split()))
26
    result = min_operations_to_equalize_energy(N, K, energy)
27
    results.append(result)
28
29
30
for result in results:
31
    print(result)",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834032
1387834029,gusingevivek,unknown,unknown,"1
def solve_product_array(n, values):
2
    """"""
3
    Calculate product of all elements except self for each position
4
    5
    Args:
6
        n (int): Size of the array
7
        values (list): Input array of integers
8
        9
    Returns:
10
        list: Array where each element is product of all numbers except self
11
    """"""
12
    # Edge case - if n < 2
13
    if n < 2:
14
        return values
15
    16
    # Initialize result array with 1s
17
    result = [1] * n
18
    19
    # Calculate products of all elements to the left of each position
20
    left_product = 1
21
    for i in range(n):
22
        result[i] = left_product
23
        left_product *= values[i]
24
    25
    # Calculate products of all elements to the right and multiply with left products
26
    right_product = 1
27
    for i in range(n-1, -1, -1):
28
        result[i] *= right_product
29
        right_product *= values[i]
30
    31
    return result
32
33
def main():
34
    # Read number of test cases
35
    T = int(input())
36
    37
    # Process each test case
38
    for _ in range(T):
39
        # Read array size
40
        n = int(input())
41
        42
        # Read array values
43
        values = list(map(int, input().split()))
44
        45
        # Calculate result
46
        result = solve_product_array(n, values)
47
        48
        # Print result
49
        print(*result)
50
51
if __name__ == ""__main__"":
52
    main()",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387834029
1387834028,67_harshit_pras1,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
int main() {
7
    int t;
8
    cin >> t;
9
    10
    while (t--) {
11
        int n;
12
        cin >> n;
13
        14
        vector<int> nums(n);
15
        for (int i = 0; i < n; i++) {
16
            cin >> nums[i];
17
        }
18
        19
        vector<long long> prefixSum(n + 1, 0);
20
        for (int i = 0; i < n; i++) {
21
            prefixSum[i + 1] = prefixSum[i] + nums[i];
22
        }
23
        24
        long long maxDiff = 0;
25
        for (int i = 1; i < n; i++) {
26
            long long leftSum = prefixSum[i] - prefixSum[0];
27
            long long rightSum = prefixSum[n] - prefixSum[i];
28
            29
            long long diff = abs(leftSum - rightSum);
30
            maxDiff = max(maxDiff, diff);
31
        }
32
        33
        cout << maxDiff << endl;
34
    }
35
    36
    return 0;
37
}",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834028
1387834031,h1032221373,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834031
1387834025,princesharma8050,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # If total energy is not divisible by N, equal distribution is impossible
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target = total_energy // N  # Each station should have this much energy
9
    operations = 0
10
    balance = 0  # Tracks surplus or deficit
11
    12
    for i in range(N):
13
        diff = energy[i] - target
14
        balance += diff  # Keep track of cumulative surplus or deficit
15
        if abs(balance) % K != 0:  # If balance cannot be transferred in K units, return -1
16
            return -1
17
        operations += abs(diff) // K  # Each diff/K move is one operation
18
19
    return operations // 2  # Since each move affects two stations, divide by 2
20
21
# Read input
22
T = int(input())
23
for _ in range(T):
24
    N, K = map(int, input().split())
25
    energy = list(map(int, input().split()))
26
    print(min_operations_to_equalize(N, K, energy))
27",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834025
1387834026,ktiwari3215,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    for _ in range(T):
4
        N, K = map(int, input().split())  # N is the number of stations, K is the energy per transfer
5
        energy = list(map(int, input().split()))  # List of energy levels
6
        7
        total_energy = sum(energy)
8
        9
        # If total energy is not divisible by N, it's impossible to equalize
10
        if total_energy % N != 0:
11
            print(-1)
12
            continue
13
        14
        target_energy = total_energy // N
15
        operations = 0
16
        current_balance = 0
17
        18
        for i in range(N):
19
            # Calculate the difference from target energy for the current station
20
            current_balance += energy[i] - target_energy
21
            # The number of operations required is how much imbalance has been accumulated
22
            operations += abs(current_balance) // K
23
            24
            # If at any point, the imbalance isn't divisible by K, return -1
25
            if abs(current_balance) % K != 0:
26
                operations = -1
27
                break
28
        29
        print(operations)
30
31
# Call the function to run the solution
32
solve()",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834026
1387834027,smeetadeshra,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K = case[0]  # Number of stations, units of energy transferable
6
        energy = case[1]  # Energy levels of the stations
7
        8
        total_energy = sum(energy)
9
        10
        # If total energy is not divisible by N, equalization is impossible
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target_energy = total_energy // N
16
        operations = 0
17
        imbalance = 0  # Tracks cumulative imbalance
18
        19
        for i in range(N):
20
            imbalance += (energy[i] - target_energy)
21
            # Check if imbalance can be fixed using multiples of K
22
            if imbalance % K != 0:
23
                results.append(-1)
24
                break
25
            operations += abs(imbalance) // K
26
        else:
27
            results.append(operations)
28
    29
    return results
30
31
32
# Input Handling
33
if __name__ == ""__main__"":
34
    T = int(input())  # Number of test cases
35
    test_cases = []
36
    37
    for _ in range(T):
38
        N, K = map(int, input().split())  # N = number of stations, K = energy transfer units
39
        energy = list(map(int, input().split()))  # Energy levels of the stations
40
        test_cases.append(((N, K), energy))
41
    42
    results = min_operations_to_equalize_energy(T, test_cases)
43
    for result in results:
44
        print(result)
45",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834027
1387834015,h1032221348,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    total_sum = sum(nums)
4
    left_sum = 0
5
    max_diff = 0
6
7
    for i in range(n - 1):
8
        left_sum += nums[i]
9
        right_sum = total_sum - left_sum
10
        max_diff = max(max_diff, abs(left_sum - right_sum))
11
12
    return max_diff
13
14
# Input reading
15
t = int(input())
16
results = []
17
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    results.append(max_absolute_difference(nums))
22
23
# Output results
24
for res in results:
25
    print(res)
26",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834015
1387834020,shikharguptaoct1,unknown,unknown,"1
def minimum_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
4
    for i in range(t):
5
        # Access test case elements directly using index i
6
        n, k = test_cases[i]['n'], test_cases[i]['k']
7
        energy = test_cases[i]['energy']
8
9
        total_energy = sum(energy)
10
11
        if total_energy % n != 0:
12
            results.append(-1)
13
            continue
14
15
        target_energy = total_energy // n
16
        operations = 0
17
        current_transfer = 0
18
19
        for j in range(n):
20
            current_transfer += energy[j] - target_energy
21
            if current_transfer % k != 0:
22
                results.append(-1)
23
                break
24
            operations += abs(current_transfer) // k
25
        else:
26
            results.append(operations)
27
28
    return results
29
30
31
# Read input
32
T = int(input().strip())
33
test_cases = []
34
for _ in range(T):
35
    n, k = map(int, input().strip().split())
36
    energy = list(map(int, input().strip().split()))
37
    test_cases.append({""n"": n, ""k"": k, ""energy"": energy})
38
39
# Process and output results
40
results = minimum_operations_to_equalize_energy(T, test_cases)
41
for result in results:
42
    print(result)",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834020
1387834022,adiv40816,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for _ in range(t):
4
        n, nums = test_cases[_]
5
        6
        # Calculate the prefix sum
7
        prefix_sum = [0] * (n + 1)
8
        for i in range(n):
9
            prefix_sum[i + 1] = prefix_sum[i] + nums[i]
10
        11
        total_sum = prefix_sum[n]
12
        max_diff = 0
13
        14
        # Iterate to find the max absolute difference
15
        for i in range(1, n):
16
            left_sum = prefix_sum[i]
17
            right_sum = total_sum - left_sum
18
            max_diff = max(max_diff, abs(left_sum - right_sum))
19
        20
        results.append(max_diff)
21
    22
    return results
23
24
25
# Input Reading and Output
26
t = int(input())  # Number of test cases
27
test_cases = []
28
for _ in range(t):
29
    n = int(input())
30
    nums = list(map(int, input().split()))
31
    test_cases.append((n, nums))
32
33
results = max_absolute_difference(t, test_cases)
34
for result in results:
35
    print(result)
36",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834022
1387834014,ayushaj14,unknown,unknown,"1
def max_abs_difference_partition(test_cases):
2
    results = []
3
4
    for nums in test_cases:
5
        n = len(nums)
6
7
        # Compute prefix sums
8
        prefix_sum = [0] * n
9
        prefix_sum[0] = nums[0]
10
        11
        for i in range(1, n):
12
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
13
14
        total_sum = prefix_sum[-1]
15
        max_diff = 0
16
17
        # Compute max absolute difference by iterating through possible partitions
18
        for i in range(n - 1):
19
            left_sum = prefix_sum[i]
20
            right_sum = total_sum - left_sum
21
            max_diff = max(max_diff, abs(left_sum - right_sum))
22
23
        results.append(str(max_diff))
24
25
    # Print all results at once
26
    print(""\n"".join(results))
27
28
29
def main():
30
    # Read input
31
    t = int(input().strip())
32
    test_cases = []
33
34
    for _ in range(t):
35
        n = int(input().strip())
36
        nums = list(map(int, input().strip().split()))
37
        test_cases.append(nums)
38
39
    max_abs_difference_partition(test_cases)
40
41
42
if __name__ == ""__main__"":
43
    main()",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834014
1387834007,aadarshpandey931,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834007
1387834013,goswamyashutosh9,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        # Check if total energy is divisible by N
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target = total_energy // N
16
        surplus = 0
17
        operations = 0
18
19
        for i in range(N):
20
            diff = energy[i] - target
21
            surplus += diff
22
23
            # If the surplus at any point isn't divisible by K, it's impossible
24
            if surplus % K != 0:
25
                results.append(-1)
26
                break
27
28
            # Add operations needed for this station
29
            operations += abs(diff) // K
30
        else:
31
            # If loop completes without breaking, check if surplus balances to zero
32
            if surplus == 0:
33
                results.append(operations // 2)  # Divide by 2 to avoid double-counting
34
            else:
35
                results.append(-1)
36
37
    return results
38
39
40
# Input Reading
41
def main():
42
    T = int(input().strip())
43
    test_cases = []
44
45
    for _ in range(T):
46
        # Read N and K
47
        N, K = map(int, input().strip().split())
48
        # Read energy array
49
        energy = list(map(int, input().strip().split()))
50
        test_cases.append(((N, K), energy))
51
52
    # Compute Results
53
    results = min_operations_to_equalize_energy(T, test_cases)
54
55
    # Output Results
56
    for res in results:
57
        print(res)
58
59
60
# Run the program
61
if __name__ == ""__main__"":
62
    main()
63",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387834013
1387834010,h1032221029,unknown,unknown,"1
def max_subarray_difference(nums):
2
    n = len(nums)
3
    max_diff = float('-inf')
4
    5
    for i in range(1, n):
6
    7
        left_sum = sum(nums[:i])
8
        right_sum = sum(nums[i:])
9
        10
       11
        curr_diff = abs(left_sum - right_sum)
12
        max_diff = max(max_diff, curr_diff)
13
    14
    return max_diff
15
16
17
t = int(input())
18
19
20
for _ in range(t):
21
    22
    n = int(input())
23
    24
   25
    nums = list(map(int, input().split()))
26
    27
  28
    result = max_subarray_difference(nums)
29
    print(result)",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834010
1387833999,h1032220685,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K, energy = case['N'], case['K'], case['energy']
6
        total_energy = sum(energy)
7
8
        # Check if total energy is divisible by N
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target = total_energy // N
14
        differences = [(e - target) for e in energy]
15
16
        # Check if each difference is divisible by K
17
        if any(diff % K != 0 for diff in differences):
18
            results.append(-1)
19
            continue
20
21
        # Calculate the number of operations
22
        cumulative_sum = 0
23
        operations = 0
24
25
        for diff in differences:
26
            cumulative_sum += diff // K
27
            operations += abs(cumulative_sum)
28
29
        results.append(operations)
30
31
    return results
32
33
# Input parsing
34
def parse_input():
35
    T = int(input())
36
    test_cases = []
37
38
    for _ in range(T):
39
        N, K = map(int, input().split())
40
        energy = list(map(int, input().split()))
41
        test_cases.append({""N"": N, ""K"": K, ""energy"": energy})
42
43
    return test_cases
44
45
# Output results
46
def main():
47
    test_cases = parse_input()
48
    results = minimum_operations(test_cases)
49
    for res in results:
50
        print(res)
51
52
if __name__ == ""__main__"":
53
    main()
54",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833999
1387833997,h1032221515,unknown,unknown,"1
def product_distribution(test_cases):
2
    results = []
3
4
    for t in range(test_cases):
5
        n = int(input())  # Use input() instead of raw_input()
6
        values = list(map(int, input().split()))  # Convert input to a list of integers
7
        total_product = 1
8
        zero_count = 0
9
10
        # Calculate the product of all non-zero values and count zeros
11
        for value in values:
12
            if value == 0:
13
                zero_count += 1
14
            else:
15
                total_product *= value
16
17
        # Generate the result for the current test case
18
        result = []
19
        for value in values:
20
            if zero_count > 1:
21
                # If more than one zero, all products are 0
22
                result.append(0)
23
            elif zero_count == 1:
24
                # If exactly one zero, only the zero position gets the product
25
                result.append(total_product if value == 0 else 0)
26
            else:
27
                # No zeros, divide the total product by the current value
28
                result.append(total_product // value)
29
30
        # Store the result as a space-separated string
31
        results.append("" "".join(map(str, result)))
32
33
    # Print all results at once
34
    for res in results:
35
        print(res)
36
37
38
# Input number of test cases
39
T = int(input())
40
product_distribution(T)",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833997
1387834001,shubhamgupta3009,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static int maxPartitionDifference(int[] nums) {
7
        int n = nums.length;
8
        int[] prefixSum = new int[n + 1];
9
10
        for (int i = 0; i < n; i++) {
11
            prefixSum[i + 1] = prefixSum[i] + nums[i];
12
        }
13
14
        int maxDiff = 0;
15
        for (int i = 1; i < n; i++) {
16
            int leftSum = prefixSum[i];
17
            int rightSum = prefixSum[n] - prefixSum[i];
18
            maxDiff = Math.max(maxDiff, Math.abs(leftSum - rightSum));
19
        }
20
21
        return maxDiff;
22
    }
23
24
    public static void main(String[] args) {
25
        Scanner scanner = new Scanner(System.in);
26
        int T = scanner.nextInt();
27
28
        for (int t = 0; t < T; t++) {
29
            int n = scanner.nextInt();
30
            int[] nums = new int[n];
31
32
            for (int i = 0; i < n; i++) {
33
                nums[i] = scanner.nextInt();
34
            }
35
36
            System.out.println(maxPartitionDifference(nums));
37
        }
38
39
        scanner.close();
40
    }
41
}",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387834001
1387833993,sohampatil1807,unknown,unknown,"1
def max_subarray_difference(nums, n):
2
    """"""
3
    Calculate maximum absolute difference between sums of two contiguous subarrays.
4
    5
    Args:
6
        nums: List of integers
7
        n: Length of the array
8
    Returns:
9
        Maximum absolute difference possible
10
    """"""
11
    # Handle edge case
12
    if n < 2:
13
        return 0
14
        15
    # Keep track of maximum difference
16
    max_diff = float('-inf')
17
    18
    # Calculate total sum once
19
    total_sum = sum(nums)
20
    21
    # Keep track of left subarray sum
22
    left_sum = 0
23
    24
    # Try each possible partition point
25
    for i in range(n - 1):  # Stop at n-1 to ensure right subarray is non-empty
26
        # Add current element to left sum
27
        left_sum += nums[i]
28
        29
        # Right sum can be calculated using total_sum - left_sum
30
        right_sum = total_sum - left_sum
31
        32
        # Calculate absolute difference
33
        curr_diff = abs(left_sum - right_sum)
34
        35
        # Update maximum difference if current is larger
36
        max_diff = max(max_diff, curr_diff)
37
    38
    return max_diff
39
40
def main():
41
    # Read number of test cases
42
    t = int(input())
43
    44
    # Process each test case
45
    for _ in range(t):
46
        # Read array size
47
        n = int(input())
48
        49
        # Read array elements
50
        nums = list(map(int, input().split()))
51
        52
        # Calculate and print result
53
        result = max_subarray_difference(nums, n)
54
        print(result)
55
56
if __name__ == ""__main__"":
57
    main()
58",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833993
1387833995,vigneshalle16,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for test in test_cases:
5
        n, nums = test
6
        7
        # Compute prefix sums
8
        prefix_sum = [0] * n
9
        prefix_sum[0] = nums[0]
10
        for i in range(1, n):
11
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
12
        13
        # Compute suffix sums
14
        suffix_sum = [0] * n
15
        suffix_sum[n - 1] = nums[n - 1]
16
        for i in range(n - 2, -1, -1):
17
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
18
        19
        # Calculate maximum absolute difference
20
        max_abs_diff = 0
21
        for i in range(1, n):
22
            abs_diff = abs(prefix_sum[i - 1] - suffix_sum[i])
23
            max_abs_diff = max(max_abs_diff, abs_diff)
24
        25
        results.append(max_abs_diff)
26
    27
    return results
28
29
30
# Input processing
31
t = int(input())
32
test_cases = []
33
34
for _ in range(t):
35
    n = int(input())
36
    nums = list(map(int, input().split()))
37
    test_cases.append((n, nums))
38
39
# Get results
40
results = max_absolute_difference(t, test_cases)
41
42
# Output results
43
for res in results:
44
    print(res)
45",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833995
1387833991,warangsmit,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n=int(input())
4
    arr=list(map(int,input().split()))
5
    summ=sum(arr)
6
    ans=0
7
    total=0
8
    for i in arr[:-1]:
9
        total+=i
10
        comp=summ-total
11
        ans=max(ans,abs(comp-total))
12
    print(ans)",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833991
1387833990,sanika_wani,unknown,unknown,"1
def minimum_operations(t, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, k, energy = case
6
        total_energy = sum(energy)
7
        8
       9
        if total_energy % n != 0:
10
            results.append(-1)
11
            continue
12
        13
        target_energy = total_energy // n
14
        prefix_sum = 0
15
        operations = 0
16
        17
     18
        for e in energy:
19
            imbalance = e - target_energy
20
            prefix_sum += imbalance
21
            22
            23
            if prefix_sum % k != 0:
24
                results.append(-1)
25
                break
26
            operations += abs(prefix_sum // k)
27
        else:
28
            results.append(operations)
29
    30
    return results
31
32
if __name__ == ""__main__"":
33
    t = int(input())
34
    test_cases = []
35
    for _ in range(t):
36
        n, k = map(int, input().split())
37
        energy = list(map(int, input().split()))
38
        test_cases.append((n, k, energy))
39
    40
    results = minimum_operations(t, test_cases)
41
    for res in results:
42
        print(res)
43",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833990
1387833985,ng873042,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
4
    # Step 1: Check if equal distribution is possible
5
    if total_energy % N != 0:
6
        return -1
7
8
    target = total_energy // N
9
    moves_needed = 0
10
    balance = 0  # To track net energy transfer
11
12
    # Step 2: Compute required transfers
13
    for e in energy:
14
        diff = e - target
15
        if diff % K != 0:
16
            return -1
17
        balance += diff // K  # Tracking total required moves
18
        if diff > 0:
19
            moves_needed += diff // K
20
21
    # Step 3: Ensure net balance is 0 (to avoid extra moves)
22
    if balance != 0:
23
        return -1
24
25
    return moves_needed
26
27
# Read input
28
T = int(input())  # Number of test cases
29
for _ in range(T):
30
    N, K = map(int, input().split())  # Read N and K
31
    energy = list(map(int, input().split()))  # Read energy array
32
    print(min_operations_to_equalize(N, K, energy))  # Print result",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833985
1387833987,singhark94,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <tuple>
4
#include <numeric>
5
#include <cmath>
6
using namespace std;
7
8
vector<int> minOperations(vector<tuple<int, int, vector<int>>>& test_cases) {
9
    vector<int> results;
10
11
    for (const auto& test_case : test_cases) {
12
        int N, K;
13
        vector<int> energy;
14
        tie(N, K, energy) = test_case;
15
16
        long long total_energy = accumulate(energy.begin(), energy.end(), 0LL);
17
        if (total_energy % N != 0) {
18
            results.push_back(-1);
19
            continue;
20
        }
21
22
        long long target = total_energy / N;
23
        long long operations = 0;
24
        long long balance = 0;
25
        bool possible = true;
26
27
        for (int i = 0; i < N; ++i) {
28
            balance += energy[i] - target;
29
            if (balance % K != 0) {
30
                possible = false;
31
                break;
32
            }
33
            operations += abs(balance) / K;
34
        }
35
36
        results.push_back(possible ? operations : -1);
37
    }
38
39
    return results;
40
}
41
42
int main() {
43
    int T;
44
    cin >> T;
45
    vector<tuple<int, int, vector<int>>> test_cases(T);
46
47
    for (int t = 0; t < T; ++t) {
48
        int N, K;
49
        cin >> N >> K;
50
        vector<int> energy(N);
51
        for (int i = 0; i < N; ++i) {
52
            cin >> energy[i];
53
        }
54
        test_cases[t] = make_tuple(N, K, energy);
55
    }
56
57
    vector<int> results = minOperations(test_cases);
58
    for (int res : results) {
59
        cout << res << endl;
60
    }
61
62
    return 0;
63
}
64",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833987
1387833989,h1032220754,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for n, nums in test_cases:
4
        prefix_sum = 0
5
        total_sum = sum(nums)
6
        max_diff = 0
7
8
        for i in range(n - 1):
9
            prefix_sum += nums[i]
10
            suffix_sum = total_sum - prefix_sum
11
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
12
13
        results.append(max_diff)
14
15
    return results
16
17
def main():
18
    T = int(input())
19
    test_cases = []
20
21
    for _ in range(T):
22
        n = int(input())
23
        nums = list(map(int, input().split()))
24
        test_cases.append((n, nums))
25
26
    results = max_absolute_difference(test_cases)
27
    for res in results:
28
        print(res)
29
30
if __name__ == ""__main__"":
31
    main()
32",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833989
1387833981,aadarshpandey931,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833981
1387833982,suryampandey5942,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)
49",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833982
1387833983,omg40787,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n = case[0]
6
        nums = case[1]
7
8
        # Calculate prefix sums
9
        prefix_sum = [0] * n
10
        prefix_sum[0] = nums[0]
11
        for i in range(1, n):
12
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
13
14
        # Calculate suffix sums
15
        suffix_sum = [0] * n
16
        suffix_sum[-1] = nums[-1]
17
        for i in range(n - 2, -1, -1):
18
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
19
20
        # Calculate the maximum absolute difference
21
        max_diff = 0
22
        for i in range(n - 1):
23
            left_sum = prefix_sum[i]
24
            right_sum = suffix_sum[i + 1]
25
            max_diff = max(max_diff, abs(left_sum - right_sum))
26
27
        results.append(max_diff)
28
29
    return results
30
31
# Example usage:
32
test_cases = [
33
    (3, [2, 3, 4]),
34
]
35
36
results = max_absolute_difference(test_cases)
37
for result in results:
38
    print(result)
39",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833983
1387833971,amanpandey200521,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        # Initialize prefix and suffix products
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
18
        # Compute the result array
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
22
        # Append the result for the test case
23
        results.append(result)
24
    25
    return results
26
27
# Read input
28
T = int(input())
29
test_cases = []
30
for _ in range(T):
31
    n = int(input())
32
    values = list(map(int, input().split()))
33
    test_cases.append((n, values))
34
35
# Process test cases
36
results = product_except_self(test_cases)
37
38
# Print output
39
for result in results:
40
    print(' '.join(map(str, result)))
41",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833971
1387833972,h1032221739,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        surplus = 0
12
        for i in range(N):
13
            diff = energy[i] - target
14
            surplus += diff
15
            if surplus % K != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(surplus // K)
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
results = minimum_operations(test_cases)
31
for res in results:
32
    print(res)",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833972
1387833973,rugvedkatkade66,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][0]
5
        energy = test_cases[t][1]
6
        7
        # Step 1: Check if total energy is divisible by N
8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        # Step 2: Calculate target energy per station
14
        target_energy = total_energy // N
15
        16
        # Step 3: Calculate the prefix sum of energy differences
17
        prefix_sum = 0
18
        operations = 0
19
        possible = True
20
        for i in range(N):
21
            diff = energy[i] - target_energy
22
            prefix_sum += diff
23
            if abs(prefix_sum) % K != 0:  # If prefix_sum cannot be redistributed in multiples of K
24
                possible = False
25
                break
26
            operations += abs(prefix_sum) // K  # Count operations required to balance prefix_sum
27
        28
        # Step 4: Check if redistribution was possible
29
        if possible:
30
            results.append(operations)
31
        else:
32
            results.append(-1)
33
    34
    return results
35
36
# Read Input
37
import sys
38
input = sys.stdin.read
39
data = input().splitlines()
40
41
T = int(data[0])  # Number of test cases
42
test_cases = []
43
44
line_index = 1
45
for _ in range(T):
46
    N, K = map(int, data[line_index].split())
47
    line_index += 1
48
    energy = list(map(int, data[line_index].split()))
49
    line_index += 1
50
    test_cases.append(((N, K), energy))
51
52
# Process and Output Results
53
results = minimum_operations_to_equalize(T, test_cases)
54
for res in results:
55
    print(res)
56",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833973
1387833970,karmakarsanket98,unknown,unknown,"1
def compute_result(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n, values = test_cases[t]
6
        7
        # Initialize prefix and suffix arrays
8
        prefix = [1] * n
9
        suffix = [1] * n
10
        result = [0] * n
11
        12
        # Calculate prefix products
13
        for i in range(1, n):
14
            prefix[i] = prefix[i - 1] * values[i - 1]
15
        16
        # Calculate suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix[i] = suffix[i + 1] * values[i + 1]
19
        20
        # Calculate the result for each index
21
        for i in range(n):
22
            result[i] = prefix[i] * suffix[i]
23
        24
        results.append(result)
25
    26
    return results
27
28
29
# Input
30
T = int(input())
31
test_cases = []
32
for _ in range(T):
33
    n = int(input())
34
    values = list(map(int, input().split()))
35
    test_cases.append((n, values))
36
37
# Compute results
38
results = compute_result(T, test_cases)
39
40
# Output
41
for res in results:
42
    print("" "".join(map(str, res)))
43",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833970
1387833965,h1032231332,unknown,unknown,"1
def solve():
2
    t = int(input())  # number of test cases
3
    for _ in range(t):
4
        n = int(input())  # size of the array
5
        nums = list(map(int, input().split()))  # the array
6
        7
        # Calculate the total sum of the array
8
        total_sum = sum(nums)
9
        10
        # Variables to track the left sum and maximum absolute difference
11
        left_sum = 0
12
        max_difference = 0
13
        14
        # Iterate to find the maximum absolute difference
15
        for i in range(n - 1):  # We stop at n-1 since we need non-empty right subarray
16
            left_sum += nums[i]
17
            right_sum = total_sum - left_sum
18
            max_difference = max(max_difference, abs(left_sum - right_sum))
19
        20
        print(max_difference)
21
22
# Call the function to solve the problem
23
solve()",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833965
1387833966,syedtahami123,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))
42
43
44
45",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833966
1387833968,swayam_prajapat1,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):  
2
    results = []  
3
    4
    for case in test_cases:  
5
        N, K = case[0]  
6
        energy = case[1]  
7
8
        total_energy = sum(energy)  
9
10
        # Check if total energy is divisible by N  
11
        if total_energy % N != 0:  
12
            results.append(-1)  
13
            continue  
14
        15
        target_energy = total_energy // N  
16
        operations = 0  
17
        current_surplus = 0  
18
        19
        # Calculate the operations needed to equalize energy  
20
        for e in energy:  
21
            # Calculate current difference from target  
22
            current_balance = e - target_energy  
23
            24
            # Current balance is how much we need to give or take.   
25
            # Update surplus if current balance is positive, else deficit.  
26
            current_surplus += current_balance  
27
            28
            # If current surplus is positive, we can use it to balance in future steps  
29
            if current_surplus > 0:  
30
                operations += current_surplus // K  
31
        32
        # Check if we balanced correctly by using all surplus  
33
        if current_surplus % K != 0:  
34
            results.append(-1)  
35
        else:  
36
            results.append(operations)  
37
38
    return results  
39
40
# Read input and execute the function  
41
import sys  
42
43
# Use sys.stdin.read to handle input in one go  
44
input_data = sys.stdin.read().strip().splitlines()  
45
T = int(input_data[0])  
46
test_cases = []  
47
48
for i in range(1, len(input_data), 2):  
49
    N, K = map(int, input_data[i].split())  
50
    energy = list(map(int, input_data[i + 1].split()))  
51
    test_cases.append(((N, K), energy))  
52
53
# Get results and print  
54
results = min_operations_to_equalize(T, test_cases)  
55
56
for result in results:  
57
    print(result)",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833968
1387833962,ktiwari3215,unknown,unknown,"1
def solve():
2
    T = int(input())  # number of test cases
3
    for _ in range(T):
4
        n = int(input())  # number of nodes in the network
5
        values = list(map(int, input().split()))  # list of node values
6
7
        # Arrays to store the left and right products
8
        left = [1] * n
9
        right = [1] * n
10
        result = [0] * n
11
12
        # Fill the left array
13
        for i in range(1, n):
14
            left[i] = left[i - 1] * values[i - 1]
15
16
        # Fill the right array
17
        for i in range(n - 2, -1, -1):
18
            right[i] = right[i + 1] * values[i + 1]
19
20
        # Calculate result by multiplying corresponding left and right products
21
        for i in range(n):
22
            result[i] = left[i] * right[i]
23
24
        print("" "".join(map(str, result)))
25
26
# Call the function to run the solution
27
solve()",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833962
1387833963,h1032221373,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt(); // Number of test cases
8
        9
        while (T-- > 0) {
10
            int N = scanner.nextInt(); // Number of power stations
11
            int K = scanner.nextInt(); // Energy transfer per operation
12
            int[] energy = new int[N];
13
            14
            long totalEnergy = 0; // Use long to avoid overflow
15
            16
            // Read the energy levels and calculate the total energy
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextInt();
19
                totalEnergy += energy[i];
20
            }
21
            22
            // Check if total energy is divisible by N
23
            if (totalEnergy % N != 0) {
24
                System.out.println(-1);
25
                continue;
26
            }
27
            28
            long target = totalEnergy / N; // Target energy per station
29
            long imbalance = 0, operations = 0;
30
            boolean possible = true;
31
            32
            for (int i = 0; i < N; i++) {
33
                // Calculate the difference from the target
34
                imbalance += energy[i] - target;
35
                36
                // If the imbalance is not a multiple of K, it's not possible to balance
37
                if (Math.abs(imbalance) % K != 0) {
38
                    possible = false;
39
                    break;
40
                }
41
                42
                // Count operations required to fix imbalance
43
                operations += Math.abs(imbalance) / K;
44
            }
45
            46
            // If balancing is possible, print the operations; otherwise, -1
47
            System.out.println(possible ? operations : -1);
48
        }
49
        50
        scanner.close();
51
    }
52
}
53",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833963
1387833964,3277kunaljain,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        total_energy = sum(energy)     
7
        if total_energy % N != 0:
8
            print(-1)
9
            continue      
10
        target_energy = total_energy // N
11
        operations = 0
12
        current_balance = 0       
13
        for i in range(N):
14
            current_balance += energy[i] - target_energy
15
            operations += abs(current_balance) // K
16
            if abs(current_balance) % K != 0:
17
                operations = -1
18
                break
19
        print(operations)
20
solve()",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833964
1387833960,shrikrushna07,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)
36",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833960
1387833959,abhaywadkar2004,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
void solve() {
6
    int T;
7
    cin >> T;
8
9
    while (T--) {
10
        int N;
11
        long long K;
12
        cin >> N >> K;
13
14
        vector<long long> energy(N);
15
        long long total_energy = 0;
16
17
        for (auto &e : energy) {
18
            cin >> e;
19
            total_energy += e;
20
        }
21
22
        if (total_energy % N != 0) {
23
            cout << -1 << endl;
24
            continue;
25
        }
26
27
        long long target_energy = total_energy / N, surplus = 0;
28
29
        bool possible = true;
30
        for (auto e : energy) {
31
            long long diff = e - target_energy;
32
            if (diff % K != 0) {
33
                possible = false;
34
                break;
35
            }
36
            surplus += diff / K;
37
        }
38
39
        cout << (possible && surplus == 0 ? abs(surplus) : -1) << endl;
40
    }
41
}
42
43
int main() {
44
    ios::sync_with_stdio(false);
45
    cin.tie(nullptr);
46
    solve();
47
    return 0;
48
}
49",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833959
1387833961,pratiksolves,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
int main() {
7
    int t; 
8
    cin >> t;
9
    while (t--) {
10
        int n;
11
        cin >> n;
12
        vector<int> nums(n);
13
        for (int i = 0; i < n; ++i) {
14
            cin >> nums[i];
15
        }
16
17
        long long total_sum = 0;
18
        for (int i = 0; i < n; ++i) {
19
            total_sum += nums[i];
20
        }
21
22
        long long prefix_sum = 0;
23
        long long max_diff = 0;
24
25
        for (int i = 0; i < n - 1; ++i) {
26
            prefix_sum += nums[i];
27
            long long right_sum = total_sum - prefix_sum;
28
            max_diff = max(max_diff, abs(prefix_sum - right_sum));
29
        }
30
31
        cout << max_diff << endl;
32
    }
33
    return 0;
34
}
35",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833961
1387833956,rahulgeorge1212,unknown,unknown,"1
def min_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
    4
    for test_case in test_cases:
5
        N, K = test_case[0], test_case[1]
6
        energies = test_case[2]
7
        8
        total_energy = sum(energies)
9
        10
        # Check if total energy is divisible by N
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target_energy = total_energy // N
16
        operations = 0
17
        balance = 0
18
        19
        # Process each station
20
        for i in range(N):
21
            # Calculate the current difference from the target
22
            diff = energies[i] - target_energy
23
            balance += diff
24
            25
            # We need to balance this difference by transferring multiples of K
26
            if balance % K != 0:
27
                results.append(-1)
28
                break
29
            operations += abs(balance) // K
30
        31
        else:
32
            results.append(operations)
33
    34
    return results
35
36
# Input processing
37
t = int(input())  # number of test cases
38
test_cases = []
39
for _ in range(t):
40
    N, K = map(int, input().split())  # number of stations and units of energy that can be transferred in one operation
41
    energies = list(map(int, input().split()))  # energy at each station
42
    test_cases.append((N, K, energies))
43
44
# Call function and print results
45
results = min_operations_to_equalize_energy(t, test_cases)
46
for result in results:
47
    print(result)
48",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833956
1387833953,krishjain,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833953
1387833954,1_ashwarya,unknown,unknown,"1
def calculate_result(values, n):
2
3
    result = [1] * n
4
    5
    left_product = 1
6
    for i in range(n):
7
        result[i] = left_product
8
        left_product *= values[i]
9
    10
    right_product = 1
11
    for i in range(n-1, -1, -1):
12
        result[i] *= right_product
13
        right_product *= values[i]
14
    15
    return result
16
17
T = int(input())
18
19
for _ in range(T):
20
    n = int(input())
21
    values = list(map(int, input().split()))
22
    23
    result = calculate_result(values, n)
24
    25
    print("" "".join(map(str, result)))",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833954
1387833955,h1032221013,unknown,unknown,"1
def solve_product_array(n, values):
2
    if n < 2:
3
        return values
4
    result = [1] * n
5
    left_product = 1
6
    for i in range(n):
7
        result[i] = left_product
8
        left_product *= values[i]
9
    right_product = 1
10
    for i in range(n-1, -1, -1):
11
        result[i] *= right_product
12
        right_product *= values[i]
13
    return result
14
15
def main():
16
    T = int(input())
17
    for _ in range(T):
18
        n = int(input())
19
        values = list(map(int, input().split()))
20
        result = solve_product_array(n, values)
21
        print(*result)
22
23
if __name__ == ""__main__"":
24
    main()
25",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833955
1387833944,shshloka,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for t in test_cases:
4
        n, nums = t
5
6
        prefix_sum = [0] * n
7
        prefix_sum[0] = nums[0]
8
        for i in range(1, n):
9
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
10
        11
        total_sum = prefix_sum[-1]
12
        max_diff = 0
13
        14
        for i in range(n - 1):
15
            left_sum = prefix_sum[i]
16
            right_sum = total_sum - left_sum
17
            max_diff = max(max_diff, abs(left_sum - right_sum))
18
        19
        results.append(max_diff)
20
    21
    return results
22
23
t = int(input())
24
test_cases = []
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
results = max_absolute_difference(test_cases)
31
for res in results:
32
    print(res)
33",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833944
1387833946,Gayathripoojary1,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, nums = case[""n""], case[""nums""]
6
        total_sum = sum(nums)
7
        left_sum = 0
8
        max_diff = 0
9
10
      11
        for i in range(n - 1):
12
            left_sum += nums[i]
13
            right_sum = total_sum - left_sum
14
            max_diff = max(max_diff, abs(left_sum - right_sum))
15
16
        results.append(max_diff)
17
18
    return results
19
20
def main():
21
    t = int(input())
22
    test_cases = []
23
24
    for _ in range(t):
25
        n = int(input())
26
        nums = list(map(int, input().split()))
27
        test_cases.append({""n"": n, ""nums"": nums})
28
29
    results = max_absolute_difference(t, test_cases)
30
31
    for res in results:
32
        print(res)
33
34
35
if __name__ == ""__main__"":
36
    main()",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833946
1387833951,h1032220278,unknown,unknown,"1
def readvalues():
2
    3
    return list(map(int, input().split()))
4
5
def calproduct(values):
6
    res = []
7
    totalproduct = 1
8
    for value in values:
9
        totalproduct *= value
10
    for value in values:
11
        res.append(totalproduct // value)
12
    return res
13
14
testcases = int(input())
15
for i in range(testcases):
16
    n = int(input())  
17
    values = readvalues() 
18
    result = calproduct(values)
19
    print("" "".join(map(str, result)))
20",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833951
1387833940,samadshaikh22005,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
void solve() {
6
    int T;
7
    cin >> T;
8
    9
    while (T--) {
10
        int N, K;
11
        cin >> N >> K;
12
        vector<int> energy(N);
13
        14
        int sum = 0;
15
        for (int i = 0; i < N; i++) {
16
            cin >> energy[i];
17
            sum += energy[i];
18
        }
19
        20
        if (sum % N != 0) {
21
            cout << -1 << endl;
22
            continue;
23
        }
24
        25
        int target = sum / N;
26
        int operations = 0;
27
        int balance = 0;
28
        29
        for (int i = 0; i < N; i++) {
30
            balance += energy[i] - target;
31
            operations += abs(balance) / K;
32
            33
            if (abs(balance) % K != 0) {
34
                operations = -1;
35
                break;
36
            }
37
        }
38
        39
        cout << operations << endl;
40
    }
41
}
42
43
int main() {
44
    solve();
45
    return 0;
46
}
47",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833940
1387833943,dhananjaygaur04,unknown,unknown,"1
def product_array(values):
2
    """"""
3
    Calculates the product of all elements in the array except the element at the current index.
4
5
    Args:
6
        values: A list of integers.
7
8
    Returns:
9
        A list of integers, where each element is the product of all other elements in the original list.
10
    """"""
11
12
    n = len(values)
13
    result = [1] * n
14
15
    # Calculate left product
16
    left_product = 1
17
    for i in range(n):
18
        result[i] = left_product
19
        left_product *= values[i]
20
21
    # Calculate right product
22
    right_product = 1
23
    for i in range(n - 1, -1, -1):
24
        result[i] *= right_product
25
        right_product *= values[i]
26
27
    return result
28
29
if __name__ == ""__main__"":
30
    T = int(input())
31
32
    for _ in range(T):
33
        n = int(input())
34
        values = list(map(int, input().split()))
35
36
        result = product_array(values)
37
        print(*result)",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833943
1387833942,siddhinnaik05,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
9
int main() {
10
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
11
    int T;
12
    cin >> T;  // Read number of test cases
13
14
    while (T--) {
15
        int n;
16
        cin >> n;  // Read the size of the array
17
        18
        vector<int> values(n), result(n, 1);
19
20
        // Read the values of the nodes
21
        for (int i = 0; i < n; ++i) {
22
            cin >> values[i];
23
        }
24
25
        // Step 1: Calculate prefix product and store in result array
26
        int prefix_product = 1;
27
        for (int i = 0; i < n; ++i) {
28
            result[i] *= prefix_product;
29
            prefix_product *= values[i];
30
        }
31
32
        // Step 2: Calculate suffix product and update result array
33
        int suffix_product = 1;
34
        for (int i = n - 1; i >= 0; --i) {
35
            result[i] *= suffix_product;
36
            suffix_product *= values[i];
37
        }
38
39
        // Output the result array
40
        for (int i = 0; i < n; ++i) {
41
            cout << result[i] << "" "";
42
        }
43
        cout << endl;
44
    }
45
    return 0;
46
}",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833942
1387833929,damodarryadav,unknown,unknown,"1
#include <iostream>
2
3
#include <vector>
4
5
#include <cmath> // For abs function
6
7
using namespace std;
8
9
int main() {
10
11
    int t; // Number of test cases
12
13
    cin >> t;
14
15
    while (t--) {
16
17
        int n; // Size of the array
18
19
        cin >> n;
20
21
        vector<int> nums(n);
22
23
        vector<long long> prefixSum(n); // Prefix sum array
24
25
        for (int i = 0; i < n; ++i) {
26
27
            cin >> nums[i];
28
29
            if (i == 0) {
30
31
                prefixSum[i] = nums[i];
32
33
            } else {
34
35
                prefixSum[i] = prefixSum[i - 1] + nums[i];
36
37
            }
38
39
        }
40
41
        long long totalSum = prefixSum[n - 1]; // Total sum of the array
42
43
        long long maxDifference = 0;
44
45
        // Iterate through possible partition points
46
47
        for (int i = 0; i < n - 1; ++i) {
48
49
            long long leftSum = prefixSum[i];
50
51
            long long rightSum = totalSum - leftSum;
52
53
            maxDifference = max(maxDifference, abs(leftSum - rightSum));
54
55
        }
56
57
        cout << maxDifference << endl;
58
59
    }
60
61
    return 0;
62
63
}",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833929
1387833932,smeetadeshra,unknown,unknown,"1
def compute_product_excluding_self(test_cases):
2
    results1 = []
3
    for t in range(test_cases):
4
        n = int(input())
5
        values = list(map(int, input().split()))
6
        7
        prefix = [1] * n
8
        suffix = [1] * n
9
        10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] * values[i - 1]
12
        13
        for i in range(n - 2, -1, -1):
14
            suffix[i] = suffix[i + 1] * values[i + 1]
15
        16
        result = [prefix[i] * suffix[i] for i in range(n)]
17
        results1.append("" "".join(map(str, result)))
18
    19
    print(""\n"".join(results1))
20
if __name__ == ""__main__"":
21
    T = int(input())
22
    compute_product_excluding_self(T)
23",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833932
1387833935,shruthika2720,unknown,unknown,"1
def maxAbsDifference(t, test_cases):
2
    results = []
3
    4
    for test_case in test_cases:
5
        n, nums = test_case
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        11
        for i in range(1, n):
12
            prefix_sum += nums[i - 1]
13
            left_sum = prefix_sum
14
            right_sum = total_sum - left_sum
15
            max_diff = max(max_diff, abs(left_sum - right_sum))
16
        17
        results.append(max_diff)
18
    19
    return results
20
21
22
t = int(input())  
23
test_cases = []
24
for _ in range(t):
25
    n = int(input())  
26
    nums = list(map(int, input().split()))  
27
    test_cases.append((n, nums))
28
29
30
results = maxAbsDifference(t, test_cases)
31
for result in results:
32
    print(result)
33",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833935
1387833923,shubhamgupta3009,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        try {
7
            Scanner scanner = new Scanner(System.in);
8
            int T = scanner.nextInt();
9
            10
            for (int t = 0; t < T; t++) {
11
                int N = scanner.nextInt();
12
                long K = scanner.nextLong();
13
                14
                long[] energy = new long[N];
15
                for (int i = 0; i < N; i++) {
16
                    energy[i] = scanner.nextLong();
17
                }
18
                19
                System.out.println(minOperationsToEqualize(N, K, energy));
20
            }
21
            scanner.close();
22
        } catch (Exception e) {
23
            return;
24
        }
25
    }
26
    27
    private static long minOperationsToEqualize(int N, long K, long[] energy) {
28
        try {
29
            if (N == 1) return 0;
30
            31
            long total = 0;
32
            boolean allSame = true;
33
            34
            for (int i = 1; i < N; i++) {
35
                if (energy[i] != energy[0]) {
36
                    allSame = false;
37
                    break;
38
                }
39
            }
40
            41
            if (allSame) return 0;
42
            43
            for (long e : energy) {
44
                total += e;
45
            }
46
            47
            if (total % N != 0) {
48
                return -1;
49
            }
50
            51
            long target = total / N;
52
            long[] diffs = new long[N];
53
            54
            for (int i = 0; i < N; i++) {
55
                diffs[i] = energy[i] - target;
56
                if (Math.abs(diffs[i]) % K != 0) {
57
                    return -1;
58
                }
59
            }
60
            61
            long operations = 0;
62
            long runningDiff = 0;
63
            64
            for (int i = 0; i < N - 1; i++) {
65
                runningDiff += diffs[i];
66
                if (runningDiff != 0) {
67
                    if (Math.abs(runningDiff) % K != 0) {
68
                        return -1;
69
                    }
70
                    operations += Math.abs(runningDiff) / K;
71
                }
72
            }
73
            74
            runningDiff += diffs[N-1];
75
            if (runningDiff != 0) {
76
                return -1;
77
            }
78
            79
            return operations;
80
        } catch (Exception e) {
81
            return -1;
82
        }
83
    }
84
}",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833923
1387833925,yashrajverma0805,unknown,unknown,"1
def max_subarray_difference(arr, n):
2
    # Calculate prefix sums array
3
    prefix_sum = [0] * (n + 1)
4
    for i in range(n):
5
        prefix_sum[i + 1] = prefix_sum[i] + arr[i]
6
    7
    max_diff = float('-inf')
8
    9
    # Try all possible partition points
10
    # For each partition point i, 
11
    # left subarray is [0:i] and right subarray is [i:n]
12
    for i in range(1, n):
13
        # Use prefix sums to get subarray sums in O(1)
14
        left_sum = prefix_sum[i] - prefix_sum[0]  # sum of arr[0:i]
15
        right_sum = prefix_sum[n] - prefix_sum[i]  # sum of arr[i:n]
16
        17
        # Calculate absolute difference
18
        diff = abs(left_sum - right_sum)
19
        max_diff = max(max_diff, diff)
20
    21
    return max_diff
22
23
def solve():
24
    # Read number of test cases
25
    t = int(input())
26
    27
    for _ in range(t):
28
        # Read array size
29
        n = int(input())
30
        31
        # Read array elements
32
        nums = list(map(int, input().split()))
33
        34
        # Calculate and print result
35
        result = max_subarray_difference(nums, n)
36
        print(result)
37
38
if __name__ == ""__main__"":
39
    solve()
40",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833925
1387833927,h1032220736,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        7
        int T = scanner.nextInt();  // Number of test cases
8
        9
        for (int t = 0; t < T; t++) {
10
            int n = scanner.nextInt();  // Number of nodes
11
            int[] values = new int[n];
12
            13
            // Reading the values of the nodes
14
            for (int i = 0; i < n; i++) {
15
                values[i] = scanner.nextInt();
16
            }
17
            18
            // Result array to store the final result
19
            int[] result = new int[n];
20
            21
            // Compute left product and store it in the result array
22
            int left = 1;
23
            for (int i = 0; i < n; i++) {
24
                result[i] = left;
25
                left *= values[i];
26
            }
27
            28
            // Compute right product and update the result array
29
            int right = 1;
30
            for (int i = n - 1; i >= 0; i--) {
31
                result[i] *= right;
32
                right *= values[i];
33
            }
34
            35
            // Print the result array
36
            for (int i = 0; i < n; i++) {
37
                System.out.print(result[i] + "" "");
38
            }
39
            System.out.println();
40
        }
41
        42
        scanner.close();
43
    }
44
}",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833927
1387833919,sohampatil1807,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    """"""
3
    Calculate minimum operations needed to equalize energy across stations.
4
    Returns -1 if impossible.
5
    """"""
6
    # Calculate total energy and check if equalization is possible
7
    total_energy = sum(energy)
8
    if total_energy % N != 0:
9
        return -1
10
        11
    target = total_energy // N
12
    13
    # If already equalized
14
    if all(e == target for e in energy):
15
        return 0
16
    17
    # Calculate needed transfers and check if possible
18
    operations = 0
19
    excess = 0  # Track running excess/deficit
20
    21
    for i in range(N):
22
        # Add current station's excess/deficit to running total
23
        excess += energy[i] - target
24
        25
        # If excess can't be transferred using K-unit operations
26
        if abs(excess) % K != 0:
27
            return -1
28
            29
        if excess != 0:
30
            operations += abs(excess) // K
31
    32
    # Check if we ended with zero excess (balanced transfers)
33
    if excess != 0:
34
        return -1
35
        36
    return operations
37
38
def main():
39
    T = int(input())
40
    for _ in range(T):
41
        N, K = map(int, input().split())
42
        energy = list(map(int, input().split()))
43
        print(min_operations_to_equalize(N, K, energy))
44
45
if __name__ == ""__main__"":
46
    main()
47",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833919
1387833921,devanshudandeka1,unknown,unknown,"1
def right():
2
    T = int(input())
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            print(-1)
11
            continue
12
        13
        target = total_energy // N
14
        operations = 0
15
        16
        for i in range(N):
17
            diff = energy[i] - target
18
            19
            if diff % K != 0:
20
                operations = -1
21
                break
22
                23
            # Move the energy to the next station
24
            if i < N - 1:
25
                energy[i + 1] += diff
26
            else:
27
                energy[0] += diff
28
            29
            operations += abs(diff) // K
30
        31
        print(operations)
32
33
right()   ",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833921
1387833918,abhig3340,unknown,unknown,"1
def product(test_cases):
2
    results = []
3
    4
    for values in test_cases:
5
        n = len(values)
6
        result = [1] * n
7
        8
        total_prod = 1
9
        for value in values:
10
            total_prod *= value
11
        12
        for i in range(n):
13
            result[i] = total_prod // values[i]
14
        15
        results.append(result)
16
    17
    return results
18
19
if __name__ == ""__main__"":
20
    T = int(input())
21
    test_cases = []
22
    23
    for _ in range(T):
24
        n = int(input())
25
        values = list(map(int, input().split()))
26
        test_cases.append(values)
27
    28
    results = product(test_cases)
29
    30
    for result in results:
31
        print("" "".join(map(str, result)))
32",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833918
1387833917,kamblesamruddhi2,unknown,unknown,"1
def solve():
2
    T = int(input())  
3
    for _ in range(T):
4
        N, K = map(int, input().split())  
5
        energy = list(map(int, input().split()))  
6
        7
        total_energy = sum(energy)
8
        9
       10
        if total_energy % N != 0:
11
            print(-1)
12
            continue
13
        14
        target_energy = total_energy // N
15
        operations = 0
16
        current_balance = 0
17
        18
        for i in range(N):
19
            20
            current_balance += energy[i] - target_energy
21
           22
            operations += abs(current_balance) // K
23
            24
            25
            if abs(current_balance) % K != 0:
26
                operations = -1
27
                break     
28
        print(operations)
29
30
solve()",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833917
1387833914,h1032220176,unknown,unknown,"1
def solve():
2
    t = int(raw_input())  
3
    for _ in range(t):
4
        n = int(raw_input()) 
5
        nums = map(int, raw_input().split())  
6
        7
        8
        total_sum = sum(nums)
9
        10
        11
        prefix_sum = 0
12
        max_diff = 0
13
        14
        15
        for i in range(n - 1):  
16
            prefix_sum += nums[i]
17
            suffix_sum = total_sum - prefix_sum
18
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
19
        20
        print max_diff
21
22
23
solve()
24",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833914
1387833913,sushanttiwari074,unknown,unknown,"1
def product_array(test_cases):
2
    results = []
3
    for values in test_cases:
4
        n = len(values)
5
        total_product = 1
6
        zero_count = values.count(0)
7
8
        for value in values:
9
            if value != 0:
10
                total_product *= value
11
12
        result = []
13
        for value in values:
14
            if zero_count > 1:
15
                result.append(0)
16
            elif zero_count == 1:
17
                result.append(total_product)
18
            else:
19
                result.append(total_product // value)
20
21
        results.append(result)
22
    23
    return results
24
25
import sys
26
27
input = sys.stdin.read
28
data = input().splitlines()
29
30
T = int(data[0])  
31
test_cases = []
32
33
index = 1
34
for _ in range(T):
35
    n = int(data[index])  
36
    index += 1
37
    values = list(map(int, data[index].split()))
38
    test_cases.append(values)
39
    index += 1
40
41
results = product_array(test_cases)
42
for res in results:
43
    print("" "".join(map(str, res)))
44",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833913
1387833915,goswamyashutosh9,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        # Check if total energy is divisible by N
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target = total_energy // N
16
        surplus = 0
17
        operations = 0
18
19
        for i in range(N):
20
            diff = energy[i] - target
21
            surplus += diff
22
23
            # If the surplus so far isn't divisible by K, it's impossible
24
            if surplus % K != 0:
25
                results.append(-1)
26
                break
27
28
            # Add the operations for this difference
29
            operations += abs(diff) // K
30
        else:
31
            # If loop completes without breaking, check the final surplus
32
            if surplus == 0:
33
                results.append(operations // 2)  # Divide by 2 to avoid double-counting
34
            else:
35
                results.append(-1)
36
37
    return results
38
39
40
# Input Reading
41
def main():
42
    T = int(input().strip())
43
    test_cases = []
44
45
    for _ in range(T):
46
        # Read N and K
47
        N, K = map(int, input().strip().split())
48
        # Read energy array
49
        energy = list(map(int, input().strip().split()))
50
        test_cases.append(((N, K), energy))
51
52
    # Compute Results
53
    results = min_operations_to_equalize_energy(T, test_cases)
54
55
    # Output Results
56
    for res in results:
57
        print(res)
58
59
60
# Run the program
61
if __name__ == ""__main__"":
62
    main()
63",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833915
1387833909,h1032220754,unknown,unknown,"1
def min_operations_to_equalize(test_cases):
2
    results = []
3
    for n, k, energy in test_cases:
4
        total_energy = sum(energy)
5
6
        if total_energy % n != 0:
7
            results.append(-1)
8
            continue
9
10
        target = total_energy // n
11
        diff = 0
12
        operations = 0
13
14
        for e in energy:
15
            diff += e - target
16
            if diff % k != 0:
17
                results.append(-1)
18
                break
19
            operations += abs(diff) // k
20
        else:
21
            results.append(operations)
22
23
    return results
24
25
def main():
26
    T = int(input())
27
    test_cases = []
28
29
    for _ in range(T):
30
        n, k = map(int, input().split())
31
        energy = list(map(int, input().split()))
32
        test_cases.append((n, k, energy))
33
34
    results = min_operations_to_equalize(test_cases)
35
    for res in results:
36
        print(res)
37
38
if __name__ == ""__main__"":
39
    main()",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833909
1387833911,shrikrushna07,unknown,unknown,"1
def equalize_energy(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
        8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        imbalance = 0
15
        operations = 0
16
        possible = True
17
        18
        for i in range(N):
19
            imbalance += energy[i] - target
20
            if imbalance % K != 0:
21
                possible = False
22
                break
23
            operations += abs(imbalance) // K
24
        25
        results.append(operations if possible else -1)
26
    27
    return results
28
29
T = int(input())
30
test_cases = []
31
32
for _ in range(T):
33
    N, K = map(int, input().split())
34
    energy = list(map(int, input().split()))
35
    test_cases.append(((N, K), energy))
36
37
results = equalize_energy(T, test_cases)
38
39
for result in results:
40
    print(result)
41",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833911
1387833907,h1032220108,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for t in range(test_cases):
4
        n = int(input())  
5
        nums = list(map(int, input().split()))
6
        prefix_sum = [0] * n
7
        prefix_sum[0] = nums[0]
8
        for i in range(1, n):
9
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
10
        total_sum = prefix_sum[-1]
11
        12
        max_difference = 0
13
        for i in range(n - 1):
14
            left_sum = prefix_sum[i]
15
            right_sum = total_sum - left_sum
16
            max_difference = max(max_difference, abs(left_sum - right_sum))
17
        18
        results.append(max_difference)
19
    for result in results:
20
        print(result)
21
t = int(input())  
22
max_absolute_difference(t)
23",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833907
1387833901,suryampandey5942,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <tuple>
4
#include <cmath>
5
using namespace std;
6
7
// Function to calculate minimum operations to equalize
8
vector<int> minimum_operations_to_equalize(vector<tuple<int, int, vector<int>>> test_cases) {
9
    vector<int> results;
10
11
    for (auto &t : test_cases) {
12
        int N, K;
13
        vector<int> energy;
14
        tie(N, K, energy) = t;
15
16
        long long total_energy = 0;
17
        for (int e : energy) {
18
            total_energy += e;
19
        }
20
21
        // Check if equalization is possible
22
        if (total_energy % N != 0) {
23
            results.push_back(-1);
24
            continue;
25
        }
26
27
        int target = total_energy / N;
28
        vector<int> diffs(N);
29
        for (int i = 0; i < N; i++) {
30
            diffs[i] = energy[i] - target;
31
        }
32
33
        // Check if all differences are divisible by K
34
        bool possible = true;
35
        for (int diff : diffs) {
36
            if (diff % K != 0) {
37
                possible = false;
38
                break;
39
            }
40
        }
41
42
        if (!possible) {
43
            results.push_back(-1);
44
            continue;
45
        }
46
47
        // Calculate minimum operations
48
        long long operations = 0;
49
        long long imbalance = 0;
50
51
        for (int diff : diffs) {
52
            imbalance += diff / K;
53
            operations += abs(imbalance);
54
        }
55
56
        results.push_back(operations);
57
    }
58
59
    return results;
60
}
61
62
int main() {
63
    int T;
64
    cin >> T;
65
66
    vector<tuple<int, int, vector<int>>> test_cases;
67
68
    for (int t = 0; t < T; t++) {
69
        int N, K;
70
        cin >> N >> K;
71
        vector<int> energy(N);
72
        for (int i = 0; i < N; i++) {
73
            cin >> energy[i];
74
        }
75
        test_cases.emplace_back(N, K, energy);
76
    }
77
78
    vector<int> results = minimum_operations_to_equalize(test_cases);
79
80
    for (int res : results) {
81
        cout << res << endl;
82
    }
83
84
    return 0;
85
}
86",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833901
1387833902,adityapatil1306,unknown,unknown,"1
T = int(input())
2
3
for _ in range(T):
4
    n = int(input())
5
    values = list(map(int, input().split()))
6
7
    result = [0] * n
8
    total_product = 1
9
    zero_count = 0
10
11
    for value in values:
12
        if value == 0:
13
            zero_count += 1
14
        else:
15
            total_product *= value
16
17
    for i in range(n):
18
        if zero_count > 1:
19
            result[i] = 0
20
        elif zero_count == 1:
21
            if values[i] == 0:
22
                result[i] = total_product
23
            else:
24
                result[i] = 0
25
        else:
26
            result[i] = total_product // values[i]
27
28
    print("" "".join(map(str, result)))
29",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833902
1387833904,h1032231332,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    for _ in range(T):
4
        N, K = map(int, input().split())  # N is the number of stations, K is the energy per transfer
5
        energy = list(map(int, input().split()))  # List of energy levels
6
        7
        total_energy = sum(energy)
8
        9
        # If total energy is not divisible by N, it's impossible to equalize
10
        if total_energy % N != 0:
11
            print(-1)
12
            continue
13
        14
        target_energy = total_energy // N
15
        operations = 0
16
        current_balance = 0
17
        18
        for i in range(N):
19
            # Calculate the difference from target energy for the current station
20
            current_balance += energy[i] - target_energy
21
            # The number of operations required is how much imbalance has been accumulated
22
            operations += abs(current_balance) // K
23
            24
            # If at any point, the imbalance isn't divisible by K, return -1
25
            if abs(current_balance) % K != 0:
26
                operations = -1
27
                break
28
        29
        print(operations)
30
31
# Call the function to run the solution
32
solve()",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833904
1387833898,omg40787,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K = case[0]
6
        energies = case[1]
7
8
        # Calculate total energy
9
        total_energy = sum(energies)
10
11
        # If total energy is not divisible by N, return -1
12
        if total_energy % N != 0:
13
            results.append(-1)
14
            continue
15
16
        # Target energy for each station
17
        target_energy = total_energy // N
18
19
        # Initialize variables to calculate operations
20
        operations = 0
21
        balance = 0
22
23
        # Traverse each station and calculate operations
24
        for energy in energies:
25
            balance += energy - target_energy
26
            if balance % K != 0:
27
                operations = -1
28
                break
29
            operations += abs(balance) // K
30
31
        results.append(operations)
32
33
    return results
34
35
# Example usage:
36
test_cases = [
37
    ((3, 2), [4, 4, 4]),
38
    ((3, 1), [5, 3, 4]),
39
    ((4, 3), [5, 5, 5, 6])
40
]
41
42
results = equalize_energy(test_cases)
43
for result in results:
44
    print(result)
45",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833898
1387833888,singhark94,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <cmath>
5
using namespace std;
6
7
int minOperationsToEqualizeEnergy(const vector<int>& energy, int N, int K) {
8
    long long total_energy = accumulate(energy.begin(), energy.end(), 0LL);
9
    if (total_energy % N != 0) return -1;  // If total energy is not divisible by N, it's impossible
10
    11
    long long target = total_energy / N;
12
    long long operations = 0;
13
    long long current_sum = 0;
14
    15
    for (int i = 0; i < N; ++i) {
16
        current_sum += energy[i] - target;
17
        if (current_sum % K != 0) return -1; // Check if it's possible to transfer K units
18
        19
        operations += abs(current_sum / K);
20
    }
21
    return operations;
22
}
23
24
int main() {
25
    int T;
26
    cin >> T;
27
    while (T--) {
28
        int N, K;
29
        cin >> N >> K;
30
        vector<int> energy(N);
31
        for (int i = 0; i < N; ++i) {
32
            cin >> energy[i];
33
        }
34
        cout << minOperationsToEqualizeEnergy(energy, N, K) << endl;
35
    }
36
    return 0;
37
}
38
39",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833888
1387833892,h1032221373,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt(); // Number of test cases
8
        9
        while (T-- > 0) {
10
            int N = scanner.nextInt(); // Number of power stations
11
            int K = scanner.nextInt(); // Energy transfer per operation
12
            int[] energy = new int[N];
13
            14
            long totalEnergy = 0; // Use long to avoid overflow
15
            16
            // Read the energy levels and calculate the total energy
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextInt();
19
                totalEnergy += energy[i];
20
            }
21
            22
            // Check if total energy is divisible by N
23
            if (totalEnergy % N != 0) {
24
                System.out.println(-1);
25
                continue;
26
            }
27
            28
            long target = totalEnergy / N; // Target energy per station
29
            long imbalance = 0, operations = 0;
30
            boolean possible = true;
31
            32
            for (int i = 0; i < N; i++) {
33
                // Calculate the difference from the target
34
                imbalance += energy[i] - target;
35
                36
                // If the imbalance is not a multiple of K, it's not possible to balance
37
                if (Math.abs(imbalance) % K != 0) {
38
                    possible = false;
39
                    break;
40
                }
41
                42
                // Count operations required to fix imbalance
43
                operations += Math.abs(imbalance) / K;
44
            }
45
            46
            // If balancing is possible, print the operations; otherwise, -1
47
            System.out.println(possible ? operations : -1);
48
        }
49
        50
        scanner.close();
51
    }
52
}
53",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833892
1387833893,h1032221062,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
4
    for test_case in test_cases:
5
        N, K, energy = test_case
6
        total_energy = sum(energy)
7
8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target = total_energy // N
14
        transfers = 0
15
        imbalance = 0
16
17
        # Calculate imbalance and transfers needed
18
        for i in range(N):
19
            imbalance += energy[i] - target
20
            if imbalance % K != 0:
21
                results.append(-1)
22
                break
23
            transfers += abs(imbalance) // K
24
        else:
25
            results.append(transfers)
26
27
    return results
28
29
30
# Input reading
31
T = int(input())  # Number of test cases
32
test_cases = []
33
34
for _ in range(T):
35
    N, K = map(int, input().split())
36
    energy = list(map(int, input().split()))
37
    test_cases.append((N, K, energy))
38
39
# Process test cases
40
results = min_operations_to_equalize(T, test_cases)
41
42
# Output results
43
for result in results:
44
    print(result)",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833893
1387833883,h1032221046,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
4
    for test_case in test_cases:
5
        n, nums = test_case
6
        left_sum = [0] * n
7
        right_sum = [0] * n
8
9
        # Calculate prefix sums (left to right)
10
        left_sum[0] = nums[0]
11
        for i in range(1, n):
12
            left_sum[i] = left_sum[i - 1] + nums[i]
13
14
        # Calculate suffix sums (right to left)
15
        right_sum[n - 1] = nums[n - 1]
16
        for i in range(n - 2, -1, -1):
17
            right_sum[i] = right_sum[i + 1] + nums[i]
18
19
        # Compute the maximum absolute difference
20
        max_diff = 0
21
        for i in range(0, n - 1):
22
            left = left_sum[i]
23
            right = right_sum[i + 1]
24
            max_diff = max(max_diff, abs(left - right))
25
26
        results.append(max_diff)
27
28
    return results
29
30
31
# Input reading
32
t = int(input())  # Number of test cases
33
test_cases = []
34
35
for _ in range(t):
36
    n = int(input())
37
    nums = list(map(int, input().split()))
38
    test_cases.append((n, nums))
39
40
# Process each test case
41
results = max_absolute_difference(t, test_cases)
42
43
# Output results
44
for result in results:
45
    print(result)
46",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833883
1387833884,h1032220685,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, values = case
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [1] * n
9
10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result array
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Process and print the output
37
output = product_except_self(test_cases)
38
for res in output:
39
    print("" "".join(map(str, res)))",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833884
1387833887,ng873042,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
3
    total_energy = sum(energy)
4
5
    # Step 1: Check if equal distribution is possible
6
7
    if total_energy % N != 0:
8
9
        return -1
10
11
    target = total_energy // N
12
13
    operations = 0
14
15
    # Step 2: Compute required transfers
16
17
    for e in energy:
18
19
        diff = e - target
20
21
        if diff % K != 0:
22
23
            return -1
24
25
        if diff > 0:
26
27
            operations += diff // K  # Count only positive transfers
28
29
    return operations
30
31
# Read input
32
33
T = int(input())  # Number of test cases
34
35
for _ in range(T):
36
37
    N, K = map(int, input().split())  # Read N and K
38
39
    energy = list(map(int, input().split()))  # Read energy array
40
41
    print(min_operations_to_equalize(N, K, energy))  # Print result",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833887
1387833877,gauravr6012,unknown,unknown,"1
def solve():
2
    import sys
3
    data = sys.stdin.read().strip().split()
4
    t = int(data[0])
5
    idx = 1
6
7
    for _ in range(t):
8
        n = int(data[idx]); idx += 1
9
        nums = list(map(int, data[idx:idx+n]))
10
        idx += n
11
        12
        total_sum = sum(nums)
13
        14
        prefix_sum = 0
15
        max_diff = 0
16
17
        for i in range(n - 1):
18
            prefix_sum += nums[i]
19
            diff = abs(2 * prefix_sum - total_sum)
20
            if diff > max_diff:
21
                max_diff = diff
22
        23
        print(max_diff)
24
25
solve()",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833877
1387833878,swayam_prajapat1,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):  
2
    results = []  
3
    4
    for case in test_cases:  
5
        N, K = case[0]  
6
        energy = case[1]  
7
8
        total_energy = sum(energy)  
9
10
        # Check if total energy is divisible by N  
11
        if total_energy % N != 0:  
12
            results.append(-1)  
13
            continue  
14
        15
        target_energy = total_energy // N  
16
        surplus = 0  
17
        deficit = 0  
18
        19
        # Calculate total surplus and deficit  
20
        for e in energy:  
21
            if e > target_energy:  
22
                surplus += (e - target_energy)  
23
            elif e < target_energy:  
24
                deficit += (target_energy - e)  
25
26
        # Check if both surplus and deficit are divisible by K for equalization  
27
        if surplus % K != 0 or deficit % K != 0:  
28
            results.append(-1)  
29
            continue  
30
        31
        # Calculate the number of operations needed  
32
        operations = surplus // K  
33
34
        # Add to results  
35
        results.append(operations)  
36
    37
    return results  
38
39
# Read input and execute the function  
40
import sys  
41
42
# Use sys.stdin.read to handle input in one go  
43
input_data = sys.stdin.read().strip().splitlines()  
44
T = int(input_data[0])  
45
test_cases = []  
46
47
for i in range(1, len(input_data), 2):  
48
    N, K = map(int, input_data[i].split())  
49
    energy = list(map(int, input_data[i + 1].split()))  
50
    test_cases.append(((N, K), energy))  
51
52
# Get results and print  
53
results = min_operations_to_equalize(T, test_cases)  
54
55
for result in results:  
56
    print(result)",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833878
1387833879,cooljaychaudhary,unknown,unknown,"1
def max_absolute_difference():
2
    t = int(input())
3
    results = []
4
    5
    for _ in range(t):
6
        n = int(input())
7
        nums = list(map(int, input().split()))
8
        9
        prefix = [0] * (n + 1)
10
        for i in range(n):
11
            prefix[i + 1] = prefix[i] + nums[i]
12
        13
        max_diff = 0
14
        for i in range(1, n):
15
            left_sum = prefix[i]
16
            right_sum = prefix[n] - left_sum
17
            max_diff = max(max_diff, abs(left_sum - right_sum))
18
        19
        results.append(max_diff)
20
    21
    print(""\n"".join(map(str, results)))
22
23
max_absolute_difference()
24",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833879
1387833873,vigneshalle16,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
        8
        # Total energy and check divisibility
9
        total_energy = sum(energy)
10
        if total_energy % N != 0:
11
            results.append(-1)
12
            continue
13
        14
        target_energy = total_energy // N
15
        accumulated_flow = 0
16
        operations = 0
17
        possible = True
18
        19
        for e in energy:
20
            diff = e - target_energy
21
            accumulated_flow += diff
22
            23
            # Check if accumulated_flow is divisible by K
24
            if accumulated_flow % K != 0:
25
                possible = False
26
                break
27
            28
            # Add absolute value of accumulated_flow to operations
29
            operations += abs(accumulated_flow)
30
        31
        if possible:
32
            results.append(operations // K)
33
        else:
34
            results.append(-1)
35
    36
    return results
37
38
39
# Input processing
40
T = int(input())
41
test_cases = []
42
43
for _ in range(T):
44
    N, K = map(int, input().split())
45
    energy = list(map(int, input().split()))
46
    test_cases.append(((N, K), energy))
47
48
# Get results
49
results = minimum_operations_to_equalize(T, test_cases)
50
51
# Output results
52
for res in results:
53
    print(res)
54",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833873
1387833869,adityapatil1306,unknown,unknown,"1
def minimum_operations(T, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K, energy = case
6
        total_energy = sum(energy)
7
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
12
        target_energy = total_energy // N
13
        transfer_needed = 0
14
15
        prefix_sum = 0
16
        possible = True
17
18
        for e in energy:
19
            prefix_sum += (e - target_energy)
20
            if prefix_sum % K != 0:
21
                possible = False
22
                break
23
            transfer_needed += abs(prefix_sum // K)
24
25
        if not possible:
26
            results.append(-1)
27
        else:
28
            results.append(transfer_needed)
29
30
    return results
31
32
T = int(input())
33
test_cases = []
34
35
for _ in range(T):
36
    N, K = map(int, input().split())
37
    energy = list(map(int, input().split()))
38
    test_cases.append((N, K, energy))
39
40
results = minimum_operations(T, test_cases)
41
for res in results:
42
    print(res)
43",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833869
1387833870,siddhantpal9082,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target_energy = total_energy // N
8
    operations = 0
9
    carry = 0
10
    11
    for i in range(N):
12
        diff = energy[i] + carry - target_energy
13
        14
        if diff % K != 0:
15
            return -1
16
        17
        carry = diff // K
18
        operations += abs(carry)
19
    20
    return operations
21
22
def solve():
23
    T = int(input())  
24
    for _ in range(T):
25
        N, K = map(int, input().split())  
26
        energy = list(map(int, input().split()))  
27
        print(min_operations_to_equalize(N, K, energy))
28
29
solve()
30",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833870
1387833871,shubhamgupta3009,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt();
8
        9
        for (int t = 0; t < T; t++) {
10
            int N = scanner.nextInt();
11
            int K = scanner.nextInt();
12
            13
            int[] energy = new int[N];
14
            for (int i = 0; i < N; i++) {
15
                energy[i] = scanner.nextInt();
16
            }
17
            18
            System.out.println(minOperationsToEqualize(N, K, energy));
19
        }
20
        scanner.close();
21
    }
22
    23
    private static long minOperationsToEqualize(int N, int K, int[] energy) {
24
        HashSet<Integer> uniqueValues = new HashSet<>();
25
        long total = 0;
26
        27
        for (int e : energy) {
28
            uniqueValues.add(e);
29
            total += e;
30
        }
31
        32
        if (uniqueValues.size() == 1) {
33
            return 0;
34
        }
35
        36
        if (total % N != 0) {
37
            return -1;
38
        }
39
        40
        int target = (int)(total / N);
41
        long[] diffs = new long[N];
42
        43
        for (int i = 0; i < N; i++) {
44
            diffs[i] = energy[i] - target;
45
            if (Math.abs(diffs[i]) % K != 0) {
46
                return -1;
47
            }
48
        }
49
        50
        long operations = 0;
51
        long runningDiff = 0;
52
        53
        for (int i = 0; i < N - 1; i++) {
54
            runningDiff += diffs[i];
55
            if (runningDiff != 0) {
56
                if (Math.abs(runningDiff) % K != 0) {
57
                    return -1;
58
                }
59
                operations += Math.abs(runningDiff) / K;
60
            }
61
        }
62
        63
        runningDiff += diffs[N-1];
64
        if (runningDiff != 0) {
65
            return -1;
66
        }
67
        68
        return operations;
69
    }
70
}",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833871
1387833867,damodarryadav,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric> // For accumulate function
4
#include <cmath>   // For abs function
5
using namespace std;
6
int main() {
7
    int T; // Number of test cases
8
    cin >> T;
9
    while (T--) {
10
        int N, K;
11
        cin >> N >> K;
12
        vector<int> energy(N);
13
        long long totalEnergy = 0;
14
        for (int i = 0; i < N; ++i) {
15
            cin >> energy[i];
16
            totalEnergy += energy[i];
17
        }
18
        // Check if equalization is possible
19
        if (totalEnergy % N != 0) {
20
            cout << -1 << endl; // Impossible to equalize
21
            continue;
22
        }
23
        long long targetEnergy = totalEnergy / N;
24
        long long balance = 0; // Cumulative balance
25
        long long operations = 0;
26
        bool possible = true;
27
        for (int i = 0; i < N; ++i) {
28
            long long diff = energy[i] - targetEnergy; // Difference at current station
29
            balance += diff; // Maintain cumulative balance
30
            31
            // Check if the imbalance at this point is resolvable in multiples of K
32
            if (abs(balance) % K != 0) {
33
                possible = false;
34
                break;
35
            }
36
            37
            operations += abs(balance); // Add to total operations
38
        }
39
        if (possible && operations % K == 0) {
40
            cout << operations / K << endl;
41
        } else {
42
            cout << -1 << endl;
43
        }
44
    }
45
    return 0;
46
}
47",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833867
1387833865,snehakumari2323,unknown,unknown,"1
def solve_testcase(N, K, energy):
2
    # Calculate total energy and target
3
    total_energy = sum(energy)
4
    5
    # Check if equal distribution is possible
6
    if total_energy % N != 0:
7
        return -1
8
    9
    target = total_energy // N
10
    11
    # If already equalized
12
    if all(e == target for e in energy):
13
        return 0
14
    15
    # For each position, calculate how many transfers are needed
16
    total_transfers = 0
17
    excess = 0  # Keep track of excess/deficit as we go around the circle
18
    19
    for i in range(N):
20
        # Current position's excess/deficit including previous remainder
21
        curr_with_excess = energy[i] + excess
22
        23
        # How far are we from target at this position
24
        diff_from_target = curr_with_excess - target
25
        26
        # This difference will need to be transferred to next position
27
        excess = diff_from_target
28
        29
        # If we need to make transfers
30
        if diff_from_target != 0:
31
            # If we can't transfer in K-unit chunks
32
            if abs(diff_from_target) % K != 0:
33
                return -1
34
                35
            # Add number of K-unit transfers needed
36
            total_transfers += abs(diff_from_target) // K
37
    38
    # After going around the circle, if there's any remainder, it's impossible
39
    if excess != 0:
40
        return -1
41
        42
    return total_transfers
43
44
def main():
45
    # Read number of test cases
46
    T = int(input())
47
    48
    # Process each test case
49
    for _ in range(T):
50
        # Read N and K
51
        N, K = map(int, input().split())
52
        53
        # Read energy array
54
        energy = list(map(int, input().split()))
55
        56
        # Solve current test case
57
        result = solve_testcase(N, K, energy)
58
        59
        # Print result
60
        print(result)
61
62
if __name__ == ""__main__"":
63
    main()",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833865
1387833868,h1032220289,unknown,unknown,"1
def main():
2
    T = int(input())  
3
    for _ in range(T):
4
        n = int(input())  
5
        values = list(map(int, input().split())) 
6
        7
        result = [1] * n
8
        9
        left_product = 1
10
        for i in range(n):
11
            result[i] = left_product
12
            left_product *= values[i]
13
        14
        right_product = 1
15
        for i in range(n-1, -1, -1):
16
            result[i] *= right_product
17
            right_product *= values[i]
18
        19
        print("" "".join(map(str, result)))
20
21
main()",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833868
1387833860,h1032221356,unknown,unknown,"1
def max_absolute_difference():
2
    t = int(input())  
3
    results = []
4
    5
    for _ in range(t):
6
        n = int(input())  
7
        nums = list(map(int, input().split()))
8
        9
        10
        prefix = [0] * (n + 1)
11
        for i in range(n):
12
            prefix[i + 1] = prefix[i] + nums[i]
13
        14
        15
        max_diff = 0
16
        for i in range(1, n): 
17
            left_sum = prefix[i]
18
            right_sum = prefix[n] - left_sum
19
            max_diff = max(max_diff, abs(left_sum - right_sum))
20
        21
        results.append(max_diff)
22
    23
    # Output all results
24
    print(""\n"".join(map(str, results)))
25
26
# Call the function
27
max_absolute_difference()
28",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833860
1387833861,karmakarsanket98,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        N, K = test_cases[t][:2]
6
        energy = test_cases[t][2]
7
        8
        total_energy = sum(energy)
9
        10
        # If total energy is not divisible by N, it's impossible to equalize
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target_energy = total_energy // N
16
        balance = 0  # Tracks accumulated energy to transfer
17
        operations = 0
18
        19
        # Calculate excess/deficit and operations
20
        for e in energy:
21
            balance += e - target_energy
22
            if balance % K != 0:
23
                results.append(-1)
24
                break
25
            operations += abs(balance) // K
26
        else:
27
            results.append(operations)
28
    29
    return results
30
31
32
# Input
33
T = int(input())
34
test_cases = []
35
for _ in range(T):
36
    N, K = map(int, input().split())
37
    energy = list(map(int, input().split()))
38
    test_cases.append((N, K, energy))
39
40
# Compute and output results
41
results = min_operations_to_equalize(T, test_cases)
42
for result in results:
43
    print(result)
44",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833861
1387833862,shubhamgupta3009,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt();
8
        9
        for (int t = 0; t < T; t++) {
10
            int N = scanner.nextInt();
11
            int K = scanner.nextInt();
12
            13
            int[] energy = new int[N];
14
            long totalEnergy = 0;
15
            int maxEnergy = 0;
16
            int minEnergy = Integer.MAX_VALUE;
17
            18
            for (int i = 0; i < N; i++) {
19
                energy[i] = scanner.nextInt();
20
                totalEnergy += energy[i];
21
                maxEnergy = Math.max(maxEnergy, energy[i]);
22
                minEnergy = Math.min(minEnergy, energy[i]);
23
            }
24
            25
            if (totalEnergy % N != 0) {
26
                System.out.println(-1);
27
                continue;
28
            }
29
            30
            int targetEnergy = (int)(totalEnergy / N);
31
            int operations = 0;
32
            33
            if (maxEnergy == minEnergy) {
34
                System.out.println(0);
35
                continue;
36
            }
37
            38
            boolean possible = true;
39
            for (int i = 0; i < N && possible; i++) {
40
                int diff = Math.abs(energy[i] - targetEnergy);
41
                if (diff % K != 0) {
42
                    possible = false;
43
                }
44
                operations += diff / K;
45
            }
46
            47
            operations = operations / 2;
48
            System.out.println(possible ? operations : -1);
49
        }
50
        scanner.close();
51
    }
52
}",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833862
1387833858,arpit21345j,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        for i in range(n - 1):  
11
            prefix_sum += nums[i]
12
            suffix_sum = total_sum - prefix_sum
13
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
14
        15
        results.append(max_diff)
16
    17
    return results
18
19
20
t = int(input())
21
test_cases = []
22
23
for _ in range(t):
24
    n = int(input())
25
    nums = list(map(int, input().split()))
26
    test_cases.append((n, nums))
27
28
results = max_absolute_difference(test_cases)
29
30
for res in results:
31
    print(res)",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833858
1387833852,vivaankotian1,unknown,unknown,"1
def compute_product_excluding_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        total_product = 1
6
        zero_count = values.count(0)
7
8
        if zero_count > 1:
9
            results.append([0] * n)
10
        elif zero_count == 1:
11
            zero_index = values.index(0)
12
            product_except_zero = 1
13
            for i in range(n):
14
                if i != zero_index:
15
                    product_except_zero *= values[i]
16
            result = [0] * n
17
            result[zero_index] = product_except_zero
18
            results.append(result)
19
        else:
20
            for value in values:
21
                total_product *= value
22
            results.append([total_product // value for value in values])
23
24
    return results
25
26
T = int(input())
27
test_cases = [(int(input()), list(map(int, input().split()))) for _ in range(T)]
28
results = compute_product_excluding_self(test_cases)
29
for result in results:
30
    print(*result)",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833852
1387833856,harshpal0050,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833856
1387833857,h1032220278,unknown,unknown,"1
def readinput():
2
    return list(map(int, input().split()))
3
        4
5
def calproduct(values):
6
    res=[]
7
    product=1
8
    for i in range(len(values)):
9
        product*=values[i]
10
    for j in range(len(values)):
11
        res.append(product//values[j])
12
    return res
13
testcases=int(input())
14
for i in range(testcases):
15
    n=int(input())
16
    values=readinput()
17
    result = calproduct(values)
18
    print("" "".join(map(str, result)))
19
    20
    21
                   ",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833857
1387833846,tiwarishashank14,unknown,unknown,"1
import java.util.Scanner;
2
3
public class EnergyEqualizer {
4
5
    public static void solve() {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt();  // Read number of test cases
8
9
        while (T-- > 0) {
10
            int N = scanner.nextInt();  // Number of power stations
11
            int K = scanner.nextInt();  // Transfer units in one operation
12
            13
            long[] energy = new long[N];
14
            long totalEnergy = 0;
15
16
            // Read energy values and compute total energy
17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextLong();
19
                totalEnergy += energy[i];
20
            }
21
22
            // Check if equalizing is possible (total energy must be divisible by N)
23
            if (totalEnergy % N != 0) {
24
                System.out.println(""-1"");
25
                continue;  // Skip to the next test case if it's impossible
26
            }
27
28
            long targetEnergy = totalEnergy / N;
29
            long operations = 0;
30
            long balance = 0;
31
            boolean possible = true;  // To track if balancing is possible
32
33
            // Iterate over the energy array to compute the minimum operations
34
            for (int i = 0; i < N; i++) {
35
                balance += energy[i] - targetEnergy;
36
37
                // Check if the balance is divisible by K
38
                if (balance % K != 0) {
39
                    possible = false;  // Impossible if balance is not divisible by K
40
                    break;
41
                }
42
43
                // Add the absolute value of the balance divided by K to operations count
44
                operations += Math.abs(balance) / K;
45
            }
46
47
            if (possible) {
48
                System.out.println(operations);  // Print the number of operations if it's possible
49
            } else {
50
                System.out.println(""-1"");  // Print -1 if balancing is not possible
51
            }
52
        }
53
        scanner.close();  // Close the scanner
54
    }
55
56
    public static void main(String[] args) {
57
        solve();  // Call the solve function to process the input and solve the problem
58
    }
59
}
60",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833846
1387833851,h1032220703,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        7
        int T = scanner.nextInt();  // Number of test cases
8
        9
        for (int t = 0; t < T; t++) {
10
            int n = scanner.nextInt();  // Number of nodes
11
            int[] values = new int[n];
12
            13
            // Reading the values of the nodes
14
            for (int i = 0; i < n; i++) {
15
                values[i] = scanner.nextInt();
16
            }
17
            18
            // Result array to store the final result
19
            int[] result = new int[n];
20
            21
            // Compute left product and store it in the result array
22
            int left = 1;
23
            for (int i = 0; i < n; i++) {
24
                result[i] = left;
25
                left *= values[i];
26
            }
27
            28
            // Compute right product and update the result array
29
            int right = 1;
30
            for (int i = n - 1; i >= 0; i--) {
31
                result[i] *= right;
32
                right *= values[i];
33
            }
34
            35
            // Print the result array
36
            for (int i = 0; i < n; i++) {
37
                System.out.print(result[i] + "" "");
38
            }
39
            System.out.println();
40
        }
41
        42
        scanner.close();
43
    }
44
}
45",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833851
1387833850,arshiyak572,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def max_absolute_difference(t, test_cases):
3
    results = []
4
    for i in range(t):
5
        n, nums = test_cases[i]
6
        7
        # Compute the total sum of the array
8
        total_sum = sum(nums)
9
        10
        # Initialize the prefix sum
11
        prefix_sum = 0
12
        max_diff = 0
13
        14
        # Iterate through the array to calculate max absolute difference
15
        for j in range(n - 1):
16
            prefix_sum += nums[j]  # Update prefix sum with current element
17
            # Calculate the sum of the second subarray
18
            second_subarray_sum = total_sum - prefix_sum
19
            # Calculate the absolute difference
20
            max_diff = max(max_diff, abs(prefix_sum - second_subarray_sum))
21
        22
        results.append(max_diff)
23
    24
    return results
25
26
# Read inputs
27
t = int(input())  # Number of test cases
28
test_cases = []
29
for _ in range(t):
30
    n = int(input())  # Size of the array
31
    nums = list(map(int, input().split()))  # Array elements
32
    test_cases.append((n, nums))
33
34
# Get the result
35
results = max_absolute_difference(t, test_cases)
36
37
# Print the results
38
for result in results:
39
    print(result)
40",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833850
1387833842,vishal986958,unknown,unknown,"1
def min_operations_to_equalize_energy(n, k, energy):
2
    total_energy = sum(energy)
3
    if total_energy % n != 0:
4
        return -1
5
    6
    target_energy = total_energy // n
7
    ops = 0
8
    9
    for i in range(n):
10
        energy_diff = energy[i] - target_energy
11
        if energy_diff % k != 0:
12
            return -1
13
        ops += abs(energy_diff // k)
14
    15
    return ops // 2
16
17
# Read number of test cases
18
T = int(input())
19
for _ in range(T):
20
    n, k = map(int, input().split())
21
    energy = list(map(int, input().split()))
22
    result = min_operations_to_equalize_energy(n, k, energy)
23
    print(result)
24",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833842
1387833843,h1032220149,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    4
    for _ in range(T):
5
        N, K = map(int, input().split())  # N is the number of stations, K is the energy per move
6
        energy = list(map(int, input().split()))  # Energy in each station
7
        8
        total_energy = sum(energy)
9
        10
        # If the total energy is not divisible by N, it's impossible
11
        if total_energy % N != 0:
12
            print(-1)
13
            continue
14
        15
        target_energy = total_energy // N
16
        operations = 0
17
        balance = 0  # This keeps track of the ""extra"" energy or deficit
18
        19
        # Try to balance the energy across the stations
20
        for i in range(N):
21
            # The difference from the target energy at this station
22
            diff = energy[i] - target_energy
23
            balance += diff
24
            # The balance must be divisible by K, otherwise it's impossible to transfer energy in multiples of K
25
            if balance % K != 0:
26
                operations = -1
27
                break
28
            # Count how many moves are needed (each move transfers K units)
29
            operations += abs(balance // K)
30
        31
        print(operations)
32
33
# Read input and process the test cases
34
solve()",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833843
1387833844,singhark94,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
vector<long long> productExceptSelf(const vector<int>& values, int n) {
6
    vector<long long> result(n, 1);
7
    8
    long long left = 1;
9
    for (int i = 0; i < n; ++i) {
10
        result[i] = left;
11
        left *= values[i];
12
    }
13
    14
    long long right = 1;
15
    for (int i = n - 1; i >= 0; --i) {
16
        result[i] *= right;
17
        right *= values[i];
18
    }
19
    20
    return result;
21
}
22
23
int main() {
24
    int T;
25
    cin >> T;
26
    27
    while (T--) {
28
        int n;
29
        cin >> n;
30
        vector<int> values(n);
31
        32
        for (int i = 0; i < n; ++i) {
33
            cin >> values[i];
34
        }
35
        36
        vector<long long> result = productExceptSelf(values, n);
37
        38
        for (int i = 0; i < n; ++i) {
39
            cout << result[i] << (i == n - 1 ? ""\n"" : "" "");
40
        }
41
    }
42
    43
    return 0;
44
}
45
46",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833844
1387833841,sonamyadav7208,unknown,unknown,"1
def solve():
2
    T = int(input())  # number of test cases
3
    for _ in range(T):
4
        n = int(input())  # number of nodes in the network
5
        values = list(map(int, input().split()))  # list of node values
6
7
        # Arrays to store the left and right products
8
        left = [1] * n
9
        right = [1] * n
10
        result = [0] * n
11
12
        # Fill the left array
13
        for i in range(1, n):
14
            left[i] = left[i - 1] * values[i - 1]
15
16
        # Fill the right array
17
        for i in range(n - 2, -1, -1):
18
            right[i] = right[i + 1] * values[i + 1]
19
20
        # Calculate result by multiplying corresponding left and right products
21
        for i in range(n):
22
            result[i] = left[i] * right[i]
23
24
        print("" "".join(map(str, result)))
25
26
# Call the function to run the solution
27
solve()",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833841
1387833837,sohampatil1807,unknown,unknown,"1
def solve_product_array(values, n):
2
    """"""
3
    Calculate product of all elements except self for each position.
4
    Uses O(1) extra space (not counting the output array).
5
    """"""
6
    # Handle edge cases
7
    if n < 2:
8
        return []
9
        10
    # Initialize result array
11
    result = [0] * n
12
    13
    # Calculate products using a two-pass approach
14
    15
    # First pass: Calculate products of all elements to the left
16
    # result[i] will store product of all elements left of i
17
    result[0] = 1
18
    for i in range(1, n):
19
        result[i] = values[i - 1] * result[i - 1]
20
    21
    # Second pass: Calculate products of all elements to the right
22
    # and multiply with existing left products
23
    right_product = 1
24
    for i in range(n - 1, -1, -1):
25
        result[i] = result[i] * right_product
26
        right_product *= values[i]
27
    28
    return result
29
30
def main():
31
    # Read number of test cases
32
    T = int(input())
33
    34
    # Process each test case
35
    for _ in range(T):
36
        # Read array size
37
        n = int(input())
38
        39
        # Read array values
40
        values = list(map(int, input().split()))
41
        42
        # Calculate result
43
        result = solve_product_array(values, n)
44
        45
        # Print result
46
        print("" "".join(map(str, result)))
47
48
if __name__ == ""__main__"":
49
    main()
50",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833837
1387833838,shrikrushna07,unknown,unknown,"1
def compute_result(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
        8
        prefix = [1] * n
9
        suffix = [1] * n
10
        result = [0] * n
11
        12
        for i in range(1, n):
13
            prefix[i] = prefix[i - 1] * values[i - 1]
14
        15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        for i in range(n):
19
            result[i] = prefix[i] * suffix[i]
20
        21
        results.append(result)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    n = int(input())
30
    values = list(map(int, input().split()))
31
    test_cases.append((n, values))
32
33
results = compute_result(T, test_cases)
34
35
for result in results:
36
    print("" "".join(map(str, result)))
37",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833838
1387833840,h1032220347,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
3
def max_absolute_difference(n, nums):
4
5
   6
7
    prefix = [0] * n
8
9
    prefix[0] = nums[0]
10
11
    for i in range(1, n):
12
13
        prefix[i] = prefix[i - 1] + nums[i]
14
15
    16
17
    suffix = [0] * n
18
19
    suffix[n - 1] = nums[n - 1]
20
21
    for i in range(n - 2, -1, -1):
22
23
        suffix[i] = suffix[i + 1] + nums[i]
24
25
    26
27
    max_diff = 0
28
29
    for i in range(n - 1):  
30
31
        left_sum = prefix[i]
32
33
        right_sum = suffix[i + 1]
34
35
        max_diff = max(max_diff, abs(left_sum - right_sum))
36
37
    38
39
    return max_diff
40
41
T = int(input().strip())  
42
43
for _ in range(T):
44
45
    N = int(input().strip()) 
46
47
    nums = list(map(int, input().strip().split())) 
48
49
    print(max_absolute_difference(N, nums))",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833840
1387833835,tejasvikhairnar,unknown,unknown,"1
def min_operations_to_equalize(N, k , energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target_energy = total_energy // N
8
    operations = 0
9
    current_balance = 0
10
    11
    for i in range(N):
12
        energy_diff = energy[i] - target_energy
13
        14
        current_balance += energy_diff
15
        16
        if current_balance % K != 0:
17
            return -1
18
        19
        operations += abs(current_balance // K)
20
    return operations
21
22
T = int(input())
23
24
for _ in range(T):
25
    N , K = map(int,input().split())
26
    energy = list(map(int,input().split()))
27
    result = min_operations_to_equalize(N,K,energy)
28
    print(result)",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833835
1387833836,h1032221348,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    prefix = [1] * n
4
    suffix = [1] * n
5
    result = [1] * n
6
    for i in range(1, n):
7
        prefix[i] = prefix[i - 1] * values[i - 1]
8
    for i in range(n - 2, -1, -1):
9
        suffix[i] = suffix[i + 1] * values[i + 1]
10
    for i in range(n):
11
        result[i] = prefix[i] * suffix[i]
12
    return result
13
14
T = int(input())
15
results = []
16
for _ in range(T):
17
    n = int(input())
18
    values = list(map(int, input().split()))
19
    results.append(product_except_self(values))
20
21
for res in results:
22
    print("" "".join(map(str, res)))
23",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833836
1387833834,h1032231291,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][""N""], test_cases[t][""K""]
5
        energy = test_cases[t][""energy""]
6
7
        total_energy = sum(energy)
8
        if total_energy % N != 0:
9
            results.append(-1)  
10
            continue
11
12
        target_energy = total_energy // N
13
        operations = 0
14
15
        diffs = [energy[i] - target_energy for i in range(N)]
16
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)  
19
            continue
20
        net_flow = 0
21
        for diff in diffs:
22
            net_flow += diff // K
23
            operations += abs(diff // K)
24
25
        if net_flow != 0:
26
            results.append(-1)  
27
        else:
28
            results.append(operations // 2)  
29
30
    return results
31
32
def main():
33
    T = int(input())
34
    test_cases = []
35
36
    for _ in range(T):
37
        N, K = map(int, input().split())
38
        energy = list(map(int, input().split()))
39
        test_cases.append({""N"": N, ""K"": K, ""energy"": energy})
40
41
    results = min_operations_to_equalize(T, test_cases)
42
43
    for result in results:
44
        print(result)
45
46
if __name__ == ""__main__"":
47
    main()
48",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833834
1387833829,harsh_singh26011,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
int minOperationsToEqualize(vector<int>& energy, int N, int K) {
6
    long long total_energy = 0;
7
    for (int e : energy) total_energy += e;
8
    9
    // If total energy is not divisible by N, equal distribution is impossible
10
    if (total_energy % N != 0) return -1;
11
12
    int target = total_energy / N;
13
    long long operations = 0;
14
    15
    for (int i = 0; i < N; i++) {
16
        int diff = energy[i] - target;
17
        if (diff % K != 0) return -1; // If we cannot transfer in multiples of K
18
        operations += abs(diff) / K;
19
    }
20
21
    return operations / 2; // Each transfer is counted twice
22
}
23
24
int main() {
25
    int T;
26
    cin >> T;
27
    while (T--) {
28
        int N, K;
29
        cin >> N >> K;
30
        vector<int> energy(N);
31
        for (int i = 0; i < N; i++) cin >> energy[i];
32
33
        cout << minOperationsToEqualize(energy, N, K) << endl;
34
    }
35
    return 0;
36
}
37",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833829
1387833831,h1032221373,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
5
public class Solution {
6
7
    public static void main(String[] args) {
8
        Scanner scanner = new Scanner(System.in);
9
        int T = scanner.nextInt(); // Number of test cases
10
        11
        while (T-- > 0) {
12
            int N = scanner.nextInt(); // Number of power stations
13
            int K = scanner.nextInt(); // Energy transfer per operation
14
            int[] energy = new int[N];
15
            16
            long totalEnergy = 0; // Use long to avoid overflow
17
            18
            // Read the energy levels and calculate the total energy
19
            for (int i = 0; i < N; i++) {
20
                energy[i] = scanner.nextInt();
21
                totalEnergy += energy[i];
22
            }
23
            24
            // Check if total energy is divisible by N
25
            if (totalEnergy % N != 0) {
26
                System.out.println(-1);
27
                continue;
28
            }
29
            30
            long target = totalEnergy / N; // Target energy per station
31
            long imbalance = 0, operations = 0;
32
            boolean possible = true;
33
            34
            for (int i = 0; i < N; i++) {
35
                // Calculate the difference from the target
36
                imbalance += energy[i] - target;
37
                38
                // If the imbalance is not a multiple of K, it's not possible to balance
39
                if (Math.abs(imbalance) % K != 0) {
40
                    possible = false;
41
                    break;
42
                }
43
                44
                // Count operations required to fix imbalance
45
                operations += Math.abs(imbalance) / K;
46
            }
47
            48
            // If balancing is possible, print the operations; otherwise, -1
49
            System.out.println(possible ? operations : -1);
50
        }
51
        52
        scanner.close();
53
    }
54
}
55",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833831
1387833832,rahulgeorge1212,unknown,unknown,"1
def maxAbsDifference(t, test_cases):
2
    results = []
3
    4
    for test_case in test_cases:
5
        n, nums = test_case
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate over possible partitions
11
        for i in range(1, n):
12
            prefix_sum += nums[i - 1]
13
            left_sum = prefix_sum
14
            right_sum = total_sum - left_sum
15
            max_diff = max(max_diff, abs(left_sum - right_sum))
16
        17
        results.append(max_diff)
18
    19
    return results
20
21
# Input processing
22
t = int(input())  # number of test cases
23
test_cases = []
24
for _ in range(t):
25
    n = int(input())  # size of the array
26
    nums = list(map(int, input().split()))  # the array itself
27
    test_cases.append((n, nums))
28
29
# Call function and print results
30
results = maxAbsDifference(t, test_cases)
31
for result in results:
32
    print(result)
33",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833832
1387833828,h1032221356,unknown,unknown,"1
def max_absolute_difference():
2
    t = int(input())  # Number of test cases
3
    results = []
4
    5
    for _ in range(t):
6
        n = int(input())  # Size of the array
7
        nums = list(map(int, input().split()))
8
        9
        # Compute prefix sum
10
        prefix = [0] * (n + 1)
11
        for i in range(n):
12
            prefix[i + 1] = prefix[i] + nums[i]
13
        14
        # Calculate the maximum absolute difference
15
        max_diff = 0
16
        for i in range(1, n):  # Partition points (at least 1 element in both subarrays)
17
            left_sum = prefix[i]
18
            right_sum = prefix[n] - left_sum
19
            max_diff = max(max_diff, abs(left_sum - right_sum))
20
        21
        results.append(max_diff)
22
    23
    # Output all results
24
    print(""\n"".join(map(str, results)))
25
26
# Call the function
27
max_absolute_difference()
28",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833828
1387833814,harshrsharma29,unknown,unknown,"1
def solve():
2
    t = int(input())
3
    for _ in range(t):
4
        n = int(input())
5
        nums = list(map(int, input().split()))
6
        7
        total_sum = sum(nums)
8
        left_sum = 0
9
        max_difference = 0
10
        11
        for i in range(n - 1):
12
            left_sum += nums[i]
13
            right_sum = total_sum - left_sum
14
            max_difference = max(max_difference, abs(left_sum - right_sum))
15
        16
        print(max_difference)
17
18
solve()",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833814
1387833823,ng873042,unknown,unknown,"1
def product_except_self(arr, n):
2
3
    result = [1] * n
4
5
    6
7
    # Compute prefix products
8
9
    prefix = 1
10
11
    for i in range(n):
12
13
        result[i] = prefix
14
15
        prefix *= arr[i]
16
17
    # Compute suffix products and finalize result
18
19
    suffix = 1
20
21
    for i in range(n-1, -1, -1):
22
23
        result[i] *= suffix
24
25
        suffix *= arr[i]
26
27
    28
29
    return result
30
31
# Read input
32
33
T = int(input())  # Number of test cases
34
35
for _ in range(T):
36
37
    n = int(input())  # Number of nodes
38
39
    values = list(map(int, input().split()))  # Node values
40
41
    print(*product_except_self(values, n))  # Print the result",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833823
1387833813,kamblesamruddhi2,unknown,unknown,"1
T = int(input())
2
for _ in range(T):
3
    n = int(input())
4
    values = list(map(int, input().split()))
5
    prefix = [1] * n
6
    suffix = [1] * n
7
    result = [1] * n
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] * values[i - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] * values[i + 1]
12
    for i in range(n):
13
        result[i] = prefix[i] * suffix[i]
14
    print("" "".join(map(str, result)))
15",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833813
1387833809,goswamyashutosh9,unknown,unknown,"1
def max_absolute_difference(nums):
2
    """"""
3
    Calculates the maximum absolute difference between the sums of two contiguous subarrays.
4
5
    Args:
6
      nums: A list of integers.
7
8
    Returns:
9
      The maximum absolute difference.
10
    """"""
11
12
    n = len(nums)
13
    prefix_sum = [0] * (n + 1)
14
15
    # Calculate prefix sum
16
    for i in range(1, n + 1):
17
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
18
19
    max_diff = 0
20
    for i in range(1, n):
21
        left_sum = prefix_sum[i]
22
        right_sum = prefix_sum[n] - left_sum
23
        max_diff = max(max_diff, abs(left_sum - right_sum))
24
25
    return max_diff
26
27
# Get input
28
t = int(input())
29
30
for _ in range(t):
31
    n = int(input())
32
    nums = list(map(int, input().split()))
33
    result = max_absolute_difference(nums)
34
    print(result)",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833809
1387833811,suryampandey5942,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <tuple>
4
#include <cmath>
5
using namespace std;
6
7
// Function to calculate minimum operations to equalize
8
vector<int> minimum_operations_to_equalize(vector<tuple<int, int, vector<int>>> test_cases) {
9
    vector<int> results;
10
11
    for (auto &t : test_cases) {
12
        int N, K;
13
        vector<int> energy;
14
        tie(N, K, energy) = t;
15
16
        long long total_energy = 0;
17
        for (int e : energy) {
18
            total_energy += e;
19
        }
20
21
        // Check if equalization is possible
22
        if (total_energy % N != 0) {
23
            results.push_back(-1);
24
            continue;
25
        }
26
27
        int target = total_energy / N;
28
        vector<int> diffs(N);
29
        for (int i = 0; i < N; i++) {
30
            diffs[i] = energy[i] - target;
31
        }
32
33
        // Check if all differences are divisible by K
34
        bool possible = true;
35
        for (int diff : diffs) {
36
            if (diff % K != 0) {
37
                possible = false;
38
                break;
39
            }
40
        }
41
42
        if (!possible) {
43
            results.push_back(-1);
44
            continue;
45
        }
46
47
        // Calculate minimum operations
48
        long long operations = 0;
49
        long long imbalance = 0;
50
51
        for (int diff : diffs) {
52
            imbalance += diff / K;
53
            operations += abs(imbalance);
54
        }
55
56
        results.push_back(operations);
57
    }
58
59
    return results;
60
}
61
62
int main() {
63
    int T;
64
    cin >> T;
65
66
    vector<tuple<int, int, vector<int>>> test_cases;
67
68
    for (int t = 0; t < T; t++) {
69
        int N, K;
70
        cin >> N >> K;
71
        vector<int> energy(N);
72
        for (int i = 0; i < N; i++) {
73
            cin >> energy[i];
74
        }
75
        test_cases.emplace_back(N, K, energy);
76
    }
77
78
    vector<int> results = minimum_operations_to_equalize(test_cases);
79
80
    for (int res : results) {
81
        cout << res << endl;
82
    }
83
84
    return 0;
85
}
86
87",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833811
1387833812,h1032220319,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
void helper(){
9
    int n;
10
    cin>>n;
11
    12
    vector<int>values(n);
13
    for(int i=0;i<n;i++){
14
        cin>>values[i];
15
    }
16
    vector<int>result(n,1);
17
    18
    int prefixPro=1;
19
    for(int i=0;i<n;i++){
20
        result[i]=prefixPro;
21
        prefixPro*=values[i];
22
    }
23
    24
    int suffixPro=1;
25
    for(int i=n-1;i>=0;i--){
26
        result[i]*=suffixPro;
27
        suffixPro*=values[i];
28
    }
29
    30
    for(int i=0;i<n;i++){
31
        cout<<result[i]<<(i==n-1? ""\n"": "" "");
32
    }
33
    34
}
35
36
int main() {
37
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
38
   int input;
39
    cin>>input;
40
    while(input--){
41
        helper();
42
    }
43
    44
    return 0;
45
}
46",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833812
1387833804,omg40787,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K = case[0]
6
        energies = case[1]
7
8
        # Calculate total energy
9
        total_energy = sum(energies)
10
11
        # If total energy is not divisible by N, return -1
12
        if total_energy % N != 0:
13
            results.append(-1)
14
            continue
15
16
        # Target energy for each station
17
        target_energy = total_energy // N
18
19
        # Initialize variables to calculate operations
20
        current_difference = 0
21
        operations = 0
22
23
        # Traverse each station and calculate operations
24
        for i in range(N):
25
            current_difference += (energies[i] - target_energy)
26
            if current_difference % K != 0:
27
                operations = -1
28
                break
29
            operations += abs(current_difference // K)
30
31
        results.append(operations if operations != -1 else -1)
32
33
    return results
34
35
# Example usage:
36
test_cases = [
37
    ((3, 2), [4, 4, 4]),
38
    ((3, 1), [5, 3, 4]),
39
    ((4, 3), [5, 5, 5, 6])
40
]
41
42
results = equalize_energy(test_cases)
43
for result in results:
44
    print(result)
45",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833804
1387833807,vigneshalle16,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for values in test_cases:
5
        n = len(values)
6
        7
        # Arrays to store prefix and suffix products
8
        prefix = [1] * n
9
        suffix = [1] * n
10
        result = [1] * n
11
        12
        # Compute prefix products
13
        for i in range(1, n):
14
            prefix[i] = prefix[i - 1] * values[i - 1]
15
        16
        # Compute suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix[i] = suffix[i + 1] * values[i + 1]
19
        20
        # Compute the result using prefix and suffix products
21
        for i in range(n):
22
            result[i] = prefix[i] * suffix[i]
23
        24
        results.append(result)
25
    26
    return results
27
28
29
# Input processing
30
T = int(input())
31
test_cases = []
32
33
for _ in range(T):
34
    n = int(input())
35
    values = list(map(int, input().split()))
36
    test_cases.append(values)
37
38
# Output the results
39
results = product_except_self(test_cases)
40
for res in results:
41
    print("" "".join(map(str, res)))
42",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833807
1387833808,paragchaudhary_1,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            print(-1)
11
            continue
12
        13
        target_energy = total_energy // N
14
        operations = 0
15
        current_balance = 0
16
        17
        for i in range(N):
18
            current_balance += energy[i] - target_energy
19
            operations += abs(current_balance) // K
20
            21
            if abs(current_balance) % K != 0:
22
                operations = -1
23
                break
24
        25
        print(operations)
26
27
solve()",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833808
1387833802,h1032220289,unknown,unknown,"1
def main():
2
    T = int(input())  
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            print(-1)
11
            continue
12
        13
        target = total_energy // N
14
        operations = 0
15
        current_balance = 0
16
        17
        for i in range(N):
18
            energy[i] -= target
19
            current_balance += energy[i]
20
            operations += abs(current_balance) // K
21
            22
            if abs(current_balance) % K != 0:
23
                operations = -1
24
                break
25
        26
        print(operations)
27
main()",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833802
1387833797,siddhantpal9082,unknown,unknown,"1
def compute_product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        result = [1] * n
6
7
        prefix = 1
8
        for i in range(n):
9
            result[i] = prefix
10
            prefix *= values[i]
11
12
        suffix = 1
13
        for i in range(n - 1, -1, -1):
14
            result[i] *= suffix
15
            suffix *= values[i]
16
17
        results.append(result)
18
    return results
19
20
t = int(input())
21
test_cases = []
22
for _ in range(t):
23
    n = int(input())
24
    values = list(map(int, input().split()))
25
    test_cases.append((n, values))
26
27
results = compute_product_except_self(test_cases)
28
for res in results:
29
    print("" "".join(map(str, res)))
30",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833797
1387833798,revatikirdat2,unknown,unknown,"1
def solve_product_array(values, n):
2
    """"""
3
    Calculate product of all elements except self for each position.
4
    Uses O(1) extra space (not counting the output array).
5
    """"""
6
    # Handle edge cases
7
    if n < 2:
8
        return []
9
        10
    # Initialize result array
11
    result = [0] * n
12
    13
    # Calculate products using a two-pass approach
14
    15
    # First pass: Calculate products of all elements to the left
16
    # result[i] will store product of all elements left of i
17
    result[0] = 1
18
    for i in range(1, n):
19
        result[i] = values[i - 1] * result[i - 1]
20
    21
    # Second pass: Calculate products of all elements to the right
22
    # and multiply with existing left products
23
    right_product = 1
24
    for i in range(n - 1, -1, -1):
25
        result[i] = result[i] * right_product
26
        right_product *= values[i]
27
    28
    return result
29
30
def main():
31
    # Read number of test cases
32
    T = int(input())
33
    34
    # Process each test case
35
    for _ in range(T):
36
        # Read array size
37
        n = int(input())
38
        39
        # Read array values
40
        values = list(map(int, input().split()))
41
        42
        # Calculate result
43
        result = solve_product_array(values, n)
44
        45
        # Print result
46
        print("" "".join(map(str, result)))
47
48
if _name_ == ""_main_"":
49
    main()",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833798
1387833800,arpit21345j,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
        12
        target = total_energy // N
13
        diffs = [energy[i] - target for i in range(N)]
14
        15
        if any(diff % K != 0 for diff in diffs):
16
            results.append(-1)
17
            continue
18
        19
        operations = 0
20
        imbalance = 0
21
        22
        for diff in diffs:
23
            imbalance += diff // K
24
            operations += abs(imbalance)
25
        26
        results.append(operations)
27
    28
    return results
29
30
31
T = int(input())
32
test_cases = []
33
34
for _ in range(T):
35
    N, K = map(int, input().split())
36
    energy = list(map(int, input().split()))
37
    test_cases.append((N, K, energy))
38
39
results = minimum_operations_to_equalize(test_cases)
40
41
for res in results:
42
    print(res)",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833800
1387833792,Amanpal3546,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
void solve() {
6
    int N, K;
7
    cin >> N >> K;
8
    9
    vector<int> energy(N);
10
    long long totalEnergy = 0;
11
    12
    for (int i = 0; i < N; i++) {
13
        cin >> energy[i];
14
        totalEnergy += energy[i];
15
    }
16
17
    // Step 1: Check if equal distribution is possible
18
    if (totalEnergy % N != 0) {
19
        cout << -1 << endl;
20
        return;
21
    }
22
23
    int target = totalEnergy / N;
24
    long long operations = 0, prefixSum = 0;
25
26
    // Step 2: Compute imbalance and operations needed
27
    for (int i = 0; i < N; i++) {
28
        int diff = energy[i] - target;
29
        30
        // Step 3: If the imbalance is not a multiple of K, return -1
31
        if (diff % K != 0) {
32
            cout << -1 << endl;
33
            return;
34
        }
35
        36
        prefixSum += diff;
37
        operations += abs(prefixSum) / K;
38
    }
39
40
    cout << operations << endl;
41
}
42
43
int main() {
44
    int T;
45
    cin >> T;
46
    47
    while (T--) {
48
        solve();
49
    }
50
    51
    return 0;
52
}",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833792
1387833793,08vijay09,unknown,unknown,"1
def max_subarray_diff(nums):
2
    n = len(nums)
3
    left_sum = [0] * n
4
    right_sum = [0] * n
5
6
    7
    left_sum[0] = nums[0]
8
    for i in range(1, n):
9
        left_sum[i] = left_sum[i - 1] + nums[i]
10
11
    12
    right_sum[n - 1] = nums[n - 1]
13
    for i in range(n - 2, -1, -1):
14
        right_sum[i] = right_sum[i + 1] + nums[i]
15
16
    max_diff = 0
17
    for i in range(n - 1):
18
        diff = abs(left_sum[i] - right_sum[i + 1])
19
        max_diff = max(max_diff, diff)
20
21
    return max_diff
22
23
if __name__ == ""__main__"":
24
    t = int(input())
25
    for _ in range(t):
26
        n = int(input())
27
        nums = list(map(int, input().split()))
28
        result = max_subarray_diff(nums)
29
        print(result)
30
31",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833793
1387833795,swayam_prajapat1,unknown,unknown,"1
def min_operations_to_equalize(t, test_cases):  
2
    results = []  
3
    4
    for case in test_cases:  
5
        N, K = case[0]  
6
        energy = case[1]  
7
8
        total_energy = sum(energy)  
9
10
        # Check if total energy is divisible by N  
11
        if total_energy % N != 0:  
12
            results.append(-1)  
13
            continue  
14
        15
        target_energy = total_energy // N  
16
        surplus = 0  
17
        deficit = 0  
18
        19
        # Calculate total surplus and deficit  
20
        for e in energy:  
21
            if e > target_energy:  
22
                surplus += (e - target_energy)  
23
            elif e < target_energy:  
24
                deficit += (target_energy - e)  
25
26
        # Check if surplus and deficit can be matched with K  
27
        if surplus % K != 0 or deficit % K != 0:  
28
            results.append(-1)  
29
            continue  
30
        31
        # Calculate the number of operations needed  
32
        operations = surplus // K  # This should equal deficit // K if the transfers are possible  
33
        34
        results.append(operations)  
35
    36
    return results  
37
38
# Read input and execute the function  
39
import sys  
40
41
# Use sys.stdin.read to handle input in one go  
42
input_data = sys.stdin.read().strip().splitlines()  
43
T = int(input_data[0])  
44
test_cases = []  
45
46
for i in range(1, len(input_data), 2):  
47
    N, K = map(int, input_data[i].split())  
48
    energy = list(map(int, input_data[i + 1].split()))  
49
    test_cases.append(((N, K), energy))  
50
51
# Get results and print  
52
results = min_operations_to_equalize(T, test_cases)  
53
54
for result in results:  
55
    print(result)",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833795
1387833787,shubhamgupta3009,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt();
8
        9
        for (int t = 0; t < T; t++) {
10
            int N = scanner.nextInt();
11
            int K = scanner.nextInt();
12
            13
            long[] energy = new long[N];
14
            long totalEnergy = 0;
15
            16
            for (int i = 0; i < N; i++) {
17
                energy[i] = scanner.nextLong();
18
                totalEnergy += energy[i];
19
            }
20
            21
            System.out.println(minOperations(energy, N, K, totalEnergy));
22
        }
23
        scanner.close();
24
    }
25
    26
    private static int minOperations(long[] energy, int N, int K, long totalEnergy) {
27
        if (N == 1) return 0;
28
        29
        if (totalEnergy % N != 0) return -1;
30
        31
        long targetEnergy = totalEnergy / N;
32
        int operations = 0;
33
        34
        for (int i = 0; i < N; i++) {
35
            if (energy[i] == targetEnergy) continue;
36
            37
            if (energy[i] > targetEnergy) {
38
                long diff = energy[i] - targetEnergy;
39
                if (diff % K != 0) return -1;
40
                41
                long transfers = diff / K;
42
                operations += transfers;
43
                energy[i] -= transfers * K;
44
                energy[(i + 1) % N] += transfers * K;
45
            }
46
        }
47
        48
        for (long e : energy) {
49
            if (e != targetEnergy) return -1;
50
        }
51
        52
        return operations;
53
    }
54
}",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833787
1387833790,h1032220149,unknown,unknown,"1
def solve():
2
    t = int(input())  # Number of test cases
3
    4
    for _ in range(t):
5
        n = int(input())  # Size of the array
6
        nums = list(map(int, input().split()))  # The array
7
        8
        total_sum = sum(nums)
9
        prefix_sum = 0
10
        max_diff = 0
11
        12
        # Iterate to find the maximum absolute difference
13
        for i in range(n - 1):  # We stop at n-1 because the partition must be between two subarrays
14
            prefix_sum += nums[i]
15
            diff = abs(2 * prefix_sum - total_sum)
16
            max_diff = max(max_diff, diff)
17
        18
        print(max_diff)
19
20
# Call the solve function to process the input and produce the output
21
solve()",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833790
1387833791,ravislprajapati,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K = case[0], case[1]
6
        energy = case[2]
7
        total_energy = sum(energy)
8
        9
        # Check if equalization is possible
10
        if total_energy % N != 0:
11
            results.append(-1)
12
            continue
13
        14
        target = total_energy // N
15
        balance = 0  # Tracks surplus/deficit of energy
16
        operations = 0
17
        18
        # Simulate the redistribution process
19
        for i in range(N):
20
            balance += (energy[i] - target)
21
            # Every K energy moved counts as an operation
22
            operations += abs(balance) // K
23
        24
        results.append(operations)
25
    26
    return results
27
28
# Input processing
29
T = int(input())  # Number of test cases
30
test_cases = []
31
32
for _ in range(T):
33
    N, K = map(int, input().split())
34
    energy = list(map(int, input().split()))
35
    test_cases.append((N, K, energy))
36
37
# Output results
38
results = minimum_operations_to_equalize(T, test_cases)
39
for result in results:
40
    print(result)
41",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833791
1387833786,h1032231273,unknown,unknown,"1
def max_subarray_diff(nums):
2
    n = len(nums)
3
    left_sum = [0] * n
4
    right_sum = [0] * n
5
6
    # Calculate prefix sums from left to right
7
    left_sum[0] = nums[0]
8
    for i in range(1, n):
9
        left_sum[i] = left_sum[i - 1] + nums[i]
10
11
    # Calculate prefix sums from right to left
12
    right_sum[n - 1] = nums[n - 1]
13
    for i in range(n - 2, -1, -1):
14
        right_sum[i] = right_sum[i + 1] + nums[i]
15
16
    max_diff = 0
17
    for i in range(n - 1):
18
        diff = abs(left_sum[i] - right_sum[i + 1])
19
        max_diff = max(max_diff, diff)
20
21
    return max_diff
22
23
if __name__ == ""__main__"":
24
    t = int(input())
25
    for _ in range(t):
26
        n = int(input())
27
        nums = list(map(int, input().split()))
28
        result = max_subarray_diff(nums)
29
        print(result)",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833786
1387833776,damodarryadav,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric> // For accumulate function
4
#include <cmath>   // For abs function
5
using namespace std;
6
int main() {
7
    int T; // Number of test cases
8
    cin >> T;
9
    while (T--) {
10
        int N, K;
11
        cin >> N >> K;
12
        vector<int> energy(N);
13
        long long totalEnergy = 0;
14
        for (int i = 0; i < N; ++i) {
15
            cin >> energy[i];
16
            totalEnergy += energy[i];
17
        }
18
        // Check if equalization is possible
19
        if (totalEnergy % N != 0) {
20
            cout << -1 << endl; // Impossible to equalize
21
            continue;
22
        }
23
        long long targetEnergy = totalEnergy / N;
24
        long long balance = 0; // Cumulative balance
25
        long long operations = 0;
26
        for (int i = 0; i < N; ++i) {
27
            balance += energy[i] - targetEnergy; // Difference between current and target
28
            operations += abs(balance);         // Accumulate absolute imbalance
29
        }
30
        // Check if the imbalance can be resolved with the given K
31
        if (operations % K == 0) {
32
            cout << operations / K << endl;
33
        } else {
34
            cout << -1 << endl;
35
        }
36
    }
37
    return 0;
38
}
39",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833776
1387833779,sudhanshdubey75,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            print(-1)
11
            continue
12
        13
        target_energy = total_energy // N
14
        operations = 0
15
        current_balance = 0
16
        17
        for i in range(N):
18
            current_balance += energy[i] - target_energy
19
            operations += abs(current_balance) // K
20
            21
            if abs(current_balance) % K != 0:
22
                operations = -1
23
                break
24
        25
        print(operations)
26
27
solve()",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833779
1387833780,h1032221641,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n = int(input())
4
    nums = list(map(int, input().split()))
5
    total = sum(nums)
6
    left_sum = 0
7
    max_diff = 0
8
    for i in range(n - 1):
9
        left_sum += nums[i]
10
        current_diff = abs(left_sum * 2 - total)
11
        if current_diff > max_diff:
12
            max_diff = current_diff
13
    print(max_diff)",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833780
1387833770,jkinsuk760,unknown,unknown,"1
def min_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
10
        target = total_energy // N
11
        diff = [energy[i] - target for i in range(N)]
12
        prefix_sum = 0
13
        ops = 0
14
        for i in range(N):
15
            prefix_sum += diff[i]
16
            if prefix_sum % K != 0:
17
                ops = -1
18
                break
19
            ops += abs(prefix_sum) // K
20
        results.append(ops)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
outputs = min_operations(test_cases)
31
for output in outputs:
32
    print(output)
33",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833770
1387833772,h1032221373,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int T = scanner.nextInt();   
9
        while (T-- > 0) {
10
            int N = scanner.nextInt(); 
11
            int K = scanner.nextInt(); 
12
            int[] energy = new int[N];
13
            14
            long totalEnergy = 0;
15
            for (int i = 0; i < N; i++) {
16
                energy[i] = scanner.nextInt();
17
                totalEnergy += energy[i];
18
            }
19
            if (totalEnergy % N != 0) {
20
                System.out.println(-1);
21
                continue;
22
            }
23
            long target = totalEnergy / N;
24
            long imbalance = 0, operations = 0;
25
            boolean possible = true;
26
            27
            for (int i = 0; i < N; i++) {
28
                imbalance += energy[i] - target;
29
                if (Math.abs(imbalance) % K != 0) {
30
                    possible = false;
31
                    break;
32
                }
33
                operations += Math.abs(imbalance) / K;
34
            }
35
            36
       37
            System.out.println(possible ? operations : -1);
38
        }
39
        40
        scanner.close();
41
    }
42
}",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833772
1387833774,ritikalath2004,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def min_operations_to_equalize(t, test_cases):
3
4
    results = []
5
6
    7
8
    for case in test_cases:
9
10
        N, K, energy = case[""N""], case[""K""], case[""energy""]
11
12
        total_energy = sum(energy)
13
14
        # If the total energy is not divisible by N, equalization is impossible
15
16
        if total_energy % N != 0:
17
18
            results.append(-1)
19
20
            continue
21
22
        target_energy = total_energy // N
23
24
        25
26
        # Calculate excess/deficit energy at each station
27
28
        balance = 0
29
30
        operations = 0
31
32
        is_possible = True
33
34
        for e in energy:
35
36
            balance += (e - target_energy)  # Track net excess/deficit
37
38
            if abs(balance) % K != 0:  # If imbalance cannot be solved by K transfers, it's impossible
39
40
                is_possible = False
41
42
                break
43
44
            operations += abs(balance) // K  # Count required operations
45
46
        if not is_possible:
47
48
            results.append(-1)
49
50
        else:
51
52
            results.append(operations)
53
54
    return results
55
56
# Input handling
57
58
def main():
59
60
    T = int(input())
61
62
    test_cases = []
63
64
    for _ in range(T):
65
66
        N, K = map(int, input().split())
67
68
        energy = list(map(int, input().split()))
69
70
        test_cases.append({""N"": N, ""K"": K, ""energy"": energy})
71
72
    results = min_operations_to_equalize(T, test_cases)
73
74
    for res in results:
75
76
        print(res)
77
78
# Sample Input/Output handling for debugging purposes
79
80
if __name__ == ""__main__"":
81
82
    main()",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833774
1387833765,nishashetty1002,unknown,unknown,"1
def solve():
2
    t = int(input())  # number of test cases
3
    for _ in range(t):
4
        n = int(input())  # size of the array
5
        nums = list(map(int, input().split()))  # the array
6
        7
        # Calculate the total sum of the array
8
        total_sum = sum(nums)
9
        10
        # Variables to track the left sum and maximum absolute difference
11
        left_sum = 0
12
        max_difference = 0
13
        14
        # Iterate to find the maximum absolute difference
15
        for i in range(n - 1):  # We stop at n-1 since we need non-empty right subarray
16
            left_sum += nums[i]
17
            right_sum = total_sum - left_sum
18
            max_difference = max(max_difference, abs(left_sum - right_sum))
19
        20
        print(max_difference)
21
22
# Call the function to solve the problem
23
solve()",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833765
1387833766,mahakantsingh113,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <cmath>
5
using namespace std;
6
7
vector<int> minimum_operations_to_equalize(int T, vector<pair<pair<int, int>, vector<int>>> &test_cases) {
8
    vector<int> results;
9
10
    for (int t = 0; t < T; t++) {
11
        int N = test_cases[t].first.first;
12
        int K = test_cases[t].first.second;
13
        vector<int> energy = test_cases[t].second;
14
15
        long long total_energy = accumulate(energy.begin(), energy.end(), 0LL);
16
17
        // Check if equalization is possible
18
        if (total_energy % N != 0) {
19
            results.push_back(-1);
20
            continue;
21
        }
22
23
        long long target = total_energy / N;
24
        vector<long long> imbalances(N);
25
        for (int i = 0; i < N; i++) {
26
            imbalances[i] = energy[i] - target;
27
        }
28
29
        long long prefix_sum = 0;
30
        long long operations = 0;
31
        bool possible = true;
32
33
        for (int i = 0; i < N; i++) {
34
            prefix_sum += imbalances[i];
35
            // If imbalance cannot be resolved using K, it's impossible
36
            if (prefix_sum % K != 0) {
37
                possible = false;
38
                break;
39
            }
40
            operations += abs(prefix_sum) / K;
41
        }
42
43
        results.push_back(possible ? operations : -1);
44
    }
45
46
    return results;
47
}
48
49
int main() {
50
    int T;
51
    cin >> T;
52
    vector<pair<pair<int, int>, vector<int>>> test_cases(T);
53
54
    for (int t = 0; t < T; t++) {
55
        int N, K;
56
        cin >> N >> K;
57
        vector<int> energy(N);
58
        for (int i = 0; i < N; i++) {
59
            cin >> energy[i];
60
        }
61
        test_cases[t] = {{N, K}, energy};
62
    }
63
64
    vector<int> results = minimum_operations_to_equalize(T, test_cases);
65
66
    for (int res : results) {
67
        cout << res << endl;
68
    }
69
70
    return 0;
71
}
72",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833766
1387833769,cooljaychaudhary,unknown,unknown,"1
def equalize_energy():
2
    T = int(input()) 
3
    results = []
4
    5
    for _ in range(T):
6
        7
        N, K = map(int, input().split())
8
        9
        energy = list(map(int, input().split()))
10
        11
        total_energy = sum(energy)
12
        13
        14
        if total_energy % N != 0:
15
            results.append(-1)
16
            continue
17
        18
        target = total_energy // N
19
        balance = 0
20
        operations = 0
21
        possible = True
22
        23
        24
        for e in energy:
25
            26
            balance += e - target
27
            28
            if balance % K != 0:
29
                possible = False
30
                break
31
            32
            operations += abs(balance) // K
33
        34
        if possible:
35
            results.append(operations)
36
        else:
37
            results.append(-1)
38
    39
    40
    print(""\n"".join(map(str, results)))
41
42
43
equalize_energy()",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833769
1387833763,ssidd9770,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for n, nums in test_cases:
4
        left_sum = [0] * n
5
        right_sum = [0] * n
6
7
        left_sum[0] = nums[0]
8
        for i in range(1, n):
9
            left_sum[i] = left_sum[i - 1] + nums[i]
10
11
        right_sum[n - 1] = nums[n - 1]
12
        for i in range(n - 2, -1, -1):
13
            right_sum[i] = right_sum[i + 1] + nums[i]
14
15
        max_diff = 0
16
        for i in range(n - 1):
17
            max_diff = max(max_diff, abs(left_sum[i] - right_sum[i + 1]))
18
19
        results.append(max_diff)
20
21
    return results
22
23
t = int(input())
24
test_cases = [(int(input()), list(map(int, input().split()))) for _ in range(t)]
25
results = max_absolute_difference(test_cases)
26
for result in results:
27
    print(result)
28",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833763
1387833757,shshloka,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
    for t in test_cases:
4
        N, K = t[0]
5
        energy = t[1]
6
        7
        total_energy = sum(energy)
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
        12
        target = total_energy // N
13
        operations = 0
14
        imbalance = 0
15
        16
        for e in energy:
17
            imbalance += e - target
18
            if abs(imbalance) % K != 0:
19
                results.append(-1)
20
                break
21
            operations += abs(imbalance) // K
22
        else:
23
            results.append(operations)
24
    25
    return results
26
27
T = int(input())
28
test_cases = []
29
for _ in range(T):
30
    N, K = map(int, input().split())
31
    energy = list(map(int, input().split()))
32
    test_cases.append(((N, K), energy))
33
34
results = equalize_energy(test_cases)
35
for res in results:
36
    print(res)
37",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833757
1387833760,ayushaj14,unknown,unknown,"1
def solve_product_exclusion(test_cases):
2
    results = []
3
4
    for values in test_cases:
5
        n = len(values)
6
        if n == 2:
7
            # Special edge case for n = 2
8
            results.append(f""{values[1]} {values[0]}"")
9
            continue
10
11
        # Initialize prefix and suffix product arrays
12
        prefix = [1] * n
13
        suffix = [1] * n
14
15
        # Compute prefix products
16
        for i in range(1, n):
17
            prefix[i] = prefix[i - 1] * values[i - 1]
18
19
        # Compute suffix products
20
        for i in range(n - 2, -1, -1):
21
            suffix[i] = suffix[i + 1] * values[i + 1]
22
23
        # Compute result for each index
24
        result = [prefix[i] * suffix[i] for i in range(n)]
25
        results.append("" "".join(map(str, result)))
26
27
    # Print all results at once
28
    print(""\n"".join(results))
29
30
31
def main():
32
    # Read input
33
    T = int(input().strip())
34
    test_cases = []
35
36
    for _ in range(T):
37
        n = int(input().strip())
38
        values = list(map(int, input().strip().split()))
39
        test_cases.append(values)
40
41
    solve_product_exclusion(test_cases)
42
43
44
if __name__ == ""__main__"":
45
    main()
46",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833760
1387833761,h1032220798,unknown,unknown,"1
def solve():
2
    t = int(input())
3
    for _ in range(t):
4
        n = int(input())
5
        nums = list(map(int, input().split()))
6
        7
        total_sum = sum(nums)
8
        left_sum = 0
9
        max_difference = 0
10
        11
        for i in range(n - 1):
12
            left_sum += nums[i]
13
            right_sum = total_sum - left_sum
14
            max_difference = max(max_difference, abs(left_sum - right_sum))
15
        16
        print(max_difference)
17
18
solve()",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833761
1387833753,sonamyadav7208,unknown,unknown,"1
def product_array(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
        8
        prefix_product = [1] * n
9
        suffix_product = [1] * n
10
        result = [1] * n
11
        12
        prefix_product[0] = values[0]
13
        for i in range(1, n):
14
            prefix_product[i] = prefix_product[i-1] * values[i]
15
        16
        suffix_product[n-1] = values[n-1]
17
        for i in range(n-2, -1, -1):
18
            suffix_product[i] = suffix_product[i+1] * values[i]
19
        20
        for i in range(n):
21
            if i == 0:
22
                result[i] = suffix_product[1]
23
            elif i == n-1:
24
                result[i] = prefix_product[n-2]
25
            else:
26
                result[i] = prefix_product[i-1] * suffix_product[i+1]
27
        28
        results.append(result)
29
    30
    return results
31
32
T = int(input())
33
test_cases = []
34
35
for _ in range(T):
36
    n = int(input())
37
    values = list(map(int, input().split()))
38
    test_cases.append((n, values))
39
40
results = product_array(T, test_cases)
41
42
for result in results:
43
    print("" "".join(map(str, result)))",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833753
1387833755,singhark94,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int findMaxDifference(vector<int>& nums) {
9
    int n = nums.size();
10
    if (n < 2) return 0;
11
    12
    // Calculate prefix sums for efficient subarray sum computation
13
    vector<long long> prefixSum(n + 1, 0);
14
    for (int i = 0; i < n; i++) {
15
        prefixSum[i + 1] = prefixSum[i] + nums[i];
16
    }
17
    18
    // Try all possible partition points to find maximum difference
19
    long long maxDiff = 0;
20
    // We need at least one element in each partition
21
    for (int i = 1; i < n; i++) {
22
        // Left subarray sum: from 0 to i-1
23
        long long leftSum = prefixSum[i] - prefixSum[0];
24
        // Right subarray sum: from i to n-1
25
        long long rightSum = prefixSum[n] - prefixSum[i];
26
        27
        // Calculate absolute difference
28
        long long diff = abs(leftSum - rightSum);
29
        maxDiff = max(maxDiff, diff);
30
    }
31
    32
    return maxDiff;
33
}
34
35
int main() {
36
    int t;
37
    cin >> t;
38
    39
    while (t--) {
40
        int n;
41
        cin >> n;
42
        43
        vector<int> nums(n);
44
        for (int i = 0; i < n; i++) {
45
            cin >> nums[i];
46
        }
47
        48
        cout << findMaxDifference(nums) << endl;
49
    }
50
    51
    return 0;
52
}",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833755
1387833756,sauravyadav244,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    total_sum = sum(nums)
4
    left_sum = 0
5
    max_diff = 0
6
7
    for i in range(n - 1):
8
        left_sum += nums[i]
9
        right_sum = total_sum - left_sum
10
        max_diff = max(max_diff, abs(left_sum - right_sum))
11
12
    return max_diff
13
14
# Input reading
15
t = int(input())
16
results = []
17
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    results.append(max_absolute_difference(nums))
22
23
# Output results
24
for res in results:
25
    print(res)
26",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833756
1387833747,h1032221359,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
5
    left_product = 1
6
    for i in range(n):
7
        result[i] = left_product
8
        left_product *= values[i]
9
   10
    right_product = 1
11
    for i in range(n-1, -1, -1):
12
        result[i] *= right_product
13
        right_product *= values[i]
14
    15
    return result
16
17
def main():
18
    import sys
19
    input = sys.stdin.read
20
    data = input().split()
21
    22
    idx = 0
23
    T = int(data[idx])
24
    idx += 1
25
    26
    for _ in range(T):
27
        n = int(data[idx])
28
        idx += 1
29
        values = list(map(int, data[idx:idx+n]))
30
        idx += n
31
        32
        result = product_except_self(values)
33
        print(' '.join(map(str, result)))
34
35
if __name__ == ""__main__"":
36
    main()",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833747
1387833749,yashdubeyenter15,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt(); 
8
        9
        while (T-- > 0) {
10
            int N = scanner.nextInt(); 
11
            int K = scanner.nextInt(); 
12
            13
            long[] energy = new long[N];
14
            long totalEnergy = 0;
15
            16
            17
            for (int i = 0; i < N; i++) {
18
                energy[i] = scanner.nextLong();
19
                totalEnergy += energy[i];
20
            }
21
            22
            System.out.println(minimumOperations(N, K, energy, totalEnergy));
23
        }
24
        25
        scanner.close();
26
    }
27
    28
    private static int minimumOperations(int N, int K, long[] energy, long totalEnergy) {
29
        30
        if (totalEnergy % N != 0) {
31
            return -1;
32
        }
33
        34
        long targetEnergy = totalEnergy / N;
35
        36
       37
        boolean isEqualized = true;
38
        for (int i = 0; i < N; i++) {
39
            if (energy[i] != targetEnergy) {
40
                isEqualized = false;
41
                break;
42
            }
43
        }
44
        if (isEqualized) {
45
            return 0;
46
        }
47
        48
       49
        for (int i = 0; i < N; i++) {
50
            if (Math.abs(energy[i] - targetEnergy) % K != 0) {
51
                return -1;
52
            }
53
        }
54
        55
        56
        int operations = 0;
57
        for (int i = 0; i < N; i++) {
58
            operations += Math.abs(energy[i] - targetEnergy) / K;
59
        }
60
        61
        62
        return operations / 2;
63
    }
64
}",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833749
1387833752,unborntadpole,unknown,unknown,"1
def listToString(l):
2
    str1 = ''
3
    for i in l:
4
        str1 = str1 + str(i) + "" ""
5
    return str1.strip()
6
7
n = int(input())
8
for i in range(n):
9
    len = int(input())
10
    values = input().split()
11
    result = []
12
    for i in range(len):
13
        temp_num = 1
14
        for value in values:
15
            value = int(value)
16
            if value !=  int(values[i]):
17
                temp_num *= value
18
        result.append(temp_num)
19
    print(listToString(result))",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833752
1387833746,paragchaudhary_1,unknown,unknown,"1
def min_operations(n, k, energy):
2
    """"""
3
    Calculates the minimum number of operations required to equalize the energy across all stations.
4
5
    Args:
6
      n: The number of power stations.
7
      k: The number of energy units that can be transferred in one operation.
8
      energy: A list of integers representing the energy of each station.
9
10
    Returns:
11
      The minimum number of operations required, or -1 if it's impossible to equalize.
12
    """"""
13
14
    total_energy = sum(energy)
15
    if total_energy % n != 0:
16
        return -1
17
18
    target_energy = total_energy // n
19
    operations = 0
20
    surplus = 0
21
    deficit = 0
22
23
    for i in range(n):
24
        diff = energy[i] - target_energy
25
        if diff > 0:
26
            surplus += diff  # Energy that needs to be transferred out
27
        elif diff < 0:
28
            deficit -= diff  # Energy that needs to be transferred in
29
30
    # Both surplus and deficit must be equal to achieve the balance
31
    if surplus != deficit:
32
        return -1
33
34
    operations = (surplus + k - 1) // k  # Total operations needed (surplus or deficit)
35
36
    return operations
37
38
# Get number of test cases
39
t = int(input())
40
41
for _ in range(t):
42
    n, k = map(int, input().split())
43
    energy = list(map(int, input().split()))
44
    result = min_operations(n, k, energy)
45
    print(result)
46",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833746
1387833743,h1032221046,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
4
    for test_case in test_cases:
5
        N, K, energy = test_case
6
        total_energy = sum(energy)
7
8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target = total_energy // N
14
        transfers = 0
15
        imbalance = 0
16
17
        # Calculate imbalance and transfers needed
18
        for i in range(N):
19
            imbalance += energy[i] - target
20
            if imbalance % K != 0:
21
                results.append(-1)
22
                break
23
            transfers += abs(imbalance) // K
24
        else:
25
            results.append(transfers)
26
27
    return results
28
29
30
# Input reading
31
T = int(input())  # Number of test cases
32
test_cases = []
33
34
for _ in range(T):
35
    N, K = map(int, input().split())
36
    energy = list(map(int, input().split()))
37
    test_cases.append((N, K, energy))
38
39
# Process test cases
40
results = min_operations_to_equalize(T, test_cases)
41
42
# Output results
43
for result in results:
44
    print(result)
45",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833743
1387833744,h1032220220,unknown,unknown,"1
def maxAbsDifference(t, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, nums = case
6
        total_sum = sum(nums)
7
        8
  9
        left_sum = 0
10
        max_diff = 0
11
        12
13
        for i in range(n - 1): 
14
            left_sum += nums[i]
15
            right_sum = total_sum - left_sum
16
            diff = abs(left_sum - right_sum)
17
            max_diff = max(max_diff, diff)
18
        19
        results.append(max_diff)
20
    21
    return results
22
23
24
t = int(input()) 
25
test_cases = []
26
for _ in range(t):
27
    n = int(input())  
28
    nums = list(map(int, input().split())) 
29
    test_cases.append((n, nums))
30
31
32
results = maxAbsDifference(t, test_cases)
33
34
35
for result in results:
36
    print(result)
37",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833744
1387833740,h1032220053,unknown,unknown,"1
def max_absolute_difference(nums, n):
2
    total_sum = sum(nums)
3
    left_sum = 0
4
    max_diff = 0
5
6
    for i in range(n - 1):
7
        left_sum += nums[i]
8
        right_sum = total_sum - left_sum
9
        max_diff = max(max_diff, abs(left_sum - right_sum))
10
    11
    return max_diff
12
13
# Input handling
14
t = int(input())
15
results = []
16
17
for _ in range(t):
18
    n = int(input())
19
    nums = list(map(int, input().split()))
20
    results.append(max_absolute_difference(nums, n))
21
22
# Output results
23
print(*results, sep=""\n"")
24",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833740
1387833736,warangsmit,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n,k=map(int,input().split())
4
    arr=list(map(int,input().split()))
5
    summ=sum(arr)
6
    if summ%n:print(-1)
7
    else:
8
        avg=summ//n
9
        bal=[i-avg for i in arr]
10
        ans=0
11
        total=0
12
        for i in bal:
13
            total+=i
14
            ans+=abs(total)//k
15
        print(ans)",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833736
1387833737,ravislprajapati,unknown,unknown,"1
def max_absolute_difference(nums):
2
    """"""
3
    Calculates the maximum absolute difference between the sums of two contiguous subarrays.
4
5
    Args:
6
      nums: A list of integers.
7
8
    Returns:
9
      The maximum absolute difference.
10
    """"""
11
12
    n = len(nums)
13
    prefix_sum = [0] * (n + 1)
14
15
    # Calculate prefix sum
16
    for i in range(1, n + 1):
17
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
18
19
    max_diff = 0
20
    for i in range(1, n):
21
        left_sum = prefix_sum[i]
22
        right_sum = prefix_sum[n] - left_sum
23
        max_diff = max(max_diff, abs(left_sum - right_sum))
24
25
    return max_diff
26
27
# Get input
28
t = int(input())
29
30
for _ in range(t):
31
    n = int(input())
32
    nums = list(map(int, input().split()))
33
    result = max_absolute_difference(nums)
34
    print(result)",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833737
1387833738,samadshaikh22005,unknown,unknown,"1
2
#include <iostream>
3
using namespace std;
4
5
void solve() {
6
    int T;
7
    cin >> T;
8
    9
    while (T--) {
10
        int n;
11
        cin >> n;
12
        int values[n], result[n];
13
        14
        for (int i = 0; i < n; i++) {
15
            cin >> values[i];
16
        }
17
        18
        result[0] = 1;
19
        for (int i = 1; i < n; i++) {
20
            result[i] = result[i - 1] * values[i - 1];
21
        }
22
        23
        int right_product = 1;
24
        for (int i = n - 1; i >= 0; i--) {
25
            result[i] *= right_product;
26
            right_product *= values[i];
27
        }
28
        29
        for (int i = 0; i < n; i++) {
30
            cout << result[i] << "" "";
31
        }
32
        cout << endl;
33
    }
34
}
35
36
int main() {
37
    solve();
38
    return 0;
39
}
40",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833738
1387833726,h1032220736,unknown,unknown,"1
def power_station_equalizer(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
7
        # Check if equal distribution is possible
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
12
        target_energy = total_energy // N
13
        operations = 0
14
        balance = 0
15
        is_possible = True
16
17
        for i in range(N):
18
            diff = energy[i] - target_energy
19
            balance += diff
20
21
            # Check if balance can be corrected in K-unit operations
22
            if abs(balance) % K != 0:
23
                is_possible = False
24
                break
25
26
            operations += abs(balance // K)
27
28
        results.append(operations if is_possible else -1)
29
30
    return results
31
32
33
# Input reading
34
T = int(input())
35
test_cases = []
36
37
for _ in range(T):
38
    N, K = map(int, input().split())
39
    energy = list(map(int, input().split()))
40
    test_cases.append((N, K, energy))
41
42
# Get and print results
43
results = power_station_equalizer(test_cases)
44
for result in results:
45
    print(result)",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833726
1387833727,h1032221356,unknown,unknown,"1
def equalize_energy():
2
    T = int(input()) 
3
    results = []
4
    5
    for _ in range(T):
6
        7
        N, K = map(int, input().split())
8
        9
        energy = list(map(int, input().split()))
10
        11
        total_energy = sum(energy)
12
        13
        14
        if total_energy % N != 0:
15
            results.append(-1)
16
            continue
17
        18
        target = total_energy // N
19
        balance = 0
20
        operations = 0
21
        possible = True
22
        23
        24
        for e in energy:
25
            26
            balance += e - target
27
            28
            if balance % K != 0:
29
                possible = False
30
                break
31
            32
            operations += abs(balance) // K
33
        34
        if possible:
35
            results.append(operations)
36
        else:
37
            results.append(-1)
38
    39
    40
    print(""\n"".join(map(str, results)))
41
42
43
equalize_energy()
44",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833727
1387833733,h1032220062,unknown,unknown,"1
def solve_testcase(n, nums):
2
3
    # If array has only 2 elements, return their absolute difference
4
5
    if n == 2:
6
7
        return abs(nums[0] - nums[1])
8
9
    10
11
    # Calculate the total sum of the array
12
13
    total_sum = sum(nums)
14
15
    16
17
    max_diff = 0
18
19
    left_sum = 0
20
21
    22
23
    # Try each possible partition point
24
25
    # We need to ensure both subarrays are non-empty,
26
27
    # so we only go up to n-1 (leaving at least one element for the right subarray)
28
29
    for i in range(n-1):
30
31
        # Add current element to left sum
32
33
        left_sum += nums[i]
34
35
        # Right sum is the remaining elements
36
37
        right_sum = total_sum - left_sum
38
39
        # Calculate absolute difference
40
41
        curr_diff = abs(left_sum - right_sum)
42
43
        # Update max_diff if current difference is larger
44
45
        max_diff = max(max_diff, curr_diff)
46
47
    48
49
    return max_diff
50
51
def main():
52
53
    # Read number of test cases
54
55
    t = int(input())
56
57
    58
59
    # Process each test case
60
61
    for _ in range(t):
62
63
        # Read array size
64
65
        n = int(input())
66
67
        # Read array elements
68
69
        nums = list(map(int, input().split()))
70
71
        72
73
        # Solve current test case
74
75
        result = solve_testcase(n, nums)
76
77
        78
79
        # Print result
80
81
        print(result)
82
83
if __name__ == ""__main__"":
84
85
    main()",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833733
1387833724,h1032221631,unknown,unknown,"1
def solve_product_excluding_self(test_cases):
2
    results = []
3
    for t in range(test_cases):
4
        n = int(input())
5
        values = list(map(int, input().split()))
6
        if n == 1:
7
            results.append([1])
8
            continue
9
10
        prefix = [1] * n
11
        suffix = [1] * n
12
        result = [0] * n
13
        for i in range(1, n):
14
            prefix[i] = prefix[i - 1] * values[i - 1]
15
16
        for i in range(n - 2, -1, -1):
17
            suffix[i] = suffix[i + 1] * values[i + 1]
18
        for i in range(n):
19
            result[i] = prefix[i] * suffix[i]
20
21
        results.append(result)
22
    for res in results:
23
        print("" "".join(map(str, res)))
24
T = int(input())
25
solve_product_excluding_self(T)
26
            ",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833724
1387833721,radhikajoshi2519,unknown,unknown,"1
def max_absolute_difference(nums, n):
2
    # Calculate the prefix sum
3
    prefix_sum = [0] * n
4
    prefix_sum[0] = nums[0]
5
    for i in range(1, n):
6
        prefix_sum[i] = prefix_sum[i - 1] + nums[i]
7
8
    total_sum = prefix_sum[-1]
9
    max_diff = 0
10
11
    # Iterate to find the maximum absolute difference
12
    for i in range(n - 1):
13
        sum_left = prefix_sum[i]
14
        sum_right = total_sum - sum_left
15
        max_diff = max(max_diff, abs(sum_left - sum_right))
16
17
    return max_diff
18
19
# Read input
20
t = int(raw_input())  # Number of test cases
21
results = []
22
for _ in range(t):
23
    n = int(raw_input())  # Size of the array
24
    nums = map(int, raw_input().split())  # Array elements
25
    results.append(max_absolute_difference(nums, n))
26
27
# Print all results
28
for res in results:
29
    print res
30",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833721
1387833722,sudhanshdubey75,unknown,unknown,"1
def solve():
2
    import sys
3
    data = sys.stdin.read().strip().split()
4
    t = int(data[0])
5
    idx = 1
6
7
    for _ in range(t):
8
        n = int(data[idx]); idx += 1
9
        nums = list(map(int, data[idx:idx+n]))
10
        idx += n
11
        12
        total_sum = sum(nums)
13
        14
        prefix_sum = 0
15
        max_diff = 0
16
17
        for i in range(n - 1):
18
            prefix_sum += nums[i]
19
            diff = abs(2 * prefix_sum - total_sum)
20
            if diff > max_diff:
21
                max_diff = diff
22
        23
        print(max_diff)
24
25
solve()",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833722
1387833723,h1032221519,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833723
1387833713,hrichamehra11,unknown,unknown,"1
def min_operations_to_equalize_energy(test_cases):
2
    results = []
3
    4
    for n, k, energy in test_cases:
5
        # Step 1: Check if total energy is divisible by N
6
        total_energy = sum(energy)
7
        if total_energy % n != 0:
8
            results.append(-1)
9
            continue
10
        11
        # Step 2: Compute target energy per station
12
        target = total_energy // n
13
        14
        # Step 3: Compute imbalance array and cumulative imbalance
15
        imbalance = [energy[i] - target for i in range(n)]
16
        cumulative = 0
17
        operations = 0
18
        feasible = True
19
        20
        for d in imbalance:
21
            cumulative += d
22
            if cumulative % k != 0:
23
                feasible = False
24
                break
25
            operations += abs(cumulative // k)
26
        27
        # Step 4: Store result based on feasibility
28
        if feasible:
29
            results.append(operations)
30
        else:
31
            results.append(-1)
32
    33
    return results
34
35
# Input Handling
36
t = int(input())
37
test_cases = []
38
for _ in range(t):
39
    n, k = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((n, k, energy))
42
43
# Processing and Output
44
output = min_operations_to_equalize_energy(test_cases)
45
for res in output:
46
    print(res)
47",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833713
1387833714,h1032220289,unknown,unknown,"1
def main():
2
    t = int(input())  
3
    for _ in range(t):
4
        n = int(input()) 
5
        nums = list(map(int, input().split()))  
6
        7
        total_sum = sum(nums)
8
        left_sum = 0
9
        max_diff = float('-inf') 
10
        11
        for i in range(n - 1):  
12
            left_sum += nums[i]
13
            right_sum = total_sum - left_sum
14
            max_diff = max(max_diff, abs(left_sum - right_sum))
15
        16
        print(max_diff)
17
main()
18",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833714
1387833719,kamblesamruddhi2,unknown,unknown,"1
T = int(input())  
2
for _ in range(T):
3
    n = int(input())
4
    values = list(map(int, input().split())) 
5
    prefix = [1] * n
6
    suffix = [1] * n
7
    result = [1] * n
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] * values[i - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] * values[i + 1]
12
    for i in range(n):
13
        result[i] = prefix[i] * suffix[i]
14
    print("" "".join(map(str, result)))",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833719
1387833708,imharsh1910,unknown,unknown,"1
def calculate_result(arr):
2
    n = len(arr)
3
    result = []
4
    for i in range(n):
5
        num = 1
6
        for j in range(n):
7
            if i != j:
8
                num *= arr[j]
9
        result.append(num)
10
    return result
11
12
T = int(input())
13
for _ in range(T):
14
    n = int(input())
15
    arr = list(map(int, input().split()))
16
    result = calculate_result(arr)
17
    print(*result)
18",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833708
1387833712,sohampatil1807,unknown,unknown,"1
def solve_product_array(values, n):
2
    """"""
3
    Calculate product of all elements except self for each position.
4
    Uses O(1) extra space (not counting the output array).
5
    """"""
6
    # Handle edge cases
7
    if n < 2:
8
        return []
9
        10
    # Initialize result array
11
    result = [0] * n
12
    13
    # Calculate products using a two-pass approach
14
    15
    # First pass: Calculate products of all elements to the left
16
    # result[i] will store product of all elements left of i
17
    result[0] = 1
18
    for i in range(1, n):
19
        result[i] = values[i - 1] * result[i - 1]
20
    21
    # Second pass: Calculate products of all elements to the right
22
    # and multiply with existing left products
23
    right_product = 1
24
    for i in range(n - 1, -1, -1):
25
        result[i] = result[i] * right_product
26
        right_product *= values[i]
27
    28
    return result
29
30
def main():
31
    # Read number of test cases
32
    T = int(input())
33
    34
    # Process each test case
35
    for _ in range(T):
36
        # Read array size
37
        n = int(input())
38
        39
        # Read array values
40
        values = list(map(int, input().split()))
41
        42
        # Calculate result
43
        result = solve_product_array(values, n)
44
        45
        # Print result
46
        print("" "".join(map(str, result)))
47
48
if _name_ == ""_main_"":
49
    main()",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833712
1387833709,yashkchaudhari1,unknown,unknown,"1
def main():
2
    import sys
3
    input = sys.stdin.read().split()
4
    ptr = 0
5
    T = int(input[ptr])
6
    ptr += 1
7
    for _ in range(T):
8
        N = int(input[ptr])
9
        K = int(input[ptr + 1])
10
        ptr += 2
11
        energy = list(map(int, input[ptr:ptr + N]))
12
        ptr += N
13
        14
        total = sum(energy)
15
        if total % N != 0:
16
            print(-1)
17
            continue
18
        avg = total // N
19
        20
        possible = True
21
        c = []
22
        for e in energy:
23
            diff = e - avg
24
            if diff % K != 0:
25
                possible = False
26
            c_val = diff // K
27
            c.append(c_val)
28
        29
        if not possible:
30
            print(-1)
31
            continue
32
        33
        # Compute prefix sums s
34
        s = [0] * N
35
        current_s = 0
36
        for i in range(1, N):
37
            current_s += c[i]
38
            s[i] = current_s
39
        40
        # Calculate max_neg_s
41
        max_neg_s = max(-s[i] for i in range(N))
42
        x0 = max(max_neg_s, 0)
43
        44
        # Compute total operations
45
        total_ops = 0
46
        for i in range(N):
47
            xi = x0 + s[i]
48
            total_ops += xi
49
        50
        print(total_ops)
51
52
if __name__ == ""__main__"":
53
    main()",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833709
1387833706,aaryanairy,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        left_sum = 0
7
        max_diff = 0
8
        for i in range(n - 1):
9
            left_sum += nums[i]
10
            right_sum = total_sum - left_sum
11
            max_diff = max(max_diff, abs(left_sum - right_sum))
12
        results.append(max_diff)
13
    return results
14
15
16
t = int(input())
17
test_cases = []
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    test_cases.append((n, nums))
22
23
results = max_absolute_difference(test_cases)
24
for res in results:
25
    print(res)",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833706
1387833702,h1032220053,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # Check if it's possible to equalize
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target = total_energy // N
9
    current_diff = 0
10
    operations = 0
11
    12
    for e in energy:
13
        current_diff += e - target
14
        if current_diff % K != 0:
15
            return -1
16
        operations += abs(current_diff) // K
17
    18
    return operations
19
20
# Input handling
21
T = int(input())
22
results = []
23
for _ in range(T):
24
    N, K = map(int, input().split())
25
    energy = list(map(int, input().split()))
26
    results.append(min_operations_to_equalize(N, K, energy))
27
28
# Output results
29
print(*results, sep=""\n"")
30",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833702
1387833703,adiv40816,unknown,unknown,"1
import sys
2
3
def min_operations_to_equalize(n, k, energy):
4
    total_energy = sum(energy)
5
    6
    # If total energy is not divisible by n, it's impossible to equalize
7
    if total_energy % n != 0:
8
        return -1
9
    10
    target = total_energy // n  # Each station should have this much energy
11
    operations = 0
12
    13
    for i in range(n):
14
        diff = energy[i] - target
15
        if diff % k != 0:
16
            return -1  # If difference is not a multiple of k, equalizing is impossible
17
        energy[i] -= diff
18
        energy[(i + 1) % n] += diff  # Transfer energy to the next station
19
        operations += abs(diff) // k
20
    21
    return operations
22
23
def main():
24
    t = int(input().strip())
25
    results = []
26
    for _ in range(t):
27
        n, k = map(int, input().strip().split())
28
        energy = list(map(int, input().strip().split()))
29
        results.append(str(min_operations_to_equalize(n, k, energy)))
30
    31
    print(""\n"".join(results))
32
33
if __name__ == ""__main__"":
34
    main()
35",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833703
1387833705,ritikalath2004,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def solve():
3
    # Read the number of test cases
4
    T = int(input())
5
6
    # Loop through each test case
7
    for _ in range(T):
8
        # Read the number of nodes (n)
9
        n = int(input())
10
11
        # Read the node values
12
        values = list(map(int, input().split()))
13
14
        # Initialize the result array and temporary variables for left and right products
15
        result = [1] * n
16
17
        # Left product calculation (store the products from the left side of each node)
18
        left_product = 1
19
        for i in range(n):
20
            result[i] = left_product
21
            left_product *= values[i]
22
23
        # Right product calculation (multiply the result with products from the right side of each node)
24
        right_product = 1
25
        for i in range(n-1, -1, -1):
26
            result[i] *= right_product
27
            right_product *= values[i]
28
29
        # Print the result array
30
        print("" "".join(map(str, result)))
31
32
# Call the solve function to execute
33
solve()",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833705
1387833695,pratiksolves,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
int main() {
6
    int T;
7
    cin >> T;
8
    9
    while (T--) {
10
        int N, K;
11
        cin >> N >> K;
12
        13
        vector<long long> energy(N);
14
        long long total_energy = 0;
15
        16
        for (int i = 0; i < N; ++i) {
17
            cin >> energy[i];
18
            total_energy += energy[i];
19
        }
20
        21
        if (total_energy % N != 0) {
22
            cout << -1 << endl;
23
            continue;
24
        }
25
        26
        long long target_energy = total_energy / N;
27
        long long operations = 0, surplus = 0;
28
        29
        30
        bool possible = true;
31
        for (int i = 0; i < N; ++i) {
32
            surplus += (energy[i] - target_energy);
33
            if (surplus % K != 0) {
34
                possible = false;
35
                break;
36
            }
37
            operations += abs(surplus / K);
38
        }
39
        40
        41
        if (possible)
42
            cout << operations << endl;
43
        else
44
            cout << -1 << endl;
45
    }
46
    47
    return 0;
48
}
49",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833695
1387833696,h1032220062,unknown,unknown,"1
def solve_testcase(N, K, energy):
2
3
    # Calculate total energy and target
4
5
    total_energy = sum(energy)
6
7
    8
9
    # Check if equal distribution is possible
10
11
    if total_energy % N != 0:
12
13
        return -1
14
15
    16
17
    target = total_energy // N
18
19
    20
21
    # If already equalized
22
23
    if all(e == target for e in energy):
24
25
        return 0
26
27
    28
29
    # For each position, calculate how many transfers are needed
30
31
    total_transfers = 0
32
33
    excess = 0  # Keep track of excess/deficit as we go around the circle
34
35
    36
37
    for i in range(N):
38
39
        # Current position's excess/deficit including previous remainder
40
41
        curr_with_excess = energy[i] + excess
42
43
        44
45
        # How far are we from target at this position
46
47
        diff_from_target = curr_with_excess - target
48
49
        50
51
        # This difference will need to be transferred to next position
52
53
        excess = diff_from_target
54
55
        56
57
        # If we need to make transfers
58
59
        if diff_from_target != 0:
60
61
            # If we can't transfer in K-unit chunks
62
63
            if abs(diff_from_target) % K != 0:
64
65
                return -1
66
67
                68
69
            # Add number of K-unit transfers needed
70
71
            total_transfers += abs(diff_from_target) // K
72
73
    74
75
    # After going around the circle, if there's any remainder, it's impossible
76
77
    if excess != 0:
78
79
        return -1
80
81
        82
83
    return total_transfers
84
85
def main():
86
87
    # Read number of test cases
88
89
    T = int(input())
90
91
    92
93
    # Process each test case
94
95
    for _ in range(T):
96
97
        # Read N and K
98
99
        N, K = map(int, input().split())
100
101
        102
103
        # Read energy array
104
105
        energy = list(map(int, input().split()))
106
107
        108
109
        # Solve current test case
110
111
        result = solve_testcase(N, K, energy)
112
113
        114
115
        # Print result
116
117
        print(result)
118
119
if __name__ == ""__main__"":
120
121
    main()",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833696
1387833697,omg40787,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K = case[0]
6
        energies = case[1]
7
8
        # Calculate total energy
9
        total_energy = sum(energies)
10
11
        # If total energy is not divisible by N, return -1
12
        if total_energy % N != 0:
13
            results.append(-1)
14
            continue
15
16
        # Target energy for each station
17
        target_energy = total_energy // N
18
19
        # Calculate the excess and deficit energy
20
        excess = 0
21
        deficit = 0
22
23
        for energy in energies:
24
            if energy > target_energy:
25
                excess += (energy - target_energy)
26
            elif energy < target_energy:
27
                deficit += (target_energy - energy)
28
29
        # Minimum number of operations required to balance excess and deficit
30
        if excess != deficit:
31
            results.append(-1)
32
        else:
33
            results.append(excess // K)
34
35
    return results
36
37
# Example usage:
38
test_cases = [
39
    ((3, 2), [4, 4, 4]),
40
    ((3, 1), [5, 3, 4]),
41
    ((4, 3), [5, 5, 5, 6])
42
]
43
44
results = equalize_energy(test_cases)
45
for result in results:
46
    print(result)
47",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833697
1387833690,h1032220347,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
3
def minimum_operations_to_equalize(T, test_cases):
4
5
    results = []
6
7
    8
9
    for t in range(T):
10
11
        N, K = test_cases[t][""N""], test_cases[t][""K""]
12
13
        energy = test_cases[t][""energy""]
14
15
        16
17
        total_energy = sum(energy)
18
19
        20
21
        # Check if total energy is divisible by N
22
23
        if total_energy % N != 0:
24
25
            results.append(-1)
26
27
            continue
28
29
        target = total_energy // N  # Target energy for each station
30
31
        32
33
        # Calculate difference array to measure imbalance
34
35
        diff = [energy[i] - target for i in range(N)]
36
37
        38
39
        # Track prefix sum to balance the circle
40
41
        prefix_sum = 0
42
43
        operations = 0
44
45
        for i in range(N):
46
47
            prefix_sum += diff[i]
48
49
            if prefix_sum % K != 0:  # If imbalance cannot be resolved with K
50
51
                operations = -1
52
53
                break
54
55
            operations += abs(prefix_sum) // K
56
57
        58
59
        results.append(operations if operations != -1 else -1)
60
61
    return results
62
63
# Input handling
64
65
if __name__ == ""__main__"":
66
67
    T = int(input())
68
69
    test_cases = []
70
71
    for _ in range(T):
72
73
        N, K = map(int, input().split())
74
75
        energy = list(map(int, input().split()))
76
77
        test_cases.append({""N"": N, ""K"": K, ""energy"": energy})
78
79
    results = minimum_operations_to_equalize(T, test_cases)
80
81
    for res in results:
82
83
        print(res)",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833690
1387833692,h1032221356,unknown,unknown,"1
def equalize_energy():
2
    T = int(input())  # Number of test cases
3
    results = []
4
    5
    for _ in range(T):
6
        # Read N and K
7
        N, K = map(int, input().split())
8
        # Read the energy array
9
        energy = list(map(int, input().split()))
10
        11
        total_energy = sum(energy)
12
        13
        # Check if total energy is divisible by N
14
        if total_energy % N != 0:
15
            results.append(-1)
16
            continue
17
        18
        target = total_energy // N
19
        balance = 0
20
        operations = 0
21
        possible = True
22
        23
        # Calculate the number of operations
24
        for e in energy:
25
            # Calculate surplus/deficit at current station
26
            balance += e - target
27
            # If balance isn't divisible by K, it's impossible
28
            if balance % K != 0:
29
                possible = False
30
                break
31
            # Operations are determined by how much balance exists
32
            operations += abs(balance) // K
33
        34
        if possible:
35
            results.append(operations)
36
        else:
37
            results.append(-1)
38
    39
    # Print all results
40
    print(""\n"".join(map(str, results)))
41
42
# Call the function
43
equalize_energy()
44",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833692
1387833691,paragchaudhary_1,unknown,unknown,"1
def min_operations(n, k, energy):
2
    total_energy = sum(energy)
3
    if total_energy % n != 0:
4
        return -1
5
6
    target_energy = total_energy // n
7
    operations = 0
8
9
    for i in range(n):
10
        diff = energy[i] - target_energy
11
        if diff > 0:
12
            operations += (diff + k - 1) // k  
13
14
    return operations
15
16
17
t = int(input())
18
19
for _ in range(t):
20
    n, k = map(int, input().split())
21
    energy = list(map(int, input().split()))
22
    result = min_operations(n, k, energy)
23
    print(result)",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833691
1387833688,kartikmadu2004,unknown,unknown,"1
def solve():
2
    t = int(input())
3
    for _ in range(t):
4
        n = int(input())
5
        nums = list(map(int, input().split()))
6
        7
        total_sum = sum(nums)
8
        left_sum = 0
9
        max_difference = 0
10
        11
        for i in range(n - 1):
12
            left_sum += nums[i]
13
            right_sum = total_sum - left_sum
14
            max_difference = max(max_difference, abs(left_sum - right_sum))
15
        16
        print(max_difference)
17
18
solve()",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833688
1387833683,jheelj86,unknown,unknown,"1
def solve_testcase(N, K, energy):
2
 3
    total_energy = sum(energy)
4
    5
   6
    if total_energy % N != 0:
7
        return -1
8
    9
    target = total_energy // N
10
    11
 12
    if all(e == target for e in energy):
13
        return 0
14
    15
16
    total_transfers = 0
17
    excess = 0 
18
    19
    for i in range(N):
20
       21
        curr_with_excess = energy[i] + excess
22
        23
       24
        diff_from_target = curr_with_excess - target
25
        26
        27
        excess = diff_from_target
28
        29
     30
        if diff_from_target != 0:
31
          32
            if abs(diff_from_target) % K != 0:
33
                return -1
34
                35
           36
            total_transfers += abs(diff_from_target) // K
37
    38
    39
    if excess != 0:
40
        return -1
41
        42
    return total_transfers
43
44
def main():
45
   46
    T = int(input())
47
    48
 49
    for _ in range(T):
50
       51
        N, K = map(int, input().split())
52
        53
      54
        energy = list(map(int, input().split()))
55
        56
       57
        result = solve_testcase(N, K, energy)
58
        59
        60
        print(result)
61
62
if __name__ == ""__main__"":
63
    main()",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833683
1387833685,harshrsharma29,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            print(-1)
11
            continue
12
        13
        target_energy = total_energy // N
14
        operations = 0
15
        current_balance = 0
16
        17
        for i in range(N):
18
            current_balance += energy[i] - target_energy
19
            operations += abs(current_balance) // K
20
            21
            if abs(current_balance) % K != 0:
22
                operations = -1
23
                break
24
        25
        print(operations)
26
27
solve()",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833685
1387833686,h1032220179,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833686
1387833677,vishal986958,unknown,unknown,"1
def calculate_result(test_cases):
2
    results = []
3
    for t in range(test_cases):
4
        n = int(input())  # Number of nodes in the current test case
5
        values = list(map(int, input().split()))
6
        7
        # Calculate prefix and suffix products
8
        prefix = [1] * n
9
        suffix = [1] * n
10
        11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] * values[i + 1]
16
        17
        # Calculate the result for the current test case
18
        result = [prefix[i] * suffix[i] for i in range(n)]
19
        results.append(result)
20
    21
    return results
22
23
# Read input
24
T = int(input())  # Number of test cases
25
output = calculate_result(T)
26
27
# Print the results
28
for res in output:
29
    print("" "".join(map(str, res)))",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833677
1387833679,aditya_jha027,unknown,unknown,"1
def maximum_absolute_difference(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, nums = case['n'], case['nums']
6
7
        prefix_sum = [0] * n
8
        prefix_sum[0] = nums[0]
9
        for i in range(1, n):
10
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
11
12
        total_sum = prefix_sum[-1]
13
14
        max_abs_diff = 0
15
        for i in range(1, n):
16
            sum_left = prefix_sum[i - 1]
17
            sum_right = total_sum - sum_left
18
            max_abs_diff = max(max_abs_diff, abs(sum_left - sum_right))
19
20
        results.append(max_abs_diff)
21
22
    return results
23
24
def parse_input():
25
    t = int(input())
26
    test_cases = []
27
28
    for _ in range(t):
29
        n = int(input())
30
        nums = list(map(int, input().split()))
31
        test_cases.append({""n"": n, ""nums"": nums})
32
33
    return test_cases
34
35
def main():
36
    test_cases = parse_input()
37
    results = maximum_absolute_difference(test_cases)
38
    for res in results:
39
        print(res)
40
41
if __name__ == ""__main__"":
42
    main()",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833679
1387833681,h1032220703,unknown,unknown,"1
def power_station_equalizer(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
7
        # Check if equal distribution is possible
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
12
        target_energy = total_energy // N
13
        operations = 0
14
        balance = 0
15
        is_possible = True
16
17
        for i in range(N):
18
            diff = energy[i] - target_energy
19
            balance += diff
20
21
            # Check if balance can be corrected in K-unit operations
22
            if abs(balance) % K != 0:
23
                is_possible = False
24
                break
25
26
            operations += abs(balance // K)
27
28
        results.append(operations if is_possible else -1)
29
30
    return results
31
32
33
# Input reading
34
T = int(input())
35
test_cases = []
36
37
for _ in range(T):
38
    N, K = map(int, input().split())
39
    energy = list(map(int, input().split()))
40
    test_cases.append((N, K, energy))
41
42
# Get and print results
43
results = power_station_equalizer(test_cases)
44
for result in results:
45
    print(result)
46",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833681
1387833674,harshtripathi752,unknown,unknown,"1
def maxSubDiff(n, nums):
2
    if n < 2:
3
        return 0
4
    preS = [0] * (n + 1)
5
    for i in range(n):
6
        preS[i + 1] = preS[i] + nums[i]
7
    8
    maxD = 0
9
    totS = preS[n]
10
    for i in range(n - 1):
11
        leftS = preS[i + 1]
12
        rightS = totS - leftS
13
        currD = abs(leftS - rightS)
14
        maxD = max(maxD, currD)
15
    16
    return maxD
17
18
t = int(input())
19
for _ in range(t):
20
    n = int(input())
21
    nums = list(map(int, input().split()))
22
    result = maxSubDiff(n, nums)
23
    print(result)",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833674
1387833675,snehimehta02,unknown,unknown,"1
def minimum_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
4
    if total_energy % N != 0:
5
        return -1
6
7
    target_energy = total_energy // N
8
    operations = 0
9
    balance = 0
10
11
    for e in energy:
12
        balance += e - target_energy
13
        if balance % K != 0:  
14
            return -1
15
        operations += abs(balance // K)
16
17
    return operations
18
19
def main():
20
    T = int(input())  
21
    results = []
22
23
    for _ in range(T):
24
        N, K = map(int, input().split())
25
        energy = list(map(int, input().split()))
26
27
        result = minimum_operations_to_equalize(N, K, energy)
28
        results.append(result)
29
30
    for result in results:
31
        print(result)
32
33
if __name__ == ""__main__"":
34
    main()
35",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833675
1387833673,jkinsuk760,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        total_product = 1
6
        zero_count = 0
7
8
        for value in values:
9
            if value != 0:
10
                total_product *= value
11
            else:
12
                zero_count += 1
13
        14
        result = []
15
        for value in values:
16
            if zero_count > 1:
17
                result.append(0)
18
            elif zero_count == 1:
19
                if value == 0:
20
                    result.append(total_product)
21
                else:
22
                    result.append(0)
23
            else:
24
                result.append(total_product // value)
25
        26
        results.append(result)
27
    return results
28
29
T = int(input())
30
test_cases = []
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
outputs = product_except_self(test_cases)
37
for output in outputs:
38
    print(' '.join(map(str, output)))
39",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833673
1387833672,goswamyashutosh9,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        # Check if total energy is divisible by N
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target = total_energy // N
16
        surplus = 0
17
        operations = 0
18
19
        for i in range(N):
20
            diff = energy[i] - target
21
            surplus += diff
22
23
            # Check if the surplus/deficit at each step is divisible by K
24
            if abs(surplus) % K != 0:
25
                results.append(-1)
26
                break
27
28
            # Add the operations required for the current difference
29
            operations += abs(diff) // K
30
        else:
31
            # If loop completes without breaking, check the final surplus
32
            if surplus == 0:
33
                results.append(operations // 2)  # Divide by 2 to avoid double-counting
34
            else:
35
                results.append(-1)
36
37
    return results
38
39
# Input Reading
40
T = int(input())
41
test_cases = []
42
43
for _ in range(T):
44
    N, K = map(int, input().split())
45
    energy = list(map(int, input().split()))
46
    test_cases.append(((N, K), energy))
47
48
# Compute Results
49
results = min_operations_to_equalize_energy(T, test_cases)
50
51
# Output Results
52
for res in results:
53
    print(res)
54",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833672
1387833666,yashkchaudhari1,unknown,unknown,"1
def main():
2
    import sys
3
    input = sys.stdin.read().split()
4
    ptr = 0
5
    T = int(input[ptr])
6
    ptr += 1
7
    for _ in range(T):
8
        N = int(input[ptr])
9
        K = int(input[ptr + 1])
10
        ptr += 2
11
        energy = list(map(int, input[ptr:ptr + N]))
12
        ptr += N
13
        14
        total = sum(energy)
15
        if total % N != 0:
16
            print(-1)
17
            continue
18
        avg = total // N
19
        20
        possible = True
21
        c = []
22
        for e in energy:
23
            diff = e - avg
24
            if diff % K != 0:
25
                possible = False
26
            c_val = diff // K
27
            c.append(c_val)
28
        29
        if not possible:
30
            print(-1)
31
            continue
32
        33
        # Compute prefix sums s
34
        s = [0] * N
35
        current_s = 0
36
        for i in range(1, N):
37
            current_s += c[i]
38
            s[i] = current_s
39
        40
        # Calculate max_neg_s
41
        max_neg_s = max(-s[i] for i in range(N))
42
        x0 = max(max_neg_s, 0)
43
        44
        # Compute total operations
45
        total_ops = 0
46
        for i in range(N):
47
            xi = x0 + s[i]
48
            total_ops += xi
49
        50
        print(total_ops)
51
52
if __name__ == ""__main__"":
53
    main()",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833666
1387833670,mahakantsingh113,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <cmath>
5
using namespace std;
6
7
vector<int> minimum_operations_to_equalize(int T, vector<pair<pair<int, int>, vector<int>>> &test_cases) {
8
    vector<int> results;
9
10
    for (int t = 0; t < T; t++) {
11
        int N = test_cases[t].first.first;
12
        int K = test_cases[t].first.second;
13
        vector<int> energy = test_cases[t].second;
14
15
        long long total_energy = accumulate(energy.begin(), energy.end(), 0LL);
16
        17
        // Check if equalization is possible
18
        if (total_energy % N != 0) {
19
            results.push_back(-1);
20
            continue;
21
        }
22
23
        int target = total_energy / N;
24
        vector<long long> imbalances(N);
25
        for (int i = 0; i < N; i++) {
26
            imbalances[i] = energy[i] - target;
27
        }
28
29
        // Calculate prefix sums and check operations
30
        long long prefix_sum = 0;
31
        long long operations = 0;
32
        bool possible = true;
33
34
        for (int i = 0; i < N; i++) {
35
            prefix_sum += imbalances[i];
36
            // If the imbalance cannot be corrected with K-unit transfers
37
            if (prefix_sum % K != 0) {
38
                possible = false;
39
                break;
40
            }
41
            operations += abs(prefix_sum) / K;
42
        }
43
44
        if (possible) {
45
            results.push_back(operations);
46
        } else {
47
            results.push_back(-1);
48
        }
49
    }
50
51
    return results;
52
}
53
54
int main() {
55
    int T;
56
    cin >> T;
57
    vector<pair<pair<int, int>, vector<int>>> test_cases(T);
58
59
    for (int t = 0; t < T; t++) {
60
        int N, K;
61
        cin >> N >> K;
62
        vector<int> energy(N);
63
        for (int i = 0; i < N; i++) {
64
            cin >> energy[i];
65
        }
66
        test_cases[t] = {{N, K}, energy};
67
    }
68
69
    vector<int> results = minimum_operations_to_equalize(T, test_cases);
70
71
    for (int res : results) {
72
        cout << res << endl;
73
    }
74
75
    return 0;
76
}
77
78",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833670
1387833671,damodarryadav,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
int main() {
5
    int T; // Number of test cases
6
    cin >> T;
7
    while (T--) {
8
        int n; // Number of nodes
9
        cin >> n;
10
        vector<int> values(n), result(n);
11
        long long totalProduct = 1; // Product of all non-zero elements
12
        int zeroCount = 0;          // Count of zeros in the array
13
        // Read input values and calculate totalProduct and zeroCount
14
        for (int i = 0; i < n; ++i) {
15
            cin >> values[i];
16
            if (values[i] == 0) {
17
                zeroCount++;
18
            } else {
19
                totalProduct *= values[i];
20
            }
21
        }
22
        // Compute result array
23
        for (int i = 0; i < n; ++i) {
24
            if (zeroCount > 1) {
25
                // If there are more than 1 zeros, all products will be zero
26
                result[i] = 0;
27
            } else if (zeroCount == 1) {
28
                // If there is exactly 1 zero
29
                result[i] = (values[i] == 0) ? totalProduct : 0;
30
            } else {
31
                // No zeros
32
                result[i] = totalProduct / values[i];
33
            }
34
        }
35
        // Print the result array
36
        for (int i = 0; i < n; ++i) {
37
            cout << result[i] << "" "";
38
        }
39
        cout << endl;
40
    }
41
    return 0;
42
}
43",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833671
1387833662,yashrajverma0805,unknown,unknown,"1
def minimum_operations(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K, energy = case
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // N  
12
        balance = 0
13
        operations = 0
14
        15
        for i in range(N):
16
            balance += energy[i] - target  
17
            if balance % K != 0:
18
                results.append(-1)
19
                break
20
            operations += abs(balance) // K  
21
        else:
22
            results.append(operations)
23
    24
    return results
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    N, K = map(int, input().split())
30
    energy = list(map(int, input().split()))
31
    test_cases.append((N, K, energy))
32
results = minimum_operations(T, test_cases)
33
for result in results:
34
    print(result)",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833662
1387833664,ag9867603762,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
4
    for _ in range(test_cases):
5
        n, k = map(int, raw_input().split())
6
        energy = map(int, raw_input().split())
7
        total_energy = sum(energy)
8
        if total_energy % n != 0:
9
            results.append(-1)
10
            continue
11
        target_energy = total_energy // n
12
        imbalance = 0
13
        operations = 0
14
        for i in range(n):
15
            imbalance += energy[i] - target_energy
16
            if imbalance % k != 0:
17
                results.append(-1)
18
                break
19
            operations += abs(imbalance // k)
20
        else:
21
            results.append(operations)
22
    for res in results:
23
        print(res)
24
25
26
T = int(raw_input())
27
equalize_energy(T)
28",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833664
1387833657,prashant_ps9833,unknown,unknown,"1
def max_abs_diff(nums):
2
    n = len(nums)
3
    prefix_sum = [0] * (n + 1)
4
5
    for i in range(1, n + 1):
6
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
7
    max_diff = 0
8
    for i in range(1, n):
9
        left_sum = prefix_sum[i]
10
        right_sum = prefix_sum[n] - left_sum
11
        max_diff = max(max_diff, abs(left_sum - right_sum))
12
13
    return max_diff
14
15
16
if __name__ == ""__main__"":
17
    t = int(input())
18
19
    for _ in range(t):
20
        n = int(input())
21
        nums = list(map(int, input().split()))
22
23
        result = max_abs_diff(nums)
24
        print(result)",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833657
1387833658,akshitha_ssays,unknown,unknown,"1
def solve():
2
3
    T = int(input())
4
5
    for _ in range(T):
6
7
        n = int(input())
8
9
        values = list(map(int, input().split()))
10
11
        result = [1] * n
12
13
        left_product = 1
14
        for i in range(n):
15
            result[i] = left_product
16
            left_product *= values[i]
17
18
        right_product = 1
19
        for i in range(n-1, -1, -1):
20
            result[i] *= right_product
21
            right_product *= values[i]
22
23
        print("" "".join(map(str, result)))
24
25
solve()",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833658
1387833660,ssidd9770,unknown,unknown,"1
def min_operations_to_equalize_energy(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
11
        target_energy = total_energy // N
12
        balance = 0
13
        operations = 0
14
15
        for i in range(N):
16
            balance += energy[i] - target_energy
17
            if balance % K != 0:
18
                results.append(-1)
19
                break
20
            operations += abs(balance // K)
21
        else:
22
            results.append(operations)
23
24
    return results
25
26
T = int(input())
27
test_cases = [(tuple(map(int, input().split())), list(map(int, input().split()))) for _ in range(T)]
28
results = min_operations_to_equalize_energy([(N, K, energy) for (N, K), energy in test_cases])
29
for result in results:
30
    print(result)
31",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833660
1387833656,swayam_prajapat1,unknown,unknown,"1
def min_operations_to_equalize(t, test_cases):  
2
    results = []  
3
    4
    for case in test_cases:  
5
        N, K = case[0]  
6
        energy = case[1]  
7
8
        total_energy = sum(energy)  
9
10
        11
        if total_energy % N != 0:  
12
            results.append(-1)  
13
            continue  
14
        15
        target_energy = total_energy // N  
16
        surplus = 0  
17
        deficit = 0  
18
        19
        20
        for e in energy:  
21
            if e > target_energy:  
22
                surplus += (e - target_energy)  
23
            elif e < target_energy:  
24
                deficit += (target_energy - e)  
25
26
        27
        if surplus % K != 0 or deficit % K != 0:  
28
            results.append(-1)  
29
            continue  
30
        31
        32
        operations = surplus // K   
33
        34
        results.append(operations)  
35
    36
    return results  
37
38
39
import sys  
40
41
42
input_data = sys.stdin.read().strip().splitlines()  
43
T = int(input_data[0])  
44
test_cases = []  
45
46
for i in range(1, len(input_data), 2):  
47
    N, K = map(int, input_data[i].split())  
48
    energy = list(map(int, input_data[i + 1].split()))  
49
    test_cases.append(((N, K), energy))  
50
51
52
results = min_operations_to_equalize(T, test_cases)  
53
54
for result in results:  
55
    print(result)",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833656
1387833653,h1032220062,unknown,unknown,"1
def solve_testcase(n, values):
2
3
    # Initialize result array
4
5
    result = [1] * n
6
7
    8
9
    # Calculate prefix products
10
11
    # result[i] will first store product of all elements to the left of i
12
13
    prefix = 1
14
15
    for i in range(n):
16
17
        result[i] = prefix
18
19
        prefix *= values[i]
20
21
    22
23
    # Calculate suffix products and combine with prefix products
24
25
    # For each position, multiply its prefix product with suffix product
26
27
    suffix = 1
28
29
    for i in range(n-1, -1, -1):
30
31
        result[i] *= suffix
32
33
        suffix *= values[i]
34
35
    36
37
    return result
38
39
def main():
40
41
    # Read number of test cases
42
43
    T = int(input())
44
45
    46
47
    # Process each test case
48
49
    for _ in range(T):
50
51
        # Read input for current test case
52
53
        n = int(input())
54
55
        values = list(map(int, input().split()))
56
57
        58
59
        # Solve current test case
60
61
        result = solve_testcase(n, values)
62
63
        64
65
        # Print result
66
67
        print(*result)
68
69
if __name__ == ""__main__"":
70
71
    main()",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833653
1387833654,radhikajoshi2519,unknown,unknown,"1
def minimum_operations():
2
    T = int(input())  # Number of test cases
3
    results = []
4
    5
    for _ in range(T):
6
        N, K = map(int, input().split())  # Number of stations and units of energy per operation
7
        energy = list(map(int, input().split()))  # Energy levels at each station
8
        9
        # Check if equalization is possible
10
        total_energy = sum(energy)
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        # Target energy level for each station
16
        target_energy = total_energy // N
17
        18
        # Calculate difference array
19
        diff = [energy[i] - target_energy for i in range(N)]
20
        21
        # Check if all differences are divisible by K
22
        if any(d % K != 0 for d in diff):
23
            results.append(-1)
24
            continue
25
        26
        # Count the number of operations needed
27
        operations = 0
28
        balance = 0
29
        for d in diff:
30
            balance += d // K
31
            operations += abs(balance)
32
        33
        results.append(operations)
34
    35
    # Print the results for all test cases
36
    print(""\n"".join(map(str, results)))
37
38
39
# Call the function to execute
40
minimum_operations()",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833654
1387833655,h1032221519,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
    # Compute the prefix sum array
5
    prefix_sum = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
8
    9
    max_diff = 0
10
    11
    # Iterate through all possible split points
12
    for i in range(1, n):
13
        left_sum = prefix_sum[i]
14
        right_sum = prefix_sum[n] - prefix_sum[i]
15
        current_diff = abs(left_sum - right_sum)
16
        17
        # Update the maximum difference
18
        if current_diff > max_diff:
19
            max_diff = current_diff
20
    21
    return max_diff
22
23
def main():
24
    import sys
25
    input = sys.stdin.read
26
    data = input().split()
27
    28
    idx = 0
29
    t = int(data[idx])  # Number of test cases
30
    idx += 1
31
    32
    for _ in range(t):
33
        n = int(data[idx])  # Size of the array
34
        idx += 1
35
        nums = list(map(int, data[idx:idx + n]))  # Array elements
36
        idx += n
37
        38
        result = max_absolute_difference(nums)
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833655
1387833648,shubhamgupta3009,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int T = scanner.nextInt();
9
10
        for (int t = 0; t < T; t++) {
11
            int n = scanner.nextInt();
12
            int[] values = new int[n];
13
            long totalProduct = 1;
14
            int zeroCount = 0;
15
16
            for (int i = 0; i < n; i++) {
17
                values[i] = scanner.nextInt();
18
                if (values[i] == 0) {
19
                    zeroCount++;
20
                } else {
21
                    totalProduct *= values[i];
22
                }
23
            }
24
25
            int[] result = new int[n];
26
            for (int i = 0; i < n; i++) {
27
                if (zeroCount > 1) {
28
                    result[i] = 0;
29
                } else if (zeroCount == 1) {
30
                    if (values[i] == 0) {
31
                        result[i] = (int) totalProduct;
32
                    } else {
33
                        result[i] = 0;
34
                    }
35
                } else {
36
                    result[i] = (int) (totalProduct / values[i]);
37
                }
38
            }
39
40
            for (int i = 0; i < n; i++) {
41
                System.out.print(result[i] + "" "");
42
            }
43
            System.out.println();
44
        }
45
46
        scanner.close();
47
    }
48
}",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833648
1387833651,abhishekgoyalas1,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()
48",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833651
1387833652,ambujbaranwal,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
import sys
3
import itertools
4
5
6
input = sys.stdin.read
7
data = input().split()
8
idx = 0
9
t = int(data[idx])
10
idx += 1
11
for _ in range(t):
12
    n = int(data[idx])
13
    idx += 1
14
    nums = list(map(int, data[idx:idx + n]))
15
    idx += n
16
    prefix = list(itertools.accumulate(nums))
17
    total_sum = prefix[-1]
18
    max_diff = max(abs(2 * p - total_sum) for p in prefix[:-1])
19
    print(max_diff)
20
21",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833652
1387833642,h1032220053,unknown,unknown,"1
def product_except_self(values, n):
2
    result = [1] * n
3
    4
    # Compute prefix products
5
    prefix = 1
6
    for i in range(n):
7
        result[i] = prefix
8
        prefix *= values[i]
9
    10
    # Compute suffix products and update result
11
    suffix = 1
12
    for i in range(n - 1, -1, -1):
13
        result[i] *= suffix
14
        suffix *= values[i]
15
    16
    return result
17
18
# Input handling
19
T = int(input())
20
for _ in range(T):
21
    n = int(input())
22
    values = list(map(int, input().split()))
23
    print(*product_except_self(values, n))
24",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833642
1387833645,ritikalath2004,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def solve():
3
4
    5
    T = int(input())
6
7
     8
9
    for _ in range(T):
10
11
       12
13
        n = int(input())
14
15
       16
17
        values = list(map(int, input().split()))
18
19
       20
21
        result = [1] * n
22
23
       24
25
        left_product = 1
26
27
        for i in range(n):
28
29
            result[i] = left_product
30
31
            left_product *= values[i]
32
33
       34
35
        right_product = 1
36
37
        for i in range(n-1, -1, -1):
38
39
            result[i] *= right_product
40
41
            right_product *= values[i]
42
43
        44
45
        print("" "".join(map(str, result)))
46
47
48
49
solve()",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833645
1387833647,aaryanairy,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        surplus = 0
12
        for i in range(N):
13
            diff = energy[i] - target
14
            surplus += diff
15
            if surplus % K != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(surplus // K)
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
results = minimum_operations(test_cases)
31
for res in results:
32
    print(res)",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833647
1387833641,h1032221062,unknown,unknown,"1
def product_except_self():
2
    # Reading number of test cases
3
    T = int(input())
4
    results = []
5
    6
    for _ in range(T):
7
        # Read the size of the array
8
        n = int(input())
9
        # Read the values of the nodes
10
        values = list(map(int, input().split()))
11
        12
        # Initialize the result array
13
        result = [1] * n
14
        15
        # Compute prefix products
16
        prefix = 1
17
        for i in range(n):
18
            result[i] = prefix
19
            prefix *= values[i]
20
        21
        # Compute suffix products and combine with prefix
22
        suffix = 1
23
        for i in range(n - 1, -1, -1):
24
            result[i] *= suffix
25
            suffix *= values[i]
26
        27
        # Store the result for this test case
28
        results.append("" "".join(map(str, result)))
29
    30
    # Print all results
31
    print(""\n"".join(results))
32
33
# Call the function
34
product_except_self()",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833641
1387833636,h1032220798,unknown,unknown,"1
def min_operations(n, k, energy):
2
    """"""
3
    Calculates the minimum number of operations required to equalize the energy across all stations.
4
5
    Args:
6
      n: The number of power stations.
7
      k: The number of energy units that can be transferred in one operation.
8
      energy: A list of integers representing the energy of each station.
9
10
    Returns:
11
      The minimum number of operations required, or -1 if it's impossible to equalize.
12
    """"""
13
14
    total_energy = sum(energy)
15
    if total_energy % n != 0:
16
        return -1
17
18
    target_energy = total_energy // n
19
    operations = 0
20
21
    for i in range(n):
22
        diff = energy[i] - target_energy
23
        if diff > 0:
24
            operations += (diff + k - 1) // k  # Ceiling division
25
26
    return operations
27
28
# Get number of test cases
29
t = int(input())
30
31
for _ in range(t):
32
    n, k = map(int, input().split())
33
    energy = list(map(int, input().split()))
34
    result = min_operations(n, k, energy)
35
    print(result)",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833636
1387833637,h1032221720,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
9
int main() {
10
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
11
    int T;
12
    cin >> T;  
13
14
    while (T--) {
15
        int n;
16
        cin >> n;  
17
        18
        vector<int> values(n), result(n, 1);
19
20
        21
        for (int i = 0; i < n; ++i) {
22
            cin >> values[i];
23
        }
24
25
        26
        int prefix_product = 1;
27
        for (int i = 0; i < n; ++i) {
28
            result[i] *= prefix_product;
29
            prefix_product *= values[i];
30
        }
31
32
      33
        int suffix_product = 1;
34
        for (int i = n - 1; i >= 0; --i) {
35
            result[i] *= suffix_product;
36
            suffix_product *= values[i];
37
        }
38
39
        40
        for (int i = 0; i < n; ++i) {
41
            cout << result[i] << "" "";
42
        }
43
        cout << endl;
44
    }
45
    return 0;
46
}
47",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833637
1387833640,h1032220371,unknown,unknown,"1
t=int(input())
2
for i in range(t):
3
    n=int(input())
4
    values=list(map(int,input().split()))
5
    6
    product=1
7
    for i in range(n):
8
        product=product*values[i]
9
        10
    result=[0]*n
11
    for i in range(n):
12
        result[i]=int(product//values[i])
13
    14
    for i in range(n-1):
15
        print(result[i],end=' ')
16
    print(result[n-1])
17
    18
    19
    20
    21",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833640
1387833632,atharvjadhav2910,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        left_sum = 0
7
        max_diff = 0
8
        for i in range(n - 1):
9
            left_sum += nums[i]
10
            right_sum = total_sum - left_sum
11
            max_diff = max(max_diff, abs(left_sum - right_sum))
12
        results.append(max_diff)
13
    return results
14
15
16
t = int(input())
17
test_cases = []
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    test_cases.append((n, nums))
22
23
results = max_absolute_difference(test_cases)
24
for res in results:
25
    print(res)",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833632
1387833634,kartikmadu2004,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            print(-1)
11
            continue
12
        13
        target_energy = total_energy // N
14
        operations = 0
15
        current_balance = 0
16
        17
        for i in range(N):
18
            current_balance += energy[i] - target_energy
19
            operations += abs(current_balance) // K
20
            21
            if abs(current_balance) % K != 0:
22
                operations = -1
23
                break
24
        25
        print(operations)
26
27
solve()",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833634
1387833633,singhark94,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
using namespace std;
5
6
long long minOperations(int N, int K, vector<int>& energy) {
7
    long long totalEnergy = accumulate(energy.begin(), energy.end(), 0LL);
8
9
    // Step 1: Check if equalization is possible
10
    if (totalEnergy % N != 0) return -1;
11
    long long target = totalEnergy / N;
12
13
    long long cumulativeSum = 0, operations = 0;
14
15
    // Step 2: Process each station and ensure valid transfers
16
    for (int i = 0; i < N; ++i) {
17
        long long diff = energy[i] - target;
18
        cumulativeSum += diff;
19
20
        // Step 3: Ensure the cumulative transfer is a multiple of K
21
        if (cumulativeSum % K != 0) return -1;
22
23
        // Step 4: Count the absolute number of moves required
24
        operations += abs(cumulativeSum) / K;
25
    }
26
27
    return operations;
28
}
29
30
int main() {
31
    int T;
32
    cin >> T;
33
34
    while (T--) {
35
        int N, K;
36
        cin >> N >> K;
37
        vector<int> energy(N);
38
        for (int i = 0; i < N; ++i) {
39
            cin >> energy[i];
40
        }
41
42
        cout << minOperations(N, K, energy) << endl;
43
    }
44
45
    return 0;
46
}
47",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833633
1387833629,sunaym1006,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def max_abs_difference(t, test_cases):
3
    results = []
4
    5
    for case in test_cases:
6
        n = case[0]
7
        nums = case[1]
8
        9
        total_sum = sum(nums)
10
        prefix_sum = 0
11
        max_diff = 0
12
        13
        for i in range(1, n):  # Partition between [0...i-1] and [i...n-1]
14
            prefix_sum += nums[i-1]  # Sum of elements from index 0 to i-1
15
            suffix_sum = total_sum - prefix_sum  # Sum of elements from index i to n-1
16
            diff = abs(prefix_sum - suffix_sum)
17
            max_diff = max(max_diff, diff)  # Track maximum absolute difference
18
        19
        results.append(max_diff)
20
    21
    return results
22
23
# Input reading part (for use in competitive programming platforms)
24
t = int(input())  # number of test cases
25
test_cases = []
26
27
for _ in range(t):
28
    n = int(input())  # size of the array
29
    nums = list(map(int, input().split()))  # elements of the array
30
    test_cases.append((n, nums))
31
32
results = max_abs_difference(t, test_cases)
33
for res in results:
34
    print(res)
35",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833629
1387833628,praveenbisht491,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        left_sum = 0
7
        max_diff = 0
8
        for i in range(n - 1):
9
            left_sum += nums[i]
10
            right_sum = total_sum - left_sum
11
            max_diff = max(max_diff, abs(left_sum - right_sum))
12
        results.append(max_diff)
13
    return results
14
15
16
t = int(input())
17
test_cases = []
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    test_cases.append((n, nums))
22
23
results = max_absolute_difference(test_cases)
24
for res in results:
25
    print(res)",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833628
1387833627,Gayathripoojary1,unknown,unknown,"1
def min_operations_to_equalize(t, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K, energy = case[""N""], case[""K""], case[""energy""]
6
        total_energy = sum(energy)
7
8
   9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target_energy = total_energy // N
14
        15
     16
        balance = 0
17
        operations = 0
18
        is_possible = True
19
20
        for e in energy:
21
            balance += (e - target_energy) 
22
            if abs(balance) % K != 0:  
23
                is_possible = False
24
                break
25
26
            operations += abs(balance) // K  
27
28
        if not is_possible:
29
            results.append(-1)
30
        else:
31
            results.append(operations)
32
33
    return results
34
35
36
def main():
37
    T = int(input())
38
    test_cases = []
39
40
    for _ in range(T):
41
        N, K = map(int, input().split())
42
        energy = list(map(int, input().split()))
43
        test_cases.append({""N"": N, ""K"": K, ""energy"": energy})
44
45
    results = min_operations_to_equalize(T, test_cases)
46
47
    for res in results:
48
        print(res)
49
50
51
if __name__ == ""__main__"":
52
    main()",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833627
1387833621,radhikajoshi2519,unknown,unknown,"1
def min_operations_to_equalize_energy(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # Check if equalization is possible
5
    if total_energy % N != 0:
6
        return -1  # Not possible to equalize
7
8
    target = total_energy // N  # Target energy for each station
9
    prefix_diff = 0  # Tracks cumulative difference
10
    operations = 0
11
12
    for e in energy:
13
        diff = e - target
14
        prefix_diff += diff
15
        # Add the absolute value of prefix_diff to operations
16
        operations += abs(prefix_diff)
17
18
    return operations // K  # Minimum number of operations
19
20
# Read input
21
T = int(raw_input())  # Number of test cases
22
results = []
23
for _ in range(T):
24
    N, K = map(int, raw_input().split())  # N: number of stations, K: transfer units
25
    energy = map(int, raw_input().split())  # Energy levels
26
    results.append(min_operations_to_equalize_energy(N, K, energy))
27
28
# Print all results
29
for res in results:
30
    print res
31",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833621
1387833622,karmakarsanket98,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for _ in range(t):
5
        n, nums = test_cases[_]
6
        7
        # Compute prefix sums
8
        prefix_sum = [0] * n
9
        prefix_sum[0] = nums[0]
10
        for i in range(1, n):
11
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
12
        13
        total_sum = prefix_sum[-1]  # Total sum of the array
14
        max_diff = 0
15
        16
        # Iterate over all possible partitions
17
        for i in range(1, n):  # Partition between [0..i-1] and [i..n-1]
18
            left_sum = prefix_sum[i - 1]
19
            right_sum = total_sum - left_sum
20
            max_diff = max(max_diff, abs(left_sum - right_sum))
21
        22
        results.append(max_diff)
23
    24
    return results
25
26
# Input
27
t = int(input())
28
test_cases = []
29
for _ in range(t):
30
    n = int(input())
31
    nums = list(map(int, input().split()))
32
    test_cases.append((n, nums))
33
34
# Compute and output results
35
results = max_absolute_difference(t, test_cases)
36
for result in results:
37
    print(result)
38",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833622
1387833623,aaryanairy,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        result = [1] * n
6
        prefix = 1
7
        for i in range(n):
8
            result[i] = prefix
9
            prefix *= values[i]
10
        suffix = 1
11
        for i in range(n - 1, -1, -1):
12
            result[i] *= suffix
13
            suffix *= values[i]
14
        results.append(result)
15
    return results
16
17
t = int(input())
18
test_cases = []
19
for _ in range(t):
20
    n = int(input())
21
    values = list(map(int, input().split()))
22
    test_cases.append((n, values))
23
24
results = product_except_self(test_cases)
25
for result in results:
26
    print("" "".join(map(str, result)))",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833623
1387833614,harshtripathi752,unknown,unknown,"1
def opEq(N, K, energy):
2
    totE = sum(energy)
3
    4
    if totE % N != 0:
5
        return -1
6
        7
    tgtE = totE // N
8
    operations = 0
9
    10
    diffs = [energy[i] - tgtE for i in range(N)]
11
    12
    for d in diffs:
13
        if d % K != 0:
14
            return -1
15
    16
    currT = 0
17
    for i in range(N-1):
18
        currT += diffs[i]
19
        if currT != 0:
20
            operations += abs(currT) // K
21
    22
    currT += diffs[N-1]
23
    if currT != 0:
24
        return -1
25
        26
    return operations
27
28
T = int(input())
29
for _ in range(T):
30
    N, K = map(int, input().split())
31
    energy = list(map(int, input().split()))
32
    result = opEq(N, K, energy)
33
    print(result)",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833614
1387833620,h1032220870,unknown,unknown,"1
2
def solve_energy_distribution(t, test_cases):
3
    results = []
4
5
    for case in test_cases:
6
        N, K, energy = case
7
        total_energy = sum(energy)
8
9
        # Check if total energy is divisible by N
10
        if total_energy % N != 0:
11
            results.append(-1)
12
            continue
13
14
        target = total_energy // N
15
        balance = 0
16
        operations = 0
17
        possible = True
18
19
        for e in energy:
20
            diff = e - target
21
22
            # Check if redistribution is possible
23
            if diff % K != 0:
24
                possible = False
25
                break
26
27
            # Update balance and count operations
28
            balance += diff // K
29
            operations += abs(balance)
30
31
        if not possible:
32
            results.append(-1)
33
        else:
34
            results.append(operations)
35
36
    return results
37
38
39
# Input Reading
40
t = int(input())  # Number of test cases
41
test_cases = []
42
43
for _ in range(t):
44
    N, K = map(int, input().split())
45
    energy = list(map(int, input().split()))
46
    test_cases.append((N, K, energy))
47
48
# Process and Output Results
49
results = solve_energy_distribution(t, test_cases)
50
for res in results:
51
    print(res)
52",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833620
1387833619,kamblesamruddhi2,unknown,unknown,"1
T = int(input())  
2
for _ in range(T):
3
    n = int(input())
4
    values = list(map(int, input().split())) 
5
    prefix = [1] * n
6
    suffix = [1] * n
7
    result = [1] * n
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] * values[i - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] * values[i + 1]
12
    for i in range(n):
13
        result[i] = prefix[i] * suffix[i]
14
    print("" "".join(map(str, result)))",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833619
1387833611,kamblesamruddhi2,unknown,unknown,"1
T = int(input())  
2
for _ in range(T):
3
    n = int(input())
4
    values = list(map(int, input().split())) 
5
    prefix = [1] * n
6
    suffix = [1] * n
7
    result = [1] * n
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] * values[i - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] * values[i + 1]
12
    for i in range(n):
13
        result[i] = prefix[i] * suffix[i]
14
    print("" "".join(map(str, result)))",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833611
1387833612,h1032221613,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833612
1387833613,shivamthakur0201,unknown,unknown,"1
def min_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, k, energy = case
6
        total_energy = sum(energy)
7
8
        # Check if total energy is divisible by N
9
        if total_energy % n != 0:
10
            results.append(-1)
11
            continue
12
13
        target = total_energy // n
14
        operations = 0
15
        16
        # Calculate prefix differences
17
        prefix_diff = 0
18
        for i in range(n):
19
            prefix_diff += energy[i] - target
20
            if prefix_diff % k != 0:
21
                operations = -1
22
                break
23
            operations += abs(prefix_diff) // k
24
25
        results.append(operations if operations != -1 else -1)
26
27
    return results
28
29
# Input reading and processing
30
def main():
31
    t = int(input())
32
    test_cases = []
33
34
    for _ in range(t):
35
        n, k = map(int, input().split())
36
        energy = list(map(int, input().split()))
37
        test_cases.append((n, k, energy))
38
39
    results = min_operations_to_equalize_energy(t, test_cases)
40
41
    for res in results:
42
        print(res)
43
44
if __name__ == ""__main__"":
45
    main()",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833613
1387833609,pranaytiwariprpk,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt();
7
        for (int t = 0; t < T; t++) {
8
            int n = scanner.nextInt();
9
            int[] values = new int[n];
10
            for (int i = 0; i < n; i++) {
11
                values[i] = scanner.nextInt();
12
            }
13
            int[] result = new int[n];
14
            long totalProduct = 1;
15
            int zeroCount = 0;
16
17
            for (int value : values) {
18
                if (value != 0) {
19
                    totalProduct *= value;
20
                } else {
21
                    zeroCount++;
22
                }
23
            }
24
            for (int i = 0; i < n; i++) {
25
                if (zeroCount > 1) {
26
                    result[i] = 0;
27
                } else if (zeroCount == 1) {
28
                    result[i] = (values[i] == 0) ? (int) totalProduct : 0;
29
                } else {
30
                    result[i] = (int) (totalProduct / values[i]);
31
                }
32
            }
33
            for (int i = 0; i < n; i++) {
34
                System.out.print(result[i] + "" "");
35
            }
36
            System.out.println();
37
        }
38
39
        scanner.close();
40
    }
41
}
42",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833609
1387833605,h1032220108,unknown,unknown,"1
def minimum_operations(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K, energy = case
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // N  
12
        balance = 0
13
        operations = 0
14
        15
        for i in range(N):
16
            balance += energy[i] - target  
17
            if balance % K != 0:
18
                results.append(-1)
19
                break
20
            operations += abs(balance) // K  
21
        else:
22
            results.append(operations)
23
    24
    return results
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    N, K = map(int, input().split())
30
    energy = list(map(int, input().split()))
31
    test_cases.append((N, K, energy))
32
results = minimum_operations(T, test_cases)
33
for result in results:
34
    print(result)
35",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833605
1387833606,kamblesamruddhi2,unknown,unknown,"1
T = int(input())  
2
for _ in range(T):
3
    n = int(input())
4
    values = list(map(int, input().split())) 
5
    prefix = [1] * n
6
    suffix = [1] * n
7
    result = [1] * n
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] * values[i - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] * values[i + 1]
12
    for i in range(n):
13
        result[i] = prefix[i] * suffix[i]
14
    print("" "".join(map(str, result)))",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833606
1387833607,shuklaram2315,unknown,unknown,"1
def max_product_excluding_current(t, test_cases):
2
    results = []
3
    for case in range(t):
4
        n = test_cases[case][0]
5
        values = test_cases[case][1]
6
        result = [1] * n
7
        prefix_product = 1
8
        for i in range(n):
9
            result[i] = prefix_product
10
            prefix_product *= values[i]
11
        suffix_product = 1
12
        for i in range(n - 1, -1, -1):
13
            result[i] *= suffix_product
14
            suffix_product *= values[i]
15
        results.append(result)
16
    return results
17
t = int(input())
18
test_cases = []
19
for _ in range(t):
20
    n = int(input())
21
    values = list(map(int, input().split()))
22
    test_cases.append((n, values))
23
results = max_product_excluding_current(t, test_cases)
24
for res in results:
25
    print("" "".join(map(str, res)))
26",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833607
1387833602,h1032220299,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
void helper(){
8
    int n;
9
    cin>>n;
10
    vector<int>values(n);
11
    for(int i = 0; i < n; i++){
12
        cin>>values[i];
13
    }
14
    vector<int>result(n);
15
    for(int i = 0; i < n; i++){
16
        long long product = 1;
17
        for(int j = 0; j < n; j++){
18
            if(i != j){
19
                product *= values[j];
20
            }
21
        }
22
        result[i] = product;
23
    }
24
    for(int i = 0; i < n; i++){
25
        cout<<result[i]<<"" "";
26
    }
27
    cout<<endl;
28
}
29
30
int main() {
31
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */
32
    int a;
33
    cin>>a;
34
    while(a--){
35
        helper();
36
    }
37
    return 0;
38
}
39",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833602
1387833604,laxmimehta0506,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
8
        // Number of test cases
9
        int T = scanner.nextInt();
10
11
        while (T-- > 0) {
12
            // Read N and K
13
            int N = scanner.nextInt();
14
            int K = scanner.nextInt();
15
            16
            // Read energy array
17
            int[] energy = new int[N];
18
            long totalEnergy = 0;
19
            for (int i = 0; i < N; i++) {
20
                energy[i] = scanner.nextInt();
21
                totalEnergy += energy[i];
22
            }
23
24
            // Check if the total energy is divisible by N
25
            if (totalEnergy % N != 0) {
26
                System.out.println(-1);
27
                continue;
28
            }
29
30
            long targetEnergy = totalEnergy / N;
31
            long operations = 0;
32
            long balance = 0;
33
34
            // Simulate the energy transfer process
35
            for (int i = 0; i < N; i++) {
36
                // Balance for this station
37
                energy[i] -= targetEnergy;
38
                balance += energy[i];
39
40
                // We need to check if we can perform a transfer of K units
41
                operations += Math.abs(balance) / K;
42
                43
                // If there's a remainder when dividing by K, it's impossible
44
                if (Math.abs(balance) % K != 0) {
45
                    operations = -1;
46
                    break;
47
                }
48
            }
49
50
            System.out.println(operations);
51
        }
52
53
        scanner.close();
54
    }
55
}
56",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833604
1387833601,h1032221629,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    total_sum = sum(nums)
4
    prefix_sum = 0
5
    max_diff = float('-inf')
6
    7
    for i in range(n - 1):
8
        prefix_sum += nums[i]
9
        remaining_sum = total_sum - prefix_sum
10
        max_diff = max(max_diff, abs(prefix_sum - remaining_sum))
11
    12
    return max_diff
13
14
def main():
15
    t = int(input())
16
    17
    for _ in range(t):
18
        n = int(input())
19
        nums = list(map(int, input().split()))
20
        result = max_absolute_difference(nums)
21
        print(result)
22
23
main()",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833601
1387833598,h1032220179,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
    5
    # Calculate the product of all elements to the left of each index
6
    left_product = 1
7
    for i in range(n):
8
        result[i] = left_product
9
        left_product *= values[i]
10
    11
    # Calculate the product of all elements to the right of each index and multiply with the left product
12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    return result
18
19
def main():
20
    import sys
21
    input = sys.stdin.read
22
    data = input().split()
23
    24
    idx = 0
25
    T = int(data[idx])
26
    idx += 1
27
    28
    for _ in range(T):
29
        n = int(data[idx])
30
        idx += 1
31
        values = list(map(int, data[idx:idx+n]))
32
        idx += n
33
        34
        result = product_except_self(values)
35
        print(' '.join(map(str, result)))
36
37
if __name__ == ""__main__"":
38
    main()",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833598
1387833599,unborntadpole,unknown,unknown,"1
def listToString(l):
2
    str1 = ''
3
    for i in l:
4
        str1 = str1 + str(i) + "" ""
5
    return str1.strip()
6
7
n = int(input())
8
for i in range(n):
9
    len = int(input())
10
    values = input().split()
11
    result = []
12
    for i in range(len):
13
        temp_num = 1
14
        for value in values:
15
            value = int(value)
16
            if value !=  int(values[i]):
17
                temp_num *= value
18
        result.append(temp_num)
19
    print(listToString(result))",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833599
1387833600,h1032220703,unknown,unknown,"1
import java.util.*;
2
3
public class PowerStationEqualizer {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
7
        // Read number of test cases
8
        int T = scanner.nextInt();
9
10
        for (int t = 0; t < T; t++) {
11
            // Read N and K
12
            int N = scanner.nextInt();
13
            int K = scanner.nextInt();
14
15
            // Read energy levels
16
            int[] energy = new int[N];
17
            long totalEnergy = 0;
18
            for (int i = 0; i < N; i++) {
19
                energy[i] = scanner.nextInt();
20
                totalEnergy += energy[i];
21
            }
22
23
            // Check if equal distribution is possible
24
            if (totalEnergy % N != 0) {
25
                System.out.println(-1);
26
                continue;
27
            }
28
29
            long targetEnergy = totalEnergy / N;
30
            long operations = 0;
31
            long balance = 0;
32
33
            boolean isPossible = true;
34
35
            for (int i = 0; i < N; i++) {
36
                long diff = energy[i] - targetEnergy;
37
                balance += diff;
38
39
                // K must perfectly divide the net balance at each step
40
                if (Math.abs(balance) % K != 0) {
41
                    isPossible = false;
42
                    break;
43
                }
44
45
                operations += Math.abs(balance / K);
46
            }
47
48
            // Output result based on the computed balance
49
            System.out.println(isPossible ? operations : -1);
50
        }
51
52
        scanner.close();
53
    }
54
}
55",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833600
1387833590,harshpal0050,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
3
    results = []
4
5
    6
7
    for t in test_cases:
8
9
        N, K, energy = t
10
11
        total_energy = sum(energy)
12
13
        14
15
        # Check if equalization is possible
16
17
        if total_energy % N != 0:
18
19
            results.append(-1)
20
21
            continue
22
23
        24
25
        target = total_energy // N
26
27
        diffs = [energy[i] - target for i in range(N)]
28
29
        30
31
        # Check if all differences are divisible by K
32
33
        if any(diff % K != 0 for diff in diffs):
34
35
            results.append(-1)
36
37
            continue
38
39
        40
41
        # Calculate minimum operations
42
43
        operations = 0
44
45
        imbalance = 0
46
47
        48
49
        for diff in diffs:
50
51
            imbalance += diff // K
52
53
            operations += abs(imbalance)
54
55
        56
57
        results.append(operations)
58
59
    60
61
    return results
62
63
# Input handling
64
65
T = int(input())
66
67
test_cases = []
68
69
for _ in range(T):
70
71
    N, K = map(int, input().split())
72
73
    energy = list(map(int, input().split()))
74
75
    test_cases.append((N, K, energy))
76
77
# Compute results
78
79
results = minimum_operations_to_equalize(test_cases)
80
81
# Output results
82
83
for res in results:
84
85
    print(res)# Enter your code here. Read input from STDIN. Print output to STDOUT",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833590
1387833591,h1032220798,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
    # Calculate left product array
7
    for i in range(1, n):
8
        left[i] = left[i-1] * arr[i-1]
9
10
    # Calculate right product array
11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * arr[i+1]
13
14
    # Calculate result array
15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
# Get number of test cases
20
t = int(input())
21
22
for _ in range(t):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result)",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833591
1387833596,codedot,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
 n=int(input())
4
 values=list(map(int,input().split()))
5
 result=[1]*n
6
 total_product=1
7
 for value in values:
8
  total_product*=value
9
 for i in range(n):
10
  result[i]=total_product//values[i]
11
 print(*result)
12",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833596
1387833587,pawanmudaliar081,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
6
        prefix_sum = [0] * n
7
        prefix_sum[0] = nums[0]
8
        for i in range(1, n):
9
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
10
        11
        total_sum = prefix_sum[-1]
12
        max_diff = 0
13
14
        for i in range(n - 1):
15
            left_sum = prefix_sum[i]
16
            right_sum = total_sum - left_sum
17
            max_diff = max(max_diff, abs(left_sum - right_sum))
18
        19
        results.append(max_diff)
20
    21
    return results
22
23
if __name__ == ""__main__"":
24
    t = int(input())
25
    test_cases = []
26
    for _ in range(t):
27
        n = int(input())
28
        nums = list(map(int, input().split()))
29
        test_cases.append((n, nums))
30
    31
    results = max_absolute_difference(t, test_cases)
32
    for res in results:
33
        print(res)
34",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833587
1387833588,sanika_wani,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
   7
    for i in range(1, n):
8
        left[i] = left[i-1] * arr[i-1]
9
10
   11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * arr[i+1]
13
14
    15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
20
T = int(input())
21
22
for _ in range(T):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result)",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833588
1387833589,shshloka,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        cumulative_diff = 0
12
        for e in energy:
13
            diff = e - target
14
            cumulative_diff += diff
15
            operations += abs(cumulative_diff)
16
        if cumulative_diff != 0:
17
            results.append(-1)
18
        else:
19
            results.append(operations // K)
20
    return results
21
22
def main():
23
    import sys
24
    input = sys.stdin.read
25
    data = input().split()
26
    idx = 0
27
    T = int(data[idx])
28
    idx += 1
29
    test_cases = []
30
    for _ in range(T):
31
        N = int(data[idx])
32
        K = int(data[idx+1])
33
        idx += 2
34
        energy = list(map(int, data[idx:idx+N]))
35
        idx += N
36
        test_cases.append((N, K, energy))
37
    results = equalize_energy(test_cases)
38
    for res in results:
39
        print(res)
40
41
if __name__ == ""__main__"":
42
    main()",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833589
1387833581,h1032220053,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        # Check if equalization is possible
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target_energy = total_energy // N
16
        operations = 0
17
        current_diff = 0
18
19
        for i in range(N):
20
            diff = energy[i] - target_energy
21
            current_diff += diff
22
23
            # If the current difference is not divisible by K, it's impossible to equalize
24
            if current_diff % K != 0:
25
                results.append(-1)
26
                break
27
28
            # Increment operations by the absolute value of current difference divided by K
29
            operations += abs(current_diff) // K
30
        else:
31
            results.append(operations)
32
33
    return results
34
35
# Input reading
36
T = int(input())
37
test_cases = []
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append(((N, K), energy))
42
43
# Solve and output results
44
results = minimum_operations_to_equalize(T, test_cases)
45
for result in results:
46
    print(result)",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833581
1387833584,h1032221613,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833584
1387833585,sohampatil1807,unknown,unknown,"1
with Ada.Text_IO, Ada.Integer_Text_IO;
2
use Ada;
3
4
procedure Solution is
5
-- Enter your code here. Read input from STDIN. Print output to STDOUT
6
def solve_product_array(values, n):
7
    """"""
8
    Calculate product of all elements except self for each position.
9
    Uses O(1) extra space (not counting the output array).
10
    """"""
11
   12
    if n < 2:
13
        return []
14
        15
    # Initialize result array
16
    result = [0] * n
17
    18
 19
    20
  21
    result[0] = 1
22
    for i in range(1, n):
23
        result[i] = values[i - 1] * result[i - 1]
24
    25
   26
    right_product = 1
27
    for i in range(n - 1, -1, -1):
28
        result[i] = result[i] * right_product
29
        right_product *= values[i]
30
    31
    return result
32
33
def main():
34
   35
    T = int(input())
36
    37
  38
    for _ in range(T):
39
       40
        n = int(input())
41
        42
        43
        values = list(map(int, input().split()))
44
        45
        46
        result = solve_product_array(values, n)
47
        48
        49
        print("" "".join(map(str, result)))
50
51
if _name_ == ""_main_"":
52
    main()
53
54
end Solution",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833585
1387833580,navinbohara5,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
    total_sum = sum(nums)
3
    left_sum = 0
4
    max_diff = float('-inf')
5
6
    7
    for i in range(n - 1):  
8
        left_sum += nums[i]
9
        right_sum = total_sum - left_sum
10
        max_diff = max(max_diff, abs(left_sum - right_sum))
11
    12
    return max_diff
13
14
15
T = int(input())  
16
for _ in range(T):
17
    n = int(input())  
18
    nums = list(map(int, input().split()))  
19
20
    21
    print(max_absolute_difference(n, nums))
22",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833580
1387833577,pulekarswaradny,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
    # Compute the prefix sum array
5
    prefix_sum = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
8
    9
    max_diff = 0
10
    11
    # Iterate through all possible split points
12
    for i in range(1, n):
13
        left_sum = prefix_sum[i]
14
        right_sum = prefix_sum[n] - prefix_sum[i]
15
        current_diff = abs(left_sum - right_sum)
16
        17
        # Update the maximum difference
18
        max_diff = max(max_diff, current_diff)
19
    20
    return max_diff
21
22
def main():
23
    import sys
24
    input = sys.stdin.read
25
    data = input().split()
26
    27
    idx = 0
28
    t = int(data[idx])  # Number of test cases
29
    idx += 1
30
    31
    results = []
32
    for _ in range(t):
33
        n = int(data[idx])  # Size of the array
34
        idx += 1
35
        nums = list(map(int, data[idx:idx + n]))  # Array elements
36
        idx += n
37
        38
        result = max_absolute_difference(nums)
39
        results.append(result)
40
    41
    for res in results:
42
        print(res)
43
44
if __name__ == ""__main__"":
45
    main()
46",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833577
1387833578,singhrajbadri,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        for i in range(n - 1):
11
            prefix_sum += nums[i]
12
            suffix_sum = total_sum - prefix_sum
13
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
14
        15
        results.append(max_diff)
16
    17
    return results
18
19
t = int(input())
20
test_cases = []
21
22
for _ in range(t):
23
    n = int(input())
24
    nums = list(map(int, input().split()))
25
    test_cases.append((n, nums))
26
27
results = max_absolute_difference(test_cases)
28
29
for res in results:
30
    print(res)
31",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833578
1387833579,harshrsharma29,unknown,unknown,"1
def min_operations(n, k, energy):
2
    """"""
3
    Calculates the minimum number of operations required to equalize the energy across all stations.
4
5
    Args:
6
      n: The number of power stations.
7
      k: The number of energy units that can be transferred in one operation.
8
      energy: A list of integers representing the energy of each station.
9
10
    Returns:
11
      The minimum number of operations required, or -1 if it's impossible to equalize.
12
    """"""
13
14
    total_energy = sum(energy)
15
    if total_energy % n != 0:
16
        return -1
17
18
    target_energy = total_energy // n
19
    operations = 0
20
21
    for i in range(n):
22
        diff = energy[i] - target_energy
23
        if diff > 0:
24
            operations += (diff + k - 1) // k  # Ceiling division
25
26
    return operations
27
28
# Get number of test cases
29
t = int(input())
30
31
for _ in range(t):
32
    n, k = map(int, input().split())
33
    energy = list(map(int, input().split()))
34
    result = min_operations(n, k, energy)
35
    print(result)",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833579
1387833573,arshiyak572,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def min_operations_to_equalize(N, K, energy):
3
    total_energy = sum(energy)
4
    5
    # Check if it's possible to equalize energy
6
    if total_energy % N != 0:
7
        return -1  # Impossible to equalize
8
    9
    target = total_energy // N
10
    operations = 0
11
    balance = 0
12
    13
    # Traverse through each station
14
    for i in range(N):
15
        # Calculate the current imbalance (how much energy needs to be transferred)
16
        balance += energy[i] - target
17
        18
        # The number of operations needed is determined by the magnitude of balance
19
        # We can only move multiples of K energy units
20
        if balance % K != 0:
21
            return -1  # If the balance is not divisible by K, return -1
22
        operations += abs(balance) // K
23
    24
    return operations
25
26
# Reading input
27
T = int(input())  # Number of test cases
28
for _ in range(T):
29
    N, K = map(int, input().split())  # Number of stations and units of energy per operation
30
    energy = list(map(int, input().split()))  # List of energy at each station
31
    32
    # Calculate and print the result for the current test case
33
    result = min_operations_to_equalize(N, K, energy)
34
    print(result)
35",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833573
1387833574,abhishekgoyalas1,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
    # Compute the prefix sum array
5
    prefix_sum = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
8
    9
    max_diff = 0
10
    11
    # Iterate through all possible split points
12
    for i in range(1, n):
13
        left_sum = prefix_sum[i]
14
        right_sum = prefix_sum[n] - prefix_sum[i]
15
        current_diff = abs(left_sum - right_sum)
16
        17
        # Update the maximum difference
18
        if current_diff > max_diff:
19
            max_diff = current_diff
20
    21
    return max_diff
22
23
def main():
24
    import sys
25
    input = sys.stdin.read
26
    data = input().split()
27
    28
    idx = 0
29
    t = int(data[idx])  # Number of test cases
30
    idx += 1
31
    32
    for _ in range(t):
33
        n = int(data[idx])  # Size of the array
34
        idx += 1
35
        nums = list(map(int, data[idx:idx + n]))  # Array elements
36
        idx += n
37
        38
        result = max_absolute_difference(nums)
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()
43",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833574
1387833575,h1032220507,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Exclude the last index to ensure two non-empty subarrays
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
# Input handling
21
t = int(input())
22
test_cases = []
23
24
for _ in range(t):
25
    n = int(input())
26
    nums = list(map(int, input().split()))
27
    test_cases.append((n, nums))
28
29
# Compute results
30
results = max_absolute_difference(test_cases)
31
32
# Output results
33
for res in results:
34
    print(res)
35",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833575
1387833570,ayushaj14,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    if n < 2:
4
        return 0
5
6
    # Calculate prefix sums
7
    prefix_sum = [0] * n
8
    prefix_sum[0] = nums[0]
9
    for i in range(1, n):
10
        prefix_sum[i] = prefix_sum[i - 1] + nums[i]
11
12
    # Calculate suffix sums
13
    suffix_sum = [0] * n
14
    suffix_sum[n - 1] = nums[n - 1]
15
    for i in range(n - 2, -1, -1):
16
        suffix_sum[i] = suffix_sum[i + 1] + nums[i]
17
18
    # Find the maximum absolute difference
19
    max_diff = 0
20
    for i in range(n - 1):
21
        left_sum = prefix_sum[i]
22
        right_sum = suffix_sum[i + 1]
23
        max_diff = max(max_diff, abs(left_sum - right_sum))
24
25
    return max_diff
26
27
def handle_test_cases(t, test_cases):
28
    results = []
29
    for i in range(t):
30
        n = test_cases[i][0]
31
        nums = test_cases[i][1]
32
        results.append(max_absolute_difference(nums))
33
    return results
34
35
# Example usage
36
t = 1
37
test_cases = [
38
    (3, [2, 3, 4])
39
]
40
41
results = handle_test_cases(t, test_cases)
42
for result in results:
43
    print(result)
44",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833570
1387833571,h1032220289,unknown,unknown,"1
def main():
2
    T = int(input())  # Number of test cases
3
    for _ in range(T):
4
        # Read N and K
5
        N, K = map(int, input().split())
6
        # Read energy values
7
        energy = list(map(int, input().split()))
8
        9
        # Calculate the total energy and check if it's divisible by N
10
        total_energy = sum(energy)
11
        12
        # If the total energy is not divisible by N, it's impossible to equalize
13
        if total_energy % N != 0:
14
            print(-1)
15
            continue
16
        17
        # Target energy each station should have
18
        target = total_energy // N
19
        operations = 0
20
        current_balance = 0
21
        22
        for i in range(N):
23
            # Calculate imbalance at the current station
24
            energy[i] -= target
25
            # Add current station imbalance to current_balance
26
            current_balance += energy[i]
27
            # The number of operations is the absolute imbalance divided by K
28
            operations += abs(current_balance) // K
29
            30
            # If it's not divisible by K, it's impossible to balance, break early
31
            if abs(current_balance) % K != 0:
32
                operations = -1
33
                break
34
        35
        # If the total number of operations is not -1, print the result
36
        print(operations)
37
main()",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833571
1387833572,adiv40816,unknown,unknown,"1
import sys
2
3
def min_operations_to_equalize(n, k, energy):
4
    total_energy = sum(energy)
5
    6
    # If total energy is not divisible by n, it's impossible to equalize
7
    if total_energy % n != 0:
8
        return -1
9
    10
    target = total_energy // n  # Each station should have this much energy
11
    balance = 0  # Tracks energy surplus or deficit
12
    operations = 0
13
    14
    for i in range(n):
15
        diff = energy[i] - target
16
        balance += diff
17
        18
        # If the balance is not a multiple of k at any step, it's impossible
19
        if balance % k != 0:
20
            return -1
21
        22
        operations += abs(diff) // k
23
    24
    return operations // 2  # Each transfer is counted twice
25
26
def main():
27
    t = int(input().strip())
28
    results = []
29
    for _ in range(t):
30
        n, k = map(int, input().strip().split())
31
        energy = list(map(int, input().strip().split()))
32
        results.append(str(min_operations_to_equalize(n, k, energy)))
33
    34
    print(""\n"".join(results))
35
36
if __name__ == ""__main__"":
37
    main()
38",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833572
1387833569,adityapatil1306,unknown,unknown,"1
def max_partition_difference(nums):
2
    n = len(nums)
3
    prefix_sum = [0] * (n + 1)
4
    5
    for i in range(n):
6
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
7
    8
    max_diff = 0
9
    for i in range(1, n):
10
        left_sum = prefix_sum[i]
11
        right_sum = prefix_sum[n] - prefix_sum[i]
12
        max_diff = max(max_diff, abs(left_sum - right_sum))
13
    14
    return max_diff
15
16
t = int(input())
17
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    print(max_partition_difference(nums))
22",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833569
1387833565,ayushchaudhary71,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        left_sum = 0
7
        max_diff = 0
8
        for i in range(n - 1):
9
            left_sum += nums[i]
10
            right_sum = total_sum - left_sum
11
            max_diff = max(max_diff, abs(left_sum - right_sum))
12
        results.append(max_diff)
13
    return results
14
15
16
t = int(input())
17
test_cases = []
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    test_cases.append((n, nums))
22
23
results = max_absolute_difference(test_cases)
24
for res in results:
25
    print(res)",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833565
1387833567,shivanshu121004,unknown,unknown,"1
def calculate_product_distribution(n, values):
2
3
    if n < 2:
4
5
        return []
6
7
    8
9
    result = [1] * n
10
11
    12
13
    left_product = 1
14
15
    for i in range(n):
16
17
        result[i] = left_product
18
19
        left_product *= values[i]
20
21
    22
23
    right_product = 1
24
25
    for i in range(n-1, -1, -1):
26
27
        result[i] *= right_product
28
29
        right_product *= values[i]
30
31
    32
33
    return result
34
35
T = int(input())
36
37
for _ in range(T):
38
39
    n = int(input())
40
41
    values = list(map(int, input().split()))
42
43
    result = calculate_product_distribution(n, values)
44
45
    print("" "".join(map(str, result)))",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833567
1387833566,praveenbisht491,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        surplus = 0
12
        for i in range(N):
13
            diff = energy[i] - target
14
            surplus += diff
15
            if surplus % K != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(surplus // K)
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
results = minimum_operations(test_cases)
31
for res in results:
32
    print(res)",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833566
1387833562,pranalipahurkar,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    total_sum = sum(nums)
4
    left_sum = 0
5
    max_diff = 0
6
7
    for i in range(n - 1):
8
        left_sum += nums[i]
9
        right_sum = total_sum - left_sum
10
        max_diff = max(max_diff, abs(left_sum - right_sum))
11
12
    return max_diff
13
14
# Input handling
15
T = int(input())
16
results = []
17
for _ in range(T):
18
    n = int(input())
19
    nums = list(map(int, input().split()))
20
    result = max_absolute_difference(nums)
21
    results.append(result)
22
23
# Output results
24
for res in results:
25
    print(res)
26",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833562
1387833559,shwetankrai0710,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
    # Compute the prefix sum array
5
    prefix_sum = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
8
    9
    max_diff = 0
10
    11
    # Iterate through all possible split points
12
    for i in range(1, n):
13
        left_sum = prefix_sum[i]
14
        right_sum = prefix_sum[n] - prefix_sum[i]
15
        current_diff = abs(left_sum - right_sum)
16
        17
        # Update the maximum difference
18
        if current_diff > max_diff:
19
            max_diff = current_diff
20
    21
    return max_diff
22
23
def main():
24
    import sys
25
    input = sys.stdin.read
26
    data = input().split()
27
    28
    idx = 0
29
    t = int(data[idx])  # Number of test cases
30
    idx += 1
31
    32
    for _ in range(t):
33
        n = int(data[idx])  # Size of the array
34
        idx += 1
35
        nums = list(map(int, data[idx:idx + n]))  # Array elements
36
        idx += n
37
        38
        result = max_absolute_difference(nums)
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833559
1387833563,h1032221728,unknown,unknown,"1
import sys
2
3
def min_operations_to_equalize_energy(test_cases):
4
    results = []
5
    6
    for N, K, energies in test_cases:
7
        total_energy = sum(energies)
8
        9
        # Check if equalization is possible
10
        if total_energy % N != 0:
11
            results.append(-1)
12
            continue
13
        14
        target_energy = total_energy // N
15
        operations = 0
16
        current_balance = 0
17
        18
        for energy in energies:
19
            # Calculate the balance at this station
20
            current_balance += energy - target_energy
21
            22
            # We can only transfer in multiples of K
23
            operations += abs(current_balance) // K
24
        25
        results.append(operations)
26
    27
    return results
28
29
# Input reading
30
input_data = sys.stdin.read().strip().splitlines()
31
T = int(input_data[0])
32
test_cases = []
33
34
index = 1
35
for _ in range(T):
36
    N, K = map(int, input_data[index].split())
37
    energies = list(map(int, input_data[index + 1].split()))
38
    test_cases.append((N, K, energies))
39
    index += 2  # Move to the next test case
40
41
# Get results
42
results = min_operations_to_equalize_energy(test_cases)
43
44
# Output results
45
for result in results:
46
    print(result)",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833563
1387833552,h1032220176,unknown,unknown,"1
def solve():
2
    T = int(raw_input())
3
    4
    for _ in range(T):
5
        6
        N, K = map(int, raw_input().split())
7
        energy = map(int, raw_input().split())
8
        9
        total_energy = sum(energy)
10
        11
       12
        if total_energy % N != 0:
13
            print -1
14
            continue
15
        16
        target = total_energy // N  
17
        moves = 0
18
        balance = 0  
19
        20
        possible = True
21
        22
        for i in range(N):
23
            diff = energy[i] - target
24
            if diff % K != 0:
25
                possible = False
26
                break
27
            28
            29
            balance += diff
30
            moves += abs(balance) // K  
31
        32
        if possible:
33
            print moves
34
        else:
35
            print -1
36
37
38
solve()
39",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833552
1387833556,arpit21345j,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
long long calculateMinOperations(int N, int K, vector<int>& energy) {
7
    long long total_energy = 0;
8
    for (int e : energy) {
9
        total_energy += e;
10
    }
11
12
    if (total_energy % N != 0) {
13
        return -1;
14
    }
15
16
    long long target = total_energy / N;
17
    vector<long long> prefix(N, 0);
18
    long long operations = 0;
19
20
    for (int i = 0; i < N; ++i) {
21
        prefix[i] = (i > 0 ? prefix[i - 1] : 0) + (energy[i] - target);
22
        if (prefix[i] % K != 0) {
23
            return -1;
24
        }
25
    }
26
27
    for (int i = 0; i < N; ++i) {
28
        operations += abs(prefix[i] / K);
29
    }
30
31
    return operations;
32
}
33
34
int main() {
35
    int T;
36
    cin >> T;
37
38
    while (T--) {
39
        int N, K;
40
        cin >> N >> K;
41
        vector<int> energy(N);
42
        for (int i = 0; i < N; ++i) {
43
            cin >> energy[i];
44
        }
45
46
        long long result = calculateMinOperations(N, K, energy);
47
        cout << result << endl;
48
    }
49
50
    return 0;
51
}
52
53",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833556
1387833558,harsh_singh26011,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
using namespace std;
5
6
class Solution {
7
public:
8
    int minOperationsToEqualize(int N, int K, vector<long long>& energy) {
9
        // Calculate total and target energy
10
        long long totalEnergy = 0;
11
        for (long long e : energy) {
12
            totalEnergy += e;
13
        }
14
        15
        // Check if equalization is impossible
16
        if (totalEnergy % N != 0) {
17
            return -1;
18
        }
19
        20
        long long targetEnergy = totalEnergy / N;
21
        22
        // Check if already equalized
23
        bool isEqual = true;
24
        for (int i = 0; i < N; i++) {
25
            if (energy[i] != targetEnergy) {
26
                isEqual = false;
27
                break;
28
            }
29
        }
30
        if (isEqual) return 0;
31
        32
        // Calculate minimum operations
33
        long long totalMoves = 0;
34
        35
        // First pass: calculate net energy movement needed
36
        vector<long long> diff(N);
37
        for (int i = 0; i < N; i++) {
38
            diff[i] = energy[i] - targetEnergy;
39
        }
40
        41
        // Second pass: count minimum operations
42
        for (int i = 0; i < N - 1; i++) {
43
            if (diff[i] != 0) {
44
                // Move energy to next position
45
                totalMoves += abs(diff[i]);
46
                diff[i + 1] += diff[i];
47
                diff[i] = 0;
48
            }
49
        }
50
        51
        // Calculate minimum operations needed
52
        return (totalMoves + K - 1) / K;
53
    }
54
};
55
56
int main() {
57
    int T;
58
    cin >> T;
59
    60
    while (T--) {
61
        int N, K;
62
        cin >> N >> K;
63
        64
        vector<long long> energy(N);
65
        for (int i = 0; i < N; i++) {
66
            cin >> energy[i];
67
        }
68
        69
        Solution solution;
70
        cout << solution.minOperationsToEqualize(N, K, energy) << endl;
71
    }
72
    73
    return 0;
74
}",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833558
1387833551,h1032221356,unknown,unknown,"1
def equalize_energy():
2
    T = int(input())
3
    results = []
4
    5
    for _ in range(T):
6
        # Read N and K
7
        N, K = map(int, input().split())
8
        # Read the energy array
9
        energy = list(map(int, input().split()))
10
        11
        total_energy = sum(energy)
12
        13
        # Check if equalization is possible
14
        if total_energy % N != 0:
15
            results.append(-1)
16
            continue
17
        18
        target = total_energy // N
19
        balance = 0
20
        operations = 0
21
        22
        # Calculate the number of operations
23
        for e in energy:
24
            balance += e - target
25
            operations += abs(balance) // K
26
        27
        results.append(operations)
28
    29
    # Print all results
30
    print(""\n"".join(map(str, results)))
31
32
# Call the function
33
equalize_energy()
34",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833551
1387833548,yt5160359,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
4
    for _ in range(test_cases):
5
        n = int(input())  # Size of the array
6
        nums = list(map(int, input().split()))
7
8
        # Calculate prefix sums
9
        prefix_sum = [0] * n
10
        prefix_sum[0] = nums[0]
11
        for i in range(1, n):
12
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
13
14
        # Calculate suffix sums
15
        suffix_sum = [0] * n
16
        suffix_sum[-1] = nums[-1]
17
        for i in range(n - 2, -1, -1):
18
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
19
20
        # Find the maximum absolute difference
21
        max_diff = 0
22
        for i in range(n - 1):
23
            left_sum = prefix_sum[i]
24
            right_sum = suffix_sum[i + 1]
25
            max_diff = max(max_diff, abs(left_sum - right_sum))
26
27
        results.append(max_diff)
28
29
    return results
30
31
# Input
32
T = int(input())  # Number of test cases
33
output = max_absolute_difference(T)
34
35
# Output results for all test cases
36
for res in output:
37
    print(res)",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833548
1387833550,h1032221613,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833550
1387833549,Amanpal3546,unknown,unknown,"1
#include <vector>
2
#include <iostream>
3
using namespace std;
4
5
void productDistribution(vector<int>& values, int n) {
6
    vector<int> result(n,1);
7
    8
    int prefix = 1;
9
    for (int i = 0; i < n; i++) {
10
        result[i] = prefix;
11
        prefix *= values[i];
12
    }
13
    14
    int suffix = 1;
15
    for (int i = n - 1; i >= 0; i--) {
16
        result[i] *= suffix;
17
        suffix *= values[i];
18
    }
19
    20
    for (int i = 0; i < n; i++) {
21
        cout << result[i] << "" "";
22
    }
23
    cout << endl;
24
    25
}
26
27
28
int main() {
29
    int T;
30
    cin >> T;
31
    32
    while(T--) {
33
        int n;
34
        cin >> n;
35
        vector<int> values(n);
36
        37
        for (int i = 0; i < n; i++) {
38
            cin >> values[i];
39
        }
40
        41
        productDistribution(values, n);
42
    }
43
    return 0;
44
}
45",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833549
1387833543,h1032231265,unknown,unknown,"1
def solve_test_cases():
2
    t = int(input())  # Read the number of test cases
3
    4
    for _ in range(t):
5
        n = int(input())  # Read the size of the array
6
        nums = list(map(int, input().split()))  # Read the array
7
        8
        # Step 1: Calculate prefix sum
9
        prefix_sum = [0] * n
10
        prefix_sum[0] = nums[0]
11
        for i in range(1, n):
12
            prefix_sum[i] = prefix_sum[i-1] + nums[i]
13
        14
        total_sum = prefix_sum[-1]  # The total sum of the entire array
15
        max_diff = float('-inf')  # To track the maximum absolute difference
16
17
        # Step 2: Evaluate each partition point
18
        for i in range(n-1):  # The partition must be between index i and i+1
19
            sum_left = prefix_sum[i]  # Sum of the left subarray
20
            sum_right = total_sum - sum_left  # Sum of the right subarray
21
            max_diff = max(max_diff, abs(sum_left - sum_right))
22
        23
        print(max_diff)
24
25
# Run the solve function to process input and output
26
solve_test_cases()
27",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833543
1387833544,h1032221618,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833544
1387833547,aayushkrishnaut,unknown,unknown,"1
def solve_product_distribution():
2
    # Read number of test cases
3
    T = int(input())
4
    5
    for _ in range(T):
6
        # Read number of nodes
7
        n = int(input())
8
        9
        # Read values array
10
        values = list(map(int, input().split()))
11
        12
        # Calculate result array
13
        result = []
14
        for i in range(n):
15
            # Initialize product as 1
16
            product = 1
17
            18
            # Multiply all values except the current position
19
            for j in range(n):
20
                if j != i:
21
                    product *= values[j]
22
            23
            result.append(product)
24
        25
        # Print result array for this test case
26
        print("" "".join(map(str, result)))
27
28
# Run the solution
29
if __name__ == ""__main__"":
30
    solve_product_distribution()",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833547
1387833540,kartikmadu2004,unknown,unknown,"1
def min_operations(n, k, energy):
2
    """"""
3
    Calculates the minimum number of operations required to equalize the energy across all stations.
4
5
    Args:
6
      n: The number of power stations.
7
      k: The number of energy units that can be transferred in one operation.
8
      energy: A list of integers representing the energy of each station.
9
10
    Returns:
11
      The minimum number of operations required, or -1 if it's impossible to equalize.
12
    """"""
13
14
    total_energy = sum(energy)
15
    if total_energy % n != 0:
16
        return -1
17
18
    target_energy = total_energy // n
19
    operations = 0
20
21
    for i in range(n):
22
        diff = energy[i] - target_energy
23
        if diff > 0:
24
            operations += (diff + k - 1) // k  # Ceiling division
25
26
    return operations
27
28
# Get number of test cases
29
t = int(input())
30
31
for _ in range(t):
32
    n, k = map(int, input().split())
33
    energy = list(map(int, input().split()))
34
    result = min_operations(n, k, energy)
35
    print(result)",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833540
1387833541,singhark94,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
using namespace std;
5
6
long long minOperations(int N, int K, vector<int>& energy) {
7
    long long totalEnergy = accumulate(energy.begin(), energy.end(), 0LL);
8
9
    // Step 1: Check if equalization is possible
10
    if (totalEnergy % N != 0) return -1;
11
    long long target = totalEnergy / N;
12
13
    long long cumulativeSum = 0, operations = 0;
14
15
    // Step 2: Process each station and ensure valid transfers
16
    for (int i = 0; i < N; ++i) {
17
        long long diff = energy[i] - target;
18
        cumulativeSum += diff;
19
20
        // Step 3: Ensure the difference can be evenly distributed using K
21
        if (cumulativeSum % K != 0) return -1;
22
23
        // Step 4: Count the absolute sum of movements
24
        operations += abs(cumulativeSum) / K;
25
    }
26
27
    return operations;
28
}
29
30
int main() {
31
    int T;
32
    cin >> T;
33
34
    while (T--) {
35
        int N, K;
36
        cin >> N >> K;
37
        vector<int> energy(N);
38
        for (int i = 0; i < N; ++i) {
39
            cin >> energy[i];
40
        }
41
42
        cout << minOperations(N, K, energy) << endl;
43
    }
44
45
    return 0;
46
}
47",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833541
1387833542,h1032221046,unknown,unknown,"1
def compute_results(test_cases):
2
    results = []
3
    for values in test_cases:
4
        n = len(values)
5
        total_product = 1
6
        zero_count = 0
7
8
        # Compute total product and count zeros
9
        for value in values:
10
            if value == 0:
11
                zero_count += 1
12
            else:
13
                total_product *= value
14
15
        # Construct the result array
16
        result = []
17
        for value in values:
18
            if zero_count > 1:
19
                # If more than one zero, all results are zero
20
                result.append(0)
21
            elif zero_count == 1:
22
                # If one zero, only the zero's position gets the product
23
                result.append(total_product if value == 0 else 0)
24
            else:
25
                # No zeros, calculate product excluding the current value
26
                result.append(total_product // value)
27
28
        results.append(result)
29
    return results
30
31
32
# Input reading
33
T = int(input())  # Number of test cases
34
test_cases = []
35
36
for _ in range(T):
37
    n = int(input())  # Number of nodes in the network
38
    values = list(map(int, input().split()))
39
    test_cases.append(values)
40
41
# Process each test case
42
results = compute_results(test_cases)
43
44
# Output the results
45
for result in results:
46
    print("" "".join(map(str, result)))
47",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833542
1387833539,h1032221506,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    total_sum = sum(nums)
4
    prefix_sum = 0
5
    max_diff = float('-inf')
6
    7
    for i in range(n - 1):
8
        prefix_sum += nums[i]
9
        remaining_sum = total_sum - prefix_sum
10
        max_diff = max(max_diff, abs(prefix_sum - remaining_sum))
11
    12
    return max_diff
13
14
def main():
15
    t = int(input())
16
    17
    for _ in range(t):
18
        n = int(input())
19
        nums = list(map(int, input().split()))
20
        result = max_absolute_difference(nums)
21
        print(result)
22
23
main()
24",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833539
1387833535,harshpal0050,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833535
1387833537,ravislprajapati,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        N, K, energy = case
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        balance = 0  # Tracks surplus/deficit of energy
15
        operations = 0
16
        17
        # Simulate the redistribution process
18
        for i in range(N):
19
            balance += (energy[i] - target)
20
            # If balance is non-zero, we need |balance| / K operations
21
            operations += abs(balance) // K
22
        23
        results.append(operations)
24
    25
    return results
26
27
# Input processing
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    N, K = map(int, input().split())
33
    energy = list(map(int, input().split()))
34
    test_cases.append((N, K, energy))
35
36
# Output results
37
for result in minimum_operations_to_equalize(T, test_cases):
38
    print(result)
39",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833537
1387833533,dhruvppaste20,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T;
7
    while (T--) {
8
        int N, K;
9
        cin >> N >> K;
10
        vector<int> A(N);
11
        for (int i = 0; i < N; i++) {
12
            cin >> A[i];
13
        }
14
        if (K == 0) {
15
            bool allEqual = true;
16
            int first = A[0];
17
            for (int x : A) {
18
                if (x != first) {
19
                    allEqual = false;
20
                    break;
21
                }
22
            }
23
            cout << (allEqual ? 0 : -1) << endl;
24
            continue;
25
        }
26
        long long sum = accumulate(A.begin(), A.end(), 0LL);
27
        if (sum % N != 0) {
28
            cout << -1 << endl;
29
            continue;
30
        }
31
        long long target = sum / N;
32
        vector<int> delta(N);
33
        bool possible = true;
34
        for (int i = 0; i < N; i++) {
35
            delta[i] = A[i] - target;
36
            if (delta[i] % K != 0) {
37
                possible = false;
38
            }
39
        }
40
        if (!possible) {
41
            cout << -1 << endl;
42
            continue;
43
        }
44
        vector<int> d(N);
45
        for (int i = 0; i < N; i++) {
46
            d[i] = delta[i] / K;
47
        }
48
        vector<int> c(N, 0);
49
        for (int i = 1; i < N; i++) {
50
            c[i] = c[i - 1] + d[i];
51
        }
52
        int max_neg_c = -c[0];
53
        for (int i = 0; i < N; i++) {
54
            max_neg_c = max(max_neg_c, -c[i]);
55
        }
56
        long long sum_c = accumulate(c.begin(), c.end(), 0LL);
57
        long long total_ops = (long long)max_neg_c * N + sum_c;
58
        cout << total_ops << endl;
59
    }
60
    return 0;
61
}",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833533
1387833528,hamso2107,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
    # Compute the prefix sum array
5
    prefix_sum = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
8
    9
    max_diff = 0
10
    11
    # Iterate through all possible split points
12
    for i in range(1, n):
13
        left_sum = prefix_sum[i]
14
        right_sum = prefix_sum[n] - prefix_sum[i]
15
        current_diff = abs(left_sum - right_sum)
16
        17
        # Update the maximum difference
18
        if current_diff > max_diff:
19
            max_diff = current_diff
20
    21
    return max_diff
22
23
def main():
24
    import sys
25
    input = sys.stdin.read
26
    data = input().split()
27
    28
    idx = 0
29
    t = int(data[idx])  # Number of test cases
30
    idx += 1
31
    32
    for _ in range(t):
33
        n = int(data[idx])  # Size of the array
34
        idx += 1
35
        nums = list(map(int, data[idx:idx + n]))  # Array elements
36
        idx += n
37
        38
        result = max_absolute_difference(nums)
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833528
1387833529,cjain1725,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    """"""
3
    Calculate minimum operations needed to equalize energy in circular power stations
4
    5
    Args:
6
        N (int): Number of power stations
7
        K (int): Units of energy that can be transferred in one operation
8
        energy (list): Array of energy values for each station
9
        10
    Returns:
11
        int: Minimum number of operations needed, or -1 if impossible
12
    """"""
13
    # Check if already equal
14
    if len(set(energy)) == 1:
15
        return 0
16
        17
    # Calculate total energy and target
18
    total = sum(energy)
19
    if total % N != 0:
20
        return -1
21
    target = total // N
22
    23
    # Compute differences from target
24
    diffs = [(x - target) for x in energy]
25
    26
    # Verify if equalization is possible with given K
27
    if any(abs(d) % K != 0 for d in diffs):
28
        return -1
29
    30
    # Count operations
31
    operations = 0
32
    running_diff = 0
33
    34
    # Count transfers needed for each position except last
35
    for i in range(N-1):
36
        running_diff += diffs[i]
37
        if running_diff != 0:
38
            if abs(running_diff) % K != 0:
39
                return -1
40
            operations += abs(running_diff) // K
41
    42
    # Check if final position balances out
43
    running_diff += diffs[N-1]
44
    if running_diff != 0:
45
        return -1
46
        47
    return operations
48
49
def main():
50
    T = int(input())
51
    for _ in range(T):
52
        N, K = map(int, input().split())
53
        energy = list(map(int, input().split()))
54
        result = min_operations_to_equalize(N, K, energy)
55
        print(result)
56
57
if __name__ == ""__main__"":
58
    main()",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833529
1387833531,sanskriti_singh9,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for _ in range(t):
4
        n = test_cases[_][0]
5
        nums = test_cases[_][1]
6
7
        # Compute prefix sums
8
        prefix_sum = [0] * n
9
        prefix_sum[0] = nums[0]
10
        for i in range(1, n):
11
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
12
13
        total_sum = prefix_sum[-1]  # Total sum of the array
14
        max_diff = 0
15
16
        # Compute maximum absolute difference by partitioning at every point
17
        for i in range(n - 1):
18
            left_sum = prefix_sum[i]
19
            right_sum = total_sum - left_sum
20
            max_diff = max(max_diff, abs(left_sum - right_sum))
21
22
        results.append(max_diff)
23
24
    return results
25
26
27
# Input
28
t = int(input())
29
test_cases = []
30
for _ in range(t):
31
    n = int(input())
32
    nums = list(map(int, input().split()))
33
    test_cases.append((n, nums))
34
35
# Output
36
output = max_absolute_difference(t, test_cases)
37
for res in output:
38
    print(res)
39",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833531
1387833524,manjesht78,unknown,unknown,"1
def product_except_self(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
8
        # Arrays to store prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
12
        # Compute prefix products
13
        for i in range(1, n):
14
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
15
16
        # Compute suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
19
20
        # Compute result array
21
        result = [prefix_products[i] * suffix_products[i] for i in range(n)]
22
        results.append(result)
23
24
    return results
25
26
# Input handling
27
if __name__ == ""__main__"":
28
    T = int(input())
29
    test_cases = []
30
31
    for _ in range(T):
32
        n = int(input())
33
        values = list(map(int, input().split()))
34
        test_cases.append((n, values))
35
36
    # Solve the problem
37
    results = product_except_self(T, test_cases)
38
39
    # Output results
40
    for result in results:
41
        print("" "".join(map(str, result)))
42",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833524
1387833525,adityadav0412,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums) 
3
    prefix_sum = [0] * (n + 1)
4
    for i in range(n):
5
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
6
    7
    max_diff = 0
8
    9
    for i in range(1, n):
10
        left_sum = prefix_sum[i]
11
        right_sum = prefix_sum[n] - prefix_sum[i]
12
        current_diff = abs(left_sum - right_sum)
13
        14
        if current_diff > max_diff:
15
            max_diff = current_diff
16
    17
    return max_diff
18
19
def main():
20
    import sys
21
    input = sys.stdin.read
22
    data = input().split()    
23
    idx = 0
24
    t = int(data[idx]) 
25
    idx += 1
26
    27
    for _ in range(t):
28
        n = int(data[idx])  
29
        idx += 1
30
        nums = list(map(int, data[idx:idx + n]))  
31
        idx += n
32
        33
        result = max_absolute_difference(nums)
34
        print(result)
35
36
if __name__ == ""__main__"":
37
    main()",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833525
1387833526,yashdubeyenter15,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt(); 
8
        9
        while (T-- > 0) {
10
            int n = scanner.nextInt();
11
            int[] values = new int[n];
12
            13
           14
            for (int i = 0; i < n; i++) {
15
                values[i] = scanner.nextInt();
16
            }
17
            18
            19
            int[] result = productExceptSelf(values);
20
            printArray(result);
21
        }
22
        23
        scanner.close();
24
    }
25
    26
    private static int[] productExceptSelf(int[] nums) {
27
        int n = nums.length;
28
        int[] result = new int[n];
29
        30
        31
        result[0] = 1;
32
        for (int i = 1; i < n; i++) {
33
            result[i] = result[i-1] * nums[i-1];
34
        }
35
        36
        37
        int rightProduct = 1;
38
        for (int i = n-1; i >= 0; i--) {
39
            result[i] = result[i] * rightProduct;
40
            rightProduct *= nums[i];
41
        }
42
        43
        return result;
44
    }
45
    46
    private static void printArray(int[] arr) {
47
        for (int i = 0; i < arr.length; i++) {
48
            System.out.print(arr[i]);
49
            if (i < arr.length - 1) {
50
                System.out.print("" "");
51
            }
52
        }
53
        System.out.println();
54
    }
55
}",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833526
1387833523,h1032220347,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
3
4
def compute_product_array(n, values):
5
6
    prefix = [1] * n
7
8
    for i in range(1, n):
9
10
        prefix[i] = prefix[i - 1] * values[i - 1]
11
12
    13
14
    suffix = [1] * n
15
16
    for i in range(n - 2, -1, -1):
17
18
        suffix[i] = suffix[i + 1] * values[i + 1]
19
20
    21
22
    result = [prefix[i] * suffix[i] for i in range(n)]
23
24
    25
26
    return result
27
28
T = int(input().strip()) 
29
30
for _ in range(T):
31
32
    n = int(input().strip()) 
33
34
    values = list(map(int, input().strip().split()))
35
36
    print("" "".join(map(str, compute_product_array(n, values))))",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833523
1387833520,h1032221714,unknown,unknown,"1
def solve():
2
    t = int(input())  # Number of test cases
3
    for _ in range(t):
4
        n = int(input())  # Size of the array
5
        nums = list(map(int, input().split()))  # The array itself
6
        7
        total_sum = sum(nums)
8
        prefix_sum = 0
9
        max_diff = 0
10
        11
        for i in range(n - 1):  # We must leave at least one element in each subarray
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        print(max_diff)
17
18
# Call the solve function
19
solve()",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833520
1387833521,shivamthakur0201,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for i in range(t):
5
        n = test_cases[i][0]
6
        nums = test_cases[i][1]
7
        8
        # Calculate total sum of the array
9
        total_sum = sum(nums)
10
        11
        # Initialize variables
12
        left_sum = 0
13
        max_difference = float('-inf')
14
        15
        # Iterate through the array to calculate differences
16
        for j in range(n - 1):
17
            left_sum += nums[j]
18
            right_sum = total_sum - left_sum
19
            max_difference = max(max_difference, abs(left_sum - right_sum))
20
        21
        results.append(max_difference)
22
    23
    return results
24
25
26
# Input handling
27
if __name__ == ""__main__"":
28
    t = int(input())  # Number of test cases
29
    test_cases = []
30
    31
    for _ in range(t):
32
        n = int(input())  # Size of the array
33
        nums = list(map(int, input().split()))  # Array elements
34
        test_cases.append((n, nums))
35
    36
    # Get the results
37
    results = max_absolute_difference(t, test_cases)
38
  39
    for res in results:
40
        print(res)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833521
1387833522,aditipandey30101,unknown,unknown,"1
def product_except_self(arr,n):
2
    prefix = [1]*n
3
    suffix = [1]*n
4
    result = [1]*n
5
    for i in range(1, n):
6
        prefix[i] = prefix[i-1]*arr[i-1]
7
    for i in range(n-2,-1,-1):
8
        suffix[i] = suffix[i+1]*arr[i+1]
9
    for i in range(n):
10
        result[i] = prefix[i]*suffix[i]
11
    return result
12
T = int(input())
13
14
for _ in range(T):
15
    n = int(input())
16
    arr = list(map(int, input().split()))
17
    print(*product_except_self(arr, n))
18",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833522
1387833513,kadamaryan21418,unknown,unknown,"1
def max_subarray_difference(nums, n):
2
    """"""
3
    Calculate maximum absolute difference between sums of two contiguous subarrays.
4
    5
    Args:
6
        nums: List of integers
7
        n: Length of the array
8
    Returns:
9
        Maximum absolute difference possible
10
    """"""
11
    # Handle edge case
12
    if n < 2:
13
        return 0
14
        15
    # Keep track of maximum difference
16
    max_diff = float('-inf')
17
    18
    # Calculate total sum once
19
    total_sum = sum(nums)
20
    21
    # Keep track of left subarray sum
22
    left_sum = 0
23
    24
    # Try each possible partition point
25
    for i in range(n-1):  # Stop at n-1 to ensure right subarray is non-empty
26
        # Add current element to left sum
27
        left_sum += nums[i]
28
        29
        # Right sum can be calculated using total_sum - left_sum
30
        right_sum = total_sum - left_sum
31
        32
        # Calculate absolute difference
33
        curr_diff = abs(left_sum - right_sum)
34
        35
        # Update maximum difference if current is larger
36
        max_diff = max(max_diff, curr_diff)
37
    38
    return max_diff
39
40
def main():
41
    # Read number of test cases
42
    t = int(input())
43
    44
    # Process each test case
45
    for _ in range(t):
46
        # Read array size
47
        n = int(input())
48
        49
        # Read array elements
50
        nums = list(map(int, input().split()))
51
        52
        # Calculate and print result
53
        result = max_subarray_difference(nums, n)
54
        print(result)
55
56
if __name__ == ""__main__"":
57
    main()",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833513
1387833514,atharvjadhav2910,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        surplus = 0
12
        for i in range(N):
13
            diff = energy[i] - target
14
            surplus += diff
15
            if surplus % K != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(surplus // K)
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
results = minimum_operations(test_cases)
31
for res in results:
32
    print(res)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833514
1387833518,parmesh214,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
    for i in range(1, n):
7
        left[i] = left[i-1] * arr[i-1]
8
9
    for i in range(n-2, -1, -1):
10
        right[i] = right[i+1] * arr[i+1]
11
12
    result = [left[i] * right[i] for i in range(n)]
13
    return result
14
15
t = int(input())
16
for _ in range(t):
17
    n = int(input())
18
    arr = list(map(int, input().split()))
19
    result = product_array(arr)
20
    print(*result)
21",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833518
1387833510,codedemon1426,unknown,unknown,"1
def solve():
2
    n = int(input())
3
    nums = list(map(int, input().split()))
4
5
    max_diff = 0
6
    total_sum = sum(nums)
7
    current_sum = 0
8
9
    for i in range(n - 1):
10
        current_sum += nums[i]
11
        sum1 = current_sum
12
        sum2 = total_sum - sum1
13
        diff = abs(sum1 - sum2)
14
        max_diff = max(max_diff, diff)
15
16
    print(max_diff)
17
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833510
1387833511,krishjain,unknown,unknown,"1
import sys
2
3
def max_absolute_difference(n, nums):
4
    total_sum = sum(nums)
5
    max_diff = 0
6
    left_sum = 0
7
    8
    for i in range(n - 1):
9
        left_sum += nums[i]
10
        right_sum = total_sum - left_sum
11
        max_diff = max(max_diff, abs(left_sum - right_sum))
12
    13
    return max_diff
14
15
def main():
16
    input = sys.stdin.read
17
    data = input().split()
18
    index = 0
19
    20
    t = int(data[index])
21
    index += 1
22
    results = []
23
    24
    for _ in range(t):
25
        n = int(data[index])
26
        index += 1
27
        nums = list(map(int, data[index:index + n]))
28
        index += n
29
        30
        results.append(str(max_absolute_difference(n, nums)))
31
    32
    sys.stdout.write(""\n"".join(results) + ""\n"")
33
34
if __name__ == ""__main__"":
35
    main()",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833511
1387833512,08vijay09,unknown,unknown,"1
def solve():
2
3
    T = int(input())  
4
5
    for _ in range(T):
6
7
        N, K = map(int, input().split())  
8
9
        energy = list(map(int, input().split())) 
10
11
        12
13
        14
15
        total_energy = sum(energy)
16
17
        18
19
        20
21
        if total_energy % N != 0:
22
23
            print(-1)
24
25
            continue
26
27
        28
29
        target = total_energy // N  
30
31
        operations = 0  
32
33
        34
35
        balance = 0  
36
37
        possible = True
38
39
        40
41
        for i in range(N):
42
43
            44
45
            energy_diff = energy[i] - target
46
47
            balance += energy_diff  
48
49
            50
51
            if balance % K != 0:
52
53
                possible = False
54
55
                break
56
57
            58
59
            operations += abs(balance) // K
60
61
        62
63
        if possible:
64
65
            print(operations)
66
67
        else:
68
69
            print(-1)
70
71
72
73
solve()",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833512
1387833509,ankushchaudhary5,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        surplus = 0
12
        for i in range(N):
13
            diff = energy[i] - target
14
            surplus += diff
15
            if surplus % K != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(surplus // K)
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
results = minimum_operations(test_cases)
31
for res in results:
32
    print(res)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833509
1387833502,h1032220754,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for values in test_cases:
4
        n = len(values)
5
        total_product = 1
6
        zero_count = 0
7
8
        # Calculate the total product of all non-zero elements
9
        for value in values:
10
            if value != 0:
11
                total_product *= value
12
            else:
13
                zero_count += 1
14
15
        result = []
16
        for value in values:
17
            if zero_count > 1:
18
                result.append(0)
19
            elif zero_count == 1:
20
                result.append(0 if value != 0 else total_product)
21
            else:
22
                result.append(total_product // value)
23
24
        results.append(result)
25
26
    return results
27
28
def main():
29
    T = int(input())
30
    test_cases = []
31
    for _ in range(T):
32
        n = int(input())
33
        values = list(map(int, input().split()))
34
        test_cases.append(values)
35
36
    results = product_except_self(test_cases)
37
    for res in results:
38
        print("" "".join(map(str, res)))
39
40
if __name__ == ""__main__"":
41
    main()",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833502
1387833503,shwetankrai0710,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833503
1387833506,nishantsahu435,unknown,unknown,"1
def solve_max_absolute_difference(test_cases):
2
    results = []
3
4
    for _ in range(test_cases):
5
        n = int(input())
6
        nums = list(map(int, input().split()))
7
8
        # Calculate prefix sums
9
        prefix_sum = [0] * n
10
        prefix_sum[0] = nums[0]
11
        for i in range(1, n):
12
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
13
14
        total_sum = prefix_sum[-1]
15
        max_diff = 0
16
17
        # Iterate to find the maximum absolute difference
18
        for i in range(n - 1):
19
            left_sum = prefix_sum[i]
20
            right_sum = total_sum - left_sum
21
            max_diff = max(max_diff, abs(left_sum - right_sum))
22
23
        results.append(max_diff)
24
25
    for result in results:
26
        print(result)
27
28
# Input handling
29
if __name__ == ""__main__"":
30
    t = int(input())
31
    solve_max_absolute_difference(t)",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833506
1387833499,h1032221618,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833499
1387833500,praveenbisht491,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        result = [1] * n
6
        prefix = 1
7
        for i in range(n):
8
            result[i] = prefix
9
            prefix *= values[i]
10
        suffix = 1
11
        for i in range(n - 1, -1, -1):
12
            result[i] *= suffix
13
            suffix *= values[i]
14
        results.append(result)
15
    return results
16
17
t = int(input())
18
test_cases = []
19
for _ in range(t):
20
    n = int(input())
21
    values = list(map(int, input().split()))
22
    test_cases.append((n, values))
23
24
results = product_except_self(test_cases)
25
for result in results:
26
    print("" "".join(map(str, result)))",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833500
1387833501,h1032221641,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    ptr = 0
6
    T = int(input[ptr])
7
    ptr +=1
8
    for _ in range(T):
9
        N, K = int(input[ptr]), int(input[ptr+1])
10
        ptr +=2
11
        energy = list(map(int, input[ptr:ptr+N]))
12
        ptr +=N
13
        total = sum(energy)
14
        if total % N != 0:
15
            print(-1)
16
            continue
17
        target = total // N
18
        delta = [target - e for e in energy]
19
        possible = True
20
        for d in delta:
21
            if d % K != 0:
22
                possible = False
23
                break
24
        if not possible:
25
            print(-1)
26
            continue
27
        if N == 1:
28
            print(0)
29
            continue
30
        d_list = [d // K for d in delta]
31
        current_sum = 0
32
        s_list = []
33
        for j in range(1, N):
34
            current_sum += d_list[j]
35
            s_list.append(current_sum)
36
        S_max = max(s_list)
37
        sum_s = sum(s_list)
38
        sum_x = N * S_max - sum_s
39
        print(sum_x)
40
41
if __name__ == ""__main__"":
42
    main()",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833501
1387833497,sonamyadav7208,unknown,unknown,"1
def solve():
2
    t = int(input())  # number of test cases
3
    for _ in range(t):
4
        n = int(input())  # size of the array
5
        nums = list(map(int, input().split()))  # the array
6
        7
        # Calculate the total sum of the array
8
        total_sum = sum(nums)
9
        10
        # Variables to track the left sum and maximum absolute difference
11
        left_sum = 0
12
        max_difference = 0
13
        14
        # Iterate to find the maximum absolute difference
15
        for i in range(n - 1):  # We stop at n-1 since we need non-empty right subarray
16
            left_sum += nums[i]
17
            right_sum = total_sum - left_sum
18
            max_difference = max(max_difference, abs(left_sum - right_sum))
19
        20
        print(max_difference)
21
22
# Call the function to solve the problem
23
solve()
24",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833497
1387833498,laxmimehta0506,unknown,unknown,"1
import java.util.Scanner;
2
3
public class MaxAbsoluteDifference {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt();  // Number of test cases
7
        8
        while (t-- > 0) {
9
            int n = sc.nextInt();  // Size of the array
10
            int[] nums = new int[n];
11
            12
            int totalSum = 0;
13
            for (int i = 0; i < n; i++) {
14
                nums[i] = sc.nextInt();
15
                totalSum += nums[i];
16
            }
17
            18
            int prefixSum = 0;
19
            int maxDiff = Integer.MIN_VALUE;
20
            21
            for (int i = 0; i < n - 1; i++) {  // Split point must be between 1 and n-1
22
                prefixSum += nums[i];
23
                int currentDiff = Math.abs(2 * prefixSum - totalSum);
24
                maxDiff = Math.max(maxDiff, currentDiff);
25
            }
26
            27
            System.out.println(maxDiff);
28
        }
29
        30
        sc.close();
31
    }
32
}
33",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833498
1387833495,sunaym1006,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def equalize_energy(T, test_cases):
3
    results = []
4
    5
    for t in range(T):
6
        N, K = test_cases[t][0], test_cases[t][1]
7
        energy = test_cases[t][2]
8
        9
        # Calculate the total energy
10
        total_energy = sum(energy)
11
        12
        # If total energy is not divisible by N, it's impossible to equalize
13
        if total_energy % N != 0:
14
            results.append(-1)
15
            continue
16
        17
        target_energy = total_energy // N
18
        operations = 0
19
        imbalance = 0
20
        21
        # Traverse through the stations to calculate imbalance and operations
22
        for i in range(N):
23
            imbalance += energy[i] - target_energy
24
            # Since each operation involves transferring K units, calculate the operations required for imbalance
25
            if imbalance % K != 0:  # If imbalance can't be fixed exactly using K, it is not possible
26
                results.append(-1)
27
                break
28
            operations += abs(imbalance) // K
29
        30
        else:  # Only append the result if the loop completes without breaking
31
            results.append(operations)
32
    33
    return results
34
35
# Input reading part (for use in competitive programming platforms)
36
T = int(input())  # number of test cases
37
test_cases = []
38
39
for _ in range(T):
40
    N, K = map(int, input().split())  # N and K for each test case
41
    energy = list(map(int, input().split()))  # energy of the stations
42
    test_cases.append((N, K, energy))
43
44
results = equalize_energy(T, test_cases)
45
for res in results:
46
    print(res)
47",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833495
1387833492,h1032221728,unknown,unknown,"1
import sys
2
3
def max_absolute_difference(test_cases):
4
    results = []
5
    6
    for nums in test_cases:
7
        n = len(nums)
8
        total_sum = sum(nums)
9
        left_sum = 0
10
        max_diff = float('-inf')
11
        12
        # Iterate through the array to find the maximum absolute difference
13
        for i in range(n - 1):  # We stop at n-1 to ensure both subarrays are non-empty
14
            left_sum += nums[i]
15
            right_sum = total_sum - left_sum
16
            max_diff = max(max_diff, abs(left_sum - right_sum))
17
        18
        results.append(max_diff)
19
    20
    return results
21
22
# Input reading
23
input_data = sys.stdin.read().strip().splitlines()
24
t = int(input_data[0])
25
test_cases = []
26
27
index = 1
28
for _ in range(t):
29
    n = int(input_data[index])  # Read the size of the array
30
    nums = list(map(int, input_data[index + 1].split()))  # Read the array elements
31
    test_cases.append(nums)
32
    index += 2  # Move to the next test case
33
34
# Get results
35
results = max_absolute_difference(test_cases)
36
37
# Output results
38
for result in results:
39
    print(result)",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833492
1387833486,gauravr6012,unknown,unknown,"1
def min_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
4
    for n, k, energy in test_cases:
5
        total_energy = sum(energy)
6
        7
        8
        if total_energy % n != 0:
9
            results.append(-1)
10
            continue
11
12
        target_energy = total_energy // n
13
        14
        15
        surplus = 0
16
        operations = 0
17
18
        for i in range(n):
19
            diff = energy[i] - target_energy
20
            surplus += diff
21
22
            23
            if surplus % k != 0:
24
                results.append(-1)
25
                break
26
27
            operations += abs(surplus) // k
28
        else:
29
            results.append(operations)
30
31
    return results
32
33
34
if __name__ == ""__main__"":
35
   36
    t = int(input())
37
    test_cases = []
38
39
    for _ in range(t):
40
        n, k = map(int, input().split())
41
        energy = list(map(int, input().split()))
42
        test_cases.append((n, k, energy))
43
44
   45
    results = min_operations_to_equalize_energy(t, test_cases)
46
47
    48
    for result in results:
49
        print(result)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833486
1387833484,ravislprajapati,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        prefix = [1] * n
6
        suffix = [1] * n
7
        result = [1] * n
8
        9
        # Compute prefix products
10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] * values[i - 1]
12
        13
        # Compute suffix products
14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] * values[i + 1]
16
        17
        # Compute result array
18
        for i in range(n):
19
            result[i] = prefix[i] * suffix[i]
20
        21
        results.append(result)
22
    23
    return results
24
25
# Input Reading
26
T = int(input())
27
test_cases = []
28
for _ in range(T):
29
    n = int(input())
30
    values = list(map(int, input().split()))
31
    test_cases.append((n, values))
32
33
# Compute and Output Results
34
results = product_except_self(test_cases)
35
for res in results:
36
    print(' '.join(map(str, res)))",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833484
1387833488,pranaytiwariprpk,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
7
        // Read the number of test cases
8
        int T = scanner.nextInt();
9
10
        // Process each test case
11
        for (int t = 0; t < T; t++) {
12
            // Read the number of nodes
13
            int n = scanner.nextInt();
14
            int[] values = new int[n];
15
16
            // Read the values of the nodes
17
            for (int i = 0; i < n; i++) {
18
                values[i] = scanner.nextInt();
19
            }
20
21
            // Create the result array
22
            int[] result = new int[n];
23
24
            // Calculate the total product of all elements
25
            long totalProduct = 1;
26
            int zeroCount = 0;
27
28
            for (int value : values) {
29
                if (value != 0) {
30
                    totalProduct *= value;
31
                } else {
32
                    zeroCount++;
33
                }
34
            }
35
36
            // Calculate the result array
37
            for (int i = 0; i < n; i++) {
38
                if (zeroCount > 1) {
39
                    // If there are more than 1 zeros, all results will be 0
40
                    result[i] = 0;
41
                } else if (zeroCount == 1) {
42
                    // If there is exactly 1 zero
43
                    result[i] = (values[i] == 0) ? (int) totalProduct : 0;
44
                } else {
45
                    // No zeros, divide total product by the current value
46
                    result[i] = (int) (totalProduct / values[i]);
47
                }
48
            }
49
50
            // Print the result array
51
            for (int i = 0; i < n; i++) {
52
                System.out.print(result[i] + "" "");
53
            }
54
            System.out.println();
55
        }
56
57
        scanner.close();
58
    }
59
}
60",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833488
1387833481,pulekarswaradny,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
31
        # Check and calculate the number of operations required
32
        for e in energy:
33
            diff = e - target_energy
34
            balance += diff
35
36
            # If balance is not divisible by K at any point, it's impossible
37
            if balance % K != 0:
38
                results.append(""-1"")
39
                break
40
            operations += abs(balance // K)
41
        else:
42
            results.append(str(operations))
43
44
    # Output all results
45
    sys.stdout.write(""\n"".join(results) + ""\n"")
46
47
if __name__ == ""__main__"":
48
    solve_test_cases()
49
50
    ",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833481
1387833482,arshiyak572,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def min_operations_to_equalize(N, K, energy):
3
    total_energy = sum(energy)
4
    5
    # Check if it's possible to equalize energy
6
    if total_energy % N != 0:
7
        return -1  # Impossible to equalize
8
    9
    target = total_energy // N
10
    operations = 0
11
    balance = 0
12
    13
    # Traverse through each station
14
    for i in range(N):
15
        # Calculate the current imbalance (how much energy needs to be transferred)
16
        balance += energy[i] - target
17
        18
        # The number of operations needed is determined by the magnitude of balance
19
        # Each imbalance of K requires one operation
20
        operations += abs(balance) // K
21
        22
    return operations
23
24
# Reading input
25
T = int(input())  # Number of test cases
26
for _ in range(T):
27
    N, K = map(int, input().split())  # Number of stations and units of energy per operation
28
    energy = list(map(int, input().split()))  # List of energy at each station
29
    30
    # Calculate and print the result for the current test case
31
    result = min_operations_to_equalize(N, K, energy)
32
    print(result)
33",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833482
1387833483,dhuvesh_salian,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833483
1387833479,harshrsharma29,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
    # Calculate left product array
7
    for i in range(1, n):
8
        left[i] = left[i-1] * arr[i-1]
9
10
    # Calculate right product array
11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * arr[i+1]
13
14
    # Calculate result array
15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
# Get number of test cases
20
t = int(input())
21
22
for _ in range(t):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833479
1387833480,ayushchaudhary71,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        surplus = 0
12
        for i in range(N):
13
            diff = energy[i] - target
14
            surplus += diff
15
            if surplus % K != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(surplus // K)
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
results = minimum_operations(test_cases)
31
for res in results:
32
    print(res)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833480
1387833478,rahulpurohitrp71,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
3
    results = []
4
5
    6
7
    for t in test_cases:
8
9
        n, nums = t
10
11
        total_sum = sum(nums)
12
13
        prefix_sum = 0
14
15
        max_diff = 0
16
17
        18
19
        # Iterate through possible partitions
20
21
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
22
23
            prefix_sum += nums[i]
24
25
            suffix_sum = total_sum - prefix_sum
26
27
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
28
29
        30
31
        results.append(max_diff)
32
33
    34
35
    return results
36
37
# Input handling
38
39
t = int(input())
40
41
test_cases = []
42
43
for _ in range(t):
44
45
    n = int(input())
46
47
    nums = list(map(int, input().split()))
48
49
    test_cases.append((n, nums))
50
51
# Compute results
52
53
results = max_absolute_difference(test_cases)
54
55
# Output results
56
57
for res in results:
58
59
    print(res)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833478
1387833477,3277kunaljain,unknown,unknown,"1
T = int(input())  
2
for _ in range(T):
3
    n = int(input())
4
    values = list(map(int, input().split())) 
5
    prefix = [1] * n
6
    suffix = [1] * n
7
    result = [1] * n
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] * values[i - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] * values[i + 1]
12
    for i in range(n):
13
        result[i] = prefix[i] * suffix[i]
14
    print("" "".join(map(str, result)))
15",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833477
1387833474,ayushaj14,unknown,unknown,"1
def min_operations_to_equalize_energy(n, k, energy):
2
    total_energy = sum(energy)
3
    if total_energy % n != 0:
4
        return -1
5
    6
    target = total_energy // n
7
    operations = 0
8
    current_energy = 0
9
    10
    for i in range(n):
11
        current_energy += energy[i] - target
12
        if current_energy % k != 0:
13
            return -1
14
        operations += abs(current_energy // k)
15
    16
    return operations
17
18
def handle_test_cases(T, test_cases):
19
    results = []
20
    for i in range(T):
21
        n, k = test_cases[i][0]
22
        energy = test_cases[i][1]
23
        results.append(min_operations_to_equalize_energy(n, k, energy))
24
    return results
25
26
# Example usage
27
T = 3
28
test_cases = [
29
    ((3, 2), [4, 4, 4]),
30
    ((3, 1), [5, 3, 4]),
31
    ((4, 3), [5, 5, 5, 6])
32
]
33
34
results = handle_test_cases(T, test_cases)
35
for result in results:
36
    print(result)
37
38
    ",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833474
1387833475,h1032231295,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for n, nums in test_cases:
4
        # Compute prefix sums
5
        prefix_sum = [0] * n
6
        prefix_sum[0] = nums[0]
7
        for i in range(1, n):
8
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
9
        10
        # Find maximum absolute difference
11
        total_sum = prefix_sum[-1]
12
        max_diff = 0
13
        for i in range(n - 1):
14
            left_sum = prefix_sum[i]
15
            right_sum = total_sum - left_sum
16
            max_diff = max(max_diff, abs(left_sum - right_sum))
17
        18
        results.append(max_diff)
19
    return results
20
21
22
# Input Handling
23
t = int(input())
24
test_cases = []
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Output Results
31
results = max_absolute_difference(test_cases)
32
for result in results:
33
    print(result)
34",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833475
1387833476,h1032221029,unknown,unknown,"1
def can_equalize_energy(N, K, energy):
2
   3
    total_energy = sum(energy)
4
    5
    6
    if total_energy % N != 0:
7
        return -1
8
    9
    target_energy = total_energy // N
10
    operations = 0
11
    12
    13
    if all(e == target_energy for e in energy):
14
        return 0
15
    16
   17
    current = energy.copy()
18
    seen_states = set()
19
    20
    while True:
21
        state = tuple(current)
22
        23
       24
        if state in seen_states:
25
            return -1
26
        27
        seen_states.add(state)
28
        29
   30
        made_transfer = False
31
        for i in range(N):
32
            next_i = (i + 1) % N
33
            34
            35
            if current[i] > target_energy and current[next_i] < target_energy:
36
               37
                excess = current[i] - target_energy
38
                needed = target_energy - current[next_i]
39
                transfers = min(excess // K, needed // K)
40
                41
                if transfers > 0:
42
                    current[i] -= transfers * K
43
                    current[next_i] += transfers * K
44
                    operations += transfers
45
                    made_transfer = True
46
        47
       48
        if not made_transfer:
49
           50
            if all(e == target_energy for e in current):
51
                return operations
52
            return -1
53
54
def main():
55
    T = int(input())
56
    57
    for _ in range(T):
58
   59
        N, K = map(int, input().split())
60
        61
    62
        energy = list(map(int, input().split()))
63
        64
       65
        result = can_equalize_energy(N, K, energy)
66
        print(result)
67
68
if __name__ == ""__main__"":
69
    main()",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833476
1387833471,sohampatil1807,unknown,unknown,"1
with Ada.Text_IO, Ada.Integer_Text_IO;
2
use Ada;
3
4
procedure Solution is
5
-- Enter your code here. Read input from STDIN. Print output to STDOUT
6
def solve_product_array(values, n):
7
    """"""
8
    Calculate product of all elements except self for each position.
9
    Uses O(1) extra space (not counting the output array).
10
    """"""
11
   12
    if n < 2:
13
        return []
14
        15
    # Initialize result array
16
    result = [0] * n
17
    18
 19
    20
  21
    result[0] = 1
22
    for i in range(1, n):
23
        result[i] = values[i - 1] * result[i - 1]
24
    25
   26
    right_product = 1
27
    for i in range(n - 1, -1, -1):
28
        result[i] = result[i] * right_product
29
        right_product *= values[i]
30
    31
    return result
32
33
def main():
34
   35
    T = int(input())
36
    37
  38
    for _ in range(T):
39
       40
        n = int(input())
41
        42
        43
        values = list(map(int, input().split()))
44
        45
        46
        result = solve_product_array(values, n)
47
        48
        49
        print("" "".join(map(str, result)))
50
51
if _name_ == ""_main_"":
52
    main()
53
54
end Solution",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833471
1387833472,h1032221629,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target_energy = total_energy // N
8
    operations = 0
9
    10
    for i in range(N):
11
        diff = energy[i] - target_energy
12
        13
        if diff % K != 0:
14
            return -1
15
        16
        if diff != 0:
17
            operations += abs(diff) // K
18
            energy[(i + 1) % N] += diff
19
    20
    return operations
21
22
def main():
23
    T = int(input())
24
    25
    for _ in range(T):
26
        N, K = map(int, input().split())
27
        energy = list(map(int, input().split()))
28
        29
        result = min_operations_to_equalize(N, K, energy)
30
        print(result)
31
32
main()
33",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833472
1387833473,shuklaram2315,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for case in range(t):
4
        n = test_cases[case][0]
5
        nums = test_cases[case][1]
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        for i in range(n - 1):
10
            prefix_sum += nums[i]
11
            suffix_sum = total_sum - prefix_sum
12
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
13
        results.append(max_diff)
14
    return results
15
t = int(input())
16
test_cases = []
17
for _ in range(t):
18
    n = int(input())
19
    nums = list(map(int, input().split()))
20
    test_cases.append((n, nums))
21
results = max_absolute_difference(t, test_cases)
22
for res in results:
23
    print(res)",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833473
1387833464,sohampatil1807,unknown,unknown,"1
with Ada.Text_IO, Ada.Integer_Text_IO;
2
use Ada;
3
4
procedure Solution is
5
-- Enter your code here. Read input from STDIN. Print output to STDOUT
6
def solve_product_array(values, n):
7
    """"""
8
    Calculate product of all elements except self for each position.
9
    Uses O(1) extra space (not counting the output array).
10
    """"""
11
   12
    if n < 2:
13
        return []
14
        15
    # Initialize result array
16
    result = [0] * n
17
    18
 19
    20
  21
    result[0] = 1
22
    for i in range(1, n):
23
        result[i] = values[i - 1] * result[i - 1]
24
    25
   26
    right_product = 1
27
    for i in range(n - 1, -1, -1):
28
        result[i] = result[i] * right_product
29
        right_product *= values[i]
30
    31
    return result
32
33
def main():
34
   35
    T = int(input())
36
    37
  38
    for _ in range(T):
39
       40
        n = int(input())
41
        42
        43
        values = list(map(int, input().split()))
44
        45
        46
        result = solve_product_array(values, n)
47
        48
        49
        print("" "".join(map(str, result)))
50
51
if _name_ == ""_main_"":
52
    main()
53
54
end Solution",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833464
1387833465,vnandini1530,unknown,unknown,"1
def solve_testcase(n, nums):
2
    # If array has only 2 elements, return their absolute difference
3
    if n == 2:
4
        return abs(nums[0] - nums[1])
5
    6
    # Calculate the total sum of the array
7
    total_sum = sum(nums)
8
    9
    max_diff = 0
10
    left_sum = 0
11
    12
    # Try each possible partition point
13
    # We need to ensure both subarrays are non-empty,
14
    # so we only go up to n-1 (leaving at least one element for the right subarray)
15
    for i in range(n-1):
16
        # Add current element to left sum
17
        left_sum += nums[i]
18
        # Right sum is the remaining elements
19
        right_sum = total_sum - left_sum
20
        # Calculate absolute difference
21
        curr_diff = abs(left_sum - right_sum)
22
        # Update max_diff if current difference is larger
23
        max_diff = max(max_diff, curr_diff)
24
    25
    return max_diff
26
27
def main():
28
    # Read number of test cases
29
    t = int(input())
30
    31
    # Process each test case
32
    for _ in range(t):
33
        # Read array size
34
        n = int(input())
35
        # Read array elements
36
        nums = list(map(int, input().split()))
37
        38
        # Solve current test case
39
        result = solve_testcase(n, nums)
40
        41
        # Print result
42
        print(result)
43
44
if __name__ == ""__main__"":
45
    main()
46",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833465
1387833469,sohampatil1807,unknown,unknown,"1
with Ada.Text_IO, Ada.Integer_Text_IO;
2
use Ada;
3
4
procedure Solution is
5
-- Enter your code here. Read input from STDIN. Print output to STDOUT
6
def solve_product_array(values, n):
7
    """"""
8
    Calculate product of all elements except self for each position.
9
    Uses O(1) extra space (not counting the output array).
10
    """"""
11
   12
    if n < 2:
13
        return []
14
        15
    # Initialize result array
16
    result = [0] * n
17
    18
 19
    20
  21
    result[0] = 1
22
    for i in range(1, n):
23
        result[i] = values[i - 1] * result[i - 1]
24
    25
   26
    right_product = 1
27
    for i in range(n - 1, -1, -1):
28
        result[i] = result[i] * right_product
29
        right_product *= values[i]
30
    31
    return result
32
33
def main():
34
   35
    T = int(input())
36
    37
  38
    for _ in range(T):
39
       40
        n = int(input())
41
        42
        43
        values = list(map(int, input().split()))
44
        45
        46
        result = solve_product_array(values, n)
47
        48
        49
        print("" "".join(map(str, result)))
50
51
if _name_ == ""_main_"":
52
    main()
53
54
end Solution",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833469
1387833463,h1032231291,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        Scanner scanner = new Scanner(System.in);
11
        int T = scanner.nextInt();
12
13
        for (int t = 0; t < T; t++) {
14
            int n = scanner.nextInt();
15
            int[] values = new int[n];
16
            for (int i = 0; i < n; i++) {
17
                values[i] = scanner.nextInt();
18
            }
19
20
            int[] result = new int[n];
21
            int totalProduct = 1;
22
            int zeroCount = 0;
23
24
            for (int value : values) {
25
                if (value == 0) {
26
                    zeroCount++;
27
                } else {
28
                    totalProduct *= value;
29
                }
30
            }
31
32
            for (int i = 0; i < n; i++) {
33
                if (zeroCount > 1) {
34
                    result[i] = 0;
35
                } else if (zeroCount == 1) {
36
                    if (values[i] == 0) {
37
                        result[i] = totalProduct;
38
                    } else {
39
                        result[i] = 0;
40
                    }
41
                } else {
42
                    result[i] = totalProduct / values[i];
43
                }
44
            }
45
46
            for (int i = 0; i < n; i++) {
47
                System.out.print(result[i] + "" "");
48
            }
49
            System.out.println();
50
        }
51
52
        scanner.close();
53
    }
54
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833463
1387833459,sohampatil1807,unknown,unknown,"1
with Ada.Text_IO, Ada.Integer_Text_IO;
2
use Ada;
3
4
procedure Solution is
5
-- Enter your code here. Read input from STDIN. Print output to STDOUT
6
def solve_product_array(values, n):
7
    """"""
8
    Calculate product of all elements except self for each position.
9
    Uses O(1) extra space (not counting the output array).
10
    """"""
11
   12
    if n < 2:
13
        return []
14
        15
    # Initialize result array
16
    result = [0] * n
17
    18
 19
    20
  21
    result[0] = 1
22
    for i in range(1, n):
23
        result[i] = values[i - 1] * result[i - 1]
24
    25
   26
    right_product = 1
27
    for i in range(n - 1, -1, -1):
28
        result[i] = result[i] * right_product
29
        right_product *= values[i]
30
    31
    return result
32
33
def main():
34
   35
    T = int(input())
36
    37
  38
    for _ in range(T):
39
       40
        n = int(input())
41
        42
        43
        values = list(map(int, input().split()))
44
        45
        46
        result = solve_product_array(values, n)
47
        48
        49
        print("" "".join(map(str, result)))
50
51
if _name_ == ""_main_"":
52
    main()
53
54
end Solution",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833459
1387833461,hamso2107,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833461
1387833462,h1032231317,unknown,unknown,"1
def product_except_self(t, test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        product = 1
6
        zero_count = 0
7
        for val in values:
8
            if val != 0:
9
                product *= val
10
            else:
11
                zero_count += 1
12
13
        result = []
14
        for val in values:
15
            if zero_count > 1:
16
                result.append(0)
17
            elif zero_count == 1:
18
                if val == 0:
19
                    result.append(product)
20
                else:
21
                    result.append(0)
22
            else:
23
                result.append(product // val)
24
        results.append(result)
25
    return results
26
27
def main():
28
    t = int(input())
29
    test_cases = []
30
    for _ in range(t):
31
        n = int(input())
32
        values = list(map(int, input().split()))
33
        test_cases.append((n, values))
34
35
    results = product_except_self(t, test_cases)
36
    for res in results:
37
        print("" "".join(map(str, res)))
38
39
40
if __name__ == ""__main__"":
41
    main()
42",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833462
1387833456,mahekjitu20,unknown,unknown,"1
def calculate_product_except_self(values):
2
    n = len(values)
3
    4
    # Initialize the result array
5
    result = [1] * n
6
    7
    # Step 1: Calculate products of elements to the left of each element
8
    left_product = 1
9
    for i in range(n):
10
        result[i] = left_product
11
        left_product *= values[i]
12
    13
    # Step 2: Calculate products of elements to the right of each element
14
    right_product = 1
15
    for i in range(n-1, -1, -1):
16
        result[i] *= right_product
17
        right_product *= values[i]
18
    19
    return result
20
21
# Input reading
22
t = int(input())  # Number of test cases
23
for _ in range(t):
24
    n = int(input())  # Size of the array (number of nodes)
25
    values = list(map(int, input().split()))  # Array of node values
26
    result = calculate_product_except_self(values)
27
    print(*result)  # Print the result array
28",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833456
1387833457,harshtripathi752,unknown,unknown,"1
def opEq(N, K, energy):
2
    totE = sum(energy)
3
4
    if totE % N != 0:
5
        return -1
6
    7
    tgtE = totE // N
8
    9
    if all(e == tgtE for e in energy):
10
        return 0
11
12
    operations = 0
13
    currE = energy.copy()
14
    15
    for _ in range(N):
16
        moreIterations = False
17
        18
        for i in range(N):
19
            next_i = (i + 1) % N
20
            21
            if currE[i] > tgtE:
22
                transfer = min(K, currE[i] - tgtE)
23
                if transfer == 0:
24
                    continue
25
                    26
                currE[i] -= transfer
27
                currE[next_i] += transfer
28
                operations += 1
29
                moreIterations = True
30
        31
        if all(e == tgtE for e in currE):
32
            return operations
33
            34
        if not moreIterations:
35
            return -1
36
    37
    return -1
38
39
T = int(input())
40
41
for _ in range(T):
42
    N, K = map(int, input().split())
43
    energy = list(map(int, input().split()))
44
    result = opEq(N, K, energy)
45
    46
    print(result)",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833457
1387833458,hrichamehra11,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for n, nums in test_cases:
5
        prefix_sum = [0] * n
6
        prefix_sum[0] = nums[0]
7
        for i in range(1, n):
8
            prefix_sum[i] = prefix_sum[i-1] + nums[i]
9
        10
        suffix_sum = [0] * n
11
        suffix_sum[n-1] = nums[n-1]
12
        for i in range(n-2, -1, -1):
13
            suffix_sum[i] = suffix_sum[i+1] + nums[i]
14
        15
  16
        max_diff = 0
17
        for i in range(1, n):  
18
            left_sum = prefix_sum[i-1]
19
            right_sum = suffix_sum[i]
20
            max_diff = max(max_diff, abs(left_sum - right_sum))
21
        22
        results.append(max_diff)
23
    24
    return results
25
26
27
t = int(input())
28
test_cases = []
29
for _ in range(t):
30
    n = int(input())
31
    nums = list(map(int, input().split()))
32
    test_cases.append((n, nums))
33
34
35
output = max_absolute_difference(test_cases)
36
for res in output:
37
    print(res)
38",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833458
1387833454,arpit21345j,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
long long calculateMinOperations(int N, int K, vector<int>& energy) {
7
    long long total_energy = 0;
8
    for (int e : energy) {
9
        total_energy += e;
10
    }
11
12
    if (total_energy % N != 0) {
13
        return -1;
14
    }
15
16
    long long target = total_energy / N;
17
    vector<long long> prefix(N, 0);
18
    long long operations = 0;
19
20
    for (int i = 0; i < N; ++i) {
21
        prefix[i] = (i > 0 ? prefix[i - 1] : 0) + (energy[i] - target);
22
        if (prefix[i] % K != 0) {
23
            return -1;
24
        }
25
        operations += abs(prefix[i] / K);
26
    }
27
28
    return operations;
29
}
30
31
int main() {
32
    int T;
33
    cin >> T;
34
35
    while (T--) {
36
        int N, K;
37
        cin >> N >> K;
38
        vector<int> energy(N);
39
        for (int i = 0; i < N; ++i) {
40
            cin >> energy[i];
41
        }
42
43
        long long result = calculateMinOperations(N, K, energy);
44
        cout << result << endl;
45
    }
46
47
    return 0;
48
}
49",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833454
1387833453,h1032220480,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833453
1387833455,01snehapandey01,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    t = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(t):
13
        n = int(data[idx])
14
        idx += 1
15
        nums = list(map(int, data[idx].split()))
16
        idx += 1
17
18
        # Prefix sum array
19
        prefix_sum = [0] * n
20
        prefix_sum[0] = nums[0]
21
22
        for i in range(1, n):
23
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
24
25
        total_sum = prefix_sum[-1]
26
        max_abs_diff = 0
27
28
        # Check all possible partitions
29
        for i in range(n - 1):
30
            left_sum = prefix_sum[i]
31
            right_sum = total_sum - left_sum
32
            max_abs_diff = max(max_abs_diff, abs(left_sum - right_sum))
33
34
        results.append(str(max_abs_diff))
35
36
    sys.stdout.write(""\n"".join(results) + ""\n"")
37
38
if __name__ == ""__main__"":
39
    solve_test_cases()
40",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833455
1387833452,anushanchan33,unknown,unknown,"1
def minimum_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
4
    for _ in range(t):
5
        n, k = test_cases[_]['n'], test_cases[_]['k']
6
        energy = test_cases[_]['energy']
7
8
        total_energy = sum(energy)
9
10
        # Check if equalization is possible
11
        if total_energy % n != 0:
12
            results.append(-1)
13
            continue
14
15
        target_energy = total_energy // n
16
        operations = 0
17
        current_transfer = 0
18
19
        # Calculate the operations
20
        possible = True
21
        for i in range(n):
22
            current_transfer += energy[i] - target_energy
23
            if current_transfer % k != 0:
24
                results.append(-1)
25
                possible = False
26
                break
27
            operations += abs(current_transfer) // k
28
29
        if possible:
30
            results.append(operations)
31
32
    return results
33
34
35
# Main Input/Output Code
36
if __name__ == ""__main__"":
37
    T = int(input().strip())
38
    test_cases = []
39
    for _ in range(T):
40
        n, k = map(int, input().strip().split())
41
        energy = list(map(int, input().strip().split()))
42
        test_cases.append({""n"": n, ""k"": k, ""energy"": energy})
43
44
    results = minimum_operations_to_equalize_energy(T, test_cases)
45
    for result in results:
46
        print(result)
47",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833452
1387833442,kesaragar1234,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833442
1387833444,chaussajjad,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for _ in range(t):
4
        n, nums = test_cases[_]
5
        prefix = [0] * n
6
        prefix[0] = nums[0]
7
        8
        for i in range(1, n):
9
            prefix[i] = prefix[i - 1] + nums[i]
10
        11
        total_sum = prefix[-1]
12
        max_diff = 0
13
        14
        for i in range(1, n):
15
            left_sum = prefix[i - 1]
16
            right_sum = total_sum - left_sum
17
            max_diff = max(max_diff, abs(left_sum - right_sum))
18
        19
        results.append(max_diff)
20
    return results
21
22
# Input
23
t = int(input())
24
test_cases = []
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Output
31
results = max_absolute_difference(t, test_cases)
32
for res in results:
33
    print(res)
34",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833444
1387833451,goswamyashutosh9,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        prefix = [1] * n
6
        suffix = [1] * n
7
        result = [1] * n
8
        9
        # Compute prefix products
10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] * values[i - 1]
12
        13
        # Compute suffix products
14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] * values[i + 1]
16
        17
        # Compute result array
18
        for i in range(n):
19
            result[i] = prefix[i] * suffix[i]
20
        21
        results.append(result)
22
    23
    return results
24
25
# Input Reading
26
T = int(input())
27
test_cases = []
28
for _ in range(T):
29
    n = int(input())
30
    values = list(map(int, input().split()))
31
    test_cases.append((n, values))
32
33
# Compute and Output Results
34
results = product_except_self(test_cases)
35
for res in results:
36
    print(' '.join(map(str, res)))",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833451
1387833438,shshloka,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        cumulative_diff = 0
12
        for e in energy:
13
            diff = e - target
14
            cumulative_diff += diff
15
            operations += abs(cumulative_diff)
16
        if cumulative_diff != 0:
17
            results.append(-1)
18
        else:
19
            results.append(operations // K)
20
    return results
21
22
def main():
23
    import sys
24
    input = sys.stdin.read
25
    data = input().split()
26
    idx = 0
27
    T = int(data[idx])
28
    idx += 1
29
    test_cases = []
30
    for _ in range(T):
31
        N = int(data[idx])
32
        K = int(data[idx+1])
33
        idx += 2
34
        energy = list(map(int, data[idx:idx+N]))
35
        idx += N
36
        test_cases.append((N, K, energy))
37
    results = equalize_energy(test_cases)
38
    for res in results:
39
        print(res)
40
41
if __name__ == ""__main__"":
42
    main()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833438
1387833439,yt5160359,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()
48",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833439
1387833441,akashyadv7233,unknown,unknown,"1
function processData(input) {
2
    const lines = input.trim().split(""\n"");
3
    const T = parseInt(lines[0]);
4
    const results = [];
5
    let index = 1;
6
7
    for (let t = 0; t < T; t++) {
8
        const n = parseInt(lines[index]);
9
        const values = lines[index + 1].split("" "").map(Number);
10
        index += 2;
11
12
        const result = Array(n).fill(1);
13
        const prefix = Array(n).fill(1);
14
        const suffix = Array(n).fill(1);
15
16
        for (let i = 1; i < n; i++) {
17
            prefix[i] = prefix[i - 1] * values[i - 1];
18
        }
19
20
        for (let i = n - 2; i >= 0; i--) {
21
            suffix[i] = suffix[i + 1] * values[i + 1];
22
        }
23
24
        for (let i = 0; i < n; i++) {
25
            result[i] = prefix[i] * suffix[i];
26
        }
27
28
        results.push(result.join("" ""));
29
    }
30
31
    console.log(results.join(""\n""));
32
}
33
34
// Handle standard input
35
process.stdin.resume();
36
process.stdin.setEncoding(""utf-8"");
37
let _input = """";
38
39
process.stdin.on(""data"", function (chunk) {
40
    _input += chunk;
41
});
42
43
process.stdin.on(""end"", function () {
44
    processData(_input);
45
});
46",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833441
1387833434,shubhamvirani33,unknown,unknown,"1
def product_except_self(t, test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        result = [1] * n
6
        prefix = 1
7
        for i in range(n):
8
            result[i] = prefix
9
            prefix *= values[i]
10
        suffix = 1
11
        for i in range(n - 1, -1, -1):
12
            result[i] *= suffix
13
            suffix *= values[i]
14
        results.append(result)
15
    return results
16
T = int(input())
17
test_cases = []
18
for _ in range(T):
19
    n = int(input())
20
    values = list(map(int, input().split()))
21
    test_cases.append((n, values))
22
output = product_except_self(T, test_cases)
23
for res in output:
24
    print("" "".join(map(str, res)))",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833434
1387833437,h1032220703,unknown,unknown,"1
import java.util.*;
2
3
public class PowerStationEqualizer {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
7
        // Read number of test cases
8
        int T = scanner.nextInt();
9
10
        for (int t = 0; t < T; t++) {
11
            // Read N and K
12
            int N = scanner.nextInt();
13
            int K = scanner.nextInt();
14
15
            // Read energy levels
16
            int[] energy = new int[N];
17
            long totalEnergy = 0;
18
            for (int i = 0; i < N; i++) {
19
                energy[i] = scanner.nextInt();
20
                totalEnergy += energy[i];
21
            }
22
23
            // Check if equal distribution is possible
24
            if (totalEnergy % N != 0) {
25
                System.out.println(-1);
26
                continue;
27
            }
28
29
            long targetEnergy = totalEnergy / N;
30
            long operations = 0;
31
            long balance = 0; // Net balance carried over stations
32
33
            for (int i = 0; i < N; i++) {
34
                long diff = energy[i] - targetEnergy;
35
                balance += diff;
36
37
                // Check if balance can be corrected in K-unit operations
38
                if (K == 0 || balance % K != 0) {
39
                    System.out.println(-1);
40
                    break;
41
                }
42
43
                operations += Math.abs(balance / K);
44
45
                if (i == N - 1) {
46
                    System.out.println(operations);
47
                }
48
            }
49
        }
50
51
        scanner.close();
52
    }
53
}
54",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833437
1387833435,h1032221618,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833435
1387833432,rahulpurohitrp71,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
3
    results = []
4
5
    6
7
    for t in test_cases:
8
9
        N, K, energy = t
10
11
        total_energy = sum(energy)
12
13
        14
15
        # Check if equalization is possible
16
17
        if total_energy % N != 0:
18
19
            results.append(-1)
20
21
            continue
22
23
        24
25
        target = total_energy // N
26
27
        diffs = [energy[i] - target for i in range(N)]
28
29
        30
31
        # Check if all differences are divisible by K
32
33
        if any(diff % K != 0 for diff in diffs):
34
35
            results.append(-1)
36
37
            continue
38
39
        40
41
        # Calculate minimum operations
42
43
        operations = 0
44
45
        imbalance = 0
46
47
        48
49
        for diff in diffs:
50
51
            imbalance += diff // K
52
53
            operations += abs(imbalance)
54
55
        56
57
        results.append(operations)
58
59
    60
61
    return results
62
63
# Input handling
64
65
T = int(input())
66
67
test_cases = []
68
69
for _ in range(T):
70
71
    N, K = map(int, input().split())
72
73
    energy = list(map(int, input().split()))
74
75
    test_cases.append((N, K, energy))
76
77
# Compute results
78
79
results = minimum_operations_to_equalize(test_cases)
80
81
# Output results
82
83
for res in results:
84
85
    print(res)",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833432
1387833429,navinbohara5,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
   5
    if total_energy % N != 0:
6
        return -1
7
8
    target = total_energy // N  
9
    operations = 0
10
    balance = 0
11
12
   13
    for i in range(N):
14
        diff = energy[i] - target  
15
        balance += diff  
16
        17
        18
        if balance % K != 0:
19
            return -1
20
21
        operations += abs(balance) // K  
22
    23
    return operations
24
25
26
T = int(input())  
27
for _ in range(T):
28
    N, K = map(int, input().split())  
29
    energy = list(map(int, input().split()))  
30
    31
    32
    print(min_operations_to_equalize(N, K, energy))
33",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833429
1387833430,tanishqsatote369,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int findMaxDifference(vector<int>& nums) {
9
    int n = nums.size();
10
    if (n < 2) return 0;
11
    12
    // Calculate prefix sums for efficient subarray sum computation
13
    vector<long long> prefixSum(n + 1, 0);
14
    for (int i = 0; i < n; i++) {
15
        prefixSum[i + 1] = prefixSum[i] + nums[i];
16
    }
17
    18
    // Try all possible partition points to find maximum difference
19
    long long maxDiff = 0;
20
    // We need at least one element in each partition
21
    for (int i = 1; i < n; i++) {
22
        // Left subarray sum: from 0 to i-1
23
        long long leftSum = prefixSum[i] - prefixSum[0];
24
        // Right subarray sum: from i to n-1
25
        long long rightSum = prefixSum[n] - prefixSum[i];
26
        27
        // Calculate absolute difference
28
        long long diff = abs(leftSum - rightSum);
29
        maxDiff = max(maxDiff, diff);
30
    }
31
    32
    return maxDiff;
33
}
34
35
int main() {
36
    int t;
37
    cin >> t;
38
    39
    while (t--) {
40
        int n;
41
        cin >> n;
42
        43
        vector<int> nums(n);
44
        for (int i = 0; i < n; i++) {
45
            cin >> nums[i];
46
        }
47
        48
        cout << findMaxDifference(nums) << endl;
49
    }
50
    51
    return 0;
52
}
53
54
55
56",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833430
1387833431,aayushkrishnaut,unknown,unknown,"1
def max_subarray_difference(arr, n):
2
    # Calculate prefix sums array
3
    prefix_sum = [0] * (n + 1)
4
    for i in range(n):
5
        prefix_sum[i + 1] = prefix_sum[i] + arr[i]
6
    7
    max_diff = float('-inf')
8
    9
    # Try all possible partition points
10
    # For each partition point i, 
11
    # left subarray is [0:i] and right subarray is [i:n]
12
    for i in range(1, n):
13
        # Use prefix sums to get subarray sums in O(1)
14
        left_sum = prefix_sum[i] - prefix_sum[0]  # sum of arr[0:i]
15
        right_sum = prefix_sum[n] - prefix_sum[i]  # sum of arr[i:n]
16
        17
        # Calculate absolute difference
18
        diff = abs(left_sum - right_sum)
19
        max_diff = max(max_diff, diff)
20
    21
    return max_diff
22
23
def solve():
24
    # Read number of test cases
25
    t = int(input())
26
    27
    for _ in range(t):
28
        # Read array size
29
        n = int(input())
30
        31
        # Read array elements
32
        nums = list(map(int, input().split()))
33
        34
        # Calculate and print result
35
        result = max_subarray_difference(nums, n)
36
        print(result)
37
38
if __name__ == ""__main__"":
39
    solve()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833431
1387833427,nishashetty1002,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        N, K = map(int, input().split())
5
        energy = list(map(int, input().split()))
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            print(-1)
11
            continue
12
        13
        target_energy = total_energy // N
14
        operations = 0
15
        current_balance = 0
16
        17
        for i in range(N):
18
            current_balance += energy[i] - target_energy
19
            operations += abs(current_balance) // K
20
            21
            if abs(current_balance) % K != 0:
22
                operations = -1
23
                break
24
        25
        print(operations)
26
27
solve()
28",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833427
1387833428,codedemon1426,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    energies = list(map(int, input().split()))
4
5
    total_energy = sum(energies)
6
    if total_energy % n != 0:
7
        print(-1)
8
        return
9
10
    target_energy = total_energy // n
11
    diff = [energies[i] - target_energy for i in range(n)]
12
    c_diff = [0] * n
13
    c_diff[0] = 0
14
    for i in range(1, n):
15
        c_diff[i] = c_diff[i-1] + diff[i-1]
16
17
    operations = 0
18
    for i in range(1, n):
19
        if c_diff[i] % k != 0:
20
            print(-1)
21
            return
22
        operations += abs(c_diff[i]) // k
23
24
    print(operations)
25
26
27
t = int(input())
28
for _ in range(t):
29
    solve()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833428
1387833426,singhark94,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
using namespace std;
5
6
long long minOperations(int N, int K, vector<int>& energy) {
7
    long long totalEnergy = accumulate(energy.begin(), energy.end(), 0LL);
8
9
    // Step 1: Check if equalization is possible
10
    if (totalEnergy % N != 0) return -1;
11
    long long target = totalEnergy / N;
12
13
    vector<long long> diff(N, 0);
14
    long long cumulativeSum = 0, operations = 0;
15
16
    // Step 2: Compute the difference array and validate transfers
17
    for (int i = 0; i < N; ++i) {
18
        diff[i] = energy[i] - target;
19
        cumulativeSum += diff[i];
20
21
        // Instead of direct modulus check, we check if each step can transfer using K
22
        if (cumulativeSum % K != 0) return -1;
23
24
        // Step 3: Count the moves needed for balancing
25
        operations += abs(cumulativeSum) / K;
26
    }
27
28
    return operations;
29
}
30
31
int main() {
32
    int T;
33
    cin >> T;
34
35
    while (T--) {
36
        int N, K;
37
        cin >> N >> K;
38
        vector<int> energy(N);
39
        for (int i = 0; i < N; ++i) {
40
            cin >> energy[i];
41
        }
42
43
        cout << minOperations(N, K, energy) << endl;
44
    }
45
46
    return 0;
47
}
48
49",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833426
1387833423,guptashrey856,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
    # Compute the prefix sum array
5
    prefix_sum = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
8
    9
    max_diff = 0
10
    11
    # Iterate through all possible split points
12
    for i in range(1, n):
13
        left_sum = prefix_sum[i]
14
        right_sum = prefix_sum[n] - prefix_sum[i]
15
        current_diff = abs(left_sum - right_sum)
16
        17
        # Update the maximum difference
18
        if current_diff > max_diff:
19
            max_diff = current_diff
20
    21
    return max_diff
22
23
def main():
24
    import sys
25
    input = sys.stdin.read
26
    data = input().split()
27
    28
    idx = 0
29
    t = int(data[idx])  # Number of test cases
30
    idx += 1
31
    32
    for _ in range(t):
33
        n = int(data[idx])  # Size of the array
34
        idx += 1
35
        nums = list(map(int, data[idx:idx + n]))  # Array elements
36
        idx += n
37
        38
        result = max_absolute_difference(nums)
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833423
1387833424,sahilgupta75070,unknown,unknown,"1
def solve():
2
    t = int(input())  # Number of test cases
3
    4
    for _ in range(t):
5
        n = int(input())  # Size of the array
6
        nums = list(map(int, input().split()))  # The array
7
        8
        total_sum = sum(nums)
9
        prefix_sum = 0
10
        max_diff = 0
11
        12
        # Iterate to find the maximum absolute difference
13
        for i in range(n - 1):  # We stop at n-1 because the partition must be between two subarrays
14
            prefix_sum += nums[i]
15
            diff = abs(2 * prefix_sum - total_sum)
16
            max_diff = max(max_diff, diff)
17
        18
        print(max_diff)
19
20
# Call the solve function to process the input and produce the output
21
solve()
22
23",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833424
1387833425,snehakumari2323,unknown,unknown,"1
def solve_testcase(n, values):
2
    # Initialize result array
3
    result = [1] * n
4
    5
    # Calculate prefix products
6
    # result[i] will first store product of all elements to the left of i
7
    prefix = 1
8
    for i in range(n):
9
        result[i] = prefix
10
        prefix *= values[i]
11
    12
    # Calculate suffix products and combine with prefix products
13
    # For each position, multiply its prefix product with suffix product
14
    suffix = 1
15
    for i in range(n-1, -1, -1):
16
        result[i] *= suffix
17
        suffix *= values[i]
18
    19
    return result
20
21
def main():
22
    # Read number of test cases
23
    T = int(input())
24
    25
    # Process each test case
26
    for _ in range(T):
27
        # Read input for current test case
28
        n = int(input())
29
        values = list(map(int, input().split()))
30
        31
        # Solve current test case
32
        result = solve_testcase(n, values)
33
        34
        # Print result
35
        print(*result)
36
37
if __name__ == ""__main__"":  # Fixed the typo here
38
    main()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833425
1387833422,shwetankrai0710,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
    5
    # Calculate the product of all elements to the left of each index
6
    left_product = 1
7
    for i in range(n):
8
        result[i] = left_product
9
        left_product *= values[i]
10
    11
    # Calculate the product of all elements to the right of each index and multiply with the left product
12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    return result
18
19
def main():
20
    import sys
21
    input = sys.stdin.read
22
    data = input().split()
23
    24
    idx = 0
25
    T = int(data[idx])
26
    idx += 1
27
    28
    for _ in range(T):
29
        n = int(data[idx])
30
        idx += 1
31
        values = list(map(int, data[idx:idx+n]))
32
        idx += n
33
        34
        result = product_except_self(values)
35
        print(' '.join(map(str, result)))
36
37
if __name__ == ""__main__"":
38
    main()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833422
1387833416,shuklajaikishan1,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        left_sum = 0
7
        max_diff = 0
8
        for i in range(n - 1):
9
            left_sum += nums[i]
10
            right_sum = total_sum - left_sum
11
            max_diff = max(max_diff, abs(left_sum - right_sum))
12
        results.append(max_diff)
13
    return results
14
15
16
t = int(input())
17
test_cases = []
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    test_cases.append((n, nums))
22
23
results = max_absolute_difference(test_cases)
24
for res in results:
25
    print(res)
26
    ",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833416
1387833418,prashant_ps9833,unknown,unknown,"1
def min_operations_to_equalize_energy(test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, k, energy = case
6
        total_energy = sum(energy)
7
        8
        if total_energy % n != 0:
9
            results.append(-1)
10
            continue
11
        12
        target_energy = total_energy // n
13
        diffs = [energy[i] - target_energy for i in range(n)]
14
        15
        if any(abs(diff) % k != 0 for diff in diffs):
16
            results.append(-1)
17
            continue
18
19
        operations = 0
20
        balance = 0  
21
        for diff in diffs:
22
            balance += diff // k
23
            operations += abs(balance)
24
        25
        results.append(operations)
26
    27
    return results
28
29
T = int(input()) 
30
test_cases = []
31
32
for _ in range(T):
33
    n, k = map(int, input().split())  
34
    energy = list(map(int, input().split()))  
35
    test_cases.append((n, k, energy))
36
37
for result in min_operations_to_equalize_energy(test_cases):
38
    print(result)",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833418
1387833420,aditya_jha027,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K, energy = case['N'], case['K'], case['energy']
6
        total_energy = sum(energy)
7
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
12
        target = total_energy // N
13
        differences = [(e - target) for e in energy]
14
15
        if any(diff % K != 0 for diff in differences):
16
            results.append(-1)
17
            continue
18
19
        cumulative_sum = 0
20
        operations = 0
21
22
        for diff in differences:
23
            cumulative_sum += diff // K
24
            operations += abs(cumulative_sum)
25
26
        results.append(operations)
27
28
    return results
29
30
def parse_input():
31
    T = int(input())
32
    test_cases = []
33
34
    for _ in range(T):
35
        N, K = map(int, input().split())
36
        energy = list(map(int, input().split()))
37
        test_cases.append({""N"": N, ""K"": K, ""energy"": energy})
38
39
    return test_cases
40
41
def main():
42
    test_cases = parse_input()
43
    results = minimum_operations(test_cases)
44
    for res in results:
45
        print(res)
46
47
if __name__ == ""__main__"":
48
    main()
49",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833420
1387833414,h1032220403,unknown,unknown,"1
def min_operations_to_equalize_energy(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, k, energy = case
6
7
        total_energy = sum(energy)
8
        if total_energy % n != 0:
9
            # If total energy is not divisible by n, equalization is impossible
10
            results.append(-1)
11
            continue
12
13
        target_energy = total_energy // n
14
        balance = 0
15
        operations = 0
16
17
        for e in energy:
18
            balance += e - target_energy
19
            if balance % k != 0:
20
                results.append(-1)
21
                break
22
            operations += abs(balance) // k
23
        else:
24
            results.append(operations)
25
26
    return results
27
28
# Input
29
T = int(input())
30
test_cases = []
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    energy = list(map(int, input().split()))
34
    test_cases.append((n, k, energy))
35
36
# Process
37
results = min_operations_to_equalize_energy(test_cases)
38
39
# Output
40
for result in results:
41
    print(result)
42",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833414
1387833415,h1032220108,unknown,unknown,"1
def can_equalize(N, K, energy):
2
    total = sum(energy)
3
    if total % N != 0: 
4
        return -1
5
    6
    target = total // N
7
8
    diff = [e - target for e in energy]
9
    10
    # If already equalized
11
    if all(d == 0 for d in diff):
12
        return 0
13
    pos_sum = sum(d for d in diff if d > 0)
14
    for d in diff:
15
        if d != 0 and abs(d) % K != 0:
16
            return -1
17
    return pos_sum // K
18
19
def main():
20
    T = int(input())
21
    for _ in range(T):
22
        N, K = map(int, input().split())
23
        energy = list(map(int, input().split()))
24
        print(can_equalize(N, K, energy))
25
26
if __name__ == ""__main__"":
27
    main()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833415
1387833411,paragchaudhary_1,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
    7
    for i in range(1, n):
8
        left[i] = left[i-1] * arr[i-1]
9
10
    11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * arr[i+1]
13
14
   15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
20
t = int(input())
21
22
for _ in range(t):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result)",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833411
1387833405,prathameshbhoit1,unknown,unknown,"1
def minimum_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
    for i in range(t):  # Changed _ to i to properly index test_cases
4
        n, k = test_cases[i]['n'], test_cases[i]['k']  # Fixed indexing
5
        energy = test_cases[i]['energy']  # Fixed indexing
6
        7
        # Calculate total and target energy
8
        total_energy = sum(energy)
9
        if total_energy % n != 0:
10
            results.append(-1)
11
            continue
12
            13
        target_energy = total_energy // n
14
        operations = 0
15
        current_transfer = 0
16
        17
        # Check each station
18
        for j in range(n):
19
            current_transfer += energy[j] - target_energy
20
            if current_transfer % k != 0:
21
                results.append(-1)
22
                break
23
            operations += abs(current_transfer) // k
24
        else:
25
            results.append(operations)
26
            27
    return results
28
29
# Input processing
30
T = int(input().strip())
31
test_cases = []
32
for _ in range(T):
33
    n, k = map(int, input().strip().split())
34
    energy = list(map(int, input().strip().split()))
35
    test_cases.append({""n"": n, ""k"": k, ""energy"": energy})
36
37
# Get and print results
38
results = minimum_operations_to_equalize_energy(T, test_cases)
39
for result in results:
40
    print(result)",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833405
1387833410,h1032220149,unknown,unknown,"1
import java.util.*;
2
3
public class EqualizeEnergy {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt();
8
9
        for (int i = 0; i < T; i++) {
10
            int N = scanner.nextInt();
11
            int K = scanner.nextInt();
12
            int[] energy = new int[N];
13
14
            for (int j = 0; j < N; j++) {
15
                energy[j] = scanner.nextInt();
16
            }
17
18
            int minOperations = findMinOperations(energy, K);
19
            System.out.println(minOperations);
20
        }
21
    }
22
23
    public static int findMinOperations(int[] energy, int K) {
24
        int N = energy.length;
25
        int totalEnergy = 0;
26
27
        // Calculate total energy
28
        for (int i = 0; i < N; i++) {
29
            totalEnergy += energy[i];
30
        }
31
32
        // Check if equal distribution is possible
33
        if (totalEnergy % N != 0) {
34
            return -1; // Equalization is not possible
35
        }
36
37
        int targetEnergy = totalEnergy / N;
38
        int operations = 0;
39
40
        // Adjust energy levels to the target
41
        for (int i = 0; i < N; i++) {
42
            int diff = energy[i] - targetEnergy;
43
            if (diff > 0) {
44
                operations += Math.abs(diff) / K;
45
                if (Math.abs(diff) % K != 0) {
46
                    operations++;
47
                }
48
            }
49
        }
50
51
        return operations;
52
    }
53
}",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833410
1387833409,kadamaryan21418,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    """"""
3
    Calculate minimum operations needed to equalize energy across stations.
4
    Returns -1 if impossible.
5
    """"""
6
    # Calculate total energy and check if equalization is possible
7
    total_energy = sum(energy)
8
    if total_energy % N != 0:
9
        return -1
10
        11
    target = total_energy // N
12
    13
    # If already equalized
14
    if all(e == target for e in energy):
15
        return 0
16
    17
    # Calculate needed transfers and check if possible
18
    operations = 0
19
    excess = 0  # Track running excess/deficit
20
    21
    for i in range(N):
22
        # Add current station's excess/deficit to running total
23
        excess += energy[i] - target
24
        25
        # If excess can't be transferred using K-unit operations
26
        if abs(excess) % K != 0:
27
            return -1
28
            29
        if excess != 0:
30
            operations += abs(excess) // K
31
    32
    # Check if we ended with zero excess (balanced transfers)
33
    if excess != 0:
34
        return -1
35
        36
    return operations
37
38
def main():
39
    T = int(input())
40
    for _ in range(T):
41
        N, K = map(int, input().split())
42
        energy = list(map(int, input().split()))
43
        print(min_operations_to_equalize(N, K, energy))
44
45
if __name__ == ""__main__"":
46
    main()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833409
1387833403,cooljaychaudhary,unknown,unknown,"1
def product_except_self():
2
    # Reading number of test cases
3
    T = int(input())
4
    results = []
5
    6
    for _ in range(T):
7
        # Read the size of the array
8
        n = int(input())
9
        # Read the values of the nodes
10
        values = list(map(int, input().split()))
11
        12
        # Initialize the result array
13
        result = [1] * n
14
        15
        # Compute prefix products
16
        prefix = 1
17
        for i in range(n):
18
            result[i] = prefix
19
            prefix *= values[i]
20
        21
        # Compute suffix products and combine with prefix
22
        suffix = 1
23
        for i in range(n - 1, -1, -1):
24
            result[i] *= suffix
25
            suffix *= values[i]
26
        27
        # Store the result for this test case
28
        results.append("" "".join(map(str, result)))
29
    30
    # Print all results
31
    print(""\n"".join(results))
32
33
# Call the function
34
product_except_self()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833403
1387833394,rahulpurohitrp71,unknown,unknown,"1
def product_except_self(test_cases):
2
3
    results = []
4
5
    6
7
    for t in test_cases:
8
9
        n, values = t
10
11
        prefix = [1] * n
12
13
        suffix = [1] * n
14
15
        result = [0] * n
16
17
        18
19
        # Compute prefix products
20
21
        for i in range(1, n):
22
23
            prefix[i] = prefix[i - 1] * values[i - 1]
24
25
        26
27
        # Compute suffix products
28
29
        for i in range(n - 2, -1, -1):
30
31
            suffix[i] = suffix[i + 1] * values[i + 1]
32
33
        34
35
        # Compute result using prefix and suffix
36
37
        for i in range(n):
38
39
            result[i] = prefix[i] * suffix[i]
40
41
        42
43
        results.append(result)
44
45
    46
47
    return results
48
49
# Input handling
50
51
T = int(input())
52
53
test_cases = []
54
55
for _ in range(T):
56
57
    n = int(input())
58
59
    values = list(map(int, input().split()))
60
61
    test_cases.append((n, values))
62
63
# Compute results
64
65
results = product_except_self(test_cases)
66
67
# Output results
68
69
for res in results:
70
71
    print("" "".join(map(str, res)))",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833394
1387833397,dishug2409,unknown,unknown,"1
def max_abs_difference(n, nums):
2
    # Calculate prefix sums
3
    prefix_sum = [0] * n
4
    prefix_sum[0] = nums[0]
5
    for i in range(1, n):
6
        prefix_sum[i] = prefix_sum[i - 1] + nums[i]
7
8
    total_sum = prefix_sum[-1]
9
    max_difference = 0
10
11
    # Iterate through all possible partitions
12
    for i in range(n - 1):
13
        left_sum = prefix_sum[i]
14
        right_sum = total_sum - left_sum
15
        max_difference = max(max_difference, abs(left_sum - right_sum))
16
17
    return max_difference
18
19
# Input handling
20
t = int(input())  # Number of test cases
21
results = []
22
for _ in range(t):
23
    n = int(input())  # Size of the array
24
    nums = list(map(int, input().split()))
25
    results.append(max_abs_difference(n, nums))
26
27
# Output results
28
for result in results:
29
    print(result)
30",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833397
1387833401,h1032221613,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833401
1387833390,h1032220480,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833390
1387833392,Gayathripoojary1,unknown,unknown,"1
def solve():
2
  3
    T = int(input())
4
5
   6
    for _ in range(T):
7
       8
        n = int(input())
9
10
       11
        values = list(map(int, input().split()))
12
13
     14
        result = [1] * n
15
16
        17
        left_product = 1
18
        for i in range(n):
19
            result[i] = left_product
20
            left_product *= values[i]
21
22
     23
        right_product = 1
24
        for i in range(n-1, -1, -1):
25
            result[i] *= right_product
26
            right_product *= values[i]
27
28
       29
        print("" "".join(map(str, result)))
30
31
32
solve()",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833392
1387833393,codedemon1426,unknown,unknown,"1
def solve():
2
    n = int(input())
3
    values = list(map(int, input().split()))
4
5
    result = [0] * n
6
7
    for i in range(n):
8
        product = 1
9
        for j in range(n):
10
            if i != j:
11
                product *= values[j]
12
        result[i] = product
13
14
    print(*result)
15
16
17
t = int(input())
18
for _ in range(t):
19
    solve()",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833393
1387833386,h1032220507,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833386
1387833385,amanpandey9295,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
#include <math.h>
4
5
// Function to calculate the maximum absolute difference
6
int maxAbsoluteDifference(int n, int *nums) {
7
    long long total_sum = 0;
8
    long long left_sum = 0;
9
    long long max_diff = 0;
10
11
    // Calculate the total sum of the array
12
    for (int i = 0; i < n; i++) {
13
        total_sum += nums[i];
14
    }
15
16
    // Iterate through the array to calculate the maximum absolute difference
17
    for (int i = 0; i < n - 1; i++) {
18
        left_sum += nums[i];
19
        long long right_sum = total_sum - left_sum;
20
21
        // Calculate the absolute difference
22
        long long diff = llabs(left_sum - right_sum);
23
24
        // Update the maximum difference
25
        if (diff > max_diff) {
26
            max_diff = diff;
27
        }
28
    }
29
30
    return max_diff;
31
}
32
33
int main() {
34
    int t;
35
    scanf(""%d"", &t); // Number of test cases
36
37
    while (t--) {
38
        int n;
39
        scanf(""%d"", &n); // Size of the array
40
41
        int *nums = (int *)malloc(n * sizeof(int));
42
        for (int i = 0; i < n; i++) {
43
            scanf(""%d"", &nums[i]); // Array elements
44
        }
45
46
        // Calculate and print the result for the current test case
47
        printf(""%d\n"", maxAbsoluteDifference(n, nums));
48
49
        free(nums);
50
    }
51
52
    return 0;
53
}
54
55",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833385
1387833388,ssidd9770,unknown,unknown,"1
def compute_product_excluding_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        total_product = 1
6
        zero_count = values.count(0)
7
8
        if zero_count > 1:
9
            results.append([0] * n)
10
        elif zero_count == 1:
11
            zero_index = values.index(0)
12
            product_except_zero = 1
13
            for i in range(n):
14
                if i != zero_index:
15
                    product_except_zero *= values[i]
16
            result = [0] * n
17
            result[zero_index] = product_except_zero
18
            results.append(result)
19
        else:
20
            for value in values:
21
                total_product *= value
22
            results.append([total_product // value for value in values])
23
24
    return results
25
26
T = int(input())
27
test_cases = [(int(input()), list(map(int, input().split()))) for _ in range(T)]
28
results = compute_product_excluding_self(test_cases)
29
for result in results:
30
    print(*result)
31",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833388
1387833382,h1032221506,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target_energy = total_energy // N
8
    operations = 0
9
    10
    for i in range(N):
11
        diff = energy[i] - target_energy
12
        13
        if diff % K != 0:
14
            return -1
15
        16
        if diff != 0:
17
            operations += abs(diff) // K
18
            energy[(i + 1) % N] += diff
19
    20
    return operations
21
22
def main():
23
    T = int(input())
24
    25
    for _ in range(T):
26
        N, K = map(int, input().split())
27
        energy = list(map(int, input().split()))
28
        29
        result = min_operations_to_equalize(N, K, energy)
30
        print(result)
31
32
main()
33",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833382
1387833379,manjesht78,unknown,unknown,"1
def min_operations_to_equalize_energy(test_cases):
2
    results = []
3
    for N, K, energies in test_cases:
4
        total_energy = sum(energies)
5
        if total_energy % N != 0:
6
            results.append(-1)
7
            continue
8
        9
        target_energy = total_energy // N
10
        operations = 0
11
        current_balance = 0
12
        13
        for energy in energies:
14
            current_balance += (energy - target_energy)
15
            if current_balance % K != 0:
16
                operations = -1
17
                break
18
            operations += abs(current_balance) // K
19
        20
        results.append(operations if operations != -1 else -1)
21
    22
    return results
23
24
try:
25
    T = int(input())
26
except EOFError:
27
    print(""No input provided."")
28
    T = 0
29
30
test_cases = []
31
for _ in range(T):
32
    N, K = map(int, input().split())
33
    energies = list(map(int, input().split()))
34
    test_cases.append((N, K, energies))
35
36
results = min_operations_to_equalize_energy(test_cases)
37
for result in results:
38
    print(result)",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833379
1387833380,h1032220872,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int findMaxDifference(vector<int>& nums) {
9
    int n = nums.size();
10
    if (n < 2) return 0;
11
    12
    // Calculate prefix sums for efficient subarray sum computation
13
    vector<long long> prefixSum(n + 1, 0);
14
    for (int i = 0; i < n; i++) {
15
        prefixSum[i + 1] = prefixSum[i] + nums[i];
16
    }
17
    18
    // Try all possible partition points to find maximum difference
19
    long long maxDiff = 0;
20
    // We need at least one element in each partition
21
    for (int i = 1; i < n; i++) {
22
        // Left subarray sum: from 0 to i-1
23
        long long leftSum = prefixSum[i] - prefixSum[0];
24
        // Right subarray sum: from i to n-1
25
        long long rightSum = prefixSum[n] - prefixSum[i];
26
        27
        // Calculate absolute difference
28
        long long diff = abs(leftSum - rightSum);
29
        maxDiff = max(maxDiff, diff);
30
    }
31
    32
    return maxDiff;
33
}
34
35
int main() {
36
    int t;
37
    cin >> t;
38
    39
    while (t--) {
40
        int n;
41
        cin >> n;
42
        43
        vector<int> nums(n);
44
        for (int i = 0; i < n; i++) {
45
            cin >> nums[i];
46
        }
47
        48
        cout << findMaxDifference(nums) << endl;
49
    }
50
    51
    return 0;
52
}
53",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833380
1387833381,dhuvesh_salian,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833381
1387833377,laxmimehta0506,unknown,unknown,"1
import java.util.Scanner;
2
3
public class EnergyEqualization {
4
    5
    public static int minOperations(int N, int K, int[] energy) {
6
        // Step 1: Calculate total energy
7
        long totalEnergy = 0;
8
        for (int e : energy) {
9
            totalEnergy += e;
10
        }
11
12
        // Step 2: If the total energy is not divisible by N, return -1
13
        if (totalEnergy % N != 0) {
14
            return -1;
15
        }
16
17
        // Step 3: Calculate the target energy per station
18
        long target = totalEnergy / N;
19
20
        // Step 4: Track the cumulative balance and the operations
21
        long currentBalance = 0;
22
        int operations = 0;
23
24
        // Step 5: Iterate over each station
25
        for (int i = 0; i < N; i++) {
26
            // Calculate the difference between current energy and target
27
            long diff = energy[i] - target;
28
            29
            // Add the difference to the cumulative balance
30
            currentBalance += diff;
31
            32
            // If the current balance is not divisible by K, return -1
33
            if (currentBalance % K != 0) {
34
                return -1;
35
            }
36
37
            // Increment the operation count by the absolute value of the balance divided by K
38
            operations += Math.abs(currentBalance / K);
39
        }
40
41
        return operations;
42
    }
43
    44
    public static void main(String[] args) {
45
        Scanner sc = new Scanner(System.in);
46
        int T = sc.nextInt(); // Number of test cases
47
        48
        while (T-- > 0) {
49
            int N = sc.nextInt(); // Number of stations
50
            int K = sc.nextInt(); // Energy transfer in one operation
51
            int[] energy = new int[N];
52
            53
            for (int i = 0; i < N; i++) {
54
                energy[i] = sc.nextInt();
55
            }
56
            57
            // Get the result for the current test case
58
            int result = minOperations(N, K, energy);
59
            System.out.println(result);
60
        }
61
        62
        sc.close();
63
    }
64
}
65",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833377
1387833376,h1032220685,unknown,unknown,"1
with Ada.Text_IO; use Ada.Text_IO;
2
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
3
4
procedure Product_Except_Self is
5
   type Int_Array is array (Positive range <>) of Integer;
6
7
   -- Function to calculate the product array except self
8
   function Compute_Products (Values : Int_Array; N : Integer) return Int_Array is
9
      Prefix  : Int_Array (1 .. N) := (others => 1);
10
      Suffix  : Int_Array (1 .. N) := (others => 1);
11
      Result  : Int_Array (1 .. N) := (others => 0);
12
   begin
13
      -- Calculate Prefix products
14
      for I in 2 .. N loop
15
         Prefix(I) := Prefix(I - 1) * Values(I - 1);
16
      end loop;
17
18
      -- Calculate Suffix products
19
      for I in reverse 1 .. N - 1 loop
20
         Suffix(I) := Suffix(I + 1) * Values(I + 1);
21
      end loop;
22
23
      -- Compute result using Prefix and Suffix
24
      for I in 1 .. N loop
25
         Result(I) := Prefix(I) * Suffix(I);
26
      end loop;
27
28
      return Result;
29
   end Compute_Products;
30
31
   -- Main block for input and processing test cases
32
   T : Integer;
33
begin
34
   -- Input the number of test cases
35
   Get(T);
36
37
   for Test in 1 .. T loop
38
      declare
39
         N      : Integer;
40
         Values : Int_Array (1 .. 100_000);
41
      begin
42
         -- Input the size of the array
43
         Get(N);
44
45
         -- Read the values
46
         for I in 1 .. N loop
47
            Get(Values(I));
48
         end loop;
49
50
         -- Compute the result
51
         declare
52
            Result : Int_Array (1 .. N) := Compute_Products(Values, N);
53
         begin
54
            -- Print the result in the required format
55
            for I in 1 .. N loop
56
               if I > 1 then
57
                  Put("" ""); -- Add a space before every number except the first
58
               end if;
59
               declare
60
                  Image : String := Integer'Image(Result(I)); -- Get string representation
61
               begin
62
                  Put(Image(Image'First + 1 .. Image'Last)); -- Remove leading space
63
               end;
64
            end loop;
65
            New_Line;
66
         end;
67
      end;
68
   end loop;
69
end Product_Except_Self;
70",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833376
1387833378,h1032221771,unknown,unknown,"1
def max_abs_diff_partition(t, test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        prefix_sum = 0
7
        max_diff = 0
8
9
10
        for i in range(n - 1):  
11
            prefix_sum += nums[i]
12
            suffix_sum = total_sum - prefix_sum
13
            diff = abs(prefix_sum - suffix_sum)
14
            max_diff = max(max_diff, diff)
15
16
        results.append(max_diff)
17
18
    return results
19
20
t = int(input())  
21
test_cases = []
22
for _ in range(t):
23
    n = int(input())  
24
    nums = list(map(int, input().split()))  
25
    test_cases.append((n, nums))
26
27
results = max_abs_diff_partition(t, test_cases)
28
for result in results:
29
    print(result)
30",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833378
1387833372,cooljaychaudhary,unknown,unknown,"1
def product_except_self():
2
    # Reading number of test cases
3
    T = int(input())
4
    results = []
5
    6
    for _ in range(T):
7
        # Read the size of the array
8
        n = int(input())
9
        # Read the values of the nodes
10
        values = list(map(int, input().split()))
11
        12
        # Initialize the result array
13
        result = [1] * n
14
        15
        # Compute prefix products
16
        prefix = 1
17
        for i in range(n):
18
            result[i] = prefix
19
            prefix *= values[i]
20
        21
        # Compute suffix products and combine with prefix
22
        suffix = 1
23
        for i in range(n - 1, -1, -1):
24
            result[i] *= suffix
25
            suffix *= values[i]
26
        27
        # Store the result for this test case
28
        results.append("" "".join(map(str, result)))
29
    30
    # Print all results
31
    print(""\n"".join(results))
32
33
# Call the function
34
product_except_self()",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833372
1387833375,sujalnegi421,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        left_sum = 0
7
        max_diff = 0
8
        for i in range(n - 1):
9
            left_sum += nums[i]
10
            right_sum = total_sum - left_sum
11
            max_diff = max(max_diff, abs(left_sum - right_sum))
12
        results.append(max_diff)
13
    return results
14
15
16
t = int(input())
17
test_cases = []
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    test_cases.append((n, nums))
22
23
results = max_absolute_difference(test_cases)
24
for res in results:
25
    print(res)",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833375
1387833373,jheelj86,unknown,unknown,"1
def solve_testcase(n, values):
2
3
    result = [1] * n
4
    5
6
    prefix = 1
7
    for i in range(n):
8
        result[i] = prefix
9
        prefix *= values[i]
10
11
    suffix = 1
12
    for i in range(n-1, -1, -1):
13
        result[i] *= suffix
14
        suffix *= values[i]
15
    16
    return result
17
18
def main():
19
    20
    T = int(input())
21
    22
 23
    for _ in range(T):
24
        25
        n = int(input())
26
        values = list(map(int, input().split()))
27
        28
    29
        result = solve_testcase(n, values)
30
        31
        print(*result)
32
33
if __name__ == ""__main__"":
34
    main()
35",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833373
1387833371,harsh_singh26011,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
using namespace std;
5
6
class Solution {
7
public:
8
    int minOperationsToEqualize(int N, int K, vector<long long>& energy) {
9
        // Check if equalization is possible
10
        long long totalEnergy = accumulate(energy.begin(), energy.end(), 0LL);
11
        12
        // If total energy is not divisible by N, equalization is impossible
13
        if (totalEnergy % N != 0) {
14
            return -1;
15
        }
16
        17
        long long targetEnergy = totalEnergy / N;
18
        19
        // Check if all stations are already equal
20
        bool alreadyEqual = true;
21
        for (int i = 0; i < N; i++) {
22
            if (energy[i] != targetEnergy) {
23
                alreadyEqual = false;
24
                break;
25
            }
26
        }
27
        if (alreadyEqual) return 0;
28
        29
        // Simulate the energy transfer process
30
        int operations = 0;
31
        vector<long long> current = energy;
32
        33
        while (true) {
34
            bool equalized = true;
35
            bool madeProgress = false;
36
            37
            // Try to equalize by transferring energy around the circle
38
            for (int i = 0; i < N; i++) {
39
                int next = (i + 1) % N;
40
                41
                if (current[i] > targetEnergy && current[next] < targetEnergy) {
42
                    long long diff = min(current[i] - targetEnergy,
43
                                      min((long long)K, 
44
                                          targetEnergy - current[next]));
45
                    if (diff > 0) {
46
                        current[i] -= diff;
47
                        current[next] += diff;
48
                        operations++;
49
                        madeProgress = true;
50
                    }
51
                }
52
                53
                if (current[i] != targetEnergy) {
54
                    equalized = false;
55
                }
56
            }
57
            58
            // If we've equalized or can't make progress, break
59
            if (equalized) return operations;
60
            if (!madeProgress) return -1;
61
            62
            // Safety check for infinite loops
63
            if (operations > N * totalEnergy) return -1;
64
        }
65
    }
66
};
67
68
int main() {
69
    int T;
70
    cin >> T;
71
    72
    while (T--) {
73
        int N, K;
74
        cin >> N >> K;
75
        76
        vector<long long> energy(N);
77
        for (int i = 0; i < N; i++) {
78
            cin >> energy[i];
79
        }
80
        81
        Solution solution;
82
        cout << solution.minOperationsToEqualize(N, K, energy) << endl;
83
    }
84
    85
    return 0;
86
}
87",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833371
1387833368,sohamkadam0012,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
int maxAbsoluteDifference(int *arr, int n) {
5
    int totalSum = 0;
6
    int leftSum = 0;
7
    int maxDiff = 0;
8
9
    // Calculate total sum of array
10
    for (int i = 0; i < n; i++) {
11
        totalSum += arr[i];
12
    }
13
14
    // Iterate to find the maximum absolute difference
15
    for (int i = 0; i < n - 1; i++) {
16
        leftSum += arr[i];
17
        int rightSum = totalSum - leftSum;
18
        int absDiff = abs(leftSum - rightSum);
19
        if (absDiff > maxDiff) {
20
            maxDiff = absDiff;
21
        }
22
    }
23
24
    return maxDiff;
25
}
26
27
int main() {
28
    int t;
29
    scanf(""%d"", &t);
30
31
    while (t--) {
32
        int n;
33
        scanf(""%d"", &n);
34
35
        int *arr = (int *)malloc(n * sizeof(int));
36
        for (int i = 0; i < n; i++) {
37
            scanf(""%d"", &arr[i]);
38
        }
39
40
        printf(""%d\n"", maxAbsoluteDifference(arr, n));
41
42
        free(arr);
43
    }
44
45
    return 0;
46
}
47
48",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833368
1387833369,omg40787,unknown,unknown,"1
def product_distribution(test_cases):
2
    results = []
3
4
    for t in test_cases:
5
        n = t[0]
6
        values = t[1]
7
8
        if n == 0:
9
            results.append([])
10
            continue
11
12
        # Initialize prefix and suffix arrays
13
        prefix_products = [1] * n
14
        suffix_products = [1] * n
15
        result = [0] * n
16
17
        # Calculate prefix products
18
        for i in range(1, n):
19
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
20
21
        # Calculate suffix products
22
        for i in range(n - 2, -1, -1):
23
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
24
25
        # Calculate result array
26
        for i in range(n):
27
            result[i] = prefix_products[i] * suffix_products[i]
28
29
        results.append(result)
30
31
    return results
32
33
# Example usage:
34
test_cases = [
35
    (5, [1, 2, 3, 4, 5]),
36
    (5, [10, 3, 5, 6, 2])
37
]
38
39
results = product_distribution(test_cases)
40
for result in results:
41
    print(' '.join(map(str, result)))
42",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833369
1387833370,h1032221728,unknown,unknown,"1
import sys
2
3
def product_except_self(test_cases):
4
    results = []
5
    6
    for values in test_cases:
7
        n = len(values)
8
        result = [1] * n
9
        10
        # Calculate the left products
11
        left_product = 1
12
        for i in range(n):
13
            result[i] = left_product
14
            left_product *= values[i]
15
        16
        # Calculate the right products and multiply with the left products
17
        right_product = 1
18
        for i in range(n - 1, -1, -1):
19
            result[i] *= right_product
20
            right_product *= values[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
# Input reading
27
input_data = sys.stdin.read().strip().splitlines()
28
T = int(input_data[0])
29
test_cases = []
30
31
index = 1
32
for _ in range(T):
33
    n = int(input_data[index])  # Read the number of nodes
34
    values = list(map(int, input_data[index + 1].split()))  # Read the values
35
    test_cases.append(values)
36
    index += 2  # Move to the next test case
37
38
# Get results
39
results = product_except_self(test_cases)
40
41
# Output results
42
for result in results:
43
    print("" "".join(map(str, result)))",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833370
1387833364,ayushaj14,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    # Initialize result array
4
    result = [1] * n
5
    left_product = 1
6
    7
    # Compute left product for each index
8
    for i in range(n):
9
        result[i] *= left_product
10
        left_product *= values[i]
11
    12
    right_product = 1
13
    14
    # Compute right product for each index
15
    for i in range(n-1, -1, -1):
16
        result[i] *= right_product
17
        right_product *= values[i]
18
    19
    return result
20
21
# Function to handle multiple test cases
22
def handle_test_cases(T, test_cases):
23
    results = []
24
    for i in range(T):
25
        n = test_cases[i][0]
26
        values = test_cases[i][1]
27
        results.append(product_except_self(values))
28
    return results
29
30
# Example usage
31
T = 2
32
test_cases = [
33
    (3, [1, 2, 3]),
34
    (4, [-1, 1, 0, -3])
35
]
36
37
results = handle_test_cases(T, test_cases)
38
for result in results:
39
    print(result)
40",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833364
1387833367,h1032221714,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    for _ in range(T):
4
        N, K = map(int, input().split())  # N: number of stations, K: units of energy in one transfer
5
        energy = list(map(int, input().split()))  # Array of energy at each station
6
        7
        total_energy = sum(energy)
8
        9
        # Check if it's possible to equalize the energy
10
        if total_energy % N != 0:
11
            print(-1)
12
            continue
13
        14
        target = total_energy // N  # Target energy per station
15
        operations = 0
16
        current_diff = 0
17
        18
        for i in range(N):
19
            # Calculate how much energy we need to add or remove
20
            current_diff += energy[i] - target
21
            22
            # Check if the difference can be resolved using K energy units
23
            if current_diff % K != 0:
24
                operations = -1
25
                break
26
            operations += abs(current_diff) // K
27
        28
        print(operations)
29
30
# Call the solve function
31
solve()",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833367
1387833366,shuklajaikishan1,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        surplus = 0
12
        for i in range(N):
13
            diff = energy[i] - target
14
            surplus += diff
15
            if surplus % K != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(surplus // K)
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
results = minimum_operations(test_cases)
31
for res in results:
32
    print(res)",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833366
1387833361,kesaragar1234,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
4
    for _ in range(test_cases):
5
        n = int(input())  # Size of the array
6
        nums = list(map(int, input().split()))
7
8
        # Calculate prefix sums
9
        prefix_sum = [0] * n
10
        prefix_sum[0] = nums[0]
11
        for i in range(1, n):
12
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
13
14
        # Calculate suffix sums
15
        suffix_sum = [0] * n
16
        suffix_sum[-1] = nums[-1]
17
        for i in range(n - 2, -1, -1):
18
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
19
20
        # Find the maximum absolute difference
21
        max_diff = 0
22
        for i in range(n - 1):
23
            left_sum = prefix_sum[i]
24
            right_sum = suffix_sum[i + 1]
25
            max_diff = max(max_diff, abs(left_sum - right_sum))
26
27
        results.append(max_diff)
28
29
    return results
30
31
# Input
32
T = int(input())  # Number of test cases
33
output = max_absolute_difference(T)
34
35
# Output results for all test cases
36
for res in output:
37
    print(res)
38",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833361
1387833362,prashant_ps9833,unknown,unknown,"1
def min_operations_to_equalize_energy(test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, k, energy = case
6
        total_energy = sum(energy)
7
        8
        # If total energy is not divisible by N, it's impossible to equalize
9
        if total_energy % n != 0:
10
            results.append(-1)
11
            continue
12
        13
        target_energy = total_energy // n
14
        diffs = [energy[i] - target_energy for i in range(n)]
15
        16
        # Check if the differences are divisible by K
17
        if any(abs(diff) % k != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate the number of operations required
22
        operations = 0
23
        balance = 0  # Running balance of energy adjustments
24
        for diff in diffs:
25
            balance += diff // k
26
            operations += abs(balance)
27
        28
        results.append(operations)
29
    30
    return results
31
32
33
# Input processing
34
T = int(input())  # Number of test cases
35
test_cases = []
36
37
for _ in range(T):
38
    n, k = map(int, input().split())  # Read N (stations) and K (transferable units)
39
    energy = list(map(int, input().split()))  # Energy levels of the stations
40
    test_cases.append((n, k, energy))
41
42
# Solve and output results
43
for result in min_operations_to_equalize_energy(test_cases):
44
    print(result)
45",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833362
1387833363,h1032220870,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    # Compute the total sum of the array
4
    total_sum = sum(nums)
5
    prefix_sum = 0
6
    max_diff = 0
7
8
    # Iterate through possible partition points
9
    for i in range(n - 1):
10
        prefix_sum += nums[i]
11
        left_sum = prefix_sum
12
        right_sum = total_sum - prefix_sum
13
        max_diff = max(max_diff, abs(left_sum - right_sum))
14
15
    return max_diff
16
17
18
def main():
19
    t = int(input())  # Number of test cases
20
    results = []
21
22
    for _ in range(t):
23
        n = int(input())  # Size of the array
24
        nums = list(map(int, input().split()))  # Array elements
25
        results.append(max_absolute_difference(nums))
26
27
    for res in results:
28
        print(res)
29
30
31
# Example Input:
32
# 1
33
# 3
34
# 2 3 4
35
36
if __name__ == ""__main__"":
37
    main()
38",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833363
1387833360,aagnihotri2203,unknown,unknown,"1
def solve():
2
    import sys
3
    data = sys.stdin.read().strip().split()
4
    t = int(data[0])
5
    idx = 1
6
7
    for _ in range(t):
8
        n = int(data[idx]); idx += 1
9
        nums = list(map(int, data[idx:idx+n]))
10
        idx += n
11
        12
        total_sum = sum(nums)
13
        14
        prefix_sum = 0
15
        max_diff = 0
16
17
        for i in range(n - 1):
18
            prefix_sum += nums[i]
19
            diff = abs(2 * prefix_sum - total_sum)
20
            if diff > max_diff:
21
                max_diff = diff
22
        23
        print(max_diff)
24
25
solve()",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833360
1387833357,harikeshyadav161,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
3
    results = []
4
5
    for test in test_cases:
6
7
        n, nums = test
8
9
        prefix = [0] * n
10
11
        suffix = [0] * n
12
13
        prefix[0] = nums[0]
14
15
        for i in range(1, n):
16
17
            prefix[i] = prefix[i - 1] + nums[i]
18
19
        suffix[-1] = nums[-1]
20
21
        for i in range(n - 2, -1, -1):
22
23
            suffix[i] = suffix[i + 1] + nums[i]
24
25
        max_diff = 0
26
27
        for i in range(n - 1):  # Partition at i
28
29
            left_sum = prefix[i]
30
31
            right_sum = suffix[i + 1]
32
33
            max_diff = max(max_diff, abs(left_sum - right_sum))
34
35
        results.append(max_diff)
36
37
    return results
38
39
t = int(input())
40
41
test_cases = []
42
43
for _ in range(t):
44
45
    n = int(input())
46
47
    nums = list(map(int, input().split()))
48
49
    test_cases.append((n, nums))
50
51
results = max_absolute_difference(t, test_cases)
52
53
for res in results:
54
55
    print(res)",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833357
1387833359,mahakantsingh113,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
#include <cmath>
5
using namespace std;
6
7
vector<int> minimum_operations_to_equalize(int T, vector<pair<pair<int, int>, vector<int>>> &test_cases) {
8
    vector<int> results;
9
10
    for (int t = 0; t < T; t++) {
11
        int N = test_cases[t].first.first;
12
        int K = test_cases[t].first.second;
13
        vector<int> energy = test_cases[t].second;
14
15
        long long total_energy = accumulate(energy.begin(), energy.end(), 0LL);
16
        17
        // Check if equalization is possible
18
        if (total_energy % N != 0) {
19
            results.push_back(-1);
20
            continue;
21
        }
22
23
        int target = total_energy / N;
24
        vector<int> imbalances(N);
25
        for (int i = 0; i < N; i++) {
26
            imbalances[i] = energy[i] - target;
27
        }
28
29
        // Calculate prefix sums and check operations
30
        long long prefix_sum = 0;
31
        long long operations = 0;
32
        bool possible = true;
33
34
        for (int i = 0; i < N; i++) {
35
            prefix_sum += imbalances[i];
36
            // If the imbalance cannot be corrected with K-unit transfers
37
            if (prefix_sum % K != 0) {
38
                possible = false;
39
                break;
40
            }
41
            operations += abs(prefix_sum) / K;
42
        }
43
44
        if (possible) {
45
            results.push_back(operations);
46
        } else {
47
            results.push_back(-1);
48
        }
49
    }
50
51
    return results;
52
}
53
54
int main() {
55
    int T;
56
    cin >> T;
57
    vector<pair<pair<int, int>, vector<int>>> test_cases(T);
58
59
    for (int t = 0; t < T; t++) {
60
        int N, K;
61
        cin >> N >> K;
62
        vector<int> energy(N);
63
        for (int i = 0; i < N; i++) {
64
            cin >> energy[i];
65
        }
66
        test_cases[t] = {{N, K}, energy};
67
    }
68
69
    vector<int> results = minimum_operations_to_equalize(T, test_cases);
70
71
    for (int res : results) {
72
        cout << res << endl;
73
    }
74
75
    return 0;
76
}
77",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833359
1387833356,ruchishree244,unknown,unknown,"1
import java.util.*;
2
3
public class MaxAbsDifference {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
7
        int t = sc.nextInt(); // Number of test cases
8
        StringBuilder result = new StringBuilder();
9
10
        while (t-- > 0) {
11
            int n = sc.nextInt(); // Size of the array
12
            int[] nums = new int[n];
13
14
            // Input the array
15
            for (int i = 0; i < n; i++) {
16
                nums[i] = sc.nextInt();
17
            }
18
19
            // Compute prefix sums
20
            long[] prefixSum = new long[n];
21
            prefixSum[0] = nums[0];
22
            for (int i = 1; i < n; i++) {
23
                prefixSum[i] = prefixSum[i - 1] + nums[i];
24
            }
25
26
            long totalSum = prefixSum[n - 1]; // Total sum of the array
27
            long maxDiff = 0;
28
29
            // Iterate through possible partitions
30
            for (int i = 0; i < n - 1; i++) {
31
                long leftSum = prefixSum[i];
32
                long rightSum = totalSum - leftSum;
33
                long absDiff = Math.abs(leftSum - rightSum);
34
35
                maxDiff = Math.max(maxDiff, absDiff);
36
            }
37
38
            result.append(maxDiff).append(""\n"");
39
        }
40
41
        System.out.print(result.toString());
42
        sc.close();
43
    }
44
}
45",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833356
1387833353,parabsaloni23,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
5
    prefix_sum = [0] * (n + 1)
6
    for i in range(1, n + 1):
7
        prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
8
    9
    max_diff = 0
10
    for i in range(1, n):  
11
        sum1 = prefix_sum[i]           
12
        sum2 = prefix_sum[n] - sum1     
13
        max_diff = max(max_diff, abs(sum1 - sum2))
14
    15
    return max_diff
16
17
18
19
t = int(input())  
20
for _ in range(t):
21
    n = int(input())  
22
    nums = list(map(int, input().split()))  
23
    24
    25
    result = max_absolute_difference(nums)
26
    print(result)",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833353
1387833354,h1032221056,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
    for t in range(T):
4
       5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
        8
        total_energy = sum(energy)
9
        10
       11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target_energy = total_energy // N
16
        prefix_sum = 0
17
        min_ops = 0
18
        19
        20
        for e in energy:
21
            prefix_sum += e - target_energy
22
            if prefix_sum % K != 0:  
23
                min_ops = -1
24
                break
25
            min_ops += abs(prefix_sum // K)
26
        27
        results.append(min_ops if min_ops != -1 else -1)
28
    29
    return results
30
31
32
33
if __name__ == ""__main__"":
34
    T = int(input())
35
    test_cases = []
36
    for _ in range(T):
37
        N, K = map(int, input().split())
38
        energy = list(map(int, input().split()))
39
        test_cases.append(((N, K), energy))
40
    41
    results = min_operations_to_equalize(T, test_cases)
42
    for res in results:
43
        print(res)
44",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833354
1387833355,ankushchaudhary5,unknown,unknown,"1
def compute_result(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        # Initialize prefix and suffix arrays
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [1] * n
9
10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
18
        # Compute result by multiplying prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
22
        results.append(result)
23
24
    return results
25
26
27
def main():
28
    T = int(input())  # Read number of test cases
29
    test_cases = []
30
31
    for _ in range(T):
32
        n = int(input())  # Size of the array
33
        values = list(map(int, input().split()))  # Array elements
34
        test_cases.append((n, values))
35
36
    # Compute results
37
    results = compute_result(test_cases)
38
39
    # Print results
40
    for result in results:
41
        print("" "".join(map(str, result)))
42
43
44
if __name__ == ""__main__"":
45
    main()
46",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833355
1387833345,h1032220507,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for n, k, energy in test_cases:
4
        total_energy = sum(energy)
5
        if total_energy % n != 0:
6
            results.append(-1)
7
            continue
8
        9
        target = total_energy // n
10
        operations = 0
11
        balance = 0
12
        13
        for i in range(n):
14
            # Calculate the difference between the current station and the target
15
            diff = energy[i] - target
16
            balance += diff
17
            # Add the absolute value of the balance to operations
18
            operations += abs(balance)
19
        20
        # If every step is divisible by k, return the operations divided by k
21
        if all(abs(balance) % k == 0 for balance in energy):
22
            results.append(operations // k)
23
        else:
24
            results.append(-1)
25
    return results
26
27
# Input processing
28
t = int(input())
29
test_cases = []
30
for _ in range(t):
31
    n, k = map(int, input().split())
32
    energy = list(map(int, input().split()))
33
    test_cases.append((n, k, energy))
34
35
# Calculate results
36
output = minimum_operations(test_cases)
37
38
# Output results
39
for result in output:
40
    print(result)
41",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833345
1387833351,08vijay09,unknown,unknown,"1
def solve():
2
3
    T = int(input())  
4
5
    for _ in range(T):
6
7
        n = int(input())  
8
9
        values = list(map(int, input().split()))
10
11
        12
13
        14
15
        prefix = [1] * n
16
17
        for i in range(1, n):
18
19
            prefix[i] = prefix[i - 1] * values[i - 1]
20
21
        22
23
        24
25
        suffix = [1] * n
26
27
        for i in range(n - 2, -1, -1):
28
29
            suffix[i] = suffix[i + 1] * values[i + 1]
30
31
        32
33
        34
35
        result = [prefix[i] * suffix[i] for i in range(n)]
36
37
        38
39
        40
41
        print("" "".join(map(str, result)))
42
43
44
45
solve()",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833351
1387833352,pulekarswaradny,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
31
        # Check and calculate the number of operations required
32
        for e in energy:
33
            diff = e - target_energy
34
            balance += diff
35
            # If balance isn't zero at any point, it means redistribution isn't possible
36
            operations += abs(diff)
37
38
        # Ensure redistribution results in balance being zero
39
        if balance == 0:
40
            results.append(str(operations // 2))  # Each operation affects two elements
41
        else:
42
            results.append(""-1"")
43
44
    # Output all results
45
    sys.stdout.write(""\n"".join(results) + ""\n"")
46
47
if __name__ == ""__main__"":
48
    solve_test_cases()
49",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833352
1387833344,vnandini1530,unknown,unknown,"1
def solve_testcase(N, K, energy):
2
    # Calculate total energy and target
3
    total_energy = sum(energy)
4
    5
    # Check if equal distribution is possible
6
    if total_energy % N != 0:
7
        return -1
8
    9
    target = total_energy // N
10
    11
    # If already equalized
12
    if all(e == target for e in energy):
13
        return 0
14
    15
    # For each position, calculate how many transfers are needed
16
    total_transfers = 0
17
    excess = 0  # Keep track of excess/deficit as we go around the circle
18
    19
    for i in range(N):
20
        # Current position's excess/deficit including previous remainder
21
        curr_with_excess = energy[i] + excess
22
        23
        # How far are we from target at this position
24
        diff_from_target = curr_with_excess - target
25
        26
        # This difference will need to be transferred to next position
27
        excess = diff_from_target
28
        29
        # If we need to make transfers
30
        if diff_from_target != 0:
31
            # If we can't transfer in K-unit chunks
32
            if abs(diff_from_target) % K != 0:
33
                return -1
34
                35
            # Add number of K-unit transfers needed
36
            total_transfers += abs(diff_from_target) // K
37
    38
    # After going around the circle, if there's any remainder, it's impossible
39
    if excess != 0:
40
        return -1
41
        42
    return total_transfers
43
44
def main():
45
    # Read number of test cases
46
    T = int(input())
47
    48
    # Process each test case
49
    for _ in range(T):
50
        # Read N and K
51
        N, K = map(int, input().split())
52
        53
        # Read energy array
54
        energy = list(map(int, input().split()))
55
        56
        # Solve current test case
57
        result = solve_testcase(N, K, energy)
58
        59
        # Print result
60
        print(result)
61
62
if __name__ == ""__main__"":
63
    main()
64",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833344
1387833340,sauravyadav244,unknown,unknown,"1
def minimum_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
    4
    for i in range(t):
5
        n, k = test_cases[i][0]
6
        energy = test_cases[i][1]
7
        8
        total_energy = sum(energy)
9
        if total_energy % n != 0:
10
            results.append(-1)
11
            continue
12
        13
        target_energy = total_energy // n
14
        operations = 0
15
        balance = 0
16
        17
        for e in energy:
18
            balance += e - target_energy
19
            if balance % k != 0:
20
                results.append(-1)
21
                break
22
            operations += abs(balance) // k
23
        else:
24
            results.append(operations)
25
    26
    return results
27
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    energy = list(map(int, input().split()))
34
    test_cases.append(((n, k), energy))
35
36
37
output = minimum_operations_to_equalize_energy(T, test_cases)
38
for res in output:
39
    print(res)
40",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833340
1387833343,abhaywadkar2004,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
void solve() {
6
    int T; // Number of test cases
7
    cin >> T;
8
9
    while (T--) {
10
        int n; // Number of nodes
11
        cin >> n;
12
        13
        vector<int> values(n), result(n);
14
        for (int i = 0; i < n; ++i) {
15
            cin >> values[i];
16
        }
17
        18
        long long ans = 1; // Initialize to 1 for product calculation
19
        for (int i = 0; i < n; i++) {
20
            ans *= values[i];
21
        }
22
        23
        for (int i = 0; i < n; i++) {
24
            result[i] = ans / values[i];
25
        }
26
27
        // Output the result array
28
        for (int i = 0; i < n; i++) {
29
            cout << result[i] << "" "";
30
        }
31
        cout << endl;
32
    }
33
}
34
35
int main() {
36
    ios::sync_with_stdio(false);
37
    cin.tie(nullptr);
38
    solve();
39
    return 0;
40
}
41",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833343
1387833338,devanshudandeka1,unknown,unknown,"1
def right():
2
    T = int(input())
3
    for _ in range(T):
4
        N = int(input())
5
        value = list(map(int,input().split()))
6
        result = [1] * N
7
        8
        left_product = 1 
9
        for i in range(N):
10
            result[i] = left_product
11
            left_product *= value[i]
12
            13
        right_product = 1
14
        for i in range(N-1,-1,-1):
15
            result[i] *= right_product
16
            right_product *= value[i]
17
        print("" "".join(map(str,result)))
18
right()            
19
            ",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833338
1387833333,sahilgupta75070,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    4
    for _ in range(T):
5
        N, K = map(int, input().split())  # N is the number of stations, K is the energy per move
6
        energy = list(map(int, input().split()))  # Energy in each station
7
        8
        total_energy = sum(energy)
9
        10
        # If the total energy is not divisible by N, it's impossible
11
        if total_energy % N != 0:
12
            print(-1)
13
            continue
14
        15
        target_energy = total_energy // N
16
        operations = 0
17
        balance = 0  # This keeps track of the ""extra"" energy or deficit
18
        19
        # Try to balance the energy across the stations
20
        for i in range(N):
21
            # The difference from the target energy at this station
22
            diff = energy[i] - target_energy
23
            balance += diff
24
            # The balance must be divisible by K, otherwise it's impossible to transfer energy in multiples of K
25
            if balance % K != 0:
26
                operations = -1
27
                break
28
            # Count how many moves are needed (each move transfers K units)
29
            operations += abs(balance // K)
30
        31
        print(operations)
32
33
# Read input and process the test cases
34
solve()
35",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833333
1387833336,pawanmudaliar081,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][0]
5
        energy = test_cases[t][1]
6
        7
        total_energy = sum(energy)
8
        9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        operations = 0
15
        balance = 0
16
        17
        for i in range(N):
18
19
            balance += energy[i] - target
20
            if balance % K != 0:
21
                results.append(-1)
22
                break
23
            operations += abs(balance) // K
24
        else:
25
            results.append(operations)
26
    27
    return results
28
29
30
31
if __name__ == ""__main__"":
32
    T = int(input())
33
    test_cases = []
34
    for _ in range(T):
35
        N, K = map(int, input().split())
36
        energy = list(map(int, input().split()))
37
        test_cases.append(((N, K), energy))
38
    39
    results = min_operations_to_equalize(T, test_cases)
40
    for res in results:
41
        print(res)
42",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833336
1387833334,manjesht78,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for nums in test_cases:
4
        n = len(nums)
5
        total_sum = sum(nums)
6
        7
        max_left_sum = float('-inf')
8
        min_left_sum = float('inf')
9
        current_sum = 0
10
        11
        for i in range(n - 1):  # We stop at n-1 to ensure both parts are non-empty
12
            current_sum += nums[i]
13
            max_left_sum = max(max_left_sum, current_sum)
14
            min_left_sum = min(min_left_sum, current_sum)
15
16
        max_difference = max(abs(total_sum - 2 * max_left_sum), abs(total_sum - 2 * min_left_sum))
17
        results.append(max_difference)
18
    19
    return results
20
21
try:
22
    t = int(input())
23
except EOFError:
24
    print(""No input provided."")
25
    t = 0
26
27
test_cases = []
28
for _ in range(t):
29
    n = int(input())
30
    nums = list(map(int, input().split()))
31
    test_cases.append(nums)
32
33
results = max_absolute_difference(test_cases)
34
for result in results:
35
    print(result)",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833334
1387833327,vg2556519,unknown,unknown,"1
def can_equalize(arr, N, K):
2
   3
    total = sum(arr)
4
    if total % N != 0:
5
        return False
6
    7
    target = total // N
8
    for val in arr:
9
        diff = abs(val - target)
10
        if diff % K != 0:
11
            return False
12
    13
    return True
14
15
def min_operations(arr, N, K):
16
    if not can_equalize(arr, N, K):
17
        return -1
18
    19
    target = sum(arr) // N
20
    operations = 0
21
    arr = arr.copy()
22
    transfers = []
23
    for i in range(N):
24
        diff = arr[i] - target
25
        transfers.append(diff)
26
    27
    for i in range(N-1):
28
        if transfers[i] != 0:
29
            moves = abs(transfers[i]) // K
30
            if transfers[i] > 0:
31
                transfers[i+1] += transfers[i]
32
                operations += moves
33
            else:
34
                transfers[i+1] -= abs(transfers[i])
35
                operations += moves
36
    37
    if transfers[N-1] != 0:
38
        operations += abs(transfers[N-1]) // K
39
    40
    return operations
41
42
def solve_test_cases():
43
    T = int(input())
44
    results = []
45
    46
    for _ in range(T):
47
        N, K = map(int, input().split())
48
        arr = list(map(int, input().split()))
49
        50
        result = min_operations(arr, N, K)
51
        results.append(result)
52
    53
    for result in results:
54
        print(result)
55
56
if __name__ == ""__main__"":
57
    solve_test_cases()",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833327
1387833328,chaussajjad,unknown,unknown,"1
def min_operations(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][0]
5
        energy = test_cases[t][1]
6
        7
        total_energy = sum(energy)
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
        12
        target_energy = total_energy // N
13
        surplus = 0
14
        operations = 0
15
        is_possible = True
16
        17
        for e in energy:
18
            diff = e - target_energy
19
            surplus += diff
20
            if surplus % K != 0:
21
                is_possible = False
22
                break
23
            operations += abs(surplus) // K
24
        25
        if is_possible:
26
            results.append(operations)
27
        else:
28
            results.append(-1)
29
    30
    return results
31
32
33
# Input
34
T = int(input())
35
test_cases = []
36
37
for _ in range(T):
38
    N, K = map(int, input().split())
39
    energy = list(map(int, input().split()))
40
    test_cases.append(((N, K), energy))
41
42
# Output
43
results = min_operations(T, test_cases)
44
for res in results:
45
    print(res)
46",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833328
1387833330,adiv40816,unknown,unknown,"1
import sys
2
3
def min_operations_to_equalize(n, k, energy):
4
    total_energy = sum(energy)
5
    6
    # If total energy is not divisible by n, it's impossible to equalize
7
    if total_energy % n != 0:
8
        return -1
9
    10
    target = total_energy // n  # Each station should have this much energy
11
    operations = 0
12
    13
    for i in range(n):
14
        diff = energy[i] - target
15
        # If diff is not a multiple of k, we cannot transfer it
16
        if diff % k != 0:
17
            return -1
18
        operations += abs(diff) // k
19
    20
    return operations // 2  # Each transfer is counted twice
21
22
def main():
23
    t = int(sys.stdin.readline().strip())
24
    results = []
25
    for _ in range(t):
26
        n, k = map(int, sys.stdin.readline().strip().split())
27
        energy = list(map(int, sys.stdin.readline().strip().split()))
28
        results.append(str(min_operations_to_equalize(n, k, energy)))
29
    30
    sys.stdout.write(""\n"".join(results) + ""\n"")
31
32
if __name__ == ""__main__"":
33
    main()
34",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833330
1387833326,adityadav0412,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        N, K = map(int, data[idx].split())
14
        idx += 1
15
        energy = list(map(int, data[idx].split()))
16
        idx += 1
17
18
        total_energy = sum(energy)
19
20
        if total_energy % N != 0:
21
            results.append(""-1"")
22
            continue
23
24
        target_energy = total_energy // N
25
        operations = 0
26
        balance = 0
27
        possible = True
28
29
        for e in energy:
30
            diff = e - target_energy
31
            balance += diff
32
            if balance % K != 0:
33
                possible = False
34
                break
35
            operations += abs(balance // K)
36
37
        results.append(str(operations) if possible else ""-1"")
38
39
    sys.stdout.write(""\n"".join(results) + ""\n"")
40
41
if __name__ == ""__main__"":
42
    solve_test_cases()",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833326
1387833321,singhark94,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
using namespace std;
5
6
long long minOperations(int N, int K, vector<int>& energy) {
7
    long long totalEnergy = accumulate(energy.begin(), energy.end(), 0LL);
8
9
    // Check if equalization is possible
10
    if (totalEnergy % N != 0) return -1;
11
    long long target = totalEnergy / N;
12
13
    vector<long long> diff(N, 0);
14
    long long cumulativeSum = 0, operations = 0;
15
16
    // Compute difference array and cumulative transfers
17
    for (int i = 0; i < N; ++i) {
18
        diff[i] = energy[i] - target;
19
        cumulativeSum += diff[i];
20
21
        // If at any point, cumulative transfers cannot be divided by K, it's impossible
22
        if (cumulativeSum % K != 0) return -1;
23
24
        // Count operations needed
25
        operations += abs(cumulativeSum) / K;
26
    }
27
28
    return operations;
29
}
30
31
int main() {
32
    int T;
33
    cin >> T;
34
35
    while (T--) {
36
        int N, K;
37
        cin >> N >> K;
38
        vector<int> energy(N);
39
        for (int i = 0; i < N; ++i) {
40
            cin >> energy[i];
41
        }
42
43
        cout << minOperations(N, K, energy) << endl;
44
    }
45
46
    return 0;
47
}
48",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833321
1387833324,h1032220176,unknown,unknown,"1
def solve():
2
   3
    T = int(raw_input())
4
    5
    for _ in range(T):
6
       7
        n = int(raw_input())
8
        9
        values = map(int, raw_input().split())
10
        11
        12
        result = [1] * n
13
        14
        15
        left_product = 1
16
        for i in range(n):
17
            result[i] *= left_product
18
            left_product *= values[i]
19
        20
      21
        right_product = 1
22
        for i in range(n-1, -1, -1):
23
            result[i] *= right_product
24
            right_product *= values[i]
25
        26
       27
        print "" "".join(map(str, result))
28
29
solve()
30",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833324
1387833325,sunaym1006,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def equalize_energy(T, test_cases):
3
    results = []
4
    5
    for t in range(T):
6
        N, K = test_cases[t][0], test_cases[t][1]
7
        energy = test_cases[t][2]
8
        9
        total_energy = sum(energy)
10
        11
        # If the total energy is not divisible by N, it's impossible to equalize
12
        if total_energy % N != 0:
13
            results.append(-1)
14
            continue
15
        16
        target_energy = total_energy // N
17
        operations = 0
18
        imbalance = 0
19
        20
        # Traverse through the stations to calculate imbalance and operations
21
        for i in range(N):
22
            imbalance += energy[i] - target_energy
23
            # Number of operations required for this imbalance, with step size K
24
            operations += abs(imbalance) // K
25
        26
        results.append(operations)
27
    28
    return results
29
30
# Input reading part (for use in competitive programming platforms)
31
T = int(input())  # number of test cases
32
test_cases = []
33
34
for _ in range(T):
35
    N, K = map(int, input().split())  # N and K for each test case
36
    energy = list(map(int, input().split()))  # energy of the stations
37
    test_cases.append((N, K, energy))
38
39
results = equalize_energy(T, test_cases)
40
for res in results:
41
    print(res)
42",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833325
1387833318,tanishqsatote369,unknown,unknown,"1
2
3
#include <iostream>
4
#include <vector>
5
using namespace std;
6
7
vector<vector<long long>> computeProducts(int T, vector<pair<int, vector<int>>>& testCases) {
8
    vector<vector<long long>> results;
9
10
    for (int t = 0; t < T; ++t) {
11
        int n = testCases[t].first;
12
        vector<int>& values = testCases[t].second;
13
        14
        // Result vector
15
        vector<long long> result(n, 1);
16
17
        // Compute prefix products
18
        long long prefix = 1;
19
        for (int i = 0; i < n; ++i) {
20
            result[i] = prefix;
21
            prefix *= values[i];
22
        }
23
24
        // Compute suffix products and multiply with prefix
25
        long long suffix = 1;
26
        for (int i = n - 1; i >= 0; --i) {
27
            result[i] *= suffix;
28
            suffix *= values[i];
29
        }
30
31
        results.push_back(result);
32
    }
33
34
    return results;
35
}
36
37
int main() {
38
    int T;
39
    cin >> T;  // Number of test cases
40
    vector<pair<int, vector<int>>> testCases;
41
42
    for (int t = 0; t < T; ++t) {
43
        int n;
44
        cin >> n;  // Number of nodes
45
        vector<int> values(n);
46
        for (int i = 0; i < n; ++i) {
47
            cin >> values[i];
48
        }
49
        testCases.emplace_back(n, values);
50
    }
51
52
    // Compute results
53
    vector<vector<long long>> results = computeProducts(T, testCases);
54
55
    // Output results
56
    for (const auto& result : results) {
57
        for (size_t i = 0; i < result.size(); ++i) {
58
            if (i > 0) cout << "" "";
59
            cout << result[i];
60
        }
61
        cout << endl;
62
    }
63
64
    return 0;
65
}",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833318
1387833316,sujalnegi421,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        surplus = 0
12
        for i in range(N):
13
            diff = energy[i] - target
14
            surplus += diff
15
            if surplus % K != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(surplus // K)
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
results = minimum_operations(test_cases)
31
for res in results:
32
    print(res)",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833316
1387833319,sonamyadav7208,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    for _ in range(T):
4
        N, K = map(int, input().split())  # N is the number of stations, K is the energy per transfer
5
        energy = list(map(int, input().split()))  # List of energy levels
6
        7
        total_energy = sum(energy)
8
        9
        # If total energy is not divisible by N, it's impossible to equalize
10
        if total_energy % N != 0:
11
            print(-1)
12
            continue
13
        14
        target_energy = total_energy // N
15
        operations = 0
16
        current_balance = 0
17
        18
        for i in range(N):
19
            # Calculate the difference from target energy for the current station
20
            current_balance += energy[i] - target_energy
21
            # The number of operations required is how much imbalance has been accumulated
22
            operations += abs(current_balance) // K
23
            24
            # If at any point, the imbalance isn't divisible by K, return -1
25
            if abs(current_balance) % K != 0:
26
                operations = -1
27
                break
28
        29
        print(operations)
30
31
# Call the function to run the solution
32
solve()
33",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833319
1387833310,h1032220108,unknown,unknown,"1
def try_equalize(N, K, energy, target_energy, direction=1):
2
    energy_copy = energy.copy()
3
    operations = 0
4
    5
    for start in range(N):
6
        for i in range(N):
7
            curr_pos = (start + i * direction) % N
8
            next_pos = (start + (i + 1) * direction) % N
9
            10
            if energy_copy[curr_pos] > target_energy:
11
                diff = energy_copy[curr_pos] - target_energy
12
                if diff % K != 0:
13
                    return -1
14
                moves = diff // K
15
                operations += moves
16
                energy_copy[curr_pos] -= moves * K
17
                energy_copy[next_pos] += moves * K
18
    if all(e == target_energy for e in energy_copy):
19
        return operations
20
    return -1
21
22
def solve_test_case(N, K, energy):
23
    # Calculate total energy
24
    total_energy = sum(energy)
25
    if total_energy % N != 0:
26
        return -1
27
        28
    target_energy = total_energy // N
29
    if all(e == target_energy for e in energy):
30
        return 0
31
    forward_ops = try_equalize(N, K, energy, target_energy, 1)
32
    backward_ops = try_equalize(N, K, energy, target_energy, -1)
33
    valid_ops = []
34
    if forward_ops != -1:
35
        valid_ops.append(forward_ops)
36
    if backward_ops != -1:
37
        valid_ops.append(backward_ops)
38
    39
    return min(valid_ops) if valid_ops else -1
40
T = int(input())
41
for _ in range(T):
42
    N, K = map(int, input().split())
43
    energy = list(map(int, input().split()))
44
    result = solve_test_case(N, K, energy)
45
    print(result)",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833310
1387833311,h1032231269,unknown,unknown,"1
def solve_testcase(n, nums):
2
    if n == 2:
3
        return abs(nums[0] - nums[1])
4
    total_sum = sum(nums)
5
    max_diff = 0
6
    left_sum = 0
7
    for i in range(n - 1):
8
        left_sum += nums[i]
9
        right_sum = total_sum - left_sum
10
        curr_diff = abs(left_sum - right_sum)
11
        max_diff = max(max_diff, curr_diff)
12
    return max_diff
13
14
def main():
15
    t = int(input())
16
    for _ in range(t):
17
        n = int(input())
18
        nums = list(map(int, input().split()))
19
        result = solve_testcase(n, nums)
20
        print(result)
21
22
if __name__ == ""__main__"":
23
    main()
24",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833311
1387833312,shubhamgupta3009,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int T = scanner.nextInt();
9
10
        for (int t = 0; t < T; t++) {
11
            int N = scanner.nextInt(); 
12
            int K = scanner.nextInt(); 
13
            int[] energy = new int[N];
14
            long totalEnergy = 0;
15
16
            for (int i = 0; i < N; i++) {
17
                energy[i] = scanner.nextInt();
18
                totalEnergy += energy[i];
19
            }
20
21
            if (totalEnergy % N != 0) {
22
                System.out.println(-1);
23
                continue;
24
            }
25
26
            long targetEnergy = totalEnergy / N;
27
            long operations = 0;
28
            boolean possible = true;
29
30
            for (int i = 0; i < N; i++) {
31
                long diff = energy[i] - targetEnergy;
32
                if (diff % K != 0) {
33
                    possible = false;
34
                    break;
35
                }
36
                operations += Math.abs(diff) / K;
37
            }
38
39
            if (!possible) {
40
                System.out.println(-1);
41
            } else {
42
                System.out.println(operations / 2);
43
            }
44
        }
45
46
        scanner.close();
47
    }
48
}",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833312
1387833309,tiwarishashank14,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void solve() {
5
    int T;
6
    scanf(""%d"", &T);  // Read number of test cases
7
8
    while (T--) {
9
        int N, K;
10
        scanf(""%d %d"", &N, &K);  // Read number of stations and transfer units
11
12
        long long energy[N];
13
        long long totalEnergy = 0;
14
15
        // Read the energy values and compute the total energy
16
        for (int i = 0; i < N; i++) {
17
            scanf(""%lld"", &energy[i]);
18
            totalEnergy += energy[i];
19
        }
20
21
        // Check if equalizing is possible
22
        if (totalEnergy % N != 0) {
23
            printf(""-1\n"");
24
            continue;
25
        }
26
27
        long long targetEnergy = totalEnergy / N;
28
        long long operations = 0;
29
        long long balance = 0;
30
31
        // Iterate over the energy array to compute the minimum operations
32
        for (int i = 0; i < N; i++) {
33
            // The current balance is the sum of the differences we have processed so far
34
            balance += energy[i] - targetEnergy;
35
36
            // Check if the balance is divisible by K
37
            if (balance % K != 0) {
38
                printf(""-1\n"");
39
                break;
40
            }
41
42
            // Add the absolute value of the balance divided by K to operations count
43
            operations += abs(balance) / K;
44
        }
45
46
        if (balance % K == 0) {
47
            printf(""%lld\n"", operations);
48
        }
49
    }
50
}
51
52
int main() {
53
    solve();  // Call the solve function
54
    return 0;
55
}
56",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833309
1387833306,shuklajaikishan1,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # If total energy is not divisible by N, equalization is impossible
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target = total_energy // N
9
    operations = 0
10
    11
    for i in range(N):
12
        diff = energy[i] - target
13
        14
        # If the difference is not a multiple of K, we cannot make it equal
15
        if diff % K != 0:
16
            return -1
17
        18
        operations += abs(diff) // K
19
    20
    return operations // 2  # Each operation is counted twice (once for sending and once for receiving)
21
22
23
def main():
24
    T = int(input())  # Number of test cases
25
    26
    for _ in range(T):
27
        N, K = map(int, input().split())  # Read N and K
28
        energy = list(map(int, input().split()))  # Read energy values
29
        30
        # Compute and print result
31
        print(min_operations_to_equalize(N, K, energy))
32
33
if __name__ == ""__main__"":
34
    main()
35",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833306
1387833304,h1032220149,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ProductArrayPuzzle {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int T = scanner.nextInt();
8
9
        for (int i = 0; i < T; i++) {
10
            int n = scanner.nextInt();
11
            int[] values = new int[n];
12
13
            for (int j = 0; j < n; j++) {
14
                values[j] = scanner.nextInt();
15
            }
16
17
            int[] result = productArray(values);
18
19
            for (int j = 0; j < n; j++) {
20
                System.out.print(result[j] + "" "");
21
            }
22
            System.out.println();
23
        }
24
    }
25
26
    public static int[] productArray(int[] values) {
27
        int n = values.length;
28
        int[] left = new int[n];
29
        int[] right = new int[n];
30
        int[] result = new int[n];
31
32
        // Calculate left product array
33
        left[0] = 1;
34
        for (int i = 1; i < n; i++) {
35
            left[i] = left[i - 1] * values[i - 1];
36
        }
37
38
        // Calculate right product array
39
        right[n - 1] = 1;
40
        for (int i = n - 2; i >= 0; i--) {
41
            right[i] = right[i + 1] * values[i + 1];
42
        }
43
44
        // Calculate result array
45
        for (int i = 0; i < n; i++) {
46
            result[i] = left[i] * right[i];
47
        }
48
49
        return result;
50
    }
51
}",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833304
1387833307,ayushchaudhary71,unknown,unknown,"1
def compute_result(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        # Initialize prefix and suffix arrays
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [1] * n
9
10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
18
        # Compute result by multiplying prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
22
        results.append(result)
23
24
    return results
25
26
27
def main():
28
    T = int(input())  # Read number of test cases
29
    test_cases = []
30
31
    for _ in range(T):
32
        n = int(input())  # Size of the array
33
        values = list(map(int, input().split()))  # Array elements
34
        test_cases.append((n, values))
35
36
    # Compute results
37
    results = compute_result(test_cases)
38
39
    # Print results
40
    for result in results:
41
        print("" "".join(map(str, result)))
42
43
44
if __name__ == ""__main__"":
45
    main()
46",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833307
1387833301,h1032221373,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
          Scanner scanner = new Scanner(System.in);
8
9
        10
        int T = scanner.nextInt();
11
12
        while (T-- > 0) {
13
            int n = scanner.nextInt();
14
            int[] values = new int[n];
15
            int[] result = new int[n];
16
            int[] prefix = new int[n];
17
            int[] suffix = new int[n];
18
          19
            for (int i = 0; i < n; i++) {
20
                values[i] = scanner.nextInt();
21
            }
22
             prefix[0] = 1;
23
            for (int i = 1; i < n; i++) {
24
                prefix[i] = prefix[i - 1] * values[i - 1];
25
            }
26
27
            28
            suffix[n - 1] = 1;
29
            for (int i = n - 2; i >= 0; i--) {
30
                suffix[i] = suffix[i + 1] * values[i + 1];
31
            }
32
33
            34
            for (int i = 0; i < n; i++) {
35
                result[i] = prefix[i] * suffix[i];
36
            }
37
38
          39
            for (int i = 0; i < n; i++) {
40
                System.out.print(result[i] + "" "");
41
            }
42
            System.out.println();
43
        }
44
45
        scanner.close();
46
       47
    }
48
}",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833301
1387833303,laxmimehta0506,unknown,unknown,"1
import java.util.Scanner;
2
3
public class EnergyEqualization {
4
    5
    public static int minOperations(int N, int K, int[] energy) {
6
        long totalEnergy = 0;
7
        8
        // Calculate total energy
9
        for (int e : energy) {
10
            totalEnergy += e;
11
        }
12
        13
        // If the total energy is not divisible by N, it's impossible to equalize
14
        if (totalEnergy % N != 0) {
15
            return -1;
16
        }
17
        18
        // The target energy each station should have
19
        long target = totalEnergy / N;
20
        21
        long currentBalance = 0;
22
        int operations = 0;
23
        24
        // Iterate through each station to calculate the number of operations
25
        for (int i = 0; i < N; i++) {
26
            // Calculate the difference between current energy and target
27
            long diff = energy[i] - target;
28
            29
            // Add the difference to the current balance
30
            currentBalance += diff;
31
            32
            // If current balance is not divisible by K, it means it's impossible
33
            if (currentBalance % K != 0) {
34
                return -1;
35
            }
36
            37
            // Number of operations is the absolute value of the balance divided by K
38
            operations += Math.abs(currentBalance / K);
39
        }
40
        41
        return operations;
42
    }
43
    44
    public static void main(String[] args) {
45
        Scanner sc = new Scanner(System.in);
46
        int T = sc.nextInt(); // Number of test cases
47
        48
        while (T-- > 0) {
49
            int N = sc.nextInt(); // Number of stations
50
            int K = sc.nextInt(); // Energy transfer in one operation
51
            int[] energy = new int[N];
52
            53
            for (int i = 0; i < N; i++) {
54
                energy[i] = sc.nextInt();
55
            }
56
            57
            // Get the result for the current test case
58
            int result = minOperations(N, K, energy);
59
            System.out.println(result);
60
        }
61
        62
        sc.close();
63
    }
64
}
65",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833303
1387833302,h1032221356,unknown,unknown,"1
def product_except_self():
2
    # Reading number of test cases
3
    T = int(input())
4
    results = []
5
    6
    for _ in range(T):
7
        # Read the size of the array
8
        n = int(input())
9
        # Read the values of the nodes
10
        values = list(map(int, input().split()))
11
        12
        # Initialize the result array
13
        result = [1] * n
14
        15
        # Compute prefix products
16
        prefix = 1
17
        for i in range(n):
18
            result[i] = prefix
19
            prefix *= values[i]
20
        21
        # Compute suffix products and combine with prefix
22
        suffix = 1
23
        for i in range(n - 1, -1, -1):
24
            result[i] *= suffix
25
            suffix *= values[i]
26
        27
        # Store the result for this test case
28
        results.append("" "".join(map(str, result)))
29
    30
    # Print all results
31
    print(""\n"".join(results))
32
33
# Call the function
34
product_except_self()
35",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833302
1387833299,harikeshyadav161,unknown,unknown,"1
def moe(test_cases):
2
3
    results = []
4
5
    for t in range(len(test_cases)):
6
7
        N, K, energy = test_cases[t]
8
9
        total_energy = sum(energy)
10
11
        if total_energy % N != 0:
12
13
            results.append(-1)
14
15
            continue
16
17
        18
19
        target = total_energy // N
20
21
        operations = 0
22
23
        balance = 0  
24
25
        for i in range(N):
26
27
            balance += energy[i] - target
28
29
            if balance % K != 0:
30
31
                operations = -1
32
33
                break
34
35
            operations += abs(balance) // K
36
37
        38
39
        results.append(operations if operations != -1 else -1)
40
41
    42
43
    return results
44
45
T = int(input())
46
47
test_cases = []
48
49
for _ in range(T):
50
51
    N, K = map(int, input().split())
52
53
    energy = list(map(int, input().split()))
54
55
    test_cases.append((N, K, energy))
56
57
results = moe(test_cases)
58
59
for res in results:
60
61
    print(res)",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833299
1387833297,guptashrey856,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833297
1387833300,HarshShrivastava,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner sc=new Scanner(System.in);
8
        int t=sc.nextInt();
9
        while(t>0){
10
            int n=sc.nextInt();
11
            int input[]=new int[n];
12
            int i;
13
            long product=1;
14
            for(i=0;i<n;i++){
15
                input[i]=sc.nextInt();
16
                if(input[i]!=0)
17
                    product*=input[i];
18
            }
19
            long result[]=new long[n];
20
            for(i=0;i<n;i++){
21
                result[i]=input[i]!=0?product/input[i]:product;
22
            }    
23
            for(i=0;i<n;i++)
24
                System.out.print(result[i]+"" "");
25
            System.out.println();
26
            t--;
27
        }
28
    }
29
}",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833300
1387833294,shshloka,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        cumulative_diff = 0
12
        for e in energy:
13
            diff = e - target
14
            cumulative_diff += diff
15
            operations += abs(cumulative_diff)
16
        if cumulative_diff != 0:
17
            results.append(-1)
18
        else:
19
            results.append(operations // K)
20
    return results
21
22
def main():
23
    import sys
24
    input = sys.stdin.read
25
    data = input().split()
26
    idx = 0
27
    T = int(data[idx])
28
    idx += 1
29
    test_cases = []
30
    for _ in range(T):
31
        N = int(data[idx])
32
        K = int(data[idx+1])
33
        idx += 2
34
        energy = list(map(int, data[idx:idx+N]))
35
        idx += N
36
        test_cases.append((N, K, energy))
37
    results = equalize_energy(test_cases)
38
    for res in results:
39
        print(res)
40
41
if __name__ == ""__main__"":
42
    main()",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833294
1387833289,shuklaram2315,unknown,unknown,"1
def equalize_energy(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][:2]
5
        energy = test_cases[t][2]
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        target = total_energy // N
11
        cumulative_balance = 0
12
        operations = 0
13
        for i in range(N):
14
            balance = energy[i] - target
15
            cumulative_balance += balance
16
            operations += abs(cumulative_balance)
17
        if operations % K != 0:
18
            results.append(-1)
19
        else:
20
            results.append(operations // K)
21
    return results
22
T = int(input())
23
test_cases = []
24
for _ in range(T):
25
    N, K = map(int, input().split())
26
    energy = list(map(int, input().split()))
27
    test_cases.append((N, K, energy))
28
results = equalize_energy(T, test_cases)
29
for res in results:
30
    print(res)",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833289
1387833291,aayushkrishnaut,unknown,unknown,"1
def max_subarray_difference(arr, n):
2
    max_diff = float('-inf')
3
    4
    # Try all possible partition points
5
    for i in range(1, n):
6
        # Calculate sums of left and right subarrays
7
        left_sum = sum(arr[:i])
8
        right_sum = sum(arr[i:])
9
        10
        # Calculate absolute difference
11
        diff = abs(left_sum - right_sum)
12
        max_diff = max(max_diff, diff)
13
    14
    return max_diff
15
16
def solve():
17
    # Read number of test cases
18
    t = int(input())
19
    20
    for _ in range(t):
21
        # Read array size
22
        n = int(input())
23
        24
        # Read array elements
25
        nums = list(map(int, input().split()))
26
        27
        # Calculate and print result
28
        result = max_subarray_difference(nums, n)
29
        print(result)
30
31
if __name__ == ""__main__"":
32
    solve()",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833291
1387833290,ag9867603762,unknown,unknown,"1
def product_distribution(test_cases):
2
    results = []
3
4
    for t in range(test_cases):
5
        n = int(raw_input())  
6
        values = map(int, raw_input().split())  
7
        total_product = 1
8
        zero_count = 0
9
10
        for value in values:
11
            if value == 0:
12
                zero_count += 1
13
            else:
14
                total_product *= value
15
16
        17
        result = []
18
        for value in values:
19
            if zero_count > 1:
20
                result.append(0)
21
            elif zero_count == 1:
22
                if value == 0:
23
                    result.append(total_product)
24
                else:
25
                    result.append(0)
26
            else:
27
                result.append(total_product // value)
28
29
        results.append("" "".join(map(str, result)))
30
    for res in results:
31
        print(res)
32
33
34
T = int(raw_input())
35
product_distribution(T)
36",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833290
1387833285,pratiksolves,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
int main() {
6
    int T; 
7
    cin >> T;
8
    while (T--) {
9
        int n;
10
        cin >> n;
11
        vector<int> values(n);
12
        for (int i = 0; i < n; ++i) {
13
            cin >> values[i];
14
        }
15
16
        vector<int> result(n, 1);
17
        vector<int> prefix(n, 1);
18
        vector<int> suffix(n, 1);
19
20
        for (int i = 1; i < n; ++i) {
21
            prefix[i] = prefix[i - 1] * values[i - 1];
22
        }
23
24
        for (int i = n - 2; i >= 0; --i) {
25
            suffix[i] = suffix[i + 1] * values[i + 1];
26
        }
27
28
        for (int i = 0; i < n; ++i) {
29
            result[i] = prefix[i] * suffix[i];
30
        }
31
32
        for (int i = 0; i < n; ++i) {
33
            cout << result[i] << "" "";
34
        }
35
        cout << endl;
36
    }
37
    return 0;
38
}
39",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833285
1387833287,jhakrishnachand1,unknown,unknown,"1
def minimum_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
4
    for _ in range(t):
5
        n, k = test_cases[_]['n'], test_cases[_]['k']
6
        energy = test_cases[_]['energy']
7
8
        total_energy = sum(energy)
9
10
11
        if total_energy % n != 0:
12
            results.append(-1)
13
            continue
14
15
        target_energy = total_energy // n
16
        operations = 0
17
        current_transfer = 0
18
19
        for i in range(n):
20
            current_transfer += energy[i] - target_energy
21
            if current_transfer % k != 0:
22
                results.append(-1)
23
                break
24
            operations += abs(current_transfer) // k
25
        else:
26
            results.append(operations)
27
28
    return results
29
30
31
T = int(input().strip())
32
test_cases = []
33
for _ in range(T):
34
    n, k = map(int, input().strip().split())
35
    energy = list(map(int, input().strip().split()))
36
    test_cases.append({""n"": n, ""k"": k, ""energy"": energy})
37
38
39
results = minimum_operations_to_equalize_energy(T, test_cases)
40
for result in results:
41
    print(result)",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833287
1387833288,aryaprzz1,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for i in range(t):
5
        n = test_cases[i][0]
6
        nums = test_cases[i][1]
7
        8
        # Calculate total sum of the array
9
        total_sum = sum(nums)
10
        11
        # Initialize variables
12
        left_sum = 0
13
        max_difference = float('-inf')
14
        15
        # Iterate through the array to calculate differences
16
        for j in range(n - 1):
17
            left_sum += nums[j]
18
            right_sum = total_sum - left_sum
19
            max_difference = max(max_difference, abs(left_sum - right_sum))
20
        21
        results.append(max_difference)
22
    23
    return results
24
25
26
# Input handling
27
if __name__ == ""__main__"":
28
    t = int(input())  # Number of test cases
29
    test_cases = []
30
    31
    for _ in range(t):
32
        n = int(input())  # Size of the array
33
        nums = list(map(int, input().split()))  # Array elements
34
        test_cases.append((n, nums))
35
    36
    # Get the results
37
    results = max_absolute_difference(t, test_cases)
38
    39
    # Print the results
40
    for res in results:
41
        print(res)",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833288
1387833280,h1032220289,unknown,unknown,"1
def main():
2
    T = int(input())  # number of test cases
3
    4
    for _ in range(T):
5
        n = int(input())  # number of nodes in the network
6
        values = list(map(int, input().split()))  # values at the nodes
7
        8
        result = [1] * n
9
        10
        # Compute the prefix product (left array)
11
        left_product = 1
12
        for i in range(n):
13
            result[i] = left_product
14
            left_product *= values[i]
15
        16
        # Compute the suffix product and finalize result
17
        right_product = 1
18
        for i in range(n-1, -1, -1):
19
            result[i] *= right_product
20
            right_product *= values[i]
21
        22
        # Print the result array for the current test case
23
        print("" "".join(map(str, result)))
24
25
main()",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833280
1387833281,h1032231291,unknown,unknown,"1
def compute_result(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n, values = test_cases[t]
6
7
        prefix = [1] * n
8
        for i in range(1, n):
9
            prefix[i] = prefix[i - 1] * values[i - 1]
10
11
        suffix = [1] * n
12
        for i in range(n - 2, -1, -1):
13
            suffix[i] = suffix[i + 1] * values[i + 1]
14
15
        result = [prefix[i] * suffix[i] for i in range(n)]
16
        results.append(result)
17
18
    return results
19
20
def main():
21
    T = int(input())
22
    test_cases = []
23
24
    for _ in range(T):
25
        n = int(input())
26
        values = list(map(int, input().split()))
27
        test_cases.append((n, values))
28
29
    results = compute_result(T, test_cases)
30
31
    for result in results:
32
        print("" "".join(map(str, result)))
33
34
if __name__ == ""__main__"":
35
    main()
36",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833281
1387833284,h1032231295,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, energy = case
5
        total_energy = sum(energy)
6
        7
        # Check if equalization is possible
8
        if total_energy % n != 0:
9
            results.append(-1)
10
            continue
11
        12
        target = total_energy // n
13
        surplus = 0
14
        operations = 0
15
        possible = True
16
        17
        for i in range(n):
18
            surplus += (energy[i] - target)
19
            # Surplus must be divisible by K to be transferable
20
            if surplus % k != 0:
21
                possible = False
22
                break
23
            # Count operations
24
            operations += abs(surplus) // k
25
        26
        results.append(operations if possible else -1)
27
    28
    return results
29
30
31
# Input Handling
32
T = int(input())
33
test_cases = []
34
for _ in range(T):
35
    n, k = map(int, input().split())
36
    energy = list(map(int, input().split()))
37
    test_cases.append((n, k, energy))
38
39
# Output Results
40
results = equalize_energy(test_cases)
41
for result in results:
42
    print(result)
43",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833284
1387833279,tanmoy2005barua,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for values in test_cases:
4
        n = len(values)
5
        result = [1] * n
6
        7
        left_product = 1
8
        for i in range(n):
9
            result[i] = left_product
10
            left_product *= values[i]
11
        12
        right_product = 1
13
        for i in range(n - 1, -1, -1):
14
            result[i] *= right_product
15
            right_product *= values[i]
16
        17
        results.append(result)
18
    19
    return results
20
21
try:
22
    T = int(input())
23
except EOFError:
24
    print(""No input provided."")
25
    T = 0
26
27
test_cases = []
28
for _ in range(T):
29
    n = int(input())
30
    values = list(map(int, input().split()))
31
    test_cases.append(values)
32
33
results = product_except_self(test_cases)
34
for result in results:
35
    print("" "".join(map(str, result)))
36",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833279
1387833275,harishpandey1704,unknown,unknown,"1
def max_abs_diff(t, cases):
2
    res = []
3
4
    for case in cases:
5
        n, arr = case
6
7
        pref = [0] * n
8
        pref[0] = arr[0]
9
10
        for i in range(1, n):
11
            pref[i] = pref[i - 1] + arr[i]
12
13
        total = pref[-1]
14
        max_d = 0
15
16
        for i in range(n - 1):
17
            left = pref[i]
18
            right = total - left
19
            max_d = max(max_d, abs(left - right))
20
21
        res.append(max_d)
22
23
    return res
24
25
def main():
26
    t = int(input())
27
    cases = []
28
29
    for _ in range(t):
30
        n = int(input())
31
        arr = list(map(int, input().split()))
32
        cases.append((n, arr))
33
34
    results = max_abs_diff(t, cases)
35
36
    for r in results:
37
        print(r)
38
39
if __name__ == ""__main__"":
40
    main()
41",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833275
1387833277,h1032220835,unknown,unknown,"1
def calculate_results(T, test_cases):
2
3
    results = []
4
5
    6
7
    for t in range(T):
8
9
        n = test_cases[t][0]
10
11
        values = test_cases[t][1]
12
13
        14
15
        # Create prefix and suffix arrays
16
17
        prefix = [1] * n
18
19
        suffix = [1] * n
20
21
        22
23
        # Compute prefix product
24
25
        for i in range(1, n):
26
27
            prefix[i] = prefix[i - 1] * values[i - 1]
28
29
        30
31
        # Compute suffix product
32
33
        for i in range(n - 2, -1, -1):
34
35
            suffix[i] = suffix[i + 1] * values[i + 1]
36
37
        38
39
        # Compute result array
40
41
        result = [prefix[i] * suffix[i] for i in range(n)]
42
43
        results.append(result)
44
45
    46
47
    return results
48
49
# Input reading
50
51
T = int(input())
52
53
test_cases = []
54
55
for _ in range(T):
56
57
    n = int(input())
58
59
    values = list(map(int, input().split()))
60
61
    test_cases.append((n, values))
62
63
# Process and output results
64
65
output = calculate_results(T, test_cases)
66
67
for res in output:
68
69
    print("" "".join(map(str, res)))",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833277
1387833278,sohamkadam0012,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
#include <stdbool.h>
4
5
// Function to calculate the minimum operations or return -1 if equalization is impossible
6
int minOperationsToEqualize(int *energy, int n, int k) {
7
    long long totalEnergy = 0;
8
9
    // Calculate total energy
10
    for (int i = 0; i < n; i++) {
11
        totalEnergy += energy[i];
12
    }
13
14
    // Check if total energy is divisible by N
15
    if (totalEnergy % n != 0) {
16
        return -1; // Equalization is impossible
17
    }
18
19
    long long targetEnergy = totalEnergy / n; // Target energy for each station
20
    long long operations = 0;
21
    long long surplus = 0; // Tracks energy surplus or deficit in the cycle
22
23
    // Traverse each station and calculate surplus or deficit
24
    for (int i = 0; i < n; i++) {
25
        surplus += energy[i] - targetEnergy;
26
27
        // Check if surplus can be transferred in multiples of K
28
        if (abs(surplus) % k != 0) {
29
            return -1; // Equalization not possible
30
        }
31
32
        // Count operations needed to balance this station
33
        operations += abs(surplus / k);
34
    }
35
36
    return operations;
37
}
38
39
int main() {
40
    int T;
41
    scanf(""%d"", &T);
42
43
    while (T--) {
44
        int n, k;
45
        scanf(""%d %d"", &n, &k);
46
47
        int *energy = (int *)malloc(n * sizeof(int));
48
        for (int i = 0; i < n; i++) {
49
            scanf(""%d"", &energy[i]);
50
        }
51
52
        int result = minOperationsToEqualize(energy, n, k);
53
        printf(""%d\n"", result);
54
55
        free(energy);
56
    }
57
58
    return 0;
59
}
60",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833278
1387833270,h1032221497,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
4
    for _ in range(t):
5
        n = test_cases[_][0]
6
        nums = test_cases[_][1]
7
8
        # Prefix and suffix sums
9
        prefix_sum = [0] * n
10
        suffix_sum = [0] * n
11
12
        # Compute prefix sum
13
        prefix_sum[0] = nums[0]
14
        for i in range(1, n):
15
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
16
17
        # Compute suffix sum
18
        suffix_sum[n - 1] = nums[n - 1]
19
        for i in range(n - 2, -1, -1):
20
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
21
22
        # Calculate the maximum absolute difference
23
        max_diff = 0
24
        for i in range(n - 1):
25
            left_sum = prefix_sum[i]
26
            right_sum = suffix_sum[i + 1]
27
            max_diff = max(max_diff, abs(left_sum - right_sum))
28
29
        results.append(max_diff)
30
31
    return results
32
33
# Input reading
34
t = int(input())
35
test_cases = []
36
for _ in range(t):
37
    n = int(input())
38
    nums = list(map(int, input().split()))
39
    test_cases.append((n, nums))
40
41
# Solve and output results
42
results = max_absolute_difference(t, test_cases)
43
for result in results:
44
    print(result)",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833270
1387833272,shikharguptaoct1,unknown,unknown,"1
def compute_product_array(n, values):
2
    prefix = [1] * n
3
    for i in range(1, n):
4
        prefix[i] = prefix[i - 1] * values[i - 1]
5
    6
    suffix = [1] * n
7
    for i in range(n - 2, -1, -1):
8
        suffix[i] = suffix[i + 1] * values[i + 1]
9
    10
    result = [prefix[i] * suffix[i] for i in range(n)]
11
    12
    return result
13
14
T = int(input().strip()) 
15
for _ in range(T):
16
    n = int(input().strip()) 
17
    values = list(map(int, input().strip().split()))
18
    print("" "".join(map(str, compute_product_array(n, values))))",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833272
1387833274,h1032231265,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833274
1387833267,adityatripathi27,unknown,unknown,"1
def solve():
2
    t = int(input())  # Number of test cases
3
    for _ in range(t):
4
        n = int(input())  # Size of the array
5
        nums = list(map(int, input().split()))  # Array of integers
6
        7
        # Compute the total sum of the array
8
        total_sum = sum(nums)
9
        10
        # Initialize the prefix sum
11
        prefix_sum = 0
12
        max_diff = 0
13
        14
        # Iterate over all possible partitions (from 1 to n-1)
15
        for i in range(n - 1):
16
            prefix_sum += nums[i]
17
            # Calculate the absolute difference between the two subarrays
18
            max_diff = max(max_diff, abs(prefix_sum - (total_sum - prefix_sum)))
19
        20
        print(max_diff)
21
22
# Run the function
23
solve()
24",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833267
1387833268,h1032220480,unknown,unknown,"1
def calculate_product_exclude_self(test_cases):
2
    results = []
3
    for values in test_cases:
4
        n = len(values)
5
        # Initialize prefix and suffix arrays
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result array
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    return results
24
25
# Input handling
26
t = int(input())
27
test_cases = []
28
for _ in range(t):
29
    n = int(input())
30
    values = list(map(int, input().split()))
31
    test_cases.append(values)
32
33
# Processing and Output
34
results = calculate_product_exclude_self(test_cases)
35
for res in results:
36
    print("" "".join(map(str, res)))",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833268
1387833269,adiv40816,unknown,unknown,"1
import sys
2
3
def min_operations_to_equalize(n, k, energy):
4
    total_energy = sum(energy)
5
    6
    # If total energy is not divisible by n, it's impossible to equalize
7
    if total_energy % n != 0:
8
        return -1
9
    10
    target = total_energy // n  # Each station should have this much energy
11
    operations = 0
12
    13
    for i in range(n):
14
        diff = energy[i] - target
15
        # If diff is not a multiple of k, we cannot transfer it
16
        if diff % k != 0:
17
            return -1
18
        operations += abs(diff) // k
19
    20
    return operations // 2  # Each transfer is counted twice
21
22
def main():
23
    t = int(sys.stdin.readline().strip())
24
    results = []
25
    for _ in range(t):
26
        n, k = map(int, sys.stdin.readline().strip().split())
27
        energy = list(map(int, sys.stdin.readline().strip().split()))
28
        results.append(str(min_operations_to_equalize(n, k, energy)))
29
    30
    sys.stdout.write(""\n"".join(results) + ""\n"")
31
32
if __name__ == ""__main__"":
33
    main()
34",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833269
1387833265,suryampandey5942,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
9
int main() {
10
        11
    int t;
12
    cin>>t;
13
    14
    while(t--)
15
    {
16
        int n;
17
        cin>>n;
18
        19
        vector<int> vec1(n);
20
        21
        for(int i=0;i<n;i++)
22
        {   
23
            int dummy;
24
            cin>>dummy;
25
            vec1[i]=dummy;
26
        }
27
        28
        vector<int> ans(n);
29
        30
        for(int i=0;i<n;i++)
31
        {
32
            long long anss=1;
33
            for(int j=0;j<n;j++)
34
            {
35
                 if(i==j) continue;
36
                37
                 anss=anss*vec1[j];
38
            }
39
            ans[i]=anss;
40
          41
        }
42
        43
        for(auto it:ans)
44
        {
45
            cout<<it<<"" "";
46
        }cout<<endl;
47
    }
48
    return 0;
49
}
50",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833265
1387833261,prathameshbhoit1,unknown,unknown,"1
def can_equalize(n: int, k: int, stations: list) -> int:
2
    # Calculate total energy and target energy per station
3
    total_energy = sum(stations)
4
    5
    # Check if total energy is divisible by number of stations
6
    if total_energy % n != 0:
7
        return -1
8
    9
    target_energy = total_energy // n
10
    11
    # If already equalized, return 0
12
    if all(x == target_energy for x in stations):
13
        return 0
14
    15
    # Check if K can be used to equalize
16
    for station in stations:
17
        if abs(station - target_energy) % k != 0:
18
            return -1
19
    20
    # Calculate minimum operations needed
21
    operations = 0
22
    for i in range(n):
23
        if stations[i] == target_energy:
24
            continue
25
            26
        # Calculate how many units need to be moved
27
        diff = stations[i] - target_energy
28
        # Calculate how many operations needed for this station
29
        ops = abs(diff) // k
30
        operations += ops
31
    32
    # Since we counted both giving and receiving operations,
33
    # we need to divide by 2 to get actual number of operations
34
    return operations // 2
35
36
def solve_test_cases():
37
    # Read number of test cases
38
    t = int(input())
39
    40
    results = []
41
    for _ in range(t):
42
        # Read N and K
43
        n, k = map(int, input().split())
44
        # Read station energies
45
        stations = list(map(int, input().split()))
46
        # Solve for this test case
47
        result = can_equalize(n, k, stations)
48
        results.append(result)
49
    50
    # Print results
51
    for result in results:
52
        print(result)
53
54
# Run the solution
55
if __name__ == ""__main__"":
56
    solve_test_cases()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833261
1387833264,angelaanindyajo1,unknown,unknown,"1
def compute_product_array(n, values):
2
    prefix = [1] * n
3
    for i in range(1, n):
4
        prefix[i] = prefix[i - 1] * values[i - 1]
5
    6
    suffix = [1] * n
7
    for i in range(n - 2, -1, -1):
8
        suffix[i] = suffix[i + 1] * values[i + 1]
9
    10
    result = [prefix[i] * suffix[i] for i in range(n)]
11
    12
    return result
13
14
T = int(input().strip()) 
15
for _ in range(T):
16
    n = int(input().strip()) 
17
    values = list(map(int, input().strip().split()))
18
    print("" "".join(map(str, compute_product_array(n, values))))",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833264
1387833262,prashant_ps9833,unknown,unknown,"1
def min_operations_to_equalize_energy(test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, k, energy = case
6
        total_energy = sum(energy)
7
8
        if total_energy % n != 0:
9
            results.append(-1)
10
            continue
11
        12
        target_energy = total_energy // n
13
        diffs = [energy[i] - target_energy for i in range(n)]
14
        15
        if any(diff % k != 0 for diff in diffs):
16
            results.append(-1)
17
            continue
18
19
        pos_diff = 0
20
        neg_diff = 0
21
        for diff in diffs:
22
            if diff > 0:
23
                pos_diff += diff // k
24
            elif diff < 0:
25
                neg_diff += abs(diff) // k
26
        27
        if pos_diff == neg_diff:
28
            results.append(pos_diff)
29
        else:
30
            results.append(-1)
31
    32
    return results
33
34
T = int(input())
35
test_cases = []
36
37
for _ in range(T):
38
    n, k = map(int, input().split())
39
    energy = list(map(int, input().split()))
40
    test_cases.append((n, k, energy))
41
42
for result in min_operations_to_equalize_energy(test_cases):
43
    print(result)",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833262
1387833257,khushidoshi1978,unknown,unknown,"1
def product_of_all_except_self(test_cases):
2
    for case in test_cases:
3
        n, values = case
4
        result = [1] * n
5
6
        7
        prefix_product = 1
8
        for i in range(n):
9
            result[i] = prefix_product
10
            prefix_product *= values[i]
11
12
        13
        suffix_product = 1
14
        for i in range(n-1, -1, -1):
15
            result[i] *= suffix_product
16
            suffix_product *= values[i]
17
18
        19
        print("" "".join(map(str, result)))
20
21
22
T = int(input())  
23
test_cases = []
24
for _ in range(T):
25
    n = int(input())  
26
    values = list(map(int, input().split()))  
27
    test_cases.append((n, values))
28
product_of_all_except_self(test_cases)
29",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833257
1387833259,amanpandey9295,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
long long calculateOperations(int n, int k, int *energy) {
5
    long long total_energy = 0;
6
7
    // Calculate total energy
8
    for (int i = 0; i < n; i++) {
9
        total_energy += energy[i];
10
    }
11
12
    // Check if equalization is possible
13
    if (total_energy % n != 0) {
14
        return -1; // Not possible to equalize
15
    }
16
17
    long long target_energy = total_energy / n;
18
    long long current_balance = 0;
19
    long long operations = 0;
20
21
    // Traverse stations to calculate operations
22
    for (int i = 0; i < n; i++) {
23
        current_balance += (energy[i] - target_energy);
24
        25
        // The absolute value of current_balance represents how much energy
26
        // needs to be redistributed so far
27
        operations += llabs(current_balance);
28
    }
29
30
    return operations / k; // Divide by K (units of energy per operation)
31
}
32
33
int main() {
34
    int T;
35
    scanf(""%d"", &T); // Number of test cases
36
37
    while (T--) {
38
        int n, k;
39
        scanf(""%d %d"", &n, &k);
40
41
        int *energy = (int *)malloc(n * sizeof(int));
42
        for (int i = 0; i < n; i++) {
43
            scanf(""%d"", &energy[i]);
44
        }
45
46
        // Calculate and print the result for this test case
47
        printf(""%lld\n"", calculateOperations(n, k, energy));
48
49
        free(energy);
50
    }
51
52
    return 0;
53
}
54
55",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833259
1387833260,h1032220703,unknown,unknown,"1
import java.util.*;
2
3
public class PowerStationEqualizer {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
7
        // Read number of test cases
8
        int T = scanner.nextInt();
9
10
        for (int t = 0; t < T; t++) {
11
            // Read N and K
12
            int N = scanner.nextInt();
13
            int K = scanner.nextInt();
14
            15
            // Read energy levels
16
            int[] energy = new int[N];
17
            long totalEnergy = 0;
18
            for (int i = 0; i < N; i++) {
19
                energy[i] = scanner.nextInt();
20
                totalEnergy += energy[i];
21
            }
22
23
            // Check if equal distribution is possible
24
            if (totalEnergy % N != 0) {
25
                System.out.println(-1);
26
                continue;
27
            }
28
29
            int targetEnergy = (int) (totalEnergy / N);
30
            long operations = 0;
31
            long balance = 0; // Net balance carried over stations
32
33
            for (int i = 0; i < N; i++) {
34
                int diff = energy[i] - targetEnergy;
35
                balance += diff;
36
                37
                // Check if balance can be corrected in K-unit operations
38
                if (balance % K != 0) {
39
                    System.out.println(-1);
40
                    break;
41
                }
42
                43
                operations += Math.abs(balance / K);
44
45
                if (i == N - 1) {
46
                    System.out.println(operations);
47
                }
48
            }
49
        }
50
51
        scanner.close();
52
    }
53
}",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833260
1387833253,h1032220810,unknown,unknown,"1
def solve():
2
    n = int(input())
3
    nums = list(map(int, input().split()))
4
5
    max_diff = 0
6
    total_sum = sum(nums)
7
    current_sum = 0
8
9
    for i in range(n - 1):
10
        current_sum += nums[i]
11
        sum1 = current_sum
12
        sum2 = total_sum - sum1
13
        diff = abs(sum1 - sum2)
14
        max_diff = max(max_diff, diff)
15
16
    print(max_diff)
17
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833253
1387833254,sahilgupta75070,unknown,unknown,"1
def solve():
2
    # Read the number of test cases
3
    T = int(input())  
4
    5
    # Iterate over each test case
6
    for _ in range(T):
7
        # Read the number of nodes in this test case
8
        n = int(input())  
9
        10
        # Read the list of node values
11
        values = list(map(int, input().split())) 
12
        13
        # Initialize total product and zero count variables
14
        total_product = 1
15
        zero_count = 0
16
        zero_index = -1
17
        18
        # First pass: Calculate the total product and count zeroes
19
        for i in range(n):
20
            if values[i] != 0:
21
                total_product *= values[i]
22
            else:
23
                zero_count += 1
24
                zero_index = i
25
        26
        # Prepare the result array based on the number of zeroes
27
        result = []
28
        29
        if zero_count > 1:
30
            # If there are more than one zero, all results will be zero
31
            result = [0] * n
32
        elif zero_count == 1:
33
            # If there is exactly one zero, only the position with the zero will have the product
34
            for i in range(n):
35
                if i == zero_index:
36
                    result.append(total_product)
37
                else:
38
                    result.append(0)
39
        else:
40
            # If there are no zeros, we can directly compute result[i] = total_product / values[i]
41
            for i in range(n):
42
                result.append(total_product // values[i])  # Integer division
43
        44
        # Print the result for the current test case
45
        print("" "".join(map(str, result)))
46
47
# Call the function to process the input and produce the output
48
solve()
49",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833254
1387833255,h1032231268,unknown,unknown,"1
def solve_testcase(n, nums):
2
    # If array has only 2 elements, return their absolute difference
3
    if n == 2:
4
        return abs(nums[0] - nums[1])
5
    6
    # Calculate the total sum of the array
7
    total_sum = sum(nums)
8
    9
    max_diff = 0
10
    left_sum = 0
11
    12
    # Try each possible partition point
13
    # We need to ensure both subarrays are non-empty,
14
    # so we only go up to n-1 (leaving at least one element for the right subarray)
15
    for i in range(n-1):
16
        # Add current element to left sum
17
        left_sum += nums[i]
18
        # Right sum is the remaining elements
19
        right_sum = total_sum - left_sum
20
        # Calculate absolute difference
21
        curr_diff = abs(left_sum - right_sum)
22
        # Update max_diff if current difference is larger
23
        max_diff = max(max_diff, curr_diff)
24
    25
    return max_diff
26
27
def main():
28
    # Read number of test cases
29
    t = int(input())
30
    31
    # Process each test case
32
    for _ in range(t):
33
        # Read array size
34
        n = int(input())
35
        # Read array elements
36
        nums = list(map(int, input().split()))
37
        38
        # Solve current test case
39
        result = solve_testcase(n, nums)
40
        41
        # Print result
42
        print(result)
43
44
if __name__ == ""__main__"":
45
    main()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833255
1387833252,h1032231273,unknown,unknown,"1
def solve():
2
    T = int(input())  # Read number of test cases
3
    for _ in range(T):
4
        N, K = map(int, input().split())  # Read N and K
5
        energy = list(map(int, input().split()))  # Read energy array
6
        7
        # Step 1: Check if the total energy is divisible by N
8
        total_energy = sum(energy)
9
        10
        # If total energy is not divisible by N, return -1
11
        if total_energy % N != 0:
12
            print(-1)
13
            continue
14
        15
        target = total_energy // N  # Target energy each station should have
16
        operations = 0  # To count the number of operations
17
        18
        balance = 0  # To keep track of surplus or deficit of energy
19
        possible = True
20
        21
        for i in range(N):
22
            # Calculate the difference between current station energy and target
23
            energy_diff = energy[i] - target
24
            balance += energy_diff  # Update the balance
25
            # The balance must be a multiple of K to be valid
26
            if balance % K != 0:
27
                possible = False
28
                break
29
            # The absolute value of balance tells how many moves are needed
30
            operations += abs(balance) // K
31
        32
        if possible:
33
            print(operations)
34
        else:
35
            print(-1)
36
37
# Run the solution
38
solve()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833252
1387833245,sohamkadam0012,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
#include <stdbool.h>
4
5
// Function to calculate the minimum operations or check if equalization is impossible
6
int minOperationsToEqualize(int *energy, int n, int k) {
7
    long long totalEnergy = 0;
8
9
    // Calculate total energy
10
    for (int i = 0; i < n; i++) {
11
        totalEnergy += energy[i];
12
    }
13
14
    // Check if total energy is divisible by N
15
    if (totalEnergy % n != 0) {
16
        return -1; // Impossible to equalize
17
    }
18
19
    long long targetEnergy = totalEnergy / n; // Target energy for each station
20
    long long operations = 0;
21
    long long surplus = 0; // Tracks energy surplus or deficit in the cycle
22
23
    // Traverse each station and calculate the surplus or deficit
24
    for (int i = 0; i < n; i++) {
25
        surplus += energy[i] - targetEnergy;
26
27
        // If surplus is not divisible by K, return -1
28
        if (abs(surplus) % k != 0) {
29
            return -1;
30
        }
31
32
        // Add the number of operations needed for balancing the surplus
33
        operations += abs(surplus / k);
34
    }
35
36
    return operations;
37
}
38
39
int main() {
40
    int T;
41
    scanf(""%d"", &T);
42
43
    while (T--) {
44
        int n, k;
45
        scanf(""%d %d"", &n, &k);
46
47
        int *energy = (int *)malloc(n * sizeof(int));
48
        for (int i = 0; i < n; i++) {
49
            scanf(""%d"", &energy[i]);
50
        }
51
52
        // Edge Case: If all energy levels are the same, directly return 0
53
        bool alreadyEqual = true;
54
        for (int i = 1; i < n; i++) {
55
            if (energy[i] != energy[0]) {
56
                alreadyEqual = false;
57
                break;
58
            }
59
        }
60
61
        if (alreadyEqual) {
62
            printf(""0\n"");
63
        } else {
64
            int result = minOperationsToEqualize(energy, n, k);
65
            printf(""%d\n"", result);
66
        }
67
68
        free(energy);
69
    }
70
71
    return 0;
72
}
73",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833245
1387833243,nishashetty1002,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n = int(input())
4
    values = list(map(int, input().split()))
5
    6
    left = [1] * n
7
    for i in range(1, n):
8
        left[i] = left[i-1] * values[i-1]
9
    10
    right = [1] * n
11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * values[i+1]
13
    14
    res = [left[i] * right[i] for i in range(n)]
15
    print(' '.join(map(str, res)))",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833243
1387833251,omg40787,unknown,unknown,"1
def product_distribution(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n = t[0]
6
        values = t[1]
7
        8
        # Calculate the total product of all values
9
        total_product = 1
10
        zero_count = 0
11
        12
        for value in values:
13
            if value != 0:
14
                total_product *= value
15
            else:
16
                zero_count += 1
17
        18
        # Generate the result array
19
        result = []
20
        for value in values:
21
            if zero_count > 1:
22
                result.append(0)
23
            elif zero_count == 1:
24
                if value == 0:
25
                    result.append(total_product)
26
                else:
27
                    result.append(0)
28
            else:
29
                result.append(total_product // value)
30
        31
        results.append(result)
32
    33
    return results
34
35
# Example usage:
36
test_cases = [
37
    (5, [1, 2, 3, 4, 5]),
38
    (5, [10, 3, 5, 6, 2])
39
]
40
41
results = product_distribution(test_cases)
42
for result in results:
43
    print(' '.join(map(str, result)))
44",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833251
1387833240,ruchishree244,unknown,unknown,"1
import java.util.*;
2
3
public class EnergyEqualization {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt(); // Number of test cases
7
        StringBuilder result = new StringBuilder();
8
9
        while (T-- > 0) {
10
            int N = sc.nextInt(); // Number of stations
11
            int K = sc.nextInt(); // Units transferable in one operation
12
            long[] energy = new long[N]; // Use long to avoid overflow
13
            14
            long totalEnergy = 0;
15
            for (int i = 0; i < N; i++) {
16
                energy[i] = sc.nextLong();
17
                totalEnergy += energy[i];
18
            }
19
20
            // Check if equalization is possible
21
            if (totalEnergy % N != 0) {
22
                result.append(""-1\n"");
23
                continue;
24
            }
25
26
            long targetEnergy = totalEnergy / N;
27
            long surplus = 0;
28
            long operations = 0;
29
            boolean possible = true;
30
31
            for (int i = 0; i < N; i++) {
32
                long diff = energy[i] - targetEnergy;
33
34
                // Check if the difference is divisible by K
35
                if (diff % K != 0) {
36
                    possible = false;
37
                    break;
38
                }
39
40
                surplus += diff / K;
41
                operations += Math.abs(surplus);
42
            }
43
44
            result.append(possible ? operations : -1).append(""\n"");
45
        }
46
47
        System.out.print(result.toString());
48
        sc.close();
49
    }
50
}
51",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833240
1387833241,kadamaryan21418,unknown,unknown,"1
def solve_product_array(values, n):
2
    """"""
3
    Calculate product of all elements except self for each position.
4
    Uses O(1) extra space (not counting the output array).
5
    """"""
6
    # Handle edge cases
7
    if n < 2:
8
        return []
9
        10
    # Initialize result array
11
    result = [0] * n
12
    13
    # Calculate products using a two-pass approach
14
    15
    # First pass: Calculate products of all elements to the left
16
    # result[i] will store product of all elements left of i
17
    result[0] = 1
18
    for i in range(1, n):
19
        result[i] = values[i - 1] * result[i - 1]
20
    21
    # Second pass: Calculate products of all elements to the right
22
    # and multiply with existing left products
23
    right_product = 1
24
    for i in range(n - 1, -1, -1):
25
        result[i] = result[i] * right_product
26
        right_product *= values[i]
27
    28
    return result
29
30
def main():
31
    # Read number of test cases
32
    T = int(input())
33
    34
    # Process each test case
35
    for _ in range(T):
36
        # Read array size
37
        n = int(input())
38
        39
        # Read array values
40
        values = list(map(int, input().split()))
41
        42
        # Calculate result
43
        result = solve_product_array(values, n)
44
        45
        # Print result
46
        print("" "".join(map(str, result)))
47
48
if __name__ == ""__main__"":
49
    main()",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833241
1387833242,nishantsahu435,unknown,unknown,"1
def solve_energy_equalization(test_cases):
2
    results = []
3
4
    for t in range(test_cases):
5
        # Read N and K
6
        N, K = map(int, input().split())
7
        # Read energy array
8
        energy = list(map(int, input().split()))
9
10
        total_energy = sum(energy)
11
12
        # Check if it's possible to equalize
13
        if total_energy % N != 0:
14
            results.append(-1)
15
            continue
16
17
        target_energy = total_energy // N
18
        balance = 0
19
        operations = 0
20
21
        # Calculate the number of operations required
22
        for e in energy:
23
            balance += (e - target_energy)
24
            if balance % K != 0:
25
                results.append(-1)
26
                break
27
            operations += abs(balance) // K
28
        else:
29
            results.append(operations)
30
31
    for result in results:
32
        print(result)
33
34
# Input handling
35
if __name__ == ""__main__"":
36
    T = int(input())
37
    solve_energy_equalization(T)",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833242
1387833237,abhishekgoyalas1,unknown,unknown,"1
def product_except_self(arr, n):
2
    # Initialize prefix and suffix product arrays
3
    prefix = [1] * n
4
    suffix = [1] * n
5
    result = [1] * n
6
    7
    # Compute prefix product
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] * arr[i - 1]
10
    11
    # Compute suffix product
12
    for i in range(n - 2, -1, -1):
13
        suffix[i] = suffix[i + 1] * arr[i + 1]
14
    15
    # Compute result using prefix and suffix products
16
    for i in range(n):
17
        result[i] = prefix[i] * suffix[i]
18
    19
    return result
20
21
# Read number of test cases
22
T = int(input())
23
for _ in range(T):
24
    # Read number of elements
25
    n = int(input())
26
    # Read array elements
27
    arr = list(map(int, input().split()))
28
    # Get result and print
29
    print("" "".join(map(str, product_except_self(arr, n))))
30",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833237
1387833238,gpratik0990,unknown,unknown,"1
def calculate_results(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
        8
        # Create prefix and suffix arrays
9
        prefix = [1] * n
10
        suffix = [1] * n
11
        12
        # Compute prefix product
13
        for i in range(1, n):
14
            prefix[i] = prefix[i - 1] * values[i - 1]
15
        16
        # Compute suffix product
17
        for i in range(n - 2, -1, -1):
18
            suffix[i] = suffix[i + 1] * values[i + 1]
19
        20
        # Compute result array
21
        result = [prefix[i] * suffix[i] for i in range(n)]
22
        results.append(result)
23
    24
    return results
25
26
# Input reading
27
T = int(input())
28
test_cases = []
29
30
for _ in range(T):
31
    n = int(input())
32
    values = list(map(int, input().split()))
33
    test_cases.append((n, values))
34
35
# Process and output results
36
output = calculate_results(T, test_cases)
37
for res in output:
38
    print("" "".join(map(str, res)))",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833238
1387833239,sujalnegi421,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        result = [1] * n
6
        prefix = 1
7
        for i in range(n):
8
            result[i] = prefix
9
            prefix *= values[i]
10
        suffix = 1
11
        for i in range(n - 1, -1, -1):
12
            result[i] *= suffix
13
            suffix *= values[i]
14
        results.append(result)
15
    return results
16
17
t = int(input())
18
test_cases = []
19
for _ in range(t):
20
    n = int(input())
21
    values = list(map(int, input().split()))
22
    test_cases.append((n, values))
23
24
results = product_except_self(test_cases)
25
for result in results:
26
    print("" "".join(map(str, result)))",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833239
1387833236,vishpratik5,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833236
1387833230,h1032220352,unknown,unknown,"1
def solve():
2
    t = int(input())
3
    for _ in range(t):
4
        n = int(input())
5
        nums = list(map(int, input().split()))
6
        7
        total_sum = sum(nums)
8
        left_sum = 0
9
        max_difference = 0
10
        11
        for i in range(n - 1):
12
            left_sum += nums[i]
13
            right_sum = total_sum - left_sum
14
            max_difference = max(max_difference, abs(left_sum - right_sum))
15
        16
        print(max_difference)
17
18
if __name__ == ""__main__"":
19
    solve()
20",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833230
1387833235,h1032220167,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
    # Compute the prefix sum array
5
    prefix_sum = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
8
    9
    max_diff = 0
10
    11
    # Iterate through all possible split points
12
    for i in range(1, n):
13
        left_sum = prefix_sum[i]
14
        right_sum = prefix_sum[n] - prefix_sum[i]
15
        current_diff = abs(left_sum - right_sum)
16
        17
        # Update the maximum difference
18
        if current_diff > max_diff:
19
            max_diff = current_diff
20
    21
    return max_diff
22
23
def main():
24
    import sys
25
    input = sys.stdin.read
26
    data = input().split()
27
    28
    idx = 0
29
    t = int(data[idx])  # Number of test cases
30
    idx += 1
31
    32
    for _ in range(t):
33
        n = int(data[idx])  # Size of the array
34
        idx += 1
35
        nums = list(map(int, data[idx:idx + n]))  # Array elements
36
        idx += n
37
        38
        result = max_absolute_difference(nums)
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833235
1387833232,shubhamgupta3009,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int T = scanner.nextInt(); 
9
        10
        for (int t = 0; t < T; t++) {
11
            int N = scanner.nextInt(); 
12
            int K = scanner.nextInt(); 
13
            int[] energy = new int[N];
14
            long totalEnergy = 0;
15
16
            for (int i = 0; i < N; i++) {
17
                energy[i] = scanner.nextInt();
18
                totalEnergy += energy[i];
19
            }
20
21
            if (totalEnergy % N != 0) {
22
                System.out.println(-1);
23
                continue;
24
            }
25
26
            long targetEnergy = totalEnergy / N;
27
            long operations = 0;
28
            boolean possible = true;
29
30
            for (int i = 0; i < N; i++) {
31
                long diff = energy[i] - targetEnergy;
32
                if (diff % K != 0) {
33
                    possible = false;
34
                    break;
35
                }
36
                operations += Math.abs(diff) / K;
37
            }
38
39
            if (!possible) {
40
                System.out.println(-1);
41
            } else {
42
                System.out.println(operations / 2);
43
            }
44
        }
45
46
        scanner.close();
47
    }
48
}",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833232
1387833226,snehimehta02,unknown,unknown,"1
def compute_product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
    5
    prefix = 1
6
    for i in range(n):
7
        result[i] = prefix
8
        prefix *= values[i]
9
10
    suffix = 1
11
    for i in range(n - 1, -1, -1):
12
        result[i] *= suffix
13
        suffix *= values[i]
14
15
    return result
16
17
def main():
18
    T = int(input()) 
19
    results = []
20
21
    for _ in range(T):
22
        n = int(input())  
23
        values = list(map(int, input().split()))  
24
25
        result = compute_product_except_self(values)
26
        results.append(result)
27
28
    for result in results:
29
        print("" "".join(map(str, result)))
30
31
if __name__ == ""__main__"":
32
    main()
33",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833226
1387833225,prathameshbhoit1,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
   3
    prefix = [0] * n
4
    prefix[0] = nums[0]
5
    for i in range(1, n):
6
        prefix[i] = prefix[i - 1] + nums[i]
7
    8
    suffix = [0] * n
9
    suffix[n - 1] = nums[n - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] + nums[i]
12
    13
    max_diff = 0
14
    for i in range(n - 1):  
15
        left_sum = prefix[i]
16
        right_sum = suffix[i + 1]
17
        max_diff = max(max_diff, abs(left_sum - right_sum))
18
    19
    return max_diff
20
21
T = int(input().strip())  
22
for _ in range(T):
23
    N = int(input().strip()) 
24
    nums = list(map(int, input().strip().split())) 
25
    print(max_absolute_difference(N, nums))",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833225
1387833228,tritampanja444,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, nums = t
6
        total_sum = sum(nums)
7
        prefix_sum = 0
8
        max_diff = 0
9
        10
        # Iterate through possible partitions
11
        for i in range(n - 1):  # Last partition is invalid (requires two non-empty subarrays)
12
            prefix_sum += nums[i]
13
            suffix_sum = total_sum - prefix_sum
14
            max_diff = max(max_diff, abs(prefix_sum - suffix_sum))
15
        16
        results.append(max_diff)
17
    18
    return results
19
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Compute results
31
results = max_absolute_difference(test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)
36",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833228
1387833223,navinbohara5,unknown,unknown,"1
def product_except_self(arr, n):
2
    if n == 1:
3
        return [0]  
4
    5
  6
    prefix = [1] * n
7
    suffix = [1] * n
8
    result = [1] * n
9
10
   11
    for i in range(1, n):
12
        prefix[i] = prefix[i - 1] * arr[i - 1]
13
14
   15
    for i in range(n - 2, -1, -1):
16
        suffix[i] = suffix[i + 1] * arr[i + 1]
17
18
    19
    for i in range(n):
20
        result[i] = prefix[i] * suffix[i]
21
22
    return result
23
24
25
T = int(input())  
26
for _ in range(T):
27
    n = int(input())  
28
    arr = list(map(int, input().split()))  
29
30
    31
    print(*product_except_self(arr, n))
32",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833223
1387833224,adityapatil1306,unknown,unknown,"1
T = int(input())
2
3
for _ in range(T):
4
    n = int(input())
5
    values = list(map(int, input().split()))
6
7
    result = [0] * n
8
    total_product = 1
9
    zero_count = 0
10
11
    for value in values:
12
        if value == 0:
13
            zero_count += 1
14
        else:
15
            total_product *= value
16
17
    for i in range(n):
18
        if zero_count > 1:
19
            result[i] = 0
20
        elif zero_count == 1:
21
            if values[i] == 0:
22
                result[i] = total_product
23
            else:
24
                result[i] = 0
25
        else:
26
            result[i] = total_product // values[i]
27
28
    print("" "".join(map(str, result)))
29",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833224
1387833222,aditya_jha027,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K, energy = case
6
        total_energy = sum(energy)
7
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
12
        target = total_energy // N
13
        balance = 0
14
        max_operations = 0
15
16
        for e in energy:
17
            balance += (e - target)
18
            max_operations = max(max_operations, abs(balance))
19
20
        if max_operations % K != 0:
21
            results.append(-1)
22
        else:
23
            results.append(max_operations // K)
24
25
    return results
26
27
T = int(input())
28
test_cases = []
29
30
for _ in range(T):
31
    N, K = map(int, input().split())
32
    energy = list(map(int, input().split()))
33
    test_cases.append((N, K, energy))
34
35
output = min_operations_to_equalize(T, test_cases)
36
for res in output:
37
    print(res)
38",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833222
1387833219,gauravr6012,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
  7
    for i in range(1, n):
8
        left[i] = left[i - 1] * arr[i - 1]
9
10
   11
    for i in range(n - 2, -1, -1):
12
        right[i] = right[i + 1] * arr[i + 1]
13
14
   15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
20
t = int(input())
21
22
for _ in range(t):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result)
27",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833219
1387833214,h1032221511,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        left_sum = 0
7
        max_diff = 0
8
        for i in range(n - 1):
9
            left_sum += nums[i]
10
            right_sum = total_sum - left_sum
11
            max_diff = max(max_diff, abs(left_sum - right_sum))
12
        results.append(max_diff)
13
    return results
14
15
16
t = int(input())
17
test_cases = []
18
for _ in range(t):
19
    n = int(input())
20
    nums = list(map(int, input().split()))
21
    test_cases.append((n, nums))
22
23
results = max_absolute_difference(test_cases)
24
for res in results:
25
    print(res)
26",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833214
1387833216,h1032220835,unknown,unknown,"1
def max_abs_diff_partition(t, test_cases):
2
3
    results = []
4
5
    for case in test_cases:
6
7
        n, nums = case
8
9
        total_sum = sum(nums)
10
11
        prefix_sum = 0
12
13
        max_diff = 0
14
15
        # Iterate through the array and partition at every possible point
16
17
        for i in range(n - 1):  # We stop at n-1 because both subarrays must be non-empty
18
19
            prefix_sum += nums[i]
20
21
            suffix_sum = total_sum - prefix_sum
22
23
            diff = abs(prefix_sum - suffix_sum)
24
25
            max_diff = max(max_diff, diff)
26
27
        results.append(max_diff)
28
29
    return results
30
31
# Input and Output Handling
32
33
t = int(input())  # number of test cases
34
35
test_cases = []
36
37
for _ in range(t):
38
39
    n = int(input())  # size of the array
40
41
    nums = list(map(int, input().split()))  # the array
42
43
    test_cases.append((n, nums))
44
45
# Solve and Output Results
46
47
results = max_abs_diff_partition(t, test_cases)
48
49
for result in results:
50
51
    print(result)",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833216
1387833217,pjha9996,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        N, K = test_cases[t][""N""], test_cases[t][""K""]
6
        energy = test_cases[t][""energy""]
7
        8
        total_energy = sum(energy)
9
        10
        # Check if total energy is divisible by N
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target = total_energy // N  # Target energy for each station
16
        17
        # Calculate difference array to measure imbalance
18
        diff = [energy[i] - target for i in range(N)]
19
        20
        # Track prefix sum to balance the circle
21
        prefix_sum = 0
22
        operations = 0
23
24
        for i in range(N):
25
            prefix_sum += diff[i]
26
            if prefix_sum % K != 0:  # If imbalance cannot be resolved with K
27
                operations = -1
28
                break
29
            operations += abs(prefix_sum) // K
30
        31
        results.append(operations if operations != -1 else -1)
32
33
    return results
34
35
# Input handling
36
if __name__ == ""__main__"":
37
    T = int(input())
38
    test_cases = []
39
40
    for _ in range(T):
41
        N, K = map(int, input().split())
42
        energy = list(map(int, input().split()))
43
        test_cases.append({""N"": N, ""K"": K, ""energy"": energy})
44
45
    results = minimum_operations_to_equalize(T, test_cases)
46
47
    for res in results:
48
        print(res)
49",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833217
1387833207,pandeyadi120,unknown,unknown,"1
def solve_testcase(n, nums):
2
    # If array has only 2 elements, return their absolute difference
3
    if n == 2:
4
        return abs(nums[0] - nums[1])
5
    6
    # Calculate the total sum of the array
7
    total_sum = sum(nums)
8
    9
    max_diff = 0
10
    left_sum = 0
11
    12
    # Try each possible partition point
13
    # We need to ensure both subarrays are non-empty,
14
    # so we only go up to n-1 (leaving at least one element for the right subarray)
15
    for i in range(n-1):
16
        # Add current element to left sum
17
        left_sum += nums[i]
18
        # Right sum is the remaining elements
19
        right_sum = total_sum - left_sum
20
        # Calculate absolute difference
21
        curr_diff = abs(left_sum - right_sum)
22
        # Update max_diff if current difference is larger
23
        max_diff = max(max_diff, curr_diff)
24
    25
    return max_diff
26
27
def main():
28
    # Read number of test cases
29
    t = int(input())
30
    31
    # Process each test case
32
    for _ in range(t):
33
        # Read array size
34
        n = int(input())
35
        # Read array elements
36
        nums = list(map(int, input().split()))
37
        38
        # Solve current test case
39
        result = solve_testcase(n, nums)
40
        41
        # Print result
42
        print(result)
43
44
if __name__ == ""__main__"":
45
    main()",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833207
1387833208,yashasharma21005,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for test in test_cases:
4
        n, nums = test
5
        prefix = [0] * n
6
        suffix = [0] * n
7
        prefix[0] = nums[0]
8
        for i in range(1, n):
9
            prefix[i] = prefix[i - 1] + nums[i]
10
        suffix[-1] = nums[-1]
11
        for i in range(n - 2, -1, -1):
12
            suffix[i] = suffix[i + 1] + nums[i]
13
14
        max_diff = 0
15
        for i in range(n - 1):  # Partition at i
16
            left_sum = prefix[i]
17
            right_sum = suffix[i + 1]
18
            max_diff = max(max_diff, abs(left_sum - right_sum))
19
20
        results.append(max_diff)
21
22
    return results
23
24
t = int(input())
25
test_cases = []
26
for _ in range(t):
27
    n = int(input())
28
    nums = list(map(int, input().split()))
29
    test_cases.append((n, nums))
30
31
results = max_absolute_difference(t, test_cases)
32
for res in results:
33
    print(res)
34",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833208
1387833212,h1032220685,unknown,unknown,"1
with Ada.Text_IO; use Ada.Text_IO;
2
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
3
4
procedure Product_Except_Self is
5
   type Int_Array is array (Positive range <>) of Integer;
6
7
   -- Function to calculate the product array except self
8
   function Compute_Products (Values : Int_Array; N : Integer) return Int_Array is
9
      Prefix  : Int_Array (1 .. N) := (others => 1);
10
      Suffix  : Int_Array (1 .. N) := (others => 1);
11
      Result  : Int_Array (1 .. N) := (others => 0);
12
   begin
13
      -- Calculate Prefix products
14
      for I in 2 .. N loop
15
         Prefix(I) := Prefix(I - 1) * Values(I - 1);
16
      end loop;
17
18
      -- Calculate Suffix products
19
      for I in reverse 1 .. N - 1 loop
20
         Suffix(I) := Suffix(I + 1) * Values(I + 1);
21
      end loop;
22
23
      -- Compute result using Prefix and Suffix
24
      for I in 1 .. N loop
25
         Result(I) := Prefix(I) * Suffix(I);
26
      end loop;
27
28
      return Result;
29
   end Compute_Products;
30
31
   -- Main block for input and processing test cases
32
   T : Integer;
33
begin
34
   -- Input the number of test cases
35
   Get(T);
36
37
   for Test in 1 .. T loop
38
      declare
39
         N      : Integer;
40
         Values : Int_Array (1 .. 100_000);
41
      begin
42
         -- Input the size of the array
43
         Get(N);
44
45
         -- Read the values
46
         for I in 1 .. N loop
47
            Get(Values(I));
48
         end loop;
49
50
         -- Compute the result
51
         declare
52
            Result : Int_Array (1 .. N) := Compute_Products(Values, N);
53
         begin
54
            -- Print the result in the required format
55
            for I in 1 .. N loop
56
               if I > 1 then
57
                  Put("" ""); -- Add a space before every number except the first
58
               end if;
59
               declare
60
                  Image : String := Integer'Image(Result(I)); -- Get string representation
61
               begin
62
                  Put(Image(Image'First + 1 .. Image'Last)); -- Remove leading space
63
               end;
64
            end loop;
65
            New_Line;
66
         end;
67
      end;
68
   end loop;
69
end Product_Except_Self;
70",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833212
1387833200,sauravyadav244,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    prefix = [1] * n
4
    suffix = [1] * n
5
    result = [1] * n
6
    7
    # Compute prefix products
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] * values[i - 1]
10
    11
    # Compute suffix products
12
    for i in range(n - 2, -1, -1):
13
        suffix[i] = suffix[i + 1] * values[i + 1]
14
    15
    # Combine prefix and suffix
16
    for i in range(n):
17
        result[i] = prefix[i] * suffix[i]
18
    19
    return result
20
21
# Input reading
22
T = int(input())
23
results = []
24
for _ in range(T):
25
    n = int(input())
26
    values = list(map(int, input().split()))
27
    results.append(product_except_self(values))
28
29
# Output results
30
for res in results:
31
    print("" "".join(map(str, res)))
32",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833200
1387833202,angelaanindyajo1,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
   3
    prefix = [0] * n
4
    prefix[0] = nums[0]
5
    for i in range(1, n):
6
        prefix[i] = prefix[i - 1] + nums[i]
7
    8
    suffix = [0] * n
9
    suffix[n - 1] = nums[n - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] + nums[i]
12
    13
    max_diff = 0
14
    for i in range(n - 1):  
15
        left_sum = prefix[i]
16
        right_sum = suffix[i + 1]
17
        max_diff = max(max_diff, abs(left_sum - right_sum))
18
    19
    return max_diff
20
21
T = int(input().strip())  
22
for _ in range(T):
23
    N = int(input().strip()) 
24
    nums = list(map(int, input().strip().split())) 
25
    print(max_absolute_difference(N, nums))",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833202
1387833204,pankajchaudhar15,unknown,unknown,"1
def max_absolute_difference():
2
    t = int(input())  # Number of test cases
3
    results = []
4
    5
    for _ in range(t):
6
        n = int(input())  # Size of the array
7
        nums = list(map(int, input().split()))
8
        9
        # Compute prefix sums
10
        prefix_sum = [0] * n
11
        prefix_sum[0] = nums[0]
12
        for i in range(1, n):
13
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
14
        15
        # Total sum of the array
16
        total_sum = prefix_sum[-1]
17
        18
        # Calculate maximum absolute difference
19
        max_diff = 0
20
        for i in range(n - 1):
21
            left_sum = prefix_sum[i]
22
            right_sum = total_sum - left_sum
23
            max_diff = max(max_diff, abs(left_sum - right_sum))
24
        25
        # Store the result for the current test case
26
        results.append(max_diff)
27
    28
    # Print all results
29
    print(""\n"".join(map(str, results)))
30
31
# Example Usage
32
# Input according to the problem statement
33
max_absolute_difference()
34",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833204
1387833198,vnandini1530,unknown,unknown,"1
def solve_testcase(n, values):
2
    # Initialize result array
3
    result = [1] * n
4
    5
    # Calculate prefix products
6
    # result[i] will first store product of all elements to the left of i
7
    prefix = 1
8
    for i in range(n):
9
        result[i] = prefix
10
        prefix *= values[i]
11
    12
    # Calculate suffix products and combine with prefix products
13
    # For each position, multiply its prefix product with suffix product
14
    suffix = 1
15
    for i in range(n-1, -1, -1):
16
        result[i] *= suffix
17
        suffix *= values[i]
18
    19
    return result
20
21
def main():
22
    # Read number of test cases
23
    T = int(input())
24
    25
    # Process each test case
26
    for _ in range(T):
27
        # Read input for current test case
28
        n = int(input())
29
        values = list(map(int, input().split()))
30
        31
        # Solve current test case
32
        result = solve_testcase(n, values)
33
        34
        # Print result
35
        print(*result)
36
37
if __name__ == ""__main__"":
38
    main()
39",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833198
1387833193,arpit21345j,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <iostream>
4
#include <vector>
5
using namespace std;
6
7
vector<vector<int>> calculateProductExcludeSelf(vector<vector<int>>& testCases) {
8
    vector<vector<int>> results;
9
10
    for (const auto& values : testCases) {
11
        int n = values.size();
12
        vector<int> prefix(n, 1), suffix(n, 1), result(n, 0);
13
14
        for (int i = 1; i < n; ++i) {
15
            prefix[i] = prefix[i - 1] * values[i - 1];
16
        }
17
18
        for (int i = n - 2; i >= 0; --i) {
19
            suffix[i] = suffix[i + 1] * values[i + 1];
20
        }
21
22
        for (int i = 0; i < n; ++i) {
23
            result[i] = prefix[i] * suffix[i];
24
        }
25
26
        results.push_back(result);
27
    }
28
29
    return results;
30
}
31
32
int main() {
33
    int t;
34
    cin >> t;
35
    vector<vector<int>> testCases;
36
37
    for (int i = 0; i < t; ++i) {
38
        int n;
39
        cin >> n;
40
        vector<int> values(n);
41
        for (int j = 0; j < n; ++j) {
42
            cin >> values[j];
43
        }
44
        testCases.push_back(values);
45
    }
46
47
    vector<vector<int>> results = calculateProductExcludeSelf(testCases);
48
    for (const auto& res : results) {
49
        for (int num : res) {
50
            cout << num << "" "";
51
        }
52
        cout << endl;
53
    }
54
55
    return 0;
56
}
57",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833193
1387833195,harishpandey1704,unknown,unknown,"1
def compute_product(t):
2
    res = []
3
4
    for _ in range(t):
5
        n = int(input())
6
        arr = list(map(int, input().split()))
7
        ans = [0] * n
8
9
        prod = 1
10
        zero_cnt = 0
11
12
        for num in arr:
13
            if num != 0:
14
                prod *= num
15
            else:
16
                zero_cnt += 1
17
18
        for i in range(n):
19
            if zero_cnt > 1:
20
                ans[i] = 0
21
            elif zero_cnt == 1:
22
                ans[i] = prod if arr[i] == 0 else 0
23
            else:
24
                ans[i] = prod // arr[i]
25
26
        res.append(ans)
27
28
    for r in res:
29
        print("" "".join(map(str, r)))
30
31
32
if __name__ == ""__main__"":
33
    t = int(input())
34
    compute_product(t)
35",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833195
1387833197,gpratik0990,unknown,unknown,"1
def max_abs_diff_partition(t, test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        prefix_sum = 0
7
        max_diff = 0
8
9
        # Iterate through the array and partition at every possible point
10
        for i in range(n - 1):  # We stop at n-1 because both subarrays must be non-empty
11
            prefix_sum += nums[i]
12
            suffix_sum = total_sum - prefix_sum
13
            diff = abs(prefix_sum - suffix_sum)
14
            max_diff = max(max_diff, diff)
15
16
        results.append(max_diff)
17
18
    return results
19
20
# Input and Output Handling
21
t = int(input())  # number of test cases
22
test_cases = []
23
for _ in range(t):
24
    n = int(input())  # size of the array
25
    nums = list(map(int, input().split()))  # the array
26
    test_cases.append((n, nums))
27
28
# Solve and Output Results
29
results = max_abs_diff_partition(t, test_cases)
30
for result in results:
31
    print(result)",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833197
1387833188,jhakrishnachand1,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
    prefix = [0] * n
3
    prefix[0] = nums[0]
4
    for i in range(1, n):
5
        prefix[i] = prefix[i - 1] + nums[i]
6
7
    suffix = [0] * n
8
    suffix[n - 1] = nums[n - 1]
9
    for i in range(n - 2, -1, -1):
10
        suffix[i] = suffix[i + 1] + nums[i]
11
12
    max_diff = 0
13
    for i in range(n - 1):
14
        left_sum = prefix[i]
15
        right_sum = suffix[i + 1]
16
        max_diff = max(max_diff, abs(left_sum - right_sum))
17
18
    return max_diff
19
20
T = int(input().strip())
21
for _ in range(T):
22
    N = int(input().strip())
23
    nums = list(map(int, input().strip().split()))
24
    print(max_absolute_difference(N, nums))",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833188
1387833189,anushanchan33,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
   3
    prefix = [0] * n
4
    prefix[0] = nums[0]
5
    for i in range(1, n):
6
        prefix[i] = prefix[i - 1] + nums[i]
7
    8
    suffix = [0] * n
9
    suffix[n - 1] = nums[n - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] + nums[i]
12
    13
    max_diff = 0
14
    for i in range(n - 1):  
15
        left_sum = prefix[i]
16
        right_sum = suffix[i + 1]
17
        max_diff = max(max_diff, abs(left_sum - right_sum))
18
    19
    return max_diff
20
21
T = int(input().strip())  
22
for _ in range(T):
23
    N = int(input().strip()) 
24
    nums = list(map(int, input().strip().split())) 
25
    print(max_absolute_difference(N, nums))",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833189
1387833192,tejasvikhairnar,unknown,unknown,"1
def product_of_all_expect_current(values , n):
2
    result = [1] * n
3
    4
    left_prod = [1] * n
5
    right_prod = [1] * n
6
    7
    left_prod[0] = 1
8
    for i in range(1,n):
9
        left_prod[i] = left_prod[i - 1] * values[i - 1]
10
        11
    right_prod[n - 1] = 1
12
    for i in range(n - 2, -1, -1):
13
        right_prod[i] = right_prod[ i + 1] * values[i + 1]
14
        15
    for i in range(n):
16
        result[i] = left_prod[i] * right_prod[i]
17
        18
    return result
19
T = int(input())
20
21
for _ in range(T):
22
    n = int(input())
23
    values = list(map(int,input().split()))
24
    result = product_of_all_expect_current(values, n)
25
    print(*result)",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833192
1387833184,h1032231268,unknown,unknown,"1
def solve_testcase(N, K, energy):
2
    # Calculate total energy and target
3
    total_energy = sum(energy)
4
    5
    # Check if equal distribution is possible
6
    if total_energy % N != 0:
7
        return -1
8
    9
    target = total_energy // N
10
    11
    # If already equalized
12
    if all(e == target for e in energy):
13
        return 0
14
    15
    # For each position, calculate how many transfers are needed
16
    total_transfers = 0
17
    excess = 0  # Keep track of excess/deficit as we go around the circle
18
    19
    for i in range(N):
20
        # Current position's excess/deficit including previous remainder
21
        curr_with_excess = energy[i] + excess
22
        23
        # How far are we from target at this position
24
        diff_from_target = curr_with_excess - target
25
        26
        # This difference will need to be transferred to next position
27
        excess = diff_from_target
28
        29
        # If we need to make transfers
30
        if diff_from_target != 0:
31
            # If we can't transfer in K-unit chunks
32
            if abs(diff_from_target) % K != 0:
33
                return -1
34
                35
            # Add number of K-unit transfers needed
36
            total_transfers += abs(diff_from_target) // K
37
    38
    # After going around the circle, if there's any remainder, it's impossible
39
    if excess != 0:
40
        return -1
41
        42
    return total_transfers
43
44
def main():
45
    # Read number of test cases
46
    T = int(input())
47
    48
    # Process each test case
49
    for _ in range(T):
50
        # Read N and K
51
        N, K = map(int, input().split())
52
        53
        # Read energy array
54
        energy = list(map(int, input().split()))
55
        56
        # Solve current test case
57
        result = solve_testcase(N, K, energy)
58
        59
        # Print result
60
        print(result)
61
62
if __name__ == ""__main__"":
63
    main()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833184
1387833179,cjain1725,unknown,unknown,"1
def can_equalize(N, K, energy):
2
    """"""
3
    Determines if it's possible to equalize energy and returns minimum operations needed
4
    5
    Args:
6
        N (int): Number of power stations
7
        K (int): Units of energy that can be transferred in one operation
8
        energy (list): Array of energy values for each station
9
        10
    Returns:
11
        int: Minimum number of operations needed, or -1 if impossible
12
    """"""
13
    # Calculate total energy
14
    total_energy = sum(energy)
15
    16
    # Check if equal distribution is possible
17
    if total_energy % N != 0:
18
        return -1
19
    20
    # Target energy level for each station
21
    target = total_energy // N
22
    23
    # Check if each station can reach target with given K
24
    operations = 0
25
    diff_sum = 0  # Track total energy difference
26
    27
    # First pass: calculate required operations
28
    for i in range(N-1):
29
        diff = energy[i] - target
30
        diff_sum += diff
31
        # If absolute difference is not divisible by K, equalization is impossible
32
        if abs(diff_sum) % K != 0:
33
            return -1
34
        if diff_sum != 0:
35
            operations += 1
36
    37
    # Check last station
38
    final_diff = energy[N-1] - target
39
    if final_diff != -diff_sum:
40
        return -1
41
    42
    # If we made it here and diff_sum is not 0, we need one more operation
43
    if diff_sum != 0:
44
        operations += 1
45
    46
    return operations
47
48
def main():
49
    # Read number of test cases
50
    T = int(input())
51
    52
    # Process each test case
53
    for _ in range(T):
54
        # Read N and K
55
        N, K = map(int, input().split())
56
        57
        # Read energy values
58
        energy = list(map(int, input().split()))
59
        60
        # Calculate and print result
61
        result = can_equalize(N, K, energy)
62
        print(result)
63
64
if __name__ == ""__main__"":
65
    main()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833179
1387833178,aayushkrishnaut,unknown,unknown,"1
def max_subarray_difference(arr, n):
2
    max_diff = float('-inf')
3
    4
    # Try all possible partition points
5
    for i in range(1, n):
6
        # Calculate sums of left and right subarrays
7
        left_sum = sum(arr[:i])
8
        right_sum = sum(arr[i:])
9
        10
        # Calculate absolute difference
11
        diff = abs(left_sum - right_sum)
12
        max_diff = max(max_diff, diff)
13
    14
    return max_diff
15
16
def solve():
17
    # Read number of test cases
18
    t = int(input())
19
    20
    for _ in range(t):
21
        # Read array size
22
        n = int(input())
23
        24
        # Read array elements
25
        nums = list(map(int, input().split()))
26
        27
        # Calculate and print result
28
        result = max_subarray_difference(nums, n)
29
        print(result)
30
31
if __name__ == ""__main__"":
32
    solve()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833178
1387833172,h1032221506,unknown,unknown,"1
def calculate_product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
5
    prefix_product = 1
6
    for i in range(n):
7
        result[i] = prefix_product
8
        prefix_product *= values[i]
9
10
    suffix_product = 1
11
    for i in range(n - 1, -1, -1):
12
        result[i] *= suffix_product
13
        suffix_product *= values[i]
14
15
    return result
16
17
t = int(input())
18
outputs = []
19
20
for _ in range(t):
21
    n = int(input())
22
    values = list(map(int, input().split()))
23
    outputs.append(calculate_product_except_self(values))
24
25
for result in outputs:
26
    print("" "".join(map(str, result)))",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833172
1387833174,harsh_singh26011,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
vector<vector<long long>> computeProducts(int T, vector<pair<int, vector<int>>>& testCases) {
6
    vector<vector<long long>> results;
7
8
    for (int t = 0; t < T; ++t) {
9
        int n = testCases[t].first;
10
        vector<int>& values = testCases[t].second;
11
        12
        // Result vector
13
        vector<long long> result(n, 1);
14
15
        // Compute prefix products
16
        long long prefix = 1;
17
        for (int i = 0; i < n; ++i) {
18
            result[i] = prefix;
19
            prefix *= values[i];
20
        }
21
22
        // Compute suffix products and multiply with prefix
23
        long long suffix = 1;
24
        for (int i = n - 1; i >= 0; --i) {
25
            result[i] *= suffix;
26
            suffix *= values[i];
27
        }
28
29
        results.push_back(result);
30
    }
31
32
    return results;
33
}
34
35
int main() {
36
    int T;
37
    cin >> T;  // Number of test cases
38
    vector<pair<int, vector<int>>> testCases;
39
40
    for (int t = 0; t < T; ++t) {
41
        int n;
42
        cin >> n;  // Number of nodes
43
        vector<int> values(n);
44
        for (int i = 0; i < n; ++i) {
45
            cin >> values[i];
46
        }
47
        testCases.emplace_back(n, values);
48
    }
49
50
    // Compute results
51
    vector<vector<long long>> results = computeProducts(T, testCases);
52
53
    // Output results
54
    for (const auto& result : results) {
55
        for (size_t i = 0; i < result.size(); ++i) {
56
            if (i > 0) cout << "" "";
57
            cout << result[i];
58
        }
59
        cout << endl;
60
    }
61
62
    return 0;
63
}
64",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833174
1387833177,pandeyadi120,unknown,unknown,"1
def solve_testcase(N, K, energy):
2
    # Calculate total energy and target
3
    total_energy = sum(energy)
4
    5
    # Check if equal distribution is possible
6
    if total_energy % N != 0:
7
        return -1
8
    9
    target = total_energy // N
10
    11
    # If already equalized
12
    if all(e == target for e in energy):
13
        return 0
14
    15
    # For each position, calculate how many transfers are needed
16
    total_transfers = 0
17
    excess = 0  # Keep track of excess/deficit as we go around the circle
18
    19
    for i in range(N):
20
        # Current position's excess/deficit including previous remainder
21
        curr_with_excess = energy[i] + excess
22
        23
        # How far are we from target at this position
24
        diff_from_target = curr_with_excess - target
25
        26
        # This difference will need to be transferred to next position
27
        excess = diff_from_target
28
        29
        # If we need to make transfers
30
        if diff_from_target != 0:
31
            # If we can't transfer in K-unit chunks
32
            if abs(diff_from_target) % K != 0:
33
                return -1
34
                35
            # Add number of K-unit transfers needed
36
            total_transfers += abs(diff_from_target) // K
37
    38
    # After going around the circle, if there's any remainder, it's impossible
39
    if excess != 0:
40
        return -1
41
        42
    return total_transfers
43
44
def main():
45
    # Read number of test cases
46
    T = int(input())
47
    48
    # Process each test case
49
    for _ in range(T):
50
        # Read N and K
51
        N, K = map(int, input().split())
52
        53
        # Read energy array
54
        energy = list(map(int, input().split()))
55
        56
        # Solve current test case
57
        result = solve_testcase(N, K, energy)
58
        59
        # Print result
60
        print(result)
61
62
if __name__ == ""__main__"":
63
    main()",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833177
1387833166,sohamkadam0012,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
#include <stdbool.h>
4
5
// Function to calculate the minimum operations or check if equalization is impossible
6
int minOperationsToEqualize(int *energy, int n, int k) {
7
    long long totalEnergy = 0;
8
9
    // Calculate total energy
10
    for (int i = 0; i < n; i++) {
11
        totalEnergy += energy[i];
12
    }
13
14
    // Check if total energy is divisible by N
15
    if (totalEnergy % n != 0) {
16
        return -1; // Impossible to equalize
17
    }
18
19
    long long targetEnergy = totalEnergy / n; // Target energy for each station
20
    long long operations = 0;
21
    long long surplus = 0; // Tracks energy surplus or deficit in the cycle
22
23
    // Traverse each station and calculate the surplus or deficit
24
    for (int i = 0; i < n; i++) {
25
        surplus += energy[i] - targetEnergy;
26
27
        // Check if surplus can be transferred in multiples of K
28
        if (abs(surplus) % k != 0) {
29
            return -1;
30
        }
31
32
        // Add the number of operations needed for balancing the surplus
33
        operations += abs(surplus / k);
34
    }
35
36
    return operations;
37
}
38
39
int main() {
40
    int T;
41
    scanf(""%d"", &T);
42
43
    while (T--) {
44
        int n, k;
45
        scanf(""%d %d"", &n, &k);
46
47
        int *energy = (int *)malloc(n * sizeof(int));
48
        for (int i = 0; i < n; i++) {
49
            scanf(""%d"", &energy[i]);
50
        }
51
52
        int result = minOperationsToEqualize(energy, n, k);
53
        printf(""%d\n"", result);
54
55
        free(energy);
56
    }
57
58
    return 0;
59
}
60",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833166
1387833167,gpratik0990,unknown,unknown,"1
def equalize_energy(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][0]
5
        energy = test_cases[t][1]
6
7
        # Check if total energy is divisible by N
8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target = total_energy // N
14
        prefix_sum = 0
15
        operations = 0
16
        is_possible = True
17
18
        # Iterate through the array to calculate operations
19
        for i in range(N):
20
            diff = energy[i] - target
21
            prefix_sum += diff
22
            # Check if prefix_sum is divisible by K
23
            if prefix_sum % K != 0:
24
                is_possible = False
25
                break
26
            operations += abs(prefix_sum // K)
27
28
        if is_possible:
29
            results.append(operations)
30
        else:
31
            results.append(-1)
32
33
    return results
34
35
# Input and Output Handling
36
T = int(input())
37
test_cases = []
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append(((N, K), energy))
42
43
# Solve and Output Results
44
results = equalize_energy(T, test_cases)
45
for res in results:
46
    print(res)",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833167
1387833168,23jyotigaud,unknown,unknown,"1
import sys
2
input = sys.stdin.read
3
4
def solve():
5
    data = input().splitlines()
6
    idx = 0  
7
    T = int(data[idx])  
8
    idx += 1  
9
    results = []
10
    11
    for _ in range(T):
12
        N, K = map(int, data[idx].split())  
13
        idx += 1
14
        energy = list(map(int, data[idx].split()))
15
        idx += 1
16
        17
        total_energy = sum(energy)
18
        19
        if total_energy % N != 0:
20
            results.append(-1)
21
            continue
22
        23
        target = total_energy // N
24
        operations = 0
25
        current_balance = 0
26
        27
        for i in range(N):
28
            diff = energy[i] - target
29
            current_balance += diff
30
            if current_balance % K != 0:
31
                operations = -1
32
                break
33
            operations += abs(current_balance // K)
34
        35
        results.append(operations)
36
    37
    sys.stdout.write(""\n"".join(map(str, results)) + ""\n"")
38
39
solve()
40",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833168
1387833162,parabsaloni23,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    3
    total_energy = sum(energy)
4
    5
    6
    if total_energy % N != 0:
7
        return -1
8
    9
    10
    target = total_energy // N
11
    12
    operations = 0
13
    imbalance = 0
14
    15
    16
    for i in range(N):
17
        18
        imbalance += energy[i] - target
19
                     20
        if imbalance % K != 0:
21
            return -1
22
        23
        24
        operations += abs(imbalance) // K
25
    26
    return operations
27
28
29
30
31
32
T = int(input())  
33
for _ in range(T):
34
    N, K = map(int, input().split())  
35
    energy = list(map(int, input().split()))  
36
    37
   38
    result = min_operations_to_equalize(N, K, energy)
39
    print(result)",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833162
1387833164,singhrajbadri,unknown,unknown,"1
def equalize_energy(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
        8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        imbalance = 0
15
        operations = 0
16
        possible = True
17
        18
        for i in range(N):
19
            imbalance += energy[i] - target
20
            if imbalance % K != 0:
21
                possible = False
22
                break
23
            operations += abs(imbalance) // K
24
        25
        results.append(operations if possible else -1)
26
    27
    return results
28
29
T = int(input())
30
test_cases = []
31
32
for _ in range(T):
33
    N, K = map(int, input().split())
34
    energy = list(map(int, input().split()))
35
    test_cases.append(((N, K), energy))
36
results = equalize_energy(T, test_cases)
37
38
for result in results:
39
    print(result)
40",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833164
1387833163,h1032221562,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, nums = case
6
7
        prefix_sum = [0] * n
8
        suffix_sum = [0] * n
9
10
        prefix_sum[0] = nums[0]
11
        for i in range(1, n):
12
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
13
14
        suffix_sum[n - 1] = nums[n - 1]
15
        for i in range(n - 2, -1, -1):
16
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
17
18
        max_diff = 0
19
        for i in range(n - 1):
20
            left_sum = prefix_sum[i]
21
            right_sum = suffix_sum[i + 1]
22
            max_diff = max(max_diff, abs(left_sum - right_sum))
23
24
        results.append(max_diff)
25
26
    return results
27
28
T = int(input())
29
test_cases = []
30
for _ in range(T):
31
    n = int(input())
32
    nums = list(map(int, input().split()))
33
    test_cases.append((n, nums))
34
35
output = max_absolute_difference(test_cases)
36
for res in output:
37
    print(res)
38",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833163
1387833160,h1032231273,unknown,unknown,"1
def min_operations(n, k, energy):
2
    """"""
3
    Calculates the minimum number of operations required to equalize the energy across all stations.
4
5
    Args:
6
        n: The number of power stations.
7
        k: The number of energy units that can be transferred in one operation.
8
        energy: A list containing the energy of each power station.
9
10
    Returns:
11
        The minimum number of operations required, or -1 if it's impossible to equalize.
12
    """"""
13
14
    total_energy = sum(energy)
15
    if total_energy % n != 0:
16
        return -1  # Impossible to equalize if total energy is not divisible by n
17
18
    target_energy = total_energy // n
19
20
    operations = 0
21
    for i in range(n):
22
        diff = target_energy - energy[i]
23
        if diff > 0:
24
            operations += (diff + k - 1) // k  # Round up to the nearest multiple of k
25
26
    return operations
27
28
# Example usage
29
T = int(input())  # Number of test cases
30
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    energy = list(map(int, input().split()))
34
35
    result = min_operations(n, k, energy)
36
    print(result)
37",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833160
1387833154,princesharma8050,unknown,unknown,"1
def product_array(values):
2
    """"""
3
    Calculates the product of all elements in the array except the element at the current index.
4
5
    Args:
6
        values: A list of integers.
7
8
    Returns:
9
        A list of integers, where each element is the product of all other elements in the original list.
10
    """"""
11
12
    n = len(values)
13
    result = [1] * n
14
15
    # Calculate left product
16
    left_product = 1
17
    for i in range(n):
18
        result[i] = left_product
19
        left_product *= values[i]
20
21
    # Calculate right product
22
    right_product = 1
23
    for i in range(n - 1, -1, -1):
24
        result[i] *= right_product
25
        right_product *= values[i]
26
27
    return result
28
29
if __name__ == ""__main__"":
30
    T = int(input())
31
32
    for _ in range(T):
33
        n = int(input())
34
        values = list(map(int, input().split()))
35
36
        result = product_array(values)
37
        print(*result)",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833154
1387833157,radhikajoshi2519,unknown,unknown,"1
def product_except_self(values, n):
2
    # Initialize prefix and suffix arrays
3
    prefix = [1] * n
4
    suffix = [1] * n
5
    result = [1] * n
6
    7
    # Compute prefix product
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] * values[i - 1]
10
    11
    # Compute suffix product
12
    for i in range(n - 2, -1, -1):
13
        suffix[i] = suffix[i + 1] * values[i + 1]
14
    15
    # Compute result by multiplying prefix and suffix products
16
    for i in range(n):
17
        result[i] = prefix[i] * suffix[i]
18
    19
    return result
20
21
# Read input
22
T = int(raw_input())  # Number of test cases
23
for _ in range(T):
24
    n = int(raw_input())  # Number of nodes
25
    values = map(int, raw_input().split())  # Node values
26
    27
    # Compute the result for each test case
28
    result = product_except_self(values, n)
29
    30
    # Print the result
31
    print "" "".join(map(str, result))
32",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833157
1387833159,sanskriti_singh9,unknown,unknown,"1
def equalize_energy(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][0]  # Number of stations and K value
5
        energy = test_cases[t][1]  # Energy array
6
7
        # Calculate the total energy
8
        total_energy = sum(energy)
9
10
        # Check if equal distribution is possible
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target_energy = total_energy // N  # Energy each station should have
16
        operations = 0
17
        current_balance = 0
18
19
        # Iterate through the stations
20
        for i in range(N):
21
            # Calculate the balance at the current station
22
            current_balance += energy[i] - target_energy
23
24
            # If current balance isn't a multiple of K, it's not possible
25
            if current_balance % K != 0:
26
                results.append(-1)
27
                break
28
            operations += abs(current_balance) // K
29
        else:
30
            results.append(operations)
31
32
    return results
33
34
35
# Input
36
T = int(input())
37
test_cases = []
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append(((N, K), energy))
42
43
# Output
44
output = equalize_energy(T, test_cases)
45
for res in output:
46
    print(res)
47",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833159
1387833150,mtsn9699,unknown,unknown,"1
def min_operations_to_equalize(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
10
        target = total_energy // N
11
        excess_energy = 0
12
        operations = 0
13
14
        for i in range(N):
15
            excess_energy += energy[i] - target
16
            if excess_energy % K != 0:
17
                results.append(-1)
18
                break
19
            operations += abs(excess_energy) // K
20
        else:
21
            results.append(operations)
22
23
    return results
24
25
def main():
26
    T = int(input())
27
    test_cases = []
28
29
    for _ in range(T):
30
        N, K = map(int, input().split())
31
        energy = list(map(int, input().split()))
32
        test_cases.append((N, K, energy))
33
34
    results = min_operations_to_equalize(test_cases)
35
36
    for result in results:
37
        print(result)
38
39
if __name__ == ""__main__"":
40
    main()
41",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833150
1387833151,alstonsoares17,unknown,unknown,"1
def find_max_subarray_difference(n, nums):
2
    if n < 2:
3
        return 0
4
    prefix_sums = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_sums[i + 1] = prefix_sums[i] + nums[i]
7
    8
    max_difference = 0
9
    total_sum = prefix_sums[n]
10
    for i in range(n - 1):
11
        left_sum = prefix_sums[i + 1]
12
        right_sum = total_sum - left_sum
13
        current_difference = abs(left_sum - right_sum)
14
        max_difference = max(max_difference, current_difference)
15
    16
    return max_difference
17
18
t = int(input())
19
for _ in range(t):
20
    n = int(input())
21
    nums = list(map(int, input().split()))
22
    result = find_max_subarray_difference(n, nums)
23
    print(result)",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833151
1387833153,h1032220835,unknown,unknown,"1
def equalize_energy(T, test_cases):
2
3
    results = []
4
5
    for t in range(T):
6
7
        N, K = test_cases[t][0]
8
9
        energy = test_cases[t][1]
10
11
        # Check if total energy is divisible by N
12
13
        total_energy = sum(energy)
14
15
        if total_energy % N != 0:
16
17
            results.append(-1)
18
19
            continue
20
21
        target = total_energy // N
22
23
        prefix_sum = 0
24
25
        operations = 0
26
27
        is_possible = True
28
29
        # Iterate through the array to calculate operations
30
31
        for i in range(N):
32
33
            diff = energy[i] - target
34
35
            prefix_sum += diff
36
37
            # Check if prefix_sum is divisible by K
38
39
            if prefix_sum % K != 0:
40
41
                is_possible = False
42
43
                break
44
45
            operations += abs(prefix_sum // K)
46
47
        if is_possible:
48
49
            results.append(operations)
50
51
        else:
52
53
            results.append(-1)
54
55
    return results
56
57
# Input and Output Handling
58
59
T = int(input())
60
61
test_cases = []
62
63
for _ in range(T):
64
65
    N, K = map(int, input().split())
66
67
    energy = list(map(int, input().split()))
68
69
    test_cases.append(((N, K), energy))
70
71
# Solve and Output Results
72
73
results = equalize_energy(T, test_cases)
74
75
for res in results:
76
77
    print(res)",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833153
1387833147,h1032220810,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    energies = list(map(int, input().split()))
4
5
    total_energy = sum(energies)
6
    if total_energy % n != 0:
7
        print(-1)
8
        return
9
10
    target_energy = total_energy // n
11
    diff = [energies[i] - target_energy for i in range(n)]
12
    c_diff = [0] * n
13
    c_diff[0] = 0
14
    for i in range(1, n):
15
        c_diff[i] = c_diff[i-1] + diff[i-1]
16
17
    operations = 0
18
    for i in range(1, n):
19
        if c_diff[i] % k != 0:
20
            print(-1)
21
            return
22
        operations += abs(c_diff[i]) // k
23
24
    print(operations)
25
26
27
t = int(input())
28
for _ in range(t):
29
    solve()",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833147
1387833148,h1032220403,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, nums = case
6
7
        # Calculate prefix sums
8
        prefix_sum = [0] * n
9
        prefix_sum[0] = nums[0]
10
        for i in range(1, n):
11
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
12
13
        # Calculate maximum absolute difference
14
        total_sum = prefix_sum[-1]
15
        max_diff = 0
16
        for i in range(n - 1):
17
            left_sum = prefix_sum[i]
18
            right_sum = total_sum - left_sum
19
            max_diff = max(max_diff, abs(left_sum - right_sum))
20
21
        results.append(max_diff)
22
23
    return results
24
25
# Input
26
T = int(input())
27
test_cases = []
28
for _ in range(T):
29
    n = int(input())
30
    nums = list(map(int, input().split()))
31
    test_cases.append((n, nums))
32
33
# Process
34
results = max_absolute_difference(test_cases)
35
36
# Output
37
for result in results:
38
    print(result)",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833148
1387833146,chaussajjad,unknown,unknown,"1
def compute_results(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        n = test_cases[t][0]
5
        values = test_cases[t][1]
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [1] * n
9
        for i in range(1, n):
10
            prefix[i] = prefix[i - 1] * values[i - 1]
11
        for i in range(n - 2, -1, -1):
12
            suffix[i] = suffix[i + 1] * values[i + 1]
13
        for i in range(n):
14
            result[i] = prefix[i] * suffix[i]
15
        results.append(result)
16
    return results
17
18
T = int(input())
19
test_cases = []
20
for _ in range(T):
21
    n = int(input())
22
    values = list(map(int, input().split()))
23
    test_cases.append((n, values))
24
25
results = compute_results(T, test_cases)
26
for res in results:
27
    print("" "".join(map(str, res)))
28",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833146
1387833145,h1032220870,unknown,unknown,"1
def compute_result(values):
2
    n = len(values)
3
    prefix = [1] * n
4
    suffix = [1] * n
5
    result = [1] * n
6
7
    # Compute prefix product
8
    for i in range(1, n):
9
        prefix[i] = prefix[i - 1] * values[i - 1]
10
11
    # Compute suffix product
12
    for i in range(n - 2, -1, -1):
13
        suffix[i] = suffix[i + 1] * values[i + 1]
14
15
    # Compute result
16
    for i in range(n):
17
        result[i] = prefix[i] * suffix[i]
18
19
    return result
20
21
22
def main():
23
    t = int(input())  # Number of test cases
24
    results = []
25
26
    for _ in range(t):
27
        n = int(input())  # Number of nodes
28
        values = list(map(int, input().split()))  # Values of the nodes
29
        results.append(compute_result(values))
30
31
    for res in results:
32
        print("" "".join(map(str, res)))
33
34
35
# Example Input:
36
# 2
37
# 5
38
# 1 2 3 4 5
39
# 5
40
# 10 3 5 6 2
41
42
if __name__ == ""__main__"":
43
    main()
44",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833145
1387833142,h1032221641,unknown,unknown,"1
def main():
2
    import sys
3
    input = sys.stdin.read().split()
4
    idx = 0
5
    T = int(input[idx])
6
    idx += 1
7
    for _ in range(T):
8
        n = int(input[idx])
9
        idx += 1
10
        values = list(map(int, input[idx:idx+n]))
11
        idx += n
12
        13
        count_zeros = values.count(0)
14
        product_non_zero = 1
15
        for num in values:
16
            if num != 0:
17
                product_non_zero *= num
18
        19
        result = []
20
        for num in values:
21
            if count_zeros > 1:
22
                result.append(0)
23
            elif count_zeros == 1:
24
                if num == 0:
25
                    result.append(product_non_zero)
26
                else:
27
                    result.append(0)
28
            else:
29
                result.append(product_non_zero // num)
30
        31
        print(' '.join(map(str, result)))
32
33
if __name__ == ""__main__"":
34
    main()",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833142
1387833141,shikharguptaoct1,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
   3
    prefix = [0] * n
4
    prefix[0] = nums[0]
5
    for i in range(1, n):
6
        prefix[i] = prefix[i - 1] + nums[i]
7
    8
    suffix = [0] * n
9
    suffix[n - 1] = nums[n - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] + nums[i]
12
    13
    max_diff = 0
14
    for i in range(n - 1):  
15
        left_sum = prefix[i]
16
        right_sum = suffix[i + 1]
17
        max_diff = max(max_diff, abs(left_sum - right_sum))
18
    19
    return max_diff
20
21
T = int(input().strip())  
22
for _ in range(T):
23
    N = int(input().strip()) 
24
    nums = list(map(int, input().strip().split())) 
25
    print(max_absolute_difference(N, nums))",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833141
1387833143,h1032220108,unknown,unknown,"1
def solve_test_case(N, K, energy):
2
    total_energy = sum(energy)
3
    if total_energy % N != 0:
4
        return -1
5
        6
    target_energy = total_energy // N
7
    if all(e == target_energy for e in energy):
8
        return 0
9
    operations = 0
10
    energy_copy = energy.copy()
11
    for i in range(N):
12
        if energy_copy[i] > target_energy:
13
            excess = energy_copy[i] - target_energy
14
            if excess % K != 0:
15
                return -1
16
            operations += excess // K
17
            next_station = (i + 1) % N
18
            energy_copy[next_station] += excess
19
            20
        elif energy_copy[i] < target_energy:
21
            deficit = target_energy - energy_copy[i]
22
            if deficit % K != 0:
23
                return -1
24
                25
    return operations
26
27
def main():
28
    T = int(input()) 
29
    30
    for _ in range(T):
31
        N, K = map(int, input().split())
32
        energy = list(map(int, input().split()))
33
        result = solve_test_case(N, K, energy)
34
        print(result)
35
36
if __name__ == ""__main__"":
37
    main()",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833143
1387833139,pawanmudaliar081,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for t in range(test_cases):
4
        n = int(input())
5
        values = list(map(int, input().split()))
6
7
        total_product = 1
8
        zero_count = 0
9
        for val in values:
10
            if val == 0:
11
                zero_count += 1
12
            else:
13
                total_product *= val
14
15
16
        result = []
17
        for val in values:
18
            if zero_count > 1:
19
20
                result.append(0)
21
            elif zero_count == 1:
22
23
                if val == 0:
24
                    result.append(total_product)
25
                else:
26
                    result.append(0)
27
            else:
28
29
                result.append(total_product // val)
30
31
        results.append("" "".join(map(str, result)))
32
33
    print(""\n"".join(results))
34
35
36
if __name__ == ""__main__"":
37
    T = int(input())
38
    product_except_self(T)
39",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833139
1387833140,kadamshravani245,unknown,unknown,"1
def solve():
2
    t = int(input())  # Number of test cases
3
    4
    for _ in range(t):
5
        n = int(input())  # Size of the array
6
        nums = list(map(int, input().split()))  # The array
7
        8
        # Calculate the total sum of the array
9
        total_sum = sum(nums)
10
        11
        # Initialize variables to track the maximum difference
12
        max_diff = float('-inf')
13
        sum_left = 0
14
        15
        # Iterate through the array to consider all partition points
16
        for i in range(n - 1):
17
            sum_left += nums[i]
18
            sum_right = total_sum - sum_left
19
            max_diff = max(max_diff, abs(sum_left - sum_right))
20
        21
        # Output the maximum absolute difference for this test case
22
        print(max_diff)
23
24
# Read input and solve the problem
25
solve()
26",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833140
1387833138,h1032221029,unknown,unknown,"1
def solve_product_distribution(n, values):
2
3
    result = [1] * n
4
    5
   6
    prefix = 1
7
    for i in range(n):
8
        result[i] = prefix
9
        prefix *= values[i]
10
    11
   12
    suffix = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= suffix
15
        suffix *= values[i]
16
    17
    return result
18
19
def main():
20
    T = int(input())
21
    22
    for _ in range(T):
23
        n = int(input())
24
        values = list(map(int, input().split()))
25
        26
       27
        result = solve_product_distribution(n, values)
28
      29
        print("" "".join(map(str, result)))
30
31
if __name__ == ""__main__"":
32
    main()",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833138
1387833133,h1032231248,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    for _ in range(t):
4
        n, nums = test_cases[_]
5
        total_sum = sum(nums)
6
        prefix_sum = 0
7
        max_diff = 0
8
        9
        for i in range(n - 1):
10
            prefix_sum += nums[i]
11
            left_sum = prefix_sum
12
            right_sum = total_sum - prefix_sum
13
            max_diff = max(max_diff, abs(left_sum - right_sum))
14
        15
        results.append(max_diff)
16
    17
    return results
18
19
20
# Input and Output Handling
21
if __name__ == ""__main__"":
22
    t = int(input().strip())
23
    test_cases = []
24
    for _ in range(t):
25
        n = int(input().strip())
26
        nums = list(map(int, input().strip().split()))
27
        test_cases.append((n, nums))
28
    29
    results = max_absolute_difference(t, test_cases)
30
    print(""\n"".join(map(str, results)))
31",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833133
1387833134,vishpratik5,unknown,unknown,"1
import sys
2
3
def max_absolute_difference(n, nums):
4
    total_sum = sum(nums)
5
    max_diff = 0
6
    left_sum = 0
7
    8
    for i in range(n - 1):
9
        left_sum += nums[i]
10
        right_sum = total_sum - left_sum
11
        max_diff = max(max_diff, abs(left_sum - right_sum))
12
    13
    return max_diff
14
15
def main():
16
    input = sys.stdin.read
17
    data = input().split()
18
    index = 0
19
    20
    t = int(data[index])
21
    index += 1
22
    results = []
23
    24
    for _ in range(t):
25
        n = int(data[index])
26
        index += 1
27
        nums = list(map(int, data[index:index + n]))
28
        index += n
29
        30
        results.append(str(max_absolute_difference(n, nums)))
31
    32
    sys.stdout.write(""\n"".join(results) + ""\n"")
33
34
if __name__ == ""__main__"":
35
    main()
36",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833134
1387833137,harikeshyadav161,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
int min_operations_to_equalize(int n, int k, vector<int>& energy) {
7
    long long total_energy = 0;
8
9
    // Compute total energy
10
    for (int e : energy) {
11
        total_energy += e;
12
    }
13
14
    // Check if equalization is possible
15
    if (total_energy % n != 0) {
16
        return -1;
17
    }
18
19
    int target = total_energy / n;
20
    long long balance = 0; // Track surplus or deficit
21
    int operations = 0;
22
23
    for (int e : energy) {
24
        balance += (e - target);
25
        operations += abs(balance) / k;  // Convert surplus/deficit to operations
26
    }
27
28
    return operations;
29
}
30
31
int main() {
32
    int T;
33
    cin >> T; // Number of test cases
34
35
    while (T--) {
36
        int N, K;
37
        cin >> N >> K; // Read N and K
38
39
        vector<int> energy(N);
40
        for (int i = 0; i < N; i++) {
41
            cin >> energy[i]; // Read energy values
42
        }
43
44
        cout << min_operations_to_equalize(N, K, energy) << endl;
45
    }
46
47
    return 0;
48
}",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833137
1387833132,h1032220736,unknown,unknown,"1
def product_except_self(test_cases, inputs):
2
    index = 0
3
    results = []
4
    for t in range(test_cases):
5
        n = int(inputs[index])  # Number of nodes
6
        index += 1
7
        values = list(map(int, inputs[index].split()))
8
        index += 1
9
        10
        # Initialize prefix and suffix arrays
11
        prefix = [1] * n
12
        suffix = [1] * n
13
        result = [0] * n
14
        15
        # Compute prefix products
16
        for i in range(1, n):
17
            prefix[i] = prefix[i - 1] * values[i - 1]
18
        19
        # Compute suffix products
20
        for i in range(n - 2, -1, -1):
21
            suffix[i] = suffix[i + 1] * values[i + 1]
22
        23
        # Compute result array
24
        for i in range(n):
25
            result[i] = prefix[i] * suffix[i]
26
        27
        # Store the result as a string to join later
28
        results.append("" "".join(map(str, result)))
29
    30
    # Print all results for each test case
31
    print(""\n"".join(results))
32
33
# Input handling
34
raw_input = """"""2
35
5
36
1 2 3 4 5
37
5
38
10 3 5 6 2""""""
39
inputs = raw_input.split(""\n"")
40
T = int(inputs[0])  # Number of test cases
41
product_except_self(T, inputs[1:])
42",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833132
1387833127,mithileshtandon1,unknown,unknown,"1
def can_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
        7
    target_energy = total_energy // N
8
    operations = 0
9
    10
    differences = [energy[i] - target_energy for i in range(N)]
11
    12
    for diff in differences:
13
        if diff % K != 0:
14
            return -1
15
    16
    curr_transfer = 0
17
    for i in range(N-1):
18
        curr_transfer += differences[i]
19
        if curr_transfer != 0:
20
            operations += abs(curr_transfer) // K
21
    22
    curr_transfer += differences[N-1]
23
    if curr_transfer != 0:
24
        return -1
25
        26
    return operations
27
28
T = int(input())
29
for _ in range(T):
30
    N, K = map(int, input().split())
31
    energy = list(map(int, input().split()))
32
    result = can_equalize(N, K, energy)
33
    print(result)",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833127
1387833129,adityadav0412,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
    5
    left_product = 1
6
    for i in range(n):
7
        result[i] = left_product
8
        left_product *= values[i]
9
    10
    right_product = 1
11
    for i in range(n-1, -1, -1):
12
        result[i] *= right_product
13
        right_product *= values[i]
14
    15
    return result
16
17
def main():
18
    import sys
19
    input = sys.stdin.read
20
    data = input().split()
21
    22
    idx = 0
23
    T = int(data[idx])
24
    idx += 1
25
    26
    for _ in range(T):
27
        n = int(data[idx])
28
        idx += 1
29
        values = list(map(int, data[idx:idx+n]))
30
        idx += n
31
        32
        result = product_except_self(values)
33
        print(' '.join(map(str, result)))
34
35
if __name__ == ""__main__"":
36
    main()",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833129
1387833131,sonamyadav7208,unknown,unknown,"1
def solve():
2
    T = int(input())  # number of test cases
3
    for _ in range(T):
4
        n = int(input())  # number of nodes in the network
5
        values = list(map(int, input().split()))  # list of node values
6
7
        # Arrays to store the left and right products
8
        left = [1] * n
9
        right = [1] * n
10
        result = [0] * n
11
12
        # Fill the left array
13
        for i in range(1, n):
14
            left[i] = left[i - 1] * values[i - 1]
15
16
        # Fill the right array
17
        for i in range(n - 2, -1, -1):
18
            right[i] = right[i + 1] * values[i + 1]
19
20
        # Calculate result by multiplying corresponding left and right products
21
        for i in range(n):
22
            result[i] = left[i] * right[i]
23
24
        print("" "".join(map(str, result)))
25
26
# Call the function to run the solution
27
solve()
28",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833131
1387833124,maurya_anjali061,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    if total_energy % N != 0:
4
        return -1
5
    6
    target_energy = total_energy // N
7
    operations = 0
8
    balance = 0
9
10
    for i in range(N):
11
    12
        balance += energy[i] - target_energy
13
        14
     15
        operations += abs(balance) // K
16
    17
    return operations
18
19
T = int(input()) 
20
for _ in range(T):
21
    N, K = map(int, input().split())  
22
    energy = list(map(int, input().split()))  
23
    result = min_operations_to_equalize(N, K, energy)
24
    print(result)
25",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833124
1387833125,h1032231318,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for i in range(t):
5
        n = test_cases[i][0]
6
        nums = test_cases[i][1]
7
        8
        total_sum = sum(nums)
9
        10
        left_sum = 0
11
        max_difference = float('-inf')
12
        13
        for j in range(n - 1):
14
            left_sum += nums[j]
15
            right_sum = total_sum - left_sum
16
            max_difference = max(max_difference, abs(left_sum - right_sum))
17
        18
        results.append(max_difference)
19
    20
    return results
21
22
23
if __name__ == ""__main__"":
24
    t = int(input())  
25
    test_cases = []
26
    27
    for _ in range(t):
28
        n = int(input())  
29
        nums = list(map(int, input().split()))  
30
        test_cases.append((n, nums))
31
    32
    results = max_absolute_difference(t, test_cases)
33
    34
    for res in results:
35
        print(res)
36",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833125
1387833126,dhruvppaste20,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
int maxPartitionDifference(vector<int>& nums) {
7
    int n = nums.size();
8
    vector<long long> prefixSum(n + 1, 0);
9
    for(int i = 0; i < n; i++) {
10
        prefixSum[i + 1] = prefixSum[i] + nums[i];
11
    }
12
    13
    long long maxDiff = 0;
14
    for(int i = 1; i < n; i++) {
15
        long long leftSum = prefixSum[i];
16
        long long rightSum = prefixSum[n] - prefixSum[i];
17
        maxDiff = max(maxDiff, abs(leftSum - rightSum));
18
    }
19
    20
    return maxDiff;
21
}
22
23
int main() {
24
    ios_base::sync_with_stdio(false);
25
    cin.tie(NULL);
26
    27
    int t;
28
    cin >> t;
29
    30
    while(t--) {
31
        int n;
32
        cin >> n;
33
        34
        vector<int> nums(n);
35
        for(int i = 0; i < n; i++) {
36
            cin >> nums[i];
37
        }
38
        39
        cout << maxPartitionDifference(nums) << ""\n"";
40
    }
41
    42
    return 0;
43
}",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833126
1387833119,sunaym1006,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def product_distribution(T, test_cases):
3
    results = []
4
    5
    for t in range(T):
6
        n, values = test_cases[t]
7
        result = [1] * n
8
        9
        # Compute the prefix products
10
        prefix = [1] * n
11
        prefix[0] = values[0]
12
        for i in range(1, n):
13
            prefix[i] = prefix[i - 1] * values[i]
14
        15
        # Compute the suffix products
16
        suffix = [1] * n
17
        suffix[n - 1] = values[n - 1]
18
        for i in range(n - 2, -1, -1):
19
            suffix[i] = suffix[i + 1] * values[i]
20
        21
        # Calculate the result
22
        for i in range(n):
23
            if i == 0:
24
                result[i] = suffix[i + 1]
25
            elif i == n - 1:
26
                result[i] = prefix[i - 1]
27
            else:
28
                result[i] = prefix[i - 1] * suffix[i + 1]
29
        30
        results.append(result)
31
    32
    return results
33
34
# Input reading part (for use in competitive programming platforms)
35
T = int(input())  # number of test cases
36
test_cases = []
37
38
for _ in range(T):
39
    n = int(input())  # number of nodes
40
    values = list(map(int, input().split()))  # node values
41
    test_cases.append((n, values))
42
43
results = product_distribution(T, test_cases)
44
for res in results:
45
    print("" "".join(map(str, res)))
46",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833119
1387833120,sudhanshdubey75,unknown,unknown,"1
def min_operations(n, k, energy):
2
3
    """"""
4
5
    Calculates the minimum number of operations required to equalize the energy across all stations.
6
7
    Args:
8
9
      n: The number of power stations.
10
11
      k: The number of energy units that can be transferred in one operation.
12
13
      energy: A list of integers representing the energy of each station.
14
15
    Returns:
16
17
      The minimum number of operations required, or -1 if it's impossible to equalize.
18
19
    """"""
20
21
    total_energy = sum(energy)
22
23
    if total_energy % n != 0:
24
25
        return -1
26
27
    target_energy = total_energy // n
28
29
    operations = 0
30
31
    for i in range(n):
32
33
        diff = energy[i] - target_energy
34
35
        if diff > 0:
36
37
            operations += (diff + k - 1) // k  # Ceiling division
38
39
    return operations
40
41
# Get number of test cases
42
43
t = int(input())
44
45
for _ in range(t):
46
47
    n, k = map(int, input().split())
48
49
    energy = list(map(int, input().split()))
50
51
    result = min_operations(n, k, energy)
52
53
    print(result)",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833120
1387833122,aagnihotri2203,unknown,unknown,"1
def solve():
2
    import sys
3
    data = sys.stdin.read().strip().split()
4
    t = int(data[0])
5
    idx = 1
6
    7
    for _ in range(t):
8
        N = int(data[idx]); idx += 1
9
        K = int(data[idx]); idx += 1
10
        energies = list(map(int, data[idx:idx+N]))
11
        idx += N
12
        13
        total_energy = sum(energies)
14
        if total_energy % N != 0:
15
            print(-1)
16
            continue
17
18
        target = total_energy // N
19
        20
        diffs = []
21
        possible = True
22
        for e in energies:
23
            diff = e - target
24
            if diff % K != 0:
25
                possible = False
26
                break
27
            diffs.append(diff // K)
28
        29
        if not possible:
30
            print(-1)
31
            continue
32
        33
        prefix_sum = 0
34
        cost = 0
35
        for i in range(N - 1):
36
            prefix_sum += diffs[i]
37
            cost += abs(prefix_sum)
38
        39
        print(cost)
40
41
solve()",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833122
1387833117,ruchishree244,unknown,unknown,"1
import java.util.*;
2
3
public class EnergyEqualization {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt(); // Number of test cases
7
        StringBuilder result = new StringBuilder();
8
9
        while (T-- > 0) {
10
            int N = sc.nextInt(); // Number of stations
11
            int K = sc.nextInt(); // Units of energy transferable in one operation
12
            int[] energy = new int[N];
13
            14
            long totalEnergy = 0;
15
            for (int i = 0; i < N; i++) {
16
                energy[i] = sc.nextInt();
17
                totalEnergy += energy[i];
18
            }
19
            20
            // Check if equalization is possible
21
            if (totalEnergy % N != 0) {
22
                result.append(""-1\n"");
23
                continue;
24
            }
25
            26
            long targetEnergy = totalEnergy / N;
27
            long surplus = 0;
28
            long operations = 0;
29
            boolean possible = true;
30
31
            for (int i = 0; i < N; i++) {
32
                long diff = energy[i] - targetEnergy;
33
34
                // Check if the difference is divisible by K
35
                if (diff % K != 0) {
36
                    possible = false;
37
                    break;
38
                }
39
40
                // Accumulate surplus or deficit
41
                surplus += diff / K;
42
                operations += Math.abs(surplus);
43
            }
44
45
            result.append(possible ? operations : -1).append(""\n"");
46
        }
47
48
        System.out.print(result.toString());
49
        sc.close();
50
    }
51
}
52",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833117
1387833113,h1032221377,unknown,unknown,"1
def maxAbsoluteDifference(nums):
2
    n = len(nums)
3
    # Calculate prefix sums
4
    prefix_sum = [0] * n
5
    prefix_sum[0] = nums[0]
6
    for i in range(1, n):
7
        prefix_sum[i] = prefix_sum[i-1] + nums[i]
8
    9
    total_sum = prefix_sum[-1]
10
    max_diff = 0
11
    12
    for i in range(n-1):
13
        # Calculate the sum of the first subarray
14
        left_sum = prefix_sum[i]
15
        # Calculate the sum of the second subarray
16
        right_sum = total_sum - left_sum
17
        # Calculate the absolute difference and update max_diff
18
        max_diff = max(max_diff, abs(left_sum - right_sum))
19
    20
    return max_diff
21
22
# Input reading
23
t = int(input())  # Number of test cases
24
for _ in range(t):
25
    n = int(input())  # Size of the array
26
    nums = list(map(int, input().split()))  # Array elements
27
    print(maxAbsoluteDifference(nums))",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833113
1387833114,h1032231269,unknown,unknown,"1
def solve_testcase(N, K, energy):
2
    total_energy = sum(energy)
3
    if total_energy % N != 0:
4
        return -1
5
    target = total_energy // N
6
    if all(e == target for e in energy):
7
        return 0
8
    total_transfers = 0
9
    excess = 0
10
    for i in range(N):
11
        curr_with_excess = energy[i] + excess
12
        diff_from_target = curr_with_excess - target
13
        excess = diff_from_target
14
        if diff_from_target != 0:
15
            if abs(diff_from_target) % K != 0:
16
                return -1
17
            total_transfers += abs(diff_from_target) // K
18
    if excess != 0:
19
        return -1
20
    return total_transfers
21
22
def main():
23
    T = int(input())
24
    for _ in range(T):
25
        N, K = map(int, input().split())
26
        energy = list(map(int, input().split()))
27
        result = solve_testcase(N, K, energy)
28
        print(result)
29
30
if __name__ == ""__main__"":
31
    main()
32",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833114
1387833115,siddhikubal30,unknown,unknown,"1
def solve():
2
    T = int(input())  # Read number of test cases
3
    for _ in range(T):
4
        N, K = map(int, input().split())  # Read N and K
5
        energy = list(map(int, input().split()))  # Read energy array
6
        7
        # Step 1: Check if the total energy is divisible by N
8
        total_energy = sum(energy)
9
        10
        # If total energy is not divisible by N, return -1
11
        if total_energy % N != 0:
12
            print(-1)
13
            continue
14
        15
        target = total_energy // N  # Target energy each station should have
16
        operations = 0  # To count the number of operations
17
        18
        balance = 0  # To keep track of surplus or deficit of energy
19
        possible = True
20
        21
        for i in range(N):
22
            # Calculate the difference between current station energy and target
23
            energy_diff = energy[i] - target
24
            balance += energy_diff  # Update the balance
25
            # The balance must be a multiple of K to be valid
26
            if balance % K != 0:
27
                possible = False
28
                break
29
            # The absolute value of balance tells how many moves are needed
30
            operations += abs(balance) // K
31
        32
        if possible:
33
            print(operations)
34
        else:
35
            print(-1)
36
37
# Run the solution
38
solve()
39",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833115
1387833111,tritampanja444,unknown,unknown,"1
def minimum_operations_to_equalize(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        diffs = [energy[i] - target for i in range(N)]
15
        16
        # Check if all differences are divisible by K
17
        if any(diff % K != 0 for diff in diffs):
18
            results.append(-1)
19
            continue
20
        21
        # Calculate minimum operations
22
        operations = 0
23
        imbalance = 0
24
        25
        for diff in diffs:
26
            imbalance += diff // K
27
            operations += abs(imbalance)
28
        29
        results.append(operations)
30
    31
    return results
32
33
34
# Input handling
35
T = int(input())
36
test_cases = []
37
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append((N, K, energy))
42
43
# Compute results
44
results = minimum_operations_to_equalize(test_cases)
45
46
# Output results
47
for res in results:
48
    print(res)
49",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833111
1387833109,cjain1725,unknown,unknown,"1
def max_subarray_difference(n, nums):
2
    """"""
3
    Calculate maximum absolute difference between sums of two contiguous subarrays
4
    5
    Args:
6
        n (int): Length of array
7
        nums (list): Input array of integers
8
        9
    Returns:
10
        int: Maximum absolute difference possible
11
    """"""
12
    # We need to try all possible partitions
13
    # For each index i, we'll compare sum of elements before and after i
14
    max_diff = float('-inf')
15
    16
    # Calculate prefix sums for efficient subarray sum calculation
17
    prefix_sum = [0] * (n + 1)
18
    for i in range(n):
19
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]
20
    21
    # Try all possible partitions
22
    # We need at least one element in each partition
23
    for i in range(1, n):
24
        # Left subarray sum: from index 0 to i-1
25
        left_sum = prefix_sum[i]
26
        27
        # Right subarray sum: from index i to n-1
28
        right_sum = prefix_sum[n] - prefix_sum[i]
29
        30
        # Calculate absolute difference
31
        curr_diff = abs(left_sum - right_sum)
32
        33
        # Update maximum difference if current difference is larger
34
        max_diff = max(max_diff, curr_diff)
35
    36
    return max_diff
37
38
def main():
39
    # Read number of test cases
40
    t = int(input())
41
    42
    # Process each test case
43
    for _ in range(t):
44
        # Read array size
45
        n = int(input())
46
        47
        # Read array elements
48
        nums = list(map(int, input().split()))
49
        50
        # Calculate and print result
51
        result = max_subarray_difference(n, nums)
52
        print(result)
53
54
if __name__ == ""__main__"":
55
    main()",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833109
1387833112,h1032231268,unknown,unknown,"1
def solve_testcase(n, values):
2
    # Initialize result array
3
    result = [1] * n
4
    5
    # Calculate prefix products
6
    # result[i] will first store product of all elements to the left of i
7
    prefix = 1
8
    for i in range(n):
9
        result[i] = prefix
10
        prefix *= values[i]
11
    12
    # Calculate suffix products and combine with prefix products
13
    # For each position, multiply its prefix product with suffix product
14
    suffix = 1
15
    for i in range(n-1, -1, -1):
16
        result[i] *= suffix
17
        suffix *= values[i]
18
    19
    return result
20
21
def main():
22
    # Read number of test cases
23
    T = int(input())
24
    25
    # Process each test case
26
    for _ in range(T):
27
        # Read input for current test case
28
        n = int(input())
29
        values = list(map(int, input().split()))
30
        31
        # Solve current test case
32
        result = solve_testcase(n, values)
33
        34
        # Print result
35
        print(*result)
36
37
if __name__ == ""__main__"":
38
    main()",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833112
1387833105,pandeyadi120,unknown,unknown,"1
def solve_testcase(n, values):
2
    # Initialize result array
3
    result = [1] * n
4
    5
    # Calculate prefix products
6
    # result[i] will first store product of all elements to the left of i
7
    prefix = 1
8
    for i in range(n):
9
        result[i] = prefix
10
        prefix *= values[i]
11
    12
    # Calculate suffix products and combine with prefix products
13
    # For each position, multiply its prefix product with suffix product
14
    suffix = 1
15
    for i in range(n-1, -1, -1):
16
        result[i] *= suffix
17
        suffix *= values[i]
18
    19
    return result
20
21
def main():
22
    # Read number of test cases
23
    T = int(input())
24
    25
    # Process each test case
26
    for _ in range(T):
27
        # Read input for current test case
28
        n = int(input())
29
        values = list(map(int, input().split()))
30
        31
        # Solve current test case
32
        result = solve_testcase(n, values)
33
        34
        # Print result
35
        print(*result)
36
37
if __name__ == ""__main__"":
38
    main()",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833105
1387833107,pulekarswaradny,unknown,unknown,"1
def calculate_product_excluding_self(test_cases):
2
    results = []
3
4
    for t in range(test_cases):
5
        n = int(input())  # Number of nodes in the network
6
        values = list(map(int, input().split()))
7
8
        # Initialize prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
12
        # Calculate prefix products
13
        for i in range(1, n):
14
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
15
16
        # Calculate suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
19
20
        # Calculate result for the current test case
21
        result = [prefix_products[i] * suffix_products[i] for i in range(n)]
22
        results.append(result)
23
24
    return results
25
26
# Input
27
T = int(input())  # Number of test cases
28
output = calculate_product_excluding_self(T)
29
30
# Output results for all test cases
31
for res in output:
32
    print(*res)",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833107
1387833108,h1032221480,unknown,unknown,"1
def max_absolute_difference():
2
    t = int(input())  # Number of test cases
3
    results = []
4
    5
    for _ in range(t):
6
        n = int(input())  # Size of the array
7
        nums = list(map(int, input().split()))  # Array elements
8
        9
        # Calculate prefix sums
10
        prefix_sum = [0] * n
11
        prefix_sum[0] = nums[0]
12
        for i in range(1, n):
13
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
14
        15
        # Calculate total sum of the array
16
        total_sum = prefix_sum[-1]
17
        18
        # Calculate the maximum absolute difference
19
        max_diff = 0
20
        for i in range(n - 1):  # Split at each valid position
21
            left_sum = prefix_sum[i]
22
            right_sum = total_sum - left_sum
23
            max_diff = max(max_diff, abs(left_sum - right_sum))
24
        25
        results.append(max_diff)
26
    27
    # Print results for all test cases
28
    print(""\n"".join(map(str, results)))
29
30
31
# Call the function to execute
32
max_absolute_difference()
33",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833108
1387833104,tanmoy2005barua,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for nums in test_cases:
4
        n = len(nums)
5
        total_sum = sum(nums)
6
        7
        max_left_sum = float('-inf')
8
        min_left_sum = float('inf')
9
        current_sum = 0
10
        11
        for i in range(n - 1):  # We stop at n-1 to ensure both parts are non-empty
12
            current_sum += nums[i]
13
            max_left_sum = max(max_left_sum, current_sum)
14
            min_left_sum = min(min_left_sum, current_sum)
15
16
        max_difference = max(abs(total_sum - 2 * max_left_sum), abs(total_sum - 2 * min_left_sum))
17
        results.append(max_difference)
18
    19
    return results
20
21
try:
22
    t = int(input())
23
except EOFError:
24
    print(""No input provided."")
25
    t = 0
26
27
test_cases = []
28
for _ in range(t):
29
    n = int(input())
30
    nums = list(map(int, input().split()))
31
    test_cases.append(nums)
32
33
results = max_absolute_difference(test_cases)
34
for result in results:
35
    print(result)
36",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833104
1387833099,dhuvesh_salian,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
int main() {
7
    int T;
8
    cin >> T;
9
    10
    while (T--) {
11
        int N, K;
12
        cin >> N >> K;
13
        vector<int> energy(N);
14
        long long total_energy = 0;
15
        16
        for (int i = 0; i < N; ++i) {
17
            cin >> energy[i];
18
            total_energy += energy[i];
19
        }
20
        21
        if (total_energy % N != 0) {
22
            cout << -1 << endl;
23
            continue;
24
        }
25
        26
        int target = total_energy / N;
27
        vector<long long> prefix_diff(N, 0);
28
        long long imbalance = 0, operations = 0;
29
        30
        for (int i = 0; i < N; ++i) {
31
            imbalance += (energy[i] - target);
32
            operations += abs(imbalance);
33
        }
34
        35
        cout << operations / K << endl;
36
    }
37
    38
    return 0;
39
}
40",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833099
1387833102,mahekjitu20,unknown,unknown,"1
def compute_products(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
8
        # Initialize prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
12
        # Compute prefix products
13
        for i in range(1, n):
14
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
15
16
        # Compute suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
19
20
        # Compute result for each node
21
        result = [prefix_products[i] * suffix_products[i] for i in range(n)]
22
        results.append(result)
23
24
    return results
25
26
# Input handling
27
T = int(input())
28
test_cases = []
29
30
for _ in range(T):
31
    n = int(input())
32
    values = list(map(int, input().split()))
33
    test_cases.append((n, values))
34
35
# Compute results
36
results = compute_products(T, test_cases)
37
38
# Output results
39
for result in results:
40
    print("" "".join(map(str, result)))",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833102
1387833103,guptashrey856,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
    5
    # Calculate the product of all elements to the left of each index
6
    left_product = 1
7
    for i in range(n):
8
        result[i] = left_product
9
        left_product *= values[i]
10
    11
    # Calculate the product of all elements to the right of each index and multiply with the left product
12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    return result
18
19
def main():
20
    import sys
21
    input = sys.stdin.read
22
    data = input().split()
23
    24
    idx = 0
25
    T = int(data[idx])
26
    idx += 1
27
    28
    for _ in range(T):
29
        n = int(data[idx])
30
        idx += 1
31
        values = list(map(int, data[idx:idx+n]))
32
        idx += n
33
        34
        result = product_except_self(values)
35
        print(' '.join(map(str, result)))
36
37
if __name__ == ""__main__"":
38
    main()",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833103
1387833092,anushanchan33,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t[""N""], t[""K""], t[""energy""]
6
        total_energy = sum(energy)
7
        8
        # Check if equalization is possible
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
        13
        target = total_energy // N
14
        surplus = 0  # Tracks total surplus energy
15
        deficit = 0  # Tracks total deficit energy
16
        17
        # Calculate surplus and deficit
18
        possible = True
19
        for e in energy:
20
            diff = e - target
21
            if diff % K != 0:  # Check if transfer is possible
22
                possible = False
23
                break
24
            if diff > 0:
25
                surplus += diff // K
26
            else:
27
                deficit += (-diff) // K
28
        29
        if not possible or surplus != deficit:
30
            results.append(-1)
31
        else:
32
            results.append(surplus)
33
    34
    return results
35
36
37
# Input reading
38
T = int(input())
39
test_cases = []
40
for _ in range(T):
41
    N, K = map(int, input().split())
42
    energy = list(map(int, input().split()))
43
    test_cases.append({""N"": N, ""K"": K, ""energy"": energy})
44
45
# Output results
46
results = equalize_energy(test_cases)
47
print(""\n"".join(map(str, results)))
48",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833092
1387833095,hrichamehra11,unknown,unknown,"1
def min_operations_to_equalize(test_cases):
2
    results = []
3
    for n, k, energy in test_cases:
4
        total_energy = sum(energy)
5
        6
        if total_energy % n != 0:
7
            results.append(-1)
8
            continue
9
        10
        target_energy = total_energy // n
11
        operations = 0
12
        imbalance = 0
13
        14
        for e in energy:
15
            imbalance += e - target_energy
16
            operations += abs(imbalance) // k
17
        18
        if imbalance != 0:
19
            results.append(-1)
20
        else:
21
            results.append(operations)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
for _ in range(T):
28
    n, k = map(int, input().split())
29
    energy = list(map(int, input().split()))
30
    test_cases.append((n, k, energy))
31
32
output = min_operations_to_equalize(test_cases)
33
for res in output:
34
    print(res)
35",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833095
1387833093,ankitayadav25310,unknown,unknown,"1
def solve_testcase(n, nums):
2
    # If array has only 2 elements, return their absolute difference
3
    if n == 2:
4
        return abs(nums[0] - nums[1])
5
    6
    # Calculate the total sum of the array
7
    total_sum = sum(nums)
8
    9
    max_diff = 0
10
    left_sum = 0
11
    12
    # Try each possible partition point
13
    # We need to ensure both subarrays are non-empty,
14
    # so we only go up to n-1 (leaving at least one element for the right subarray)
15
    for i in range(n-1):
16
        # Add current element to left sum
17
        left_sum += nums[i]
18
        # Right sum is the remaining elements
19
        right_sum = total_sum - left_sum
20
        # Calculate absolute difference
21
        curr_diff = abs(left_sum - right_sum)
22
        # Update max_diff if current difference is larger
23
        max_diff = max(max_diff, curr_diff)
24
    25
    return max_diff
26
27
def main():
28
    # Read number of test cases
29
    t = int(input())
30
    31
    # Process each test case
32
    for _ in range(t):
33
        # Read array size
34
        n = int(input())
35
        # Read array elements
36
        nums = list(map(int, input().split()))
37
        38
        # Solve current test case
39
        result = solve_testcase(n, nums)
40
        41
        # Print result
42
        print(result)
43
44
if __name__ == ""__main__"":
45
    main()",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833093
1387833086,adiv40816,unknown,unknown,"1
import sys
2
3
def product_except_self(arr, n):
4
    # Step 1: Initialize prefix and suffix products
5
    prefix = [1] * n
6
    suffix = [1] * n
7
    result = [1] * n
8
    9
    # Step 2: Compute prefix products
10
    for i in range(1, n):
11
        prefix[i] = prefix[i - 1] * arr[i - 1]
12
    13
    # Step 3: Compute suffix products
14
    for i in range(n - 2, -1, -1):
15
        suffix[i] = suffix[i + 1] * arr[i + 1]
16
    17
    # Step 4: Compute result using prefix and suffix
18
    for i in range(n):
19
        result[i] = prefix[i] * suffix[i]
20
    21
    return result
22
23
# Read input
24
def main():
25
    t = int(sys.stdin.readline().strip())
26
    results = []
27
    for _ in range(t):
28
        n = int(sys.stdin.readline().strip())
29
        arr = list(map(int, sys.stdin.readline().strip().split()))
30
        results.append("" "".join(map(str, product_except_self(arr, n))))
31
    32
    # Print all results at once for efficiency
33
    sys.stdout.write(""\n"".join(results) + ""\n"")
34
35
if __name__ == ""__main__"":
36
    main()",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833086
1387833087,adityatripathi27,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    for _ in range(T):
4
        N, K = map(int, input().split())  # Read N and K
5
        energy = list(map(int, input().split()))  # Read energy array
6
        7
        total_energy = sum(energy)
8
        9
        # If total energy is not divisible by N, it's impossible to equalize
10
        if total_energy % N != 0:
11
            print(-1)
12
            continue
13
        14
        target_energy = total_energy // N  # Desired energy for each station
15
        imbalance = 0
16
        operations = 0
17
        18
        for i in range(N):
19
            # Calculate the difference between the current energy and the target energy
20
            imbalance += energy[i] - target_energy
21
            22
            # If imbalance is not a multiple of K, it's impossible to fix
23
            if imbalance % K != 0:
24
                print(-1)
25
                break
26
            # We add the number of operations required to fix the imbalance at the current station
27
            operations += abs(imbalance) // K
28
        29
        else:
30
            # If we completed the loop without breaking, print the result
31
            print(operations)
32
33
# Run the function
34
solve()
35",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833087
1387833088,aditya_jha027,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K, energy = case
6
        total_energy = sum(energy)
7
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
12
        target = total_energy // N
13
        balance = 0
14
        max_operations = 0
15
16
        for e in energy:
17
            balance += (e - target)
18
            max_operations = max(max_operations, abs(balance))
19
20
        if max_operations % K != 0:
21
            results.append(-1)
22
        else:
23
            results.append(max_operations // K)
24
25
    return results
26
27
T = int(input())
28
test_cases = []
29
30
for _ in range(T):
31
    N, K = map(int, input().split())
32
    energy = list(map(int, input().split()))
33
    test_cases.append((N, K, energy))
34
35
output = min_operations_to_equalize(T, test_cases)
36
for res in output:
37
    print(res)",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833088
1387833085,pjha9996,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
   3
    prefix = [0] * n
4
    prefix[0] = nums[0]
5
    for i in range(1, n):
6
        prefix[i] = prefix[i - 1] + nums[i]
7
    8
    suffix = [0] * n
9
    suffix[n - 1] = nums[n - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] + nums[i]
12
    13
    max_diff = 0
14
    for i in range(n - 1):  
15
        left_sum = prefix[i]
16
        right_sum = suffix[i + 1]
17
        max_diff = max(max_diff, abs(left_sum - right_sum))
18
    19
    return max_diff
20
21
T = int(input().strip())  
22
for _ in range(T):
23
    N = int(input().strip()) 
24
    nums = list(map(int, input().strip().split())) 
25
    print(max_absolute_difference(N, nums))",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833085
1387833084,kartikmadu2004,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n = int(input())
4
    values = list(map(int, input().split()))
5
    6
    left = [1] * n
7
    for i in range(1, n):
8
        left[i] = left[i-1] * values[i-1]
9
    10
    right = [1] * n
11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * values[i+1]
13
    14
    res = [left[i] * right[i] for i in range(n)]
15
    print(' '.join(map(str, res)))",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833084
1387833076,laxmimehta0506,unknown,unknown,"1
import java.util.Scanner;
2
3
public class EnergyEqualization {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        8
        int T = sc.nextInt();  // Number of test cases
9
        10
        for (int t = 0; t < T; t++) {
11
            int N = sc.nextInt();  // Number of stations
12
            int K = sc.nextInt();  // Units of energy that can be transferred in one operation
13
            int[] energy = new int[N];
14
            int totalEnergy = 0;
15
            16
            for (int i = 0; i < N; i++) {
17
                energy[i] = sc.nextInt();
18
                totalEnergy += energy[i];
19
            }
20
            21
            // If the total energy is not divisible by N, it is impossible to equalize
22
            if (totalEnergy % N != 0) {
23
                System.out.println(-1);
24
                continue;
25
            }
26
            27
            int targetEnergy = totalEnergy / N;
28
            int operations = 0;
29
            int delta = 0;
30
            31
            // Try to equalize the energy at each station
32
            for (int i = 0; i < N; i++) {
33
                // Calculate the current difference
34
                delta += energy[i] - targetEnergy;
35
                36
                // If the difference is not a multiple of K, it is impossible
37
                if (delta % K != 0) {
38
                    operations = -1;
39
                    break;
40
                }
41
                42
                // The number of operations is the sum of absolute differences divided by K
43
                operations += Math.abs(delta) / K;
44
            }
45
            46
            System.out.println(operations);
47
        }
48
        49
        sc.close();
50
    }
51
}
52",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833076
1387833077,prashant_ps9833,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        total_product = 1
6
        zero_count = 0
7
        8
        for num in values:
9
            if num == 0:
10
                zero_count += 1
11
            else:
12
                total_product *= num
13
        14
        result = []
15
        for num in values:
16
            if zero_count > 1:
17
                result.append(0)
18
            elif zero_count == 1:
19
                if num == 0:
20
                    result.append(total_product)
21
                else:
22
                    result.append(0)
23
            else:
24
                result.append(total_product // num)
25
        results.append(result)
26
    return results
27
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
for result in product_except_self(test_cases):
37
    print("" "".join(map(str, result)))",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833077
1387833073,h1032221771,unknown,unknown,"1
def equalize_energy(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][0]
5
        energy = test_cases[t][1]
6
7
        total_energy = sum(energy)
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
12
        target = total_energy // N
13
        prefix_sum = 0
14
        operations = 0
15
        is_possible = True
16
17
        for i in range(N):
18
            diff = energy[i] - target
19
            prefix_sum += diff
20
            21
            if prefix_sum % K != 0:
22
                is_possible = False
23
                break
24
            operations += abs(prefix_sum // K)
25
26
        if is_possible:
27
            results.append(operations)
28
        else:
29
            results.append(-1)
30
31
    return results
32
33
T = int(input())
34
test_cases = []
35
for _ in range(T):
36
    N, K = map(int, input().split())
37
    energy = list(map(int, input().split()))
38
    test_cases.append(((N, K), energy))
39
40
results = equalize_energy(T, test_cases)
41
for res in results:
42
    print(res)
43",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833073
1387833070,h1032221701,unknown,unknown,"1
def minimum_operations_to_equalize_energy(test_cases):
2
    results = []
3
    for n, k, energy in test_cases:
4
        total_energy = sum(energy)
5
        6
        # Check if equalization is possible
7
        if total_energy % n != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // n
12
        balance = 0
13
        operations = 0
14
        15
        # Calculate the number of operations
16
        for e in energy:
17
            balance += (e - target)
18
            # We count the absolute cumulative imbalance
19
            operations += abs(balance)
20
        21
        # Check if balance is zero after completing the cycle
22
        results.append(operations if balance == 0 else -1)
23
    24
    return results
25
26
# Input Reading
27
T = int(input())
28
test_cases = []
29
for _ in range(T):
30
    n, k = map(int, input().split())
31
    energy = list(map(int, input().split()))
32
    test_cases.append((n, k, energy))
33
34
# Compute and Output Results
35
results = minimum_operations_to_equalize_energy(test_cases)
36
for res in results:
37
    print(res)
38",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833070
1387833071,khushidoshi1978,unknown,unknown,"1
def max_abs_diff_partition(t, test_cases):
2
    for case in test_cases:
3
        n, nums = case
4
        total_sum = sum(nums)
5
        6
        7
        prefix_sum = [0] * (n + 1)
8
        for i in range(1, n + 1):
9
            prefix_sum[i] = prefix_sum[i - 1] + nums[i - 1]
10
        11
       12
        max_diff = 0
13
        14
        15
        for i in range(1, n):
16
            left_sum = prefix_sum[i]
17
            right_sum = total_sum - left_sum
18
            max_diff = max(max_diff, abs(left_sum - right_sum))
19
        20
        print(max_diff)
21
22
23
t = int(input())  
24
test_cases = []
25
26
for _ in range(t):
27
    n = int(input())  
28
    nums = list(map(int, input().split()))  
29
    test_cases.append((n, nums))
30
31
32
max_abs_diff_partition(t, test_cases)
33",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833071
1387833072,harikeshyadav161,unknown,unknown,"1
#include <iostream>
2
3
#include <vector>
4
5
#include <cmath>
6
7
using namespace std;
8
9
int min_operations_to_equalize(int n, int k, vector<int>& energy) {
10
11
    long long total_energy = 0;
12
13
    // Compute total energy
14
15
    for (int e : energy) {
16
17
        total_energy += e;
18
19
    }
20
21
    // Check if equalization is possible
22
23
    if (total_energy % n != 0) {
24
25
        return -1;
26
27
    }
28
29
    int target = total_energy / n;
30
31
    long long balance = 0; // Track surplus or deficit
32
33
    int operations = 0;
34
35
    for (int e : energy) {
36
37
        balance += (e - target);
38
39
        operations += abs(balance) / k;  // Convert surplus/deficit to operations
40
41
    }
42
43
    return operations;
44
45
}
46
47
int main() {
48
49
    int T;
50
51
    cin >> T; // Number of test cases
52
53
    while (T--) {
54
55
        int N, K;
56
57
        cin >> N >> K; // Read N and K
58
59
        vector<int> energy(N);
60
61
        for (int i = 0; i < N; i++) {
62
63
            cin >> energy[i]; // Read energy values
64
65
        }
66
67
        cout << min_operations_to_equalize(N, K, energy) << endl;
68
69
    }
70
71
    return 0;
72
73
}",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833072
1387833069,h1032221714,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    for _ in range(T):
4
        n = int(input())  # Number of nodes
5
        values = list(map(int, input().split()))  # List of node values
6
        7
        # Initialize result array
8
        result = [1] * n
9
        10
        # Create prefix product array
11
        prefix_product = [1] * n
12
        prefix_product[0] = values[0]
13
        for i in range(1, n):
14
            prefix_product[i] = prefix_product[i - 1] * values[i]
15
        16
        # Create suffix product array
17
        suffix_product = [1] * n
18
        suffix_product[n - 1] = values[n - 1]
19
        for i in range(n - 2, -1, -1):
20
            suffix_product[i] = suffix_product[i + 1] * values[i]
21
        22
        # Now calculate the result array by multiplying the corresponding prefix and suffix
23
        for i in range(n):
24
            if i == 0:
25
                result[i] = suffix_product[i + 1]
26
            elif i == n - 1:
27
                result[i] = prefix_product[i - 1]
28
            else:
29
                result[i] = prefix_product[i - 1] * suffix_product[i + 1]
30
        31
        # Print the result array
32
        print("" "".join(map(str, result)))
33
34
# Call the solve function
35
solve()",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833069
1387833067,kadamshravani245,unknown,unknown,"1
def minimum_operations():
2
    T = int(input())  # Number of test cases
3
    results = []
4
    5
    for _ in range(T):
6
        N, K = map(int, input().split())  # Number of stations and units of energy per operation
7
        energy = list(map(int, input().split()))  # Energy levels at each station
8
        9
        # Check if equalization is possible
10
        total_energy = sum(energy)
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        # Target energy level for each station
16
        target_energy = total_energy // N
17
        18
        # Calculate difference array
19
        diff = [energy[i] - target_energy for i in range(N)]
20
        21
        # Check if all differences are divisible by K
22
        if any(d % K != 0 for d in diff):
23
            results.append(-1)
24
            continue
25
        26
        # Count the number of operations needed
27
        operations = 0
28
        balance = 0
29
        for d in diff:
30
            balance += d // K
31
            operations += abs(balance)
32
        33
        results.append(operations)
34
    35
    # Print the results for all test cases
36
    print(""\n"".join(map(str, results)))
37
38
39
# Call the function to execute
40
minimum_operations()",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833067
1387833068,h1032231269,unknown,unknown,"1
def solve_testcase(n, values):
2
    result = [1] * n
3
    prefix = 1
4
    for i in range(n):
5
        result[i] = prefix
6
        prefix *= values[i]
7
    suffix = 1
8
    for i in range(n - 1, -1, -1):
9
        result[i] *= suffix
10
        suffix *= values[i]
11
    return result
12
13
def main():
14
    T = int(input())
15
    for _ in range(T):
16
        n = int(input())
17
        values = list(map(int, input().split()))
18
        result = solve_testcase(n, values)
19
        print(*result)
20
21
if __name__ == ""__main__"":
22
    main()
23",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833068
1387833066,h1032220167,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # Check if total energy is divisible by N
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target = total_energy // N  # Target energy for each station
9
    diff = [e - target for e in energy]  # Differences from the target
10
    11
    # Check if all differences are divisible by K
12
    if any(d % K != 0 for d in diff):
13
        return -1
14
    15
    # Calculate the cumulative sum of differences
16
    cumulative = 0
17
    operations = 0
18
    19
    for d in diff:
20
        cumulative += d
21
        operations += abs(cumulative) // K
22
    23
    return operations
24
25
def main():
26
    import sys
27
    input = sys.stdin.read
28
    data = input().split()
29
    30
    idx = 0
31
    T = int(data[idx])  # Number of test cases
32
    idx += 1
33
    34
    for _ in range(T):
35
        N = int(data[idx])  # Number of stations
36
        K = int(data[idx + 1])  # Units of energy to transfer
37
        idx += 2
38
        39
        energy = list(map(int, data[idx:idx + N]))  # Energy of each station
40
        idx += N
41
        42
        result = min_operations_to_equalize(N, K, energy)
43
        print(result)
44
45
if __name__ == ""__main__"":
46
    main()",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833066
1387833061,aryaprzz1,unknown,unknown,"1
def min_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, k, energy = case
6
        total_energy = sum(energy)
7
8
        # Check if total energy is divisible by N
9
        if total_energy % n != 0:
10
            results.append(-1)
11
            continue
12
13
        target = total_energy // n
14
        operations = 0
15
        16
        # Calculate prefix differences
17
        prefix_diff = 0
18
        for i in range(n):
19
            prefix_diff += energy[i] - target
20
            if prefix_diff % k != 0:
21
                operations = -1
22
                break
23
            operations += abs(prefix_diff) // k
24
25
        results.append(operations if operations != -1 else -1)
26
27
    return results
28
29
# Input reading and processing
30
def main():
31
    t = int(input())
32
    test_cases = []
33
34
    for _ in range(t):
35
        n, k = map(int, input().split())
36
        energy = list(map(int, input().split()))
37
        test_cases.append((n, k, energy))
38
39
    results = min_operations_to_equalize_energy(t, test_cases)
40
41
    for res in results:
42
        print(res)
43
44
if __name__ == ""__main__"":
45
    main()",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833061
1387833062,arshiyak572,unknown,unknown,"1
def product_of_others(n, values):
2
    # Initialize result array where result[i] will store the product of all elements except values[i]
3
    result = [1] * n
4
    5
    # First pass: Calculate the product of elements to the left of each index
6
    left_product = 1
7
    for i in range(n):
8
        result[i] = left_product
9
        left_product *= values[i]
10
    11
    # Second pass: Calculate the product of elements to the right of each index
12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    return result
18
19
# Reading input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n = int(input())  # Number of nodes in the network
23
    values = list(map(int, input().split()))  # List of node values
24
    25
    # Get the result for the current test case
26
    result = product_of_others(n, values)
27
    28
    # Print the result array
29
    print("" "".join(map(str, result)))
30",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833062
1387833063,h1032221519,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
    5
    # Calculate the product of all elements to the left of each index
6
    left_product = 1
7
    for i in range(n):
8
        result[i] = left_product
9
        left_product *= values[i]
10
    11
    # Calculate the product of all elements to the right of each index and multiply with the left product
12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    return result
18
19
def main():
20
    import sys
21
    input = sys.stdin.read
22
    data = input().split()
23
    24
    idx = 0
25
    T = int(data[idx])
26
    idx += 1
27
    28
    for _ in range(T):
29
        n = int(data[idx])
30
        idx += 1
31
        values = list(map(int, data[idx:idx+n]))
32
        idx += n
33
        34
        result = product_except_self(values)
35
        print(' '.join(map(str, result)))
36
37
if __name__ == ""__main__"":
38
    main()",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833063
1387833055,h1032220872,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
using namespace std;
5
6
long long minimumOperations(int N, int K, vector<int>& energy) {
7
    long long totalEnergy = accumulate(energy.begin(), energy.end(), 0LL);
8
9
    // Check if equalization is possible
10
    if (totalEnergy % N != 0) return -1;
11
    long long target = totalEnergy / N;
12
13
    vector<long long> difference(N, 0);
14
    for (int i = 0; i < N; ++i) {
15
        difference[i] = energy[i] - target;
16
    }
17
18
    long long cumulativeSum = 0;
19
    long long operations = 0;
20
21
    for (int i = 0; i < N; ++i) {
22
        cumulativeSum += difference[i];
23
        24
        // If cumulative sum isn't divisible by K, it's impossible
25
        if (cumulativeSum % K != 0) return -1;
26
27
        // Add absolute value of the current cumulative sum to operations
28
        operations += abs(cumulativeSum / K);
29
    }
30
31
    return operations;
32
}
33
34
int main() {
35
    int T;
36
    cin >> T; // Number of test cases
37
38
    while (T--) {
39
        int N, K;
40
        cin >> N >> K;
41
        vector<int> energy(N);
42
        for (int i = 0; i < N; ++i) {
43
            cin >> energy[i];
44
        }
45
46
        // Compute and print the result for this test case
47
        cout << minimumOperations(N, K, energy) << endl;
48
    }
49
50
    return 0;
51
}
52",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833055
1387833056,mtsn9699,unknown,unknown,"1
def compute_max_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        prefix_sum = [0] * n
6
        suffix_sum = [0] * n
7
8
        prefix_sum[0] = nums[0]
9
        for i in range(1, n):
10
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
11
12
        suffix_sum[n - 1] = nums[n - 1]
13
        for i in range(n - 2, -1, -1):
14
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
15
16
        max_diff = 0
17
        for i in range(n - 1):
18
            max_diff = max(max_diff, abs(prefix_sum[i] - suffix_sum[i + 1]))
19
20
        results.append(max_diff)
21
22
    return results
23
24
def main():
25
    t = int(input())
26
    test_cases = []
27
28
    for _ in range(t):
29
        n = int(input())
30
        nums = list(map(int, input().split()))
31
        test_cases.append((n, nums))
32
33
    results = compute_max_difference(test_cases)
34
35
    for result in results:
36
        print(result)
37
38
if __name__ == ""__main__"":
39
    main()
40",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833056
1387833059,amanpandey9295,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void calculateProductArray(int n, int *values) {
5
    int *prefix = (int *)malloc(n * sizeof(int));
6
    int *suffix = (int *)malloc(n * sizeof(int));
7
    int *result = (int *)malloc(n * sizeof(int));
8
9
    // Calculate prefix product
10
    prefix[0] = 1;
11
    for (int i = 1; i < n; i++) {
12
        prefix[i] = prefix[i - 1] * values[i - 1];
13
    }
14
15
    // Calculate suffix product
16
    suffix[n - 1] = 1;
17
    for (int i = n - 2; i >= 0; i--) {
18
        suffix[i] = suffix[i + 1] * values[i + 1];
19
    }
20
21
    // Calculate result[i] as prefix[i] * suffix[i]
22
    for (int i = 0; i < n; i++) {
23
        result[i] = prefix[i] * suffix[i];
24
    }
25
26
    // Print the result array
27
    for (int i = 0; i < n; i++) {
28
        printf(""%d "", result[i]);
29
    }
30
    printf(""\n"");
31
32
    // Free allocated memory
33
    free(prefix);
34
    free(suffix);
35
    free(result);
36
}
37
38
int main() {
39
    int T;
40
    scanf(""%d"", &T); // Number of test cases
41
42
    while (T--) {
43
        int n;
44
        scanf(""%d"", &n); // Number of nodes
45
46
        int *values = (int *)malloc(n * sizeof(int));
47
        for (int i = 0; i < n; i++) {
48
            scanf(""%d"", &values[i]); // Node values
49
        }
50
51
        // Calculate and print the result array for this test case
52
        calculateProductArray(n, values);
53
54
        free(values);
55
    }
56
57
    return 0;
58
}
59
60",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833059
1387833051,aayushkrishnaut,unknown,unknown,"1
def solve_energy_equalization():
2
    # Read number of test cases
3
    T = int(input())
4
    5
    for _ in range(T):
6
        # Read N and K
7
        N, K = map(int, input().split())
8
        9
        # Read energy values
10
        energy = list(map(int, input().split()))
11
        12
        # Check if equalization is possible
13
        total_energy = sum(energy)
14
        if total_energy % N != 0:
15
            print(-1)
16
            continue
17
            18
        target = total_energy // N
19
        operations = 0
20
        possible = True
21
        22
        # Keep track of excess/deficit at each position
23
        diff = [e - target for e in energy]
24
        25
        # Check if we can equalize with given K
26
        for i in range(N):
27
            if abs(diff[i]) % K != 0:
28
                possible = False
29
                break
30
                31
            # If current position has excess/deficit, it needs to be fixed
32
            if diff[i] != 0:
33
                # Transfer to next position
34
                next_pos = (i + 1) % N
35
                # Number of K-unit transfers needed
36
                transfers = abs(diff[i]) // K
37
                operations += transfers
38
                # Update next position's difference
39
                if diff[i] > 0:
40
                    diff[next_pos] += diff[i]
41
                else:
42
                    diff[next_pos] += diff[i]
43
                diff[i] = 0
44
        45
        # Final check - all differences should be 0
46
        if not possible or any(d != 0 for d in diff):
47
            print(-1)
48
        else:
49
            print(operations)
50
51
if __name__ == ""__main__"":
52
    solve_energy_equalization()",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833051
1387833046,01snehapandey01,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
10
    results = []
11
12
    for _ in range(T):
13
        # Read N and K
14
        N, K = map(int, data[idx].split())
15
        idx += 1
16
        # Read energy levels
17
        energy = list(map(int, data[idx].split()))
18
        idx += 1
19
20
        total_energy = sum(energy)
21
22
        # If the total energy is not divisible by N, it's impossible
23
        if total_energy % N != 0:
24
            results.append(""-1"")
25
            continue
26
27
        target_energy = total_energy // N
28
        operations = 0
29
        balance = 0
30
        possible = True
31
32
        # Check and calculate the number of operations required
33
        for e in energy:
34
            diff = e - target_energy
35
            balance += diff
36
            if balance % K != 0:
37
                possible = False
38
                break
39
            operations += abs(balance // K)
40
41
        results.append(str(operations) if possible else ""-1"")
42
43
    # Output all results
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833046
1387833048,mahekjitu20,unknown,unknown,"1
def maxAbsoluteDifference(nums):
2
    n = len(nums)
3
    # Calculate prefix sums
4
    prefix_sum = [0] * n
5
    prefix_sum[0] = nums[0]
6
    for i in range(1, n):
7
        prefix_sum[i] = prefix_sum[i-1] + nums[i]
8
    9
    total_sum = prefix_sum[-1]
10
    max_diff = 0
11
    12
    for i in range(n-1):
13
        # Calculate the sum of the first subarray
14
        left_sum = prefix_sum[i]
15
        # Calculate the sum of the second subarray
16
        right_sum = total_sum - left_sum
17
        # Calculate the absolute difference and update max_diff
18
        max_diff = max(max_diff, abs(left_sum - right_sum))
19
    20
    return max_diff
21
22
# Input reading
23
t = int(input())  # Number of test cases
24
for _ in range(t):
25
    n = int(input())  # Size of the array
26
    nums = list(map(int, input().split()))  # Array elements
27
    print(maxAbsoluteDifference(nums))
28",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833048
1387833050,h1032221511,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % N != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // N
10
        operations = 0
11
        surplus = 0
12
        for i in range(N):
13
            diff = energy[i] - target
14
            surplus += diff
15
            if surplus % K != 0:
16
                results.append(-1)
17
                break
18
            operations += abs(surplus // K)
19
        else:
20
            results.append(operations)
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    N, K = map(int, input().split())
27
    energy = list(map(int, input().split()))
28
    test_cases.append((N, K, energy))
29
30
results = minimum_operations(test_cases)
31
for res in results:
32
    print(res)
33",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833050
1387833042,h1032231273,unknown,unknown,"1
def solve():
2
    T = int(input())  # Read the number of test cases
3
    for _ in range(T):
4
        n = int(input())  # Number of nodes in this test case
5
        values = list(map(int, input().split()))  # Read the values array
6
        7
        # Step 1: Create the prefix product array
8
        prefix = [1] * n
9
        for i in range(1, n):
10
            prefix[i] = prefix[i - 1] * values[i - 1]
11
        12
        # Step 2: Create the suffix product array
13
        suffix = [1] * n
14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] * values[i + 1]
16
        17
        # Step 3: Compute the result array by multiplying prefix[i] and suffix[i]
18
        result = [prefix[i] * suffix[i] for i in range(n)]
19
        20
        # Step 4: Print the result for this test case
21
        print("" "".join(map(str, result)))
22
23
# Run the solution
24
solve()",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833042
1387833043,rahulgeorge1212,unknown,unknown,"1
def solve():
2
    # Read the number of test cases
3
    T = int(input())
4
5
    # Loop through each test case
6
    for _ in range(T):
7
        # Read the number of nodes (n)
8
        n = int(input())
9
10
        # Read the node values
11
        values = list(map(int, input().split()))
12
13
        # Initialize the result array and temporary variables for left and right products
14
        result = [1] * n
15
16
        # Left product calculation (store the products from the left side of each node)
17
        left_product = 1
18
        for i in range(n):
19
            result[i] = left_product
20
            left_product *= values[i]
21
22
        # Right product calculation (multiply the result with products from the right side of each node)
23
        right_product = 1
24
        for i in range(n-1, -1, -1):
25
            result[i] *= right_product
26
            right_product *= values[i]
27
28
        # Print the result array
29
        print("" "".join(map(str, result)))
30
31
# Call the solve function to execute
32
solve()",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833043
1387833044,sudhanshdubey75,unknown,unknown,"1
def product_array(arr):
2
3
    n = len(arr)
4
5
    left = [1] * n
6
7
    right = [1] * n
8
9
    # Calculate left product array
10
11
    for i in range(1, n):
12
13
        left[i] = left[i-1] * arr[i-1]
14
15
    # Calculate right product array
16
17
    for i in range(n-2, -1, -1):
18
19
        right[i] = right[i+1] * arr[i+1]
20
21
    # Calculate result array
22
23
    result = [left[i] * right[i] for i in range(n)]
24
25
    return result
26
27
# Get number of test cases
28
29
t = int(input())
30
31
for _ in range(t):
32
33
    n = int(input())
34
35
    arr = list(map(int, input().split()))
36
37
    result = product_array(arr)
38
39
    print(*result)",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833044
1387833038,harsh_singh26011,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int findMaxDifference(vector<int>& nums) {
9
    int n = nums.size();
10
    if (n < 2) return 0;
11
    12
    // Calculate prefix sums for efficient subarray sum computation
13
    vector<long long> prefixSum(n + 1, 0);
14
    for (int i = 0; i < n; i++) {
15
        prefixSum[i + 1] = prefixSum[i] + nums[i];
16
    }
17
    18
    // Try all possible partition points to find maximum difference
19
    long long maxDiff = 0;
20
    // We need at least one element in each partition
21
    for (int i = 1; i < n; i++) {
22
        // Left subarray sum: from 0 to i-1
23
        long long leftSum = prefixSum[i] - prefixSum[0];
24
        // Right subarray sum: from i to n-1
25
        long long rightSum = prefixSum[n] - prefixSum[i];
26
        27
        // Calculate absolute difference
28
        long long diff = abs(leftSum - rightSum);
29
        maxDiff = max(maxDiff, diff);
30
    }
31
    32
    return maxDiff;
33
}
34
35
int main() {
36
    int t;
37
    cin >> t;
38
    39
    while (t--) {
40
        int n;
41
        cin >> n;
42
        43
        vector<int> nums(n);
44
        for (int i = 0; i < n; i++) {
45
            cin >> nums[i];
46
        }
47
        48
        cout << findMaxDifference(nums) << endl;
49
    }
50
    51
    return 0;
52
}",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833038
1387833040,dishug2409,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    if total_energy % N != 0:
4
        return -1  # If the total energy is not divisible by N, equalization is impossible.
5
6
    target_energy = total_energy // N
7
    transfer_count = 0
8
    balance = 0
9
10
    for e in energy:
11
        balance += e - target_energy
12
        # Check if balance can be adjusted using K-unit transfers
13
        if balance % K != 0:
14
            return -1
15
        transfer_count += abs(balance // K)
16
17
    return transfer_count
18
19
# Input handling
20
T = int(input())  # Number of test cases
21
results = []
22
for _ in range(T):
23
    N, K = map(int, input().split())
24
    energy = list(map(int, input().split()))
25
    results.append(min_operations_to_equalize(N, K, energy))
26
27
# Output results
28
for result in results:
29
    print(result)
30",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833040
1387833041,harshtripathi752,unknown,unknown,"1
def calculateProducts(arr, n):
2
    if n < 2:
3
        return []
4
5
    result = [1] * n
6
    7
    leftProduct = 1
8
    for i in range(n):
9
        result[i] = leftProduct
10
        leftProduct *= arr[i]
11
    12
    rightProduct = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= rightProduct
15
        rightProduct *= arr[i]
16
    17
    return result
18
19
T = int(input())
20
21
for _ in range(T):
22
    n = int(input())
23
    values = list(map(int, input().split()))
24
    result = calculateProducts(values, n)
25
    print(*result)",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833041
1387833036,siddhikubal30,unknown,unknown,"1
def solve():
2
    T = int(input())  # Read the number of test cases
3
    for _ in range(T):
4
        n = int(input())  # Read the number of nodes in this test case
5
        values = list(map(int, input().split()))  # Read the values array
6
        7
        # Step 1: Initialize the result array
8
        result = [1] * n
9
        10
        # Step 2: Calculate prefix products and store in result
11
        prefix_product = 1
12
        for i in range(n):
13
            result[i] *= prefix_product
14
            prefix_product *= values[i]
15
        16
        # Step 3: Calculate suffix products and update result array
17
        suffix_product = 1
18
        for i in range(n - 1, -1, -1):
19
            result[i] *= suffix_product
20
            suffix_product *= values[i]
21
        22
        # Step 4: Print the result for this test case
23
        print("" "".join(map(str, result)))
24
25
# Run the solution
26
solve()
27",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833036
1387833034,h1032220703,unknown,unknown,"1
def min_operations_to_equalize_energy(n, k, energy):
2
    total_energy = sum(energy)
3
    4
    # Check if equalization is possible
5
    if total_energy % n != 0:
6
        return -1
7
8
    target_energy = total_energy // n
9
    transfer_operations = 0
10
    balance = 0
11
12
    for e in energy:
13
        # Calculate the difference from the target
14
        diff = e - target_energy
15
        balance += diff
16
17
        # Count the required operations
18
        transfer_operations += abs(balance) // k
19
20
    return transfer_operations
21
22
# Reading input
23
t = int(input())
24
for _ in range(t):
25
    n, k = map(int, input().strip().split())
26
    energy = list(map(int, input().strip().split()))
27
    result = min_operations_to_equalize_energy(n, k, energy)
28
    print(result)
29",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833034
1387833031,aryanrrsingh_04,unknown,unknown,"1
def maximum_absolute_difference(t, test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        7
        # Compute the prefix sum for the array
8
        prefix_sum = 0
9
        max_diff = 0
10
        11
        # Traverse through all possible partitions
12
        for i in range(n - 1):  # We must leave at least 1 element in the right subarray
13
            prefix_sum += nums[i]
14
            right_sum = total_sum - prefix_sum
15
            max_diff = max(max_diff, abs(prefix_sum - right_sum))
16
        17
        results.append(max_diff)
18
    19
    return results
20
21
# Input handling and function call
22
if __name__ == ""__main__"":
23
    t = int(input())  # Number of test cases
24
    test_cases = []
25
    for _ in range(t):
26
        n = int(input())  # Size of the array
27
        nums = list(map(int, input().split()))  # The array itself
28
        test_cases.append((n, nums))
29
    30
    results = maximum_absolute_difference(t, test_cases)
31
    for result in results:
32
        print(result)
33",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833031
1387833035,harishpandey1704,unknown,unknown,"1
def min_ops(t, cases):
2
    res = []
3
    4
    for case in cases:
5
        n, k, arr = case
6
        total = sum(arr)
7
8
        if total % n != 0:
9
            res.append(-1)
10
            continue
11
12
        target = total // n
13
        ops = 0
14
        diff = 0
15
16
        for i in range(n):
17
            diff += arr[i] - target
18
            if diff % k != 0:
19
                ops = -1
20
                break
21
            ops += abs(diff) // k
22
23
        res.append(ops if ops != -1 else -1)
24
25
    return res
26
27
def main():
28
    t = int(input())
29
    cases = []
30
31
    for _ in range(t):
32
        n, k = map(int, input().split())
33
        arr = list(map(int, input().split()))
34
        cases.append((n, k, arr))
35
36
    results = min_ops(t, cases)
37
38
    for r in results:
39
        print(r)
40
41
if __name__ == ""__main__"":
42
    main()
43",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833035
1387833026,h1032231317,unknown,unknown,"1
def min_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, energy = case
5
        total_energy = sum(energy)
6
        if total_energy % n != 0:
7
            results.append(-1)
8
            continue
9
        target = total_energy // n
10
        operations = 0
11
        prefix_diff = 0
12
        for i in range(n):
13
            prefix_diff += energy[i] - target
14
            if prefix_diff % k != 0:
15
                operations = -1
16
                break
17
            operations += abs(prefix_diff) // k
18
        results.append(operations if operations != -1 else -1)
19
    return results
20
def main():
21
    t = int(input())
22
    test_cases = []
23
    for _ in range(t):
24
        n, k = map(int, input().split())
25
        energy = list(map(int, input().split()))
26
        test_cases.append((n, k, energy))
27
    results = min_operations_to_equalize_energy(t, test_cases)
28
    for res in results:
29
        print(res)
30
if __name__ == ""__main__"":
31
    main()
32",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833026
1387833029,ruchishree244,unknown,unknown,"1
import java.util.*;
2
3
public class ProductExceptSelf {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
7
        int T = sc.nextInt(); // Number of test cases
8
        StringBuilder output = new StringBuilder();
9
10
        while (T-- > 0) {
11
            int n = sc.nextInt(); // Number of nodes
12
            int[] values = new int[n];
13
14
            for (int i = 0; i < n; i++) {
15
                values[i] = sc.nextInt();
16
            }
17
18
            // Array to store the result
19
            int[] result = new int[n];
20
21
            // Calculate prefix products
22
            int[] prefix = new int[n];
23
            prefix[0] = 1; // First element of prefix is 1
24
            for (int i = 1; i < n; i++) {
25
                prefix[i] = prefix[i - 1] * values[i - 1];
26
            }
27
28
            // Calculate suffix products and result
29
            int suffix = 1; // Initialize suffix to 1
30
            for (int i = n - 1; i >= 0; i--) {
31
                result[i] = prefix[i] * suffix;
32
                suffix *= values[i];
33
            }
34
35
            // Append results to the output
36
            for (int res : result) {
37
                output.append(res).append("" "");
38
            }
39
            output.append(""\n"");
40
        }
41
42
        System.out.print(output.toString());
43
        sc.close();
44
    }
45
}
46",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833029
1387833030,nishantsahu435,unknown,unknown,"1
def solve_product_except_self(test_cases):
2
    results = []
3
4
    for t in range(test_cases):
5
        n = int(input())
6
        values = list(map(int, input().split()))
7
8
        # Initialize prefix and suffix arrays
9
        prefix = [1] * n
10
        suffix = [1] * n
11
12
        # Calculate prefix products
13
        for i in range(1, n):
14
            prefix[i] = prefix[i - 1] * values[i - 1]
15
16
        # Calculate suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix[i] = suffix[i + 1] * values[i + 1]
19
20
        # Calculate result array
21
        result = [prefix[i] * suffix[i] for i in range(n)]
22
        results.append(result)
23
24
    for result in results:
25
        print("" "".join(map(str, result)))
26
27
# Input handling
28
if __name__ == ""__main__"":
29
    T = int(input())
30
    solve_product_except_self(T)",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833030
1387833021,shuklajaikishan1,unknown,unknown,"1
def product_except_self(arr, n):
2
    result = [1] * n
3
    left_product = 1
4
    for i in range(n):
5
        result[i] = left_product
6
        left_product *= arr[i]
7
    8
    right_product = 1
9
    for i in range(n - 1, -1, -1):
10
        result[i] *= right_product
11
        right_product *= arr[i]
12
    13
    return result
14
15
# Read input
16
def main():
17
    T = int(input())  # Number of test cases
18
    19
    for _ in range(T):
20
        n = int(input())  # Number of nodes
21
        arr = list(map(int, input().split()))  # Node values
22
        23
        # Compute and print result
24
        print("" "".join(map(str, product_except_self(arr, n))))
25
26
if __name__ == ""__main__"":
27
    main()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833021
1387833022,sohamkadam0012,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
#include <stdbool.h>
4
5
// Function to calculate the minimum operations or check if equalization is impossible
6
int minOperationsToEqualize(int *energy, int n, int k) {
7
    long long totalEnergy = 0;
8
9
    // Calculate total energy
10
    for (int i = 0; i < n; i++) {
11
        totalEnergy += energy[i];
12
    }
13
14
    // Check if total energy is divisible by N
15
    if (totalEnergy % n != 0) {
16
        return -1; // Impossible to equalize
17
    }
18
19
    long long targetEnergy = totalEnergy / n; // Target energy for each station
20
    long long operations = 0;
21
    long long surplus = 0; // Tracks energy surplus or deficit in the cycle
22
23
    // Traverse each station and calculate the surplus or deficit
24
    for (int i = 0; i < n; i++) {
25
        surplus += energy[i] - targetEnergy;
26
27
        // Check if surplus can be transferred in multiples of K
28
        if (surplus % k != 0) {
29
            return -1;
30
        }
31
32
        // Add the number of operations needed for balancing the surplus
33
        operations += abs(surplus / k);
34
    }
35
36
    return operations;
37
}
38
39
int main() {
40
    int T;
41
    scanf(""%d"", &T);
42
43
    while (T--) {
44
        int n, k;
45
        scanf(""%d %d"", &n, &k);
46
47
        int *energy = (int *)malloc(n * sizeof(int));
48
        for (int i = 0; i < n; i++) {
49
            scanf(""%d"", &energy[i]);
50
        }
51
52
        int result = minOperationsToEqualize(energy, n, k);
53
        printf(""%d\n"", result);
54
55
        free(energy);
56
    }
57
58
    return 0;
59
}
60",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833022
1387833024,h1032221473,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        # If total energy is not divisible by N, equalization is impossible
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target_energy = total_energy // N
16
        17
        # Calculate the net energy transfer needed at each station
18
        transfers = [energy[i] - target_energy for i in range(N)]
19
20
        # Check if the transfers can be achieved with the given K
21
        cumulative_transfer = 0
22
        possible = True
23
        operations = 0
24
25
        for transfer in transfers:
26
            cumulative_transfer += transfer
27
            if cumulative_transfer % K != 0:
28
                possible = False
29
                break
30
            operations += abs(cumulative_transfer // K)
31
32
        results.append(operations if possible else -1)
33
34
    return results
35
36
def max_absolute_difference(T, test_cases):
37
    results = []
38
39
    for t in range(T):
40
        n = test_cases[t][0]
41
        nums = test_cases[t][1]
42
43
        prefix_sum = [0] * n
44
        suffix_sum = [0] * n
45
46
        # Compute prefix sums
47
        prefix_sum[0] = nums[0]
48
        for i in range(1, n):
49
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
50
51
        # Compute suffix sums
52
        suffix_sum[n - 1] = nums[n - 1]
53
        for i in range(n - 2, -1, -1):
54
            suffix_sum[i] = suffix_sum[i + 1] + nums[i]
55
56
        # Calculate maximum absolute difference
57
        max_diff = 0
58
        for i in range(n - 1):
59
            diff = abs(prefix_sum[i] - suffix_sum[i + 1])
60
            max_diff = max(max_diff, diff)
61
62
        results.append(max_diff)
63
64
    return results
65
66
def main():
67
    T = int(input())
68
    test_cases = []
69
70
    for _ in range(T):
71
        N = int(input())
72
        nums = list(map(int, input().split()))
73
        test_cases.append((N, nums))
74
75
    results = max_absolute_difference(T, test_cases)
76
    for result in results:
77
        print(result)
78
79
if __name__ == ""__main__"":
80
    main()
81",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833024
1387833020,mithileshtandon1,unknown,unknown,"1
def calculate_product_distribution(n, values):
2
    if n < 2:
3
        return []
4
    5
    result = [1] * n
6
    7
    left_product = 1
8
    for i in range(n):
9
        result[i] = left_product
10
        left_product *= values[i]
11
    12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    return result
18
19
T = int(input())
20
for _ in range(T):
21
    n = int(input())
22
    values = list(map(int, input().split()))
23
    result = calculate_product_distribution(n, values)
24
    print("" "".join(map(str, result)))",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833020
1387833016,vg2556519,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
   3
    prefix = [0] * n
4
    prefix[0] = nums[0]
5
    for i in range(1, n):
6
        prefix[i] = prefix[i - 1] + nums[i]
7
    8
    suffix = [0] * n
9
    suffix[n - 1] = nums[n - 1]
10
    for i in range(n - 2, -1, -1):
11
        suffix[i] = suffix[i + 1] + nums[i]
12
    13
    max_diff = 0
14
    for i in range(n - 1):  
15
        left_sum = prefix[i]
16
        right_sum = suffix[i + 1]
17
        max_diff = max(max_diff, abs(left_sum - right_sum))
18
    19
    return max_diff
20
21
T = int(input().strip())  
22
for _ in range(T):
23
    N = int(input().strip()) 
24
    nums = list(map(int, input().strip().split())) 
25
    print(max_absolute_difference(N, nums))
26",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833016
1387833018,shshloka,unknown,unknown,"1
import sys
2
3
def main():
4
    t = int(sys.stdin.readline())
5
    for _ in range(t):
6
        n = int(sys.stdin.readline())
7
        values = list(map(int, sys.stdin.readline().split()))
8
        if n == 0:
9
            print()
10
            continue
11
        left = [1] * n
12
        for i in range(1, n):
13
            left[i] = left[i-1] * values[i-1]
14
        right_product = 1
15
        result = [0] * n
16
        for i in range(n-1, -1, -1):
17
            result[i] = left[i] * right_product
18
            right_product *= values[i]
19
        print(' '.join(map(str, result)))
20
21
if __name__ == ""__main__"":
22
    main()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833018
1387833017,anushanchan33,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        N, K, energy = t[""N""], t[""K""], t[""energy""]
6
        total_energy = sum(energy)
7
        8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
        12
        target = total_energy // N
13
        surplus = 0  
14
        deficit = 0  
15
        16
 17
        for e in energy:
18
            diff = e - target
19
            if diff % K != 0:
20
                results.append(-1)
21
                break
22
            if diff > 0:
23
                surplus += diff // K
24
            else:
25
                deficit += (-diff) // K
26
        else:
27
           28
            if surplus == deficit:
29
                results.append(surplus)
30
            else:
31
                results.append(-1)
32
    33
    return results
34
35
36
T = int(input())
37
test_cases = []
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append({""N"": N, ""K"": K, ""energy"": energy})
42
43
44
results = equalize_energy(test_cases)
45
print(""\n"".join(map(str, results)))
46",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833017
1387833009,tanmoy2005barua,unknown,unknown,"1
def min_operations_to_equalize_energy(test_cases):
2
    results = []
3
    for N, K, energies in test_cases:
4
        total_energy = sum(energies)
5
        if total_energy % N != 0:
6
            results.append(-1)
7
            continue
8
        9
        target_energy = total_energy // N
10
        operations = 0
11
        current_balance = 0
12
        13
        for energy in energies:
14
            current_balance += (energy - target_energy)
15
            if current_balance % K != 0:
16
                operations = -1
17
                break
18
            operations += abs(current_balance) // K
19
        20
        results.append(operations if operations != -1 else -1)
21
    22
    return results
23
24
try:
25
    T = int(input())
26
except EOFError:
27
    print(""No input provided."")
28
    T = 0
29
30
test_cases = []
31
for _ in range(T):
32
    N, K = map(int, input().split())
33
    energies = list(map(int, input().split()))
34
    test_cases.append((N, K, energies))
35
36
results = min_operations_to_equalize_energy(test_cases)
37
for result in results:
38
    print(result)
39",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833009
1387833011,h1032231318,unknown,unknown,"1
def equalize_energy(test_cases):
2
    results = []
3
4
    for _ in range(test_cases):
5
        N, K = map(int, input().split())
6
        energy = list(map(int, input().split()))
7
8
        total_energy = sum(energy)
9
        if total_energy % N != 0:
10
            results.append(-1)
11
            continue
12
13
        target_energy = total_energy // N
14
15
        operations = 0
16
        current_diff = 0
17
18
        for e in energy:
19
            current_diff += (e - target_energy)
20
            if current_diff % K != 0:
21
                results.append(-1)
22
                break
23
            operations += abs(current_diff) // K
24
        else:
25
            results.append(operations)
26
27
    for res in results:
28
        print(res)
29
30
31
if __name__ == ""__main__"":
32
    T = int(input())  
33
    equalize_energy(T)
34",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833011
1387833012,pankajchaudhar15,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def minimum_operations_to_equalize():
3
    T = int(input())  # Number of test cases
4
    results = []
5
    6
    for _ in range(T):
7
        N, K = map(int, input().split())
8
        energy = list(map(int, input().split()))
9
        10
        # Total energy
11
        total_energy = sum(energy)
12
        13
        # Check if total energy is divisible by N
14
        if total_energy % N != 0:
15
            results.append(-1)
16
            continue
17
        18
        # Target energy per station
19
        target = total_energy // N
20
        21
        # Calculate differences
22
        diffs = [energy[i] - target for i in range(N)]
23
        24
        # Check if it is possible to equalize (diffs must sum to 0 modulo K)
25
        if sum(diffs) % K != 0:
26
            results.append(-1)
27
            continue
28
        29
        # Calculate minimum operations using cumulative sum
30
        cumulative_diff = 0
31
        operations = 0
32
        for diff in diffs:
33
            cumulative_diff += diff
34
            operations += abs(cumulative_diff // K)
35
        36
        results.append(operations)
37
    38
    # Print results
39
    print(""\n"".join(map(str, results)))
40
41
# Example Usage
42
# Input according to the problem statement
43
minimum_operations_to_equalize()
44",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833012
1387833005,shruthika2720,unknown,unknown,"1
def solve():
2
    3
    T = int(input())
4
5
    6
    for _ in range(T):
7
        8
        n = int(input())
9
10
        11
        values = list(map(int, input().split()))
12
13
        14
        result = [1] * n
15
16
        17
        left_product = 1
18
        for i in range(n):
19
            result[i] = left_product
20
            left_product *= values[i]
21
22
        23
        right_product = 1
24
        for i in range(n-1, -1, -1):
25
            result[i] *= right_product
26
            right_product *= values[i]
27
28
        29
        print("" "".join(map(str, result)))
30
31
32
solve()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833005
1387833006,isha_bhosale04,unknown,unknown,"1
def solve():
2
    import sys
3
    input = sys.stdin.read().strip().split(""\n"")
4
    index = 0
5
    t = int(input[index])
6
    index += 1
7
    8
    results = []
9
10
    for _ in range(t):
11
        # Read array size
12
        n = int(input[index])
13
        index += 1
14
        15
        # Read array elements
16
        nums = list(map(int, input[index].split()))
17
        index += 1
18
19
        # Calculate prefix sums
20
        prefix_sum = [0] * n
21
        prefix_sum[0] = nums[0]
22
23
        for i in range(1, n):
24
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
25
26
        total_sum = prefix_sum[-1]
27
        max_abs_diff = 0
28
29
        # Compute max absolute difference by iterating over valid partitions
30
        for i in range(n - 1):
31
            left_sum = prefix_sum[i]
32
            right_sum = total_sum - left_sum
33
            max_abs_diff = max(max_abs_diff, abs(left_sum - right_sum))
34
35
        results.append(str(max_abs_diff))
36
37
    # Print all results at once to minimize I/O operations
38
    sys.stdout.write(""\n"".join(results) + ""\n"")
39
40
41
if __name__ == ""__main__"":
42
    solve()
43",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387833006
1387833008,singhrajbadri,unknown,unknown,"1
def compute_result(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
        8
        prefix = [1] * n
9
        suffix = [1] * n
10
        result = [0] * n
11
        12
        for i in range(1, n):
13
            prefix[i] = prefix[i - 1] * values[i - 1]
14
        15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        for i in range(n):
19
            result[i] = prefix[i] * suffix[i]
20
        21
        results.append(result)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    n = int(input())
30
    values = list(map(int, input().split()))
31
    test_cases.append((n, values))
32
33
results = compute_result(T, test_cases)
34
35
for result in results:
36
    print("" "".join(map(str, result)))
37",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833008
1387833004,yashasharma21005,unknown,unknown,"1
def moe(test_cases):
2
    results = []
3
4
    for t in range(len(test_cases)):
5
        N, K, energy = test_cases[t]
6
        total_energy = sum(energy)
7
        if total_energy % N != 0:
8
            results.append(-1)
9
            continue
10
        11
        target = total_energy // N
12
        operations = 0
13
        balance = 0  
14
        for i in range(N):
15
            balance += energy[i] - target
16
            if balance % K != 0:
17
                operations = -1
18
                break
19
            operations += abs(balance) // K
20
        21
        results.append(operations if operations != -1 else -1)
22
    23
    return results
24
25
T = int(input())
26
test_cases = []
27
28
for _ in range(T):
29
    N, K = map(int, input().split())
30
    energy = list(map(int, input().split()))
31
    test_cases.append((N, K, energy))
32
results = moe(test_cases)
33
for res in results:
34
    print(res)
35",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833004
1387833002,h1032221497,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        # Check if equalization is possible
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target_energy = total_energy // N
16
        operations = 0
17
        current_diff = 0
18
19
        for i in range(N):
20
            diff = energy[i] - target_energy
21
            current_diff += diff
22
23
            # If the current difference is not divisible by K, it's impossible to equalize
24
            if current_diff % K != 0:
25
                results.append(-1)
26
                break
27
28
            # Increment operations by the absolute value of current difference divided by K
29
            operations += abs(current_diff) // K
30
        else:
31
            results.append(operations)
32
33
    return results
34
35
# Input reading
36
T = int(input())
37
test_cases = []
38
for _ in range(T):
39
    N, K = map(int, input().split())
40
    energy = list(map(int, input().split()))
41
    test_cases.append(((N, K), energy))
42
43
# Solve and output results
44
results = minimum_operations_to_equalize(T, test_cases)
45
for result in results:
46
    print(result)",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387833002
1387833003,siddhantpal9082,unknown,unknown,"1
def compute_product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        result = [1] * n
6
7
        prefix = 1
8
        for i in range(n):
9
            result[i] = prefix
10
            prefix *= values[i]
11
12
        suffix = 1
13
        for i in range(n - 1, -1, -1):
14
            result[i] *= suffix
15
            suffix *= values[i]
16
17
        results.append(result)
18
    return results
19
20
t = int(input())
21
test_cases = []
22
for _ in range(t):
23
    n = int(input())
24
    values = list(map(int, input().split()))
25
    test_cases.append((n, values))
26
27
results = compute_product_except_self(test_cases)
28
for res in results:
29
    print("" "".join(map(str, res)))",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833003
1387833001,tritampanja444,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for t in test_cases:
5
        n, values = t
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result using prefix and suffix
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    24
    return results
25
26
27
# Input handling
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n = int(input())
33
    values = list(map(int, input().split()))
34
    test_cases.append((n, values))
35
36
# Compute results
37
results = product_except_self(test_cases)
38
39
# Output results
40
for res in results:
41
    print("" "".join(map(str, res)))
42",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833001
1387832993,swathiharish2349,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
void solution(vector<int>& arr, int product){
9
    int n = arr.size();
10
    int curr;
11
    for(int i=0; i<n; i++){
12
        curr=arr[i];
13
        cout<<product/curr<<"" "";
14
    }   
15
}
16
    17
int main() {
18
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
19
    int t;
20
    cin>>t;
21
    while(t--){
22
        int n;
23
        cin>>n;
24
        vector<int> arr;
25
        int product=1;
26
        for(int i=0; i<n; i++){
27
            int ele;
28
            cin>>ele;
29
            arr.push_back(ele);
30
            product*=ele;
31
        }
32
        solution(arr, product);
33
        cout<<endl;
34
    }
35
    return 0;
36
}
37",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832993
1387832998,aagnihotri2203,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().strip().split()
4
    t = int(input_data[0])
5
    idx = 1
6
    7
    for _ in range(t):
8
        n = int(input_data[idx])
9
        idx += 1
10
        arr = list(map(int, input_data[idx:idx+n]))
11
        idx += n
12
        13
        zero_count = 0
14
        product_all = 1
15
        16
        for val in arr:
17
            if val == 0:
18
                zero_count += 1
19
            else:
20
                product_all *= val
21
        22
        result = [0]*n
23
        24
        if zero_count > 1:
25
            print("" "".join(map(str, result)))
26
            continue
27
        elif zero_count == 1:
28
            for i in range(n):
29
                if arr[i] == 0:
30
                    result[i] = product_all
31
            print("" "".join(map(str, result)))
32
            continue
33
        else:
34
            for i in range(n):
35
                result[i] = product_all // arr[i]
36
            print("" "".join(map(str, result)))
37
38
solve()",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832998
1387833000,tiwarishashank14,unknown,unknown,"1
#include <stdio.h>
2
3
void solve() {
4
    int T;
5
    scanf(""%d"", &T);  // Read the number of test cases
6
    7
    while (T--) {
8
        int n;
9
        scanf(""%d"", &n);  // Read the number of nodes
10
        11
        int values[n];
12
        for (int i = 0; i < n; i++) {
13
            scanf(""%d"", &values[i]);  // Read the values of the nodes
14
        }
15
        16
        // Initialize arrays for result, prefix, and suffix
17
        long long prefix[n];
18
        long long suffix = 1;
19
        long long result[n];
20
        21
        // Calculate prefix products
22
        prefix[0] = values[0];
23
        for (int i = 1; i < n; i++) {
24
            prefix[i] = prefix[i - 1] * values[i];
25
        }
26
        27
        // Calculate the result array using suffix products
28
        for (int i = n - 1; i >= 0; i--) {
29
            if (i == 0) {
30
                result[i] = suffix;  // First element is only the suffix product
31
            } else {
32
                result[i] = prefix[i - 1] * suffix;  // Multiply prefix and suffix
33
            }
34
            suffix *= values[i];  // Update suffix for the next element
35
        }
36
        37
        // Print the result for the current test case
38
        for (int i = 0; i < n; i++) {
39
            printf(""%lld "", result[i]);
40
        }
41
        printf(""\n"");
42
    }
43
}
44
45
int main() {
46
    solve();  // Call the solve function
47
    return 0;
48
}
49
50",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387833000
1387832987,hamso2107,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
    5
    # Calculate the product of all elements to the left of each index
6
    left_product = 1
7
    for i in range(n):
8
        result[i] = left_product
9
        left_product *= values[i]
10
    11
    # Calculate the product of all elements to the right of each index and multiply with the left product
12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    return result
18
19
def main():
20
    import sys
21
    input = sys.stdin.read
22
    data = input().split()
23
    24
    idx = 0
25
    T = int(data[idx])
26
    idx += 1
27
    28
    for _ in range(T):
29
        n = int(data[idx])
30
        idx += 1
31
        values = list(map(int, data[idx:idx+n]))
32
        idx += n
33
        34
        result = product_except_self(values)
35
        print(' '.join(map(str, result)))
36
37
if __name__ == ""__main__"":
38
    main()",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832987
1387832988,shubhamgupta3009,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        Scanner scanner = new Scanner(System.in);
11
        int T = scanner.nextInt();
12
13
        for (int t = 0; t < T; t++) {
14
            int n = scanner.nextInt();
15
            int[] values = new int[n];
16
            for (int i = 0; i < n; i++) {
17
                values[i] = scanner.nextInt();
18
            }
19
20
            int[] result = new int[n];
21
            int totalProduct = 1;
22
            int zeroCount = 0;
23
24
            for (int value : values) {
25
                if (value == 0) {
26
                    zeroCount++;
27
                } else {
28
                    totalProduct *= value;
29
                }
30
            }
31
32
            for (int i = 0; i < n; i++) {
33
                if (zeroCount > 1) {
34
                    result[i] = 0;
35
                } else if (zeroCount == 1) {
36
                    if (values[i] == 0) {
37
                        result[i] = totalProduct;
38
                    } else {
39
                        result[i] = 0;
40
                    }
41
                } else {
42
                    result[i] = totalProduct / values[i];
43
                }
44
            }
45
46
            for (int i = 0; i < n; i++) {
47
                System.out.print(result[i] + "" "");
48
            }
49
            System.out.println();
50
        }
51
52
        scanner.close();
53
    }
54
}",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832988
1387832992,h1032221480,unknown,unknown,"1
def minimum_operations():
2
    T = int(input())  # Number of test cases
3
    results = []
4
    5
    for _ in range(T):
6
        N, K = map(int, input().split())  # Number of stations and units of energy per operation
7
        energy = list(map(int, input().split()))  # Energy levels at each station
8
        9
        # Check if equalization is possible
10
        total_energy = sum(energy)
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        # Target energy level for each station
16
        target_energy = total_energy // N
17
        18
        # Calculate difference array
19
        diff = [energy[i] - target_energy for i in range(N)]
20
        21
        # Check if all differences are divisible by K
22
        if any(d % K != 0 for d in diff):
23
            results.append(-1)
24
            continue
25
        26
        # Count the number of operations needed
27
        operations = 0
28
        balance = 0
29
        for d in diff:
30
            balance += d // K
31
            operations += abs(balance)
32
        33
        results.append(operations)
34
    35
    # Print the results for all test cases
36
    print(""\n"".join(map(str, results)))
37
38
39
# Call the function to execute
40
minimum_operations()
41",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832992
1387832984,ankitayadav25310,unknown,unknown,"1
def solve_testcase(N, K, energy):
2
    # Calculate total energy and target
3
    total_energy = sum(energy)
4
    5
    # Check if equal distribution is possible
6
    if total_energy % N != 0:
7
        return -1
8
    9
    target = total_energy // N
10
    11
    # If already equalized
12
    if all(e == target for e in energy):
13
        return 0
14
    15
    # For each position, calculate how many transfers are needed
16
    total_transfers = 0
17
    excess = 0  # Keep track of excess/deficit as we go around the circle
18
    19
    for i in range(N):
20
        # Current position's excess/deficit including previous remainder
21
        curr_with_excess = energy[i] + excess
22
        23
        # How far are we from target at this position
24
        diff_from_target = curr_with_excess - target
25
        26
        # This difference will need to be transferred to next position
27
        excess = diff_from_target
28
        29
        # If we need to make transfers
30
        if diff_from_target != 0:
31
            # If we can't transfer in K-unit chunks
32
            if abs(diff_from_target) % K != 0:
33
                return -1
34
                35
            # Add number of K-unit transfers needed
36
            total_transfers += abs(diff_from_target) // K
37
    38
    # After going around the circle, if there's any remainder, it's impossible
39
    if excess != 0:
40
        return -1
41
        42
    return total_transfers
43
44
def main():
45
    # Read number of test cases
46
    T = int(input())
47
    48
    # Process each test case
49
    for _ in range(T):
50
        # Read N and K
51
        N, K = map(int, input().split())
52
        53
        # Read energy array
54
        energy = list(map(int, input().split()))
55
        56
        # Solve current test case
57
        result = solve_testcase(N, K, energy)
58
        59
        # Print result
60
        print(result)
61
62
if __name__ == ""__main__"":
63
    main()",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832984
1387832978,laxmimehta0506,unknown,unknown,"1
import java.util.Scanner;
2
3
public class NodeNetwork {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        8
        int T = sc.nextInt(); // Number of test cases
9
        10
        for (int t = 0; t < T; t++) {
11
            int n = sc.nextInt(); // Number of nodes
12
            int[] values = new int[n];
13
            for (int i = 0; i < n; i++) {
14
                values[i] = sc.nextInt(); // Value of each node
15
            }
16
            17
            int[] result = new int[n];
18
            19
            // Step 1: Calculate the left product for each node
20
            int[] left = new int[n];
21
            left[0] = 1; // Nothing to the left of the first node
22
            for (int i = 1; i < n; i++) {
23
                left[i] = left[i - 1] * values[i - 1];
24
            }
25
            26
            // Step 2: Calculate the right product for each node
27
            int[] right = new int[n];
28
            right[n - 1] = 1; // Nothing to the right of the last node
29
            for (int i = n - 2; i >= 0; i--) {
30
                right[i] = right[i + 1] * values[i + 1];
31
            }
32
            33
            // Step 3: Calculate the final result by multiplying left and right products
34
            for (int i = 0; i < n; i++) {
35
                result[i] = left[i] * right[i];
36
            }
37
            38
            // Output the result array
39
            for (int i = 0; i < n; i++) {
40
                System.out.print(result[i] + "" "");
41
            }
42
            System.out.println();
43
        }
44
        45
        sc.close();
46
    }
47
}
48",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832978
1387832982,darekarisha13,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    prefix_sum = [0] * n
4
    prefix_sum[0] = nums[0]
5
6
    # Compute prefix sums
7
    for i in range(1, n):
8
        prefix_sum[i] = prefix_sum[i - 1] + nums[i]
9
10
    total_sum = prefix_sum[-1]
11
    max_difference = 0
12
13
    # Compute the maximum absolute difference
14
    for i in range(n - 1):
15
        sum_left = prefix_sum[i]
16
        sum_right = total_sum - sum_left
17
        max_difference = max(max_difference, abs(sum_left - sum_right))
18
19
    return max_difference
20
21
# Input handling
22
def main():
23
    t = int(input())  # Number of test cases
24
    results = []
25
26
    for _ in range(t):
27
        n = int(input())  # Size of the array
28
        nums = list(map(int, input().split()))  # Array elements
29
        results.append(max_absolute_difference(nums))
30
31
    # Output results for all test cases
32
    for res in results:
33
        print(res)
34
35
# Execute the program
36
if __name__ == ""__main__"":
37
    main()
38",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387832982
1387832983,kesaragar1234,unknown,unknown,"1
def calculate_product_excluding_self(test_cases):
2
    results = []
3
4
    for t in range(test_cases):
5
        n = int(input())  # Number of nodes in the network
6
        values = list(map(int, input().split()))
7
8
        # Initialize prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
12
        # Calculate prefix products
13
        for i in range(1, n):
14
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
15
16
        # Calculate suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
19
20
        # Calculate result for the current test case
21
        result = [prefix_products[i] * suffix_products[i] for i in range(n)]
22
        results.append(result)
23
24
    return results
25
26
# Input
27
T = int(input())  # Number of test cases
28
output = calculate_product_excluding_self(T)
29
30
# Output results for all test cases
31
for res in output:
32
    print(*res)
33",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832983
1387832974,h1032221377,unknown,unknown,"1
def compute_products(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
8
        # Initialize prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
12
        # Compute prefix products
13
        for i in range(1, n):
14
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
15
16
        # Compute suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
19
20
        # Compute result for each node
21
        result = [prefix_products[i] * suffix_products[i] for i in range(n)]
22
        results.append(result)
23
24
    return results
25
26
# Input handling
27
T = int(input())
28
test_cases = []
29
30
for _ in range(T):
31
    n = int(input())
32
    values = list(map(int, input().split()))
33
    test_cases.append((n, values))
34
35
# Compute results
36
results = compute_products(T, test_cases)
37
38
# Output results
39
for result in results:
40
    print("" "".join(map(str, result)))
41",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832974
1387832976,adityatripathi27,unknown,unknown,"1
def solve():
2
    T = int(input())  # Read number of test cases
3
    4
    for _ in range(T):
5
        n = int(input())  # Read the number of nodes (size of array)
6
        values = list(map(int, input().split()))  # Read the array values
7
        8
        result = [1] * n  # Initialize result array with 1s
9
        10
        # Calculate the prefix product
11
        prefix_product = 1
12
        for i in range(n):
13
            result[i] *= prefix_product
14
            prefix_product *= values[i]
15
        16
        # Calculate the suffix product and update the result array
17
        suffix_product = 1
18
        for i in range(n - 1, -1, -1):
19
            result[i] *= suffix_product
20
            suffix_product *= values[i]
21
        22
        # Output the result for this test case
23
        print("" "".join(map(str, result)))
24
25
# Run the function
26
solve()
27",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832976
1387832977,prathameshbhoit1,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # Check if it's possible to equalize
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target = total_energy // N
9
    operations = 0
10
    11
    for i in range(N):
12
        diff = energy[i] - target
13
        14
        # If the difference is not divisible by K, it's impossible
15
        if diff % K != 0:
16
            return -1
17
        18
        # Accumulate the number of operations
19
        operations += abs(diff) // K
20
    21
    # Since each operation transfers K units, divide by 2 to avoid double-counting
22
    return operations // 2
23
24
25
def main():
26
    import sys
27
    input = sys.stdin.read
28
    data = input().split()
29
    30
    idx = 0
31
    T = int(data[idx])
32
    idx += 1
33
    34
    for _ in range(T):
35
        N = int(data[idx])
36
        K = int(data[idx + 1])
37
        idx += 2
38
        39
        energy = list(map(int, data[idx:idx + N]))
40
        idx += N
41
        42
        result = min_operations_to_equalize(N, K, energy)
43
        print(result)
44
45
46
if __name__ == ""__main__"":
47
    main()",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832977
1387832969,h1032220507,unknown,unknown,"1
def calculate_product_exclude_self(test_cases):
2
    results = []
3
    for values in test_cases:
4
        n = len(values)
5
        # Initialize prefix and suffix arrays
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
        10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
        18
        # Compute result array
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
        22
        results.append(result)
23
    return results
24
25
# Input handling
26
t = int(input())
27
test_cases = []
28
for _ in range(t):
29
    n = int(input())
30
    values = list(map(int, input().split()))
31
    test_cases.append(values)
32
33
# Processing and Output
34
results = calculate_product_exclude_self(test_cases)
35
for res in results:
36
    print("" "".join(map(str, res)))
37",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832969
1387832972,yt5160359,unknown,unknown,"1
def calculate_product_excluding_self(test_cases):
2
    results = []
3
4
    for t in range(test_cases):
5
        n = int(input())  # Number of nodes in the network
6
        values = list(map(int, input().split()))
7
8
        # Initialize prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
12
        # Calculate prefix products
13
        for i in range(1, n):
14
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
15
16
        # Calculate suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
19
20
        # Calculate result for the current test case
21
        result = [prefix_products[i] * suffix_products[i] for i in range(n)]
22
        results.append(result)
23
24
    return results
25
26
# Input
27
T = int(input())  # Number of test cases
28
output = calculate_product_excluding_self(T)
29
30
# Output results for all test cases
31
for res in output:
32
    print(*res)",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832972
1387832971,h1032220167,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # Check if total energy is divisible by N
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target = total_energy // N  # Target energy for each station
9
    operations = 0
10
    11
    # Iterate through the energy array to calculate the required operations
12
    for i in range(N):
13
        diff = energy[i] - target
14
        15
        # If the difference is not divisible by K, it's impossible to equalize
16
        if diff % K != 0:
17
            return -1
18
        19
        # Add the absolute value of (diff / K) to the operations
20
        operations += abs(diff) // K
21
    22
    # Since each operation affects two stations, divide by 2
23
    return operations // 2
24
25
def main():
26
    import sys
27
    input = sys.stdin.read
28
    data = input().split()
29
    30
    idx = 0
31
    T = int(data[idx])  # Number of test cases
32
    idx += 1
33
    34
    for _ in range(T):
35
        N = int(data[idx])  # Number of stations
36
        K = int(data[idx + 1])  # Units of energy to transfer
37
        idx += 2
38
        39
        energy = list(map(int, data[idx:idx + N]))  # Energy of each station
40
        idx += N
41
        42
        result = min_operations_to_equalize(N, K, energy)
43
        print(result)
44
45
if __name__ == ""__main__"":
46
    main()",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832971
1387832967,harikeshyadav161,unknown,unknown,"1
def min_operations_to_equalize(n, k, energy):
2
3
    total_energy = sum(energy)
4
5
    6
7
    # Check if it's possible to equalize
8
9
    if total_energy % n != 0:
10
11
        return -1
12
13
    target = total_energy // n
14
15
    operations = 0
16
17
    balance = 0  # Tracks surplus/deficit carried over
18
19
    for e in energy:
20
21
        balance += (e - target)  # Track surplus or deficit
22
23
        operations += abs(balance) // k  # Convert surplus/deficit to operations
24
25
    return operations
26
27
# Reading input
28
29
T = int(input().strip())  # Number of test cases
30
31
for _ in range(T):
32
33
    N, K = map(int, input().strip().split())  # Read N and K
34
35
    energy = list(map(int, input().strip().split()))  # Read energy array
36
37
    print(min_operations_to_equalize(N, K, energy))",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832967
1387832956,h1032220352,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        n = int(input())
5
        values = list(map(int, input().split()))
6
        7
        prefix = [1] * n
8
        suffix = [1] * n
9
        result = [1] * n
10
        11
        prefix_product = 1
12
        for i in range(n):
13
            prefix[i] = prefix_product
14
            prefix_product *= values[i]
15
        16
        suffix_product = 1
17
        for i in range(n - 1, -1, -1):
18
            suffix[i] = suffix_product
19
            suffix_product *= values[i]
20
        21
        for i in range(n):
22
            result[i] = prefix[i] * suffix[i]
23
        24
        print("" "".join(map(str, result)))
25
26
if __name__ == ""__main__"":
27
    solve()
28",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832956
1387832960,h1032220108,unknown,unknown,"1
def get_product_array(arr, n):
2
    result = [1] * n
3
    left_product = 1
4
    for i in range(n):
5
        result[i] = left_product
6
        left_product *= arr[i]
7
    right_product = 1
8
    for i in range(n-1, -1, -1):
9
        result[i] *= right_product
10
        right_product *= arr[i]
11
    12
    return result
13
14
def solve_test_case():
15
    n = int(input())
16
    values = list(map(int, input().split()))
17
    result = get_product_array(values, n)
18
    print("" "".join(map(str, result)))
19
20
def main():
21
    T = int(input())
22
    for _ in range(T):
23
        solve_test_case()
24
25
if __name__ == ""__main__"":
26
    main()",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832960
1387832962,67_harshit_pras1,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
int main() {
6
    int t;
7
    cin >> t;
8
    9
    while (t--) {
10
        int n;
11
        cin >> n;
12
        13
        vector<int> values(n);
14
        for (int i = 0; i < n; i++) {
15
            cin >> values[i];
16
        }
17
        18
        vector<int> result(n);
19
        vector<int> left(n);
20
        vector<int> right(n);
21
        22
        left[0] = 1;
23
        for (int i = 1; i < n; i++) {
24
            left[i] = left[i-1] * values[i-1];
25
        }
26
        27
        right[n-1] = 1;
28
        for (int i = n-2; i >= 0; i--) {
29
            right[i] = right[i+1] * values[i+1];
30
        }
31
        32
        for (int i = 0; i < n; i++) {
33
            result[i] = left[i] * right[i];
34
        }
35
        36
        for (int i = 0; i < n; i++) {
37
            cout << result[i] << "" "";
38
        }
39
        cout << endl;
40
    }
41
    42
    return 0;
43
}",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832962
1387832953,h1032221629,unknown,unknown,"1
def calculate_product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
5
    # Calculate prefix products
6
    prefix_product = 1
7
    for i in range(n):
8
        result[i] = prefix_product
9
        prefix_product *= values[i]
10
11
    # Calculate suffix products and multiply with result
12
    suffix_product = 1
13
    for i in range(n - 1, -1, -1):
14
        result[i] *= suffix_product
15
        suffix_product *= values[i]
16
17
    return result
18
19
# Input reading and processing
20
t = int(input())  # Number of test cases
21
outputs = []
22
23
for _ in range(t):
24
    n = int(input())  # Number of nodes
25
    values = list(map(int, input().split()))
26
    outputs.append(calculate_product_except_self(values))
27
28
# Print the results
29
for result in outputs:
30
    print("" "".join(map(str, result)))
31",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832953
1387832954,dishug2409,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
5
    # Calculate prefix products
6
    prefix = 1
7
    for i in range(n):
8
        result[i] = prefix
9
        prefix *= values[i]
10
11
    # Calculate suffix products and combine with prefix
12
    suffix = 1
13
    for i in range(n - 1, -1, -1):
14
        result[i] *= suffix
15
        suffix *= values[i]
16
17
    return result
18
19
# Input handling
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n = int(input())  # Number of nodes
23
    values = list(map(int, input().split()))  # Node values
24
    result = product_except_self(values)
25
    print("" "".join(map(str, result)))
26",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832954
1387832955,aryanrrsingh_04,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    4
    for _ in range(test_cases):
5
        # Read N and K
6
        n, k = map(int, input().split())
7
        # Read the energy array
8
        energy = list(map(int, input().split()))
9
        10
        # Check if equal distribution is possible
11
        total_energy = sum(energy)
12
        if total_energy % n != 0:
13
            results.append(-1)
14
            continue
15
        16
        # Target energy per station
17
        target = total_energy // n
18
        19
        # Calculate differences
20
        diffs = [energy[i] - target for i in range(n)]
21
        22
        # Check if differences can be balanced with K
23
        if any(diff % k != 0 for diff in diffs):
24
            results.append(-1)
25
            continue
26
        27
        # Compute minimum operations using prefix sum approach
28
        operations = 0
29
        prefix_sum = 0
30
        for diff in diffs:
31
            prefix_sum += diff
32
            operations += abs(prefix_sum) // k
33
        34
        results.append(operations)
35
    36
    # Output results for all test cases
37
    print(""\n"".join(map(str, results)))
38
39
# Input and processing
40
if __name__ == ""__main__"":
41
    T = int(input())  # Number of test cases
42
    minimum_operations(T)
43",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832955
1387832948,suman197960,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
    4
    for _ in range(t):
5
        n, nums = test_cases[_]
6
        total_sum = sum(nums)
7
        prefix = 0
8
        max_diff = 0
9
        10
        # Traverse the array to calculate prefix sums and max difference
11
        for i in range(n - 1):  # Ensure we don't create an empty right subarray
12
            prefix += nums[i]
13
            left_sum = prefix
14
            right_sum = total_sum - prefix
15
            max_diff = max(max_diff, abs(left_sum - right_sum))
16
        17
        results.append(max_diff)
18
    19
    return results
20
21
# Input handling
22
t = int(input())
23
test_cases = []
24
25
for _ in range(t):
26
    n = int(input())
27
    nums = list(map(int, input().split()))
28
    test_cases.append((n, nums))
29
30
# Solve the problem
31
results = max_absolute_difference(t, test_cases)
32
33
# Output results
34
for res in results:
35
    print(res)
36",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387832948
1387832951,sohamkadam0012,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
// Function to calculate the minimum operations or check if equalization is impossible
5
int minOperationsToEqualize(int *energy, int n, int k) {
6
    long long totalEnergy = 0;
7
8
    // Calculate total energy
9
    for (int i = 0; i < n; i++) {
10
        totalEnergy += energy[i];
11
    }
12
13
    // Check if total energy is divisible by N
14
    if (totalEnergy % n != 0) {
15
        return -1; // Impossible to equalize
16
    }
17
18
    long long targetEnergy = totalEnergy / n; // Target energy for each station
19
    long long operations = 0;
20
    long long surplus = 0; // Tracks energy surplus or deficit in the cycle
21
22
    for (int i = 0; i < n; i++) {
23
        surplus += energy[i] - targetEnergy;
24
25
        // If surplus cannot be transferred in multiples of K, return -1
26
        if (surplus % k != 0) {
27
            return -1;
28
        }
29
30
        // Count operations needed to balance up to this point
31
        operations += abs(surplus / k);
32
    }
33
34
    return operations;
35
}
36
37
int main() {
38
    int T;
39
    scanf(""%d"", &T);
40
41
    while (T--) {
42
        int n, k;
43
        scanf(""%d %d"", &n, &k);
44
45
        int *energy = (int *)malloc(n * sizeof(int));
46
        for (int i = 0; i < n; i++) {
47
            scanf(""%d"", &energy[i]);
48
        }
49
50
        int result = minOperationsToEqualize(energy, n, k);
51
        printf(""%d\n"", result);
52
53
        free(energy);
54
    }
55
56
    return 0;
57
}
58",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832951
1387832950,a_redij04,unknown,unknown,"1
def solve():
2
    # Read the number of test cases
3
    t = int(input())
4
    5
    # Process each test case
6
    for _ in range(t):
7
        # Read the size of the array
8
        n = int(input())
9
        10
        # Read the array
11
        nums = list(map(int, input().split()))
12
        13
        # Compute the total sum of the array
14
        total_sum = sum(nums)
15
        16
        # Initialize prefix sum and the maximum absolute difference
17
        prefix_sum = 0
18
        max_diff = float('-inf')
19
        20
        # Iterate through the array to check the difference at each partition
21
        for i in range(n - 1):  # We need at least one element in both subarrays
22
            prefix_sum += nums[i]
23
            diff = abs(2 * prefix_sum - total_sum)
24
            max_diff = max(max_diff, diff)
25
        26
        # Output the result for the current test case
27
        print(max_diff)
28
29
# Call the solve function to execute the solution
30
solve()
31",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387832950
1387832946,sanskriti_singh9,unknown,unknown,"1
def solve():
2
    # Read number of test cases
3
    T = int(input())
4
    5
    for _ in range(T):
6
        # Read number of nodes
7
        n = int(input())
8
        9
        # Read the values array
10
        values = list(map(int, input().split()))
11
        12
        # Initialize result array
13
        result = [1] * n
14
        15
        # Left product array (multiplying all values to the left of the current index)
16
        left_product = 1
17
        for i in range(n):
18
            result[i] = left_product
19
            left_product *= values[i]
20
        21
        # Right product array (multiplying all values to the right of the current index)
22
        right_product = 1
23
        for i in range(n-1, -1, -1):
24
            result[i] *= right_product
25
            right_product *= values[i]
26
        27
        # Print the result for the current test case
28
        print("" "".join(map(str, result)))
29
30
# Run the solve function to process input and output
31
solve()",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832946
1387832943,h1032220810,unknown,unknown,"1
def solve():
2
    n = int(input())
3
    values = list(map(int, input().split()))
4
5
    result = [0] * n
6
7
    for i in range(n):
8
        product = 1
9
        for j in range(n):
10
            if i != j:
11
                product *= values[j]
12
        result[i] = product
13
14
    print(*result)
15
16
17
t = int(input())
18
for _ in range(t):
19
    solve()",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832943
1387832944,Sanika2112,unknown,unknown,"1
def max_absolute_difference(n, nums):
2
    prefix_sum = [0] * n
3
    suffix_sum = [0] * n
4
    5
    prefix_sum[0] = nums[0]
6
    suffix_sum[n-1] = nums[n-1]
7
    8
    for i in range(1, n):
9
        prefix_sum[i] = prefix_sum[i-1] + nums[i]
10
    11
    for i in range(n-2, -1, -1):
12
        suffix_sum[i] = suffix_sum[i+1] + nums[i]
13
    14
    max_diff = 0
15
    16
    for i in range(n-1):
17
        left_sum = prefix_sum[i]
18
        right_sum = suffix_sum[i+1]
19
        max_diff = max(max_diff, abs(left_sum - right_sum))
20
    21
    return max_diff
22
23
# Reading input
24
t = int(input().strip())
25
results = []
26
27
for _ in range(t):
28
    n = int(input().strip())
29
    nums = list(map(int, input().strip().split()))
30
    result = max_absolute_difference(n, nums)
31
    results.append(result)
32
33
# Output the results
34
for result in results:
35
    print(result)
36",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387832944
1387832945,h1032221771,unknown,unknown,"1
def calculate_results(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
8
        prefix = [1] * n
9
        suffix = [1] * n
10
        11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] * values[i + 1]
16
        17
        result = [prefix[i] * suffix[i] for i in range(n)]
18
        results.append(result)
19
    20
    return results
21
22
T = int(input())
23
test_cases = []
24
25
for _ in range(T):
26
    n = int(input())
27
    values = list(map(int, input().split()))
28
    test_cases.append((n, values))
29
30
output = calculate_results(T, test_cases)
31
for res in output:
32
    print("" "".join(map(str, res)))
33",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832945
1387832940,cjain1725,unknown,unknown,"1
def can_equalize(N, K, energy):
2
    """"""
3
    Determines if it's possible to equalize energy and returns minimum operations needed
4
    5
    Args:
6
        N (int): Number of power stations
7
        K (int): Units of energy that can be transferred in one operation
8
        energy (list): Array of energy values for each station
9
        10
    Returns:
11
        int: Minimum number of operations needed, or -1 if impossible
12
    """"""
13
    # Calculate total energy
14
    total_energy = sum(energy)
15
    16
    # Check if equal distribution is possible
17
    if total_energy % N != 0:
18
        return -1
19
    20
    # Target energy level for each station
21
    target = total_energy // N
22
    23
    # Check if each station can reach target with given K
24
    operations = 0
25
    diff_sum = 0  # Track total energy difference
26
    27
    # First pass: calculate required operations
28
    for i in range(N-1):
29
        diff = energy[i] - target
30
        diff_sum += diff
31
        # If absolute difference is not divisible by K, equalization is impossible
32
        if abs(diff_sum) % K != 0:
33
            return -1
34
        if diff_sum != 0:
35
            operations += 1
36
    37
    # Check last station
38
    final_diff = energy[N-1] - target
39
    if final_diff != -diff_sum:
40
        return -1
41
    42
    # If we made it here and diff_sum is not 0, we need one more operation
43
    if diff_sum != 0:
44
        operations += 1
45
    46
    return operations
47
48
def main():
49
    # Read number of test cases
50
    T = int(input())
51
    52
    # Process each test case
53
    for _ in range(T):
54
        # Read N and K
55
        N, K = map(int, input().split())
56
        57
        # Read energy values
58
        energy = list(map(int, input().split()))
59
        60
        # Calculate and print result
61
        result = can_equalize(N, K, energy)
62
        print(result)
63
64
if __name__ == ""__main__"":
65
    main()",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832940
1387832941,khushidoshi1978,unknown,unknown,"1
def min_operations_to_equalize_energy(t, test_cases):
2
    for n, k, energy in test_cases:
3
        total_energy = sum(energy)
4
        5
        6
        if total_energy % n != 0:
7
            print(-1)
8
            continue
9
        10
      11
        target_energy = total_energy // n
12
        13
        operations = 0
14
        balance = 0
15
        possible = True
16
        17
        for i in range(n):
18
           19
            diff = energy[i] - target_energy
20
            balance += diff
21
            22
            23
            if balance % k != 0:
24
                possible = False
25
                break
26
            27
           28
            operations += abs(balance // k)
29
        30
       31
        if possible:
32
            print(operations)
33
        else:
34
            print(-1)
35
36
37
T = int(input())  
38
test_cases = []
39
40
for _ in range(T):
41
    n, k = map(int, input().split())  
42
    energy = list(map(int, input().split()))  
43
    test_cases.append((n, k, energy))
44
45
46
min_operations_to_equalize_energy(T, test_cases)
47",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832941
1387832942,maurya_anjali061,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # If the total energy is not divisible by N, it's impossible to equalize
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target_energy = total_energy // N
9
    operations = 0
10
    cumulative_balance = 0
11
    12
    # Traverse through each station and compute the cumulative balance
13
    for i in range(N):
14
        # Calculate the difference between the current energy and the target energy
15
        energy_difference = energy[i] - target_energy
16
        cumulative_balance += energy_difference
17
        18
        # Count the number of operations needed to balance up to the current station
19
        operations += abs(cumulative_balance) // K
20
    21
    return operations
22
23
# Read input
24
T = int(input())  # Number of test cases
25
for _ in range(T):
26
    N, K = map(int, input().split())  # Number of stations (N) and transfer units (K)
27
    energy = list(map(int, input().split()))  # Energy at each station
28
    result = min_operations_to_equalize(N, K, energy)
29
    print(result)
30",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832942
1387832936,h1032221377,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        N, K = test_cases[t][:2]
6
        energy = test_cases[t][2]
7
        8
        total_energy = sum(energy)
9
        10
        # If the total energy is not divisible by N, it's impossible to equalize
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target = total_energy // N
16
        operations = 0
17
        excess_energy = 0
18
        19
        # Traverse the array, simulating the circular transfer
20
        for i in range(N):
21
            # Calculate the difference between current station energy and target
22
            excess_energy += energy[i] - target
23
            24
            # The number of operations required for this difference to propagate
25
            if excess_energy % K != 0:
26
                operations = -1
27
                break
28
            29
            operations += abs(excess_energy) // K
30
        31
        results.append(operations if operations != -1 else -1)
32
    33
    return results
34
35
36
# Input handling
37
T = int(input())
38
test_cases = []
39
for _ in range(T):
40
    N, K = map(int, input().split())
41
    energy = list(map(int, input().split()))
42
    test_cases.append((N, K, energy))
43
44
# Output the results
45
results = minimum_operations_to_equalize(T, test_cases)
46
for res in results:
47
    print(res)",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832936
1387832938,h1032231265,unknown,unknown,"1
def solve():
2
   3
    T = int(input())
4
    5
    for _ in range(T):
6
       7
        n = int(input())
8
        9
       10
        values = list(map(int, input().split()))
11
        12
        13
        result = [1] * n
14
        15
       16
        left_product = 1
17
        for i in range(n):
18
            result[i] = left_product
19
            left_product *= values[i]
20
        21
      22
        right_product = 1
23
        for i in range(n-1, -1, -1):
24
            result[i] *= right_product
25
            right_product *= values[i]
26
        27
       28
        print("" "".join(map(str, result)))
29
30
31
solve()
32",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832938
1387832935,siddhikubal30,unknown,unknown,"1
def solve():
2
    T = int(input())  # Read the number of test cases
3
    for _ in range(T):
4
        n = int(input())  # Number of nodes in this test case
5
        values = list(map(int, input().split()))  # Read the values array
6
        7
        # Step 1: Create the prefix product array
8
        prefix = [1] * n
9
        for i in range(1, n):
10
            prefix[i] = prefix[i - 1] * values[i - 1]
11
        12
        # Step 2: Create the suffix product array
13
        suffix = [1] * n
14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] * values[i + 1]
16
        17
        # Step 3: Compute the result array by multiplying prefix[i] and suffix[i]
18
        result = [prefix[i] * suffix[i] for i in range(n)]
19
        20
        # Step 4: Print the result for this test case
21
        print("" "".join(map(str, result)))
22
23
# Run the solution
24
solve()
25",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832935
1387832933,h1032221056,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
   7
    for i in range(1, n):
8
        left[i] = left[i-1] * arr[i-1]
9
10
   11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * arr[i+1]
13
14
    15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
20
T = int(input())
21
22
for _ in range(T):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result)",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832933
1387832928,aayushkrishnaut,unknown,unknown,"1
def is_equalization_possible(n, energy):
2
    # Calculate total energy
3
    total_energy = sum(energy)
4
    # Check if total energy is divisible by number of stations
5
    return total_energy % n == 0
6
7
def can_equalize(n, k, energy, target_energy):
8
    # Simulate operations to see if we can reach target energy
9
    curr_energy = energy.copy()
10
    visited_states = set()
11
    12
    def get_state_hash(arr):
13
        return ','.join(map(str, arr))
14
    15
    def try_equalize(ops):
16
        state = get_state_hash(curr_energy)
17
        if state in visited_states:
18
            return float('inf')
19
        visited_states.add(state)
20
        21
        # Check if energy is equalized
22
        if all(e == target_energy for e in curr_energy):
23
            return ops
24
        25
        if ops >= n * n:  # Prevent infinite loops
26
            return float('inf')
27
            28
        min_ops = float('inf')
29
        # Try transferring energy from each station
30
        for i in range(n):
31
            if curr_energy[i] >= k:
32
                # Transfer k units to next station
33
                next_station = (i + 1) % n
34
                curr_energy[i] -= k
35
                curr_energy[next_station] += k
36
                37
                result = try_equalize(ops + 1)
38
                min_ops = min(min_ops, result)
39
                40
                # Backtrack
41
                curr_energy[i] += k
42
                curr_energy[next_station] -= k
43
                44
        return min_ops
45
    46
    result = try_equalize(0)
47
    return result if result != float('inf') else -1
48
49
def solve_energy_equalization():
50
    # Read number of test cases
51
    T = int(input())
52
    53
    for _ in range(T):
54
        # Read N and K
55
        N, K = map(int, input().split())
56
        57
        # Read energy values
58
        energy = list(map(int, input().split()))
59
        60
        # First check if equalization is possible
61
        if not is_equalization_possible(N, energy):
62
            print(-1)
63
            continue
64
            65
        # Calculate target energy per station
66
        target_energy = sum(energy) // N
67
        68
        # Try to find minimum operations to equalize
69
        result = can_equalize(N, K, energy, target_energy)
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    solve_energy_equalization()",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832928
1387832929,aditya_jha027,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, values = case
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [1] * n
9
10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] * values[i - 1]
12
        13
        for i in range(n - 2, -1, -1):
14
            suffix[i] = suffix[i + 1] * values[i + 1]
15
    16
        for i in range(n):
17
            result[i] = prefix[i] * suffix[i]
18
        19
        results.append(result)
20
    21
    return results
22
23
T = int(input())
24
test_cases = []
25
26
for _ in range(T):
27
    n = int(input())
28
    values = list(map(int, input().split()))
29
    test_cases.append((n, values))
30
31
output = product_except_self(test_cases)
32
for res in output:
33
    print("" "".join(map(str, res)))",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832929
1387832932,jhakrishnachand1,unknown,unknown,"1
def compute_product_array(n, values):
2
    prefix = [1] * n
3
    for i in range(1, n):
4
        prefix[i] = prefix[i - 1] * values[i - 1]
5
    6
    suffix = [1] * n
7
    for i in range(n - 2, -1, -1):
8
        suffix[i] = suffix[i + 1] * values[i + 1]
9
    10
    result = [prefix[i] * suffix[i] for i in range(n)]
11
    12
    return result
13
14
T = int(input().strip()) 
15
for _ in range(T):
16
    n = int(input().strip()) 
17
    values = list(map(int, input().strip().split()))
18
    print("" "".join(map(str, compute_product_array(n, values))))
19",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832932
1387832923,singhark94,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <numeric>
4
using namespace std;
5
6
long long minimumOperations(int N, int K, vector<int>& energy) {
7
    long long totalEnergy = accumulate(energy.begin(), energy.end(), 0LL);
8
9
    // Check if equalization is possible
10
    if (totalEnergy % N != 0) return -1;
11
    long long target = totalEnergy / N;
12
13
    vector<long long> difference(N, 0);
14
    for (int i = 0; i < N; ++i) {
15
        difference[i] = energy[i] - target;
16
    }
17
18
    long long cumulativeSum = 0;
19
    long long operations = 0;
20
21
    for (int i = 0; i < N; ++i) {
22
        cumulativeSum += difference[i];
23
        24
        // If cumulative sum isn't divisible by K, it's impossible
25
        if (cumulativeSum % K != 0) return -1;
26
27
        // Add absolute value of the current cumulative sum to operations
28
        operations += abs(cumulativeSum / K);
29
    }
30
31
    return operations;
32
}
33
34
int main() {
35
    int T;
36
    cin >> T; // Number of test cases
37
38
    while (T--) {
39
        int N, K;
40
        cin >> N >> K;
41
        vector<int> energy(N);
42
        for (int i = 0; i < N; ++i) {
43
            cin >> energy[i];
44
        }
45
46
        // Compute and print the result for this test case
47
        cout << minimumOperations(N, K, energy) << endl;
48
    }
49
50
    return 0;
51
}
52",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832923
1387832924,h1032221511,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        result = [1] * n
6
        prefix = 1
7
        for i in range(n):
8
            result[i] = prefix
9
            prefix *= values[i]
10
        suffix = 1
11
        for i in range(n - 1, -1, -1):
12
            result[i] *= suffix
13
            suffix *= values[i]
14
        results.append(result)
15
    return results
16
17
t = int(input())
18
test_cases = []
19
for _ in range(t):
20
    n = int(input())
21
    values = list(map(int, input().split()))
22
    test_cases.append((n, values))
23
24
results = product_except_self(test_cases)
25
for result in results:
26
    print("" "".join(map(str, result)))
27",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832924
1387832925,pjha9996,unknown,unknown,"1
def compute_product_array(n, values):
2
    prefix = [1] * n
3
    for i in range(1, n):
4
        prefix[i] = prefix[i - 1] * values[i - 1]
5
    6
    suffix = [1] * n
7
    for i in range(n - 2, -1, -1):
8
        suffix[i] = suffix[i + 1] * values[i + 1]
9
    10
    result = [prefix[i] * suffix[i] for i in range(n)]
11
    12
    return result
13
14
T = int(input().strip()) 
15
for _ in range(T):
16
    n = int(input().strip()) 
17
    values = list(map(int, input().strip().split()))
18
    print("" "".join(map(str, compute_product_array(n, values))))",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832925
1387832920,h1032221562,unknown,unknown,"1
def min_operations_to_equalize(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        N, K, energy = case
6
        total_energy = sum(energy)
7
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
12
        target = total_energy // N
13
        operations = 0
14
        excess = 0
15
        16
        for i in range(N):
17
            excess += energy[i] - target
18
            if excess % K != 0:
19
                results.append(-1)
20
                break
21
            operations += abs(excess) // K
22
        else:
23
            results.append(operations)
24
25
    return results
26
27
T = int(input())
28
test_cases = []
29
for _ in range(T):
30
    N, K = map(int, input().split())
31
    energy = list(map(int, input().split()))
32
    test_cases.append((N, K, energy))
33
34
output = min_operations_to_equalize(test_cases)
35
for res in output:
36
    print(res)",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832920
1387832921,shuklaram2315,unknown,unknown,"1
def calculate_product_except_self(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        n, values = test_cases[t]
5
        prefix = [1] * n
6
        suffix = [1] * n
7
        result = [0] * n
8
        for i in range(1, n):
9
            prefix[i] = prefix[i - 1] * values[i - 1]
10
        for i in range(n - 2, -1, -1):
11
            suffix[i] = suffix[i + 1] * values[i + 1]
12
        for i in range(n):
13
            result[i] = prefix[i] * suffix[i]
14
        results.append(result)
15
    return results
16
T = int(input())
17
test_cases = []
18
for _ in range(T):
19
    n = int(input())
20
    values = list(map(int, input().split()))
21
    test_cases.append((n, values))
22
results = calculate_product_except_self(T, test_cases)
23
for result in results:
24
    print("" "".join(map(str, result)))",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832921
1387832922,parabsaloni23,unknown,unknown,"1
2
def process_test_case(n, values):
3
    4
    result = [1] * n
5
    6
    7
    left_product = 1
8
    for i in range(n):
9
        result[i] = left_product
10
        left_product *= values[i]
11
    12
    13
    right_product = 1
14
    for i in range(n-1, -1, -1):
15
        result[i] *= right_product
16
        right_product *= values[i]
17
    18
    return result
19
20
21
22
23
24
25
T = int(input()) 
26
for _ in range(T):
27
    n = int(input())  
28
    values = list(map(int, input().split()))  
29
    result = process_test_case(n, values)
30
    print("" "".join(map(str, result)))  ",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832922
1387832919,singhrajbadri,unknown,unknown,"1
def compute_result(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
        8
        # Initialize prefix and suffix arrays
9
        prefix = [1] * n
10
        suffix = [1] * n
11
        result = [0] * n
12
        13
        # Compute prefix products
14
        for i in range(1, n):
15
            prefix[i] = prefix[i - 1] * values[i - 1]
16
        17
        # Compute suffix products
18
        for i in range(n - 2, -1, -1):
19
            suffix[i] = suffix[i + 1] * values[i + 1]
20
        21
        # Compute result for each node
22
        for i in range(n):
23
            result[i] = prefix[i] * suffix[i]
24
        25
        results.append(result)
26
    27
    return results
28
29
30
# Input handling
31
T = int(input())
32
test_cases = []
33
34
for _ in range(T):
35
    n = int(input())
36
    values = list(map(int, input().split()))
37
    test_cases.append((n, values))
38
39
# Compute results
40
results = compute_result(T, test_cases)
41
42
# Output results
43
for result in results:
44
    print("" "".join(map(str, result)))
45",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832919
1387832913,h1032231332,unknown,unknown,"1
def compute_result(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, values = case
6
        7
        # Step 1: Initialize prefix and suffix arrays
8
        prefix = [1] * n
9
        suffix = [1] * n
10
        result = [1] * n
11
12
        # Step 2: Compute prefix products
13
        for i in range(1, n):
14
            prefix[i] = prefix[i - 1] * values[i - 1]
15
16
        # Step 3: Compute suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix[i] = suffix[i + 1] * values[i + 1]
19
20
        # Step 4: Compute result
21
        for i in range(n):
22
            result[i] = prefix[i] * suffix[i]
23
24
        results.append(result)
25
26
    return results
27
28
# Input handling
29
def main():
30
    T = int(input())  # Number of test cases
31
    test_cases = []
32
33
    for _ in range(T):
34
        n = int(input())  # Number of nodes
35
        values = list(map(int, input().split()))  # Node values
36
        test_cases.append((n, values))
37
38
    # Process test cases
39
    results = compute_result(test_cases)
40
41
    # Output results
42
    for result in results:
43
        print("" "".join(map(str, result)))
44
45
if __name__ == ""__main__"":
46
    main()
47",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832913
1387832914,01snehapandey01,unknown,unknown,"1
def solve_test_cases():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().strip().split(""\n"")
5
    6
    idx = 0
7
    T = int(data[idx])
8
    idx += 1
9
    10
    results = []
11
12
    for _ in range(T):
13
        n = int(data[idx])
14
        idx += 1
15
        values = list(map(int, data[idx].split()))
16
        idx += 1
17
18
        # Edge case handling is not necessary due to constraints n >= 2
19
20
        # Step 1: Calculate prefix and suffix products
21
        prefix = [1] * n
22
        suffix = [1] * n
23
        result = [0] * n
24
25
        # Build prefix product array
26
        prefix[0] = values[0]
27
        for i in range(1, n):
28
            prefix[i] = prefix[i - 1] * values[i]
29
30
        # Build suffix product array
31
        suffix[n - 1] = values[n - 1]
32
        for i in range(n - 2, -1, -1):
33
            suffix[i] = suffix[i + 1] * values[i]
34
35
        # Compute result for each node
36
        for i in range(n):
37
            left_product = prefix[i - 1] if i > 0 else 1
38
            right_product = suffix[i + 1] if i < n - 1 else 1
39
            result[i] = left_product * right_product
40
41
        results.append("" "".join(map(str, result)))
42
43
    # Print all results at once to avoid multiple I/O operations
44
    sys.stdout.write(""\n"".join(results) + ""\n"")
45
46
if __name__ == ""__main__"":
47
    solve_test_cases()
48",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832914
1387832918,aryaprzz1,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static int minOperationsToEqualize(int n, int k, long[] energy) {
5
        long totalEnergy = 0;
6
        for (long e : energy) {
7
            totalEnergy += e;
8
        }
9
        10
        if (totalEnergy % n != 0) {
11
            return -1;
12
        }
13
        14
        long targetEnergy = totalEnergy / n;
15
        16
        for (long e : energy) {
17
            if (Math.abs(e - targetEnergy) % k != 0) {
18
                return -1;
19
            }
20
        }
21
        22
        int operations = 0;
23
        for (int i = 0; i < n; i++) {
24
            long diff = energy[i] - targetEnergy;
25
            if (diff != 0) {
26
                operations += Math.abs(diff / k);
27
            }
28
        }
29
        30
        return operations / 2;
31
    }
32
    33
    public static void main(String[] args) {
34
        Scanner scanner = new Scanner(System.in);
35
        int t = scanner.nextInt();
36
        37
        while (t-- > 0) {
38
            int n = scanner.nextInt();
39
            int k = scanner.nextInt();
40
            41
            long[] energy = new long[n];
42
            for (int i = 0; i < n; i++) {
43
                energy[i] = scanner.nextLong();
44
            }
45
            46
            System.out.println(minOperationsToEqualize(n, k, energy));
47
        }
48
        49
        scanner.close();
50
    }
51
}",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832918
1387832905,h1032220220,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for values in test_cases:
5
        n = len(values)
6
        result = [1] * n
7
        8
9
        left_product = 1
10
        for i in range(n):
11
            result[i] = left_product
12
            left_product *= values[i]
13
        14
     15
        right_product = 1
16
        for i in range(n - 1, -1, -1):
17
            result[i] *= right_product
18
            right_product *= values[i]
19
        20
        results.append(result)
21
    22
    return results
23
24
T = int(input())
25
test_cases = []
26
27
for _ in range(T):
28
    n = int(input())
29
    values = list(map(int, input().split()))
30
    test_cases.append(values)
31
32
33
results = product_except_self(test_cases)
34
35
for result in results:
36
    print("" "".join(map(str, result)))",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832905
1387832910,h1032220703,unknown,unknown,"1
def max_absolute_difference(nums):
2
    n = len(nums)
3
    4
    # Compute prefix sum to quickly calculate left and right sums
5
    prefix_sum = [0] * n
6
    prefix_sum[0] = nums[0]
7
    for i in range(1, n):
8
        prefix_sum[i] = prefix_sum[i - 1] + nums[i]
9
10
    total_sum = prefix_sum[-1]
11
    max_difference = 0
12
13
    # Iterate to split into two contiguous subarrays
14
    for i in range(n - 1):  # Skip last to ensure both subarrays are non-empty
15
        left_sum = prefix_sum[i]
16
        right_sum = total_sum - left_sum
17
        max_difference = max(max_difference, abs(left_sum - right_sum))
18
19
    return max_difference
20
21
22
# Reading input
23
t = int(input())
24
for _ in range(t):
25
    n = int(input())  # size of the array
26
    nums = list(map(int, input().strip().split()))  # array elements
27
    result = max_absolute_difference(nums)
28
    print(result)
29",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387832910
1387832912,swayam_prajapat1,unknown,unknown,"1
def product_except_self(test_cases):  
2
    results = []  
3
4
    for values in test_cases:  
5
        n = len(values)  
6
        total_product = 1  
7
        zero_count = 0  
8
        9
        # Calculate total product and count zeros  
10
        for value in values:  
11
            if value == 0:  
12
                zero_count += 1  
13
            else:  
14
                total_product *= value  
15
16
        # Prepare result array  
17
        result = []  
18
        for value in values:  
19
            if zero_count > 1:  
20
                result.append(0)  # More than one zero results in zero product  
21
            elif zero_count == 1:  
22
                result.append(total_product if value == 0 else 0)  # One zero results in total product of non-zero elements  
23
            else:  
24
                result.append(total_product // value)  # Normal case  
25
26
        results.append(result)  
27
28
    return results  
29
30
# Read input  
31
import sys  
32
input = sys.stdin.read  
33
data = input().strip().split('\n')  
34
35
T = int(data[0])  
36
test_cases = []  
37
index = 1  
38
for _ in range(T):  
39
    n = int(data[index])  # Read the number of nodes  
40
    values = list(map(int, data[index + 1].split()))  # Read the values  
41
    test_cases.append(values)  
42
    index += 2  # Move to the next test case  
43
44
# Get results  
45
results = product_except_self(test_cases)  
46
47
# Print results  
48
for result in results:  
49
    print("" "".join(map(str, result)))",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832912
1387832898,h1032220872,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
vector<vector<long long>> computeProducts(int T, vector<pair<int, vector<int>>>& testCases) {
6
    vector<vector<long long>> results;
7
8
    for (int t = 0; t < T; ++t) {
9
        int n = testCases[t].first;
10
        vector<int>& values = testCases[t].second;
11
        12
        // Result vector
13
        vector<long long> result(n, 1);
14
15
        // Compute prefix products
16
        long long prefix = 1;
17
        for (int i = 0; i < n; ++i) {
18
            result[i] = prefix;
19
            prefix *= values[i];
20
        }
21
22
        // Compute suffix products and multiply with prefix
23
        long long suffix = 1;
24
        for (int i = n - 1; i >= 0; --i) {
25
            result[i] *= suffix;
26
            suffix *= values[i];
27
        }
28
29
        results.push_back(result);
30
    }
31
32
    return results;
33
}
34
35
int main() {
36
    int T;
37
    cin >> T;  // Number of test cases
38
    vector<pair<int, vector<int>>> testCases;
39
40
    for (int t = 0; t < T; ++t) {
41
        int n;
42
        cin >> n;  // Number of nodes
43
        vector<int> values(n);
44
        for (int i = 0; i < n; ++i) {
45
            cin >> values[i];
46
        }
47
        testCases.emplace_back(n, values);
48
    }
49
50
    // Compute results
51
    vector<vector<long long>> results = computeProducts(T, testCases);
52
53
    // Output results
54
    for (const auto& result : results) {
55
        for (size_t i = 0; i < result.size(); ++i) {
56
            if (i > 0) cout << "" "";
57
            cout << result[i];
58
        }
59
        cout << endl;
60
    }
61
62
    return 0;
63
}
64",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832898
1387832903,yashrajverma0805,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) throws IOException {
7
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
8
        StringBuilder resultBuilder = new StringBuilder();
9
10
        int T = Integer.parseInt(br.readLine().trim()); // Number of test cases
11
        while (T-- > 0) {
12
            String[] firstLine = br.readLine().trim().split("" "");
13
            int N = Integer.parseInt(firstLine[0]); // Number of power stations
14
            long K = Long.parseLong(firstLine[1]); // Units of energy transferable in one operation
15
16
            String[] energyInput = br.readLine().trim().split("" "");
17
            long[] energy = new long[N];
18
            long totalEnergy = 0;
19
20
            for (int i = 0; i < N; i++) {
21
                energy[i] = Long.parseLong(energyInput[i]);
22
                totalEnergy += energy[i];
23
            }
24
25
            // If total energy is not divisible by N, it's impossible to equalize
26
            if (totalEnergy % N != 0) {
27
                resultBuilder.append(""-1\n"");
28
                continue;
29
            }
30
31
            long target = totalEnergy / N; // Energy each station should have
32
            long imbalance = 0;
33
            long operations = 0;
34
35
            // Calculate the number of operations needed to balance energy
36
            for (int i = 0; i < N; i++) {
37
                imbalance += (energy[i] - target); // Accumulated imbalance
38
                operations += Math.abs(imbalance); // Count the operations needed
39
            }
40
41
            // Append the result
42
            resultBuilder.append(operations).append(""\n"");
43
        }
44
45
        // Print all results at once
46
        System.out.print(resultBuilder.toString());
47
    }
48
}
49",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832903
1387832904,alstonsoares17,unknown,unknown,"1
def can_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
        7
    target_energy = total_energy // N
8
    operations = 0
9
    10
    differences = [energy[i] - target_energy for i in range(N)]
11
    12
    for diff in differences:
13
        if diff % K != 0:
14
            return -1
15
    16
    curr_transfer = 0
17
    for i in range(N-1):
18
        curr_transfer += differences[i]
19
        if curr_transfer != 0:
20
            operations += abs(curr_transfer) // K
21
    22
    curr_transfer += differences[N-1]
23
    if curr_transfer != 0:
24
        return -1
25
        26
    return operations
27
28
T = int(input())
29
for _ in range(T):
30
    N, K = map(int, input().split())
31
    energy = list(map(int, input().split()))
32
    result = can_equalize(N, K, energy)
33
    print(result)",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832904
1387832897,tanmoy2005barua,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for values in test_cases:
4
        n = len(values)
5
        result = [1] * n
6
        left_product = 1
7
        for i in range(n):
8
            result[i] = left_product
9
            left_product *= values[i]
10
        right_product = 1
11
        for i in range(n - 1, -1, -1):
12
            result[i] *= right_product
13
            right_product *= values[i]
14
        results.append(result)
15
    return results
16
17
try:
18
    T = int(input())
19
except EOFError:
20
    print(""No input provided."")
21
    T = 0
22
23
test_cases = []
24
for _ in range(T):
25
    n = int(input())
26
    values = list(map(int, input().split()))
27
    test_cases.append(values)
28
29
results = product_except_self(test_cases)
30
for result in results:
31
    print("" "".join(map(str, result)))
32",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832897
1387832893,pranalipahurkar,unknown,unknown,"1
def min_operations_to_equalize_energy(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # If total energy is not divisible by N, it's impossible to equalize
5
    if total_energy % N != 0:
6
        return -1
7
8
    target_energy = total_energy // N
9
    operations = 0
10
    balance = 0
11
12
    for i in range(N):
13
        balance += energy[i] - target_energy
14
        15
        # If balance is not divisible by K at any point, it's impossible
16
        if balance % K != 0:
17
            return -1
18
19
        operations += abs(balance // K)
20
21
    return operations
22
23
# Input handling
24
T = int(input())
25
results = []
26
for _ in range(T):
27
    N, K = map(int, input().split())
28
    energy = list(map(int, input().split()))
29
    result = min_operations_to_equalize_energy(N, K, energy)
30
    results.append(result)
31
32
# Output results
33
for res in results:
34
    print(res)
35",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832893
1387832895,darekarisha13,unknown,unknown,"1
def min_operations_to_equalize_energy(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # Check if total energy is divisible by N
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target_energy = total_energy // N
9
    operations = 0
10
    imbalance = 0
11
12
    # Calculate imbalance across the stations
13
    for i in range(N):
14
        imbalance += (energy[i] - target_energy)
15
        16
        # If the imbalance is not divisible by K, it's impossible
17
        if imbalance % K != 0:
18
            return -1
19
        20
        # Total operations is the absolute imbalance divided by K
21
        operations += abs(imbalance) // K
22
23
    return operations
24
25
# Input handling
26
def main():
27
    T = int(input())  # Number of test cases
28
    results = []
29
30
    for _ in range(T):
31
        N, K = map(int, input().split())
32
        energy = list(map(int, input().split()))
33
        results.append(min_operations_to_equalize_energy(N, K, energy))
34
35
    # Print the results for all test cases
36
    for res in results:
37
        print(res)
38
39
# Execute the program
40
if __name__ == ""__main__"":
41
    main()
42",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832895
1387832896,kadamshravani245,unknown,unknown,"1
def solve():
2
    T = int(input())  # Number of test cases
3
    4
    for _ in range(T):
5
        n = int(input())  # Number of nodes
6
        values = list(map(int, input().split()))  # The values in the nodes
7
        8
        # Step 1: Initialize result array
9
        result = [1] * n
10
        11
        # Step 2: Compute prefix products and store them in result
12
        left_product = 1
13
        for i in range(n):
14
            result[i] *= left_product
15
            left_product *= values[i]
16
        17
        # Step 3: Compute suffix products and multiply them into result
18
        right_product = 1
19
        for i in range(n-1, -1, -1):
20
            result[i] *= right_product
21
            right_product *= values[i]
22
        23
        # Step 4: Output the result array for this test case
24
        print("" "".join(map(str, result)))
25
26
# Read input and solve the problem
27
solve()
28",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832896
1387832887,h1032231318,unknown,unknown,"1
def network_product(test_cases):
2
    results = []
3
4
    for t in range(test_cases):
5
        n = int(input())
6
        values = list(map(int, input().split()))
7
        result = [0] * n
8
9
        product = 1
10
        zero_count = 0
11
12
        for value in values:
13
            if value != 0:
14
                product *= value
15
            else:
16
                zero_count += 1
17
18
        for i in range(n):
19
            if zero_count > 1:
20
                result[i] = 0  
21
            elif zero_count == 1:
22
                result[i] = product if values[i] == 0 else 0
23
            else:
24
                result[i] = product // values[i] 
25
26
        results.append(result)
27
28
    for res in results:
29
        print("" "".join(map(str, res)))
30
31
32
if __name__ == ""__main__"":
33
    T = int(input())  
34
    network_product(T)
35",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832887
1387832891,isha_bhosale04,unknown,unknown,"1
def compute_products(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
8
        # Initialize prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
12
        # Compute prefix products
13
        for i in range(1, n):
14
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
15
16
        # Compute suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
19
20
        # Compute result for each node
21
        result = [prefix_products[i] * suffix_products[i] for i in range(n)]
22
        results.append(result)
23
24
    return results
25
26
# Input handling
27
T = int(input())
28
test_cases = []
29
30
for _ in range(T):
31
    n = int(input())
32
    values = list(map(int, input().split()))
33
    test_cases.append((n, values))
34
35
# Compute results
36
results = compute_products(T, test_cases)
37
38
# Output results
39
for result in results:
40
    print("" "".join(map(str, result)))",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832891
1387832888,h1032221497,unknown,unknown,"1
def product_except_self(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
8
        # Initialize prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
        result = [0] * n
12
13
        # Compute prefix products
14
        for i in range(1, n):
15
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
16
17
        # Compute suffix products
18
        for i in range(n - 2, -1, -1):
19
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
20
21
        # Compute result array
22
        for i in range(n):
23
            result[i] = prefix_products[i] * suffix_products[i]
24
25
        results.append(result)
26
27
    return results
28
29
# Input reading
30
T = int(input())
31
test_cases = []
32
for _ in range(T):
33
    n = int(input())
34
    values = list(map(int, input().split()))
35
    test_cases.append((n, values))
36
37
# Solve and output results
38
results = product_except_self(T, test_cases)
39
for result in results:
40
    print("" "".join(map(str, result)))",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832888
1387832885,vg2556519,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target = total_energy // N
8
    prefix_sum = 0
9
    max_transfer_needed = 0
10
    11
    for i in range(N):
12
        prefix_sum += energy[i] - target
13
        max_transfer_needed = max(max_transfer_needed, abs(prefix_sum))
14
    15
    return (max_transfer_needed + K - 1) // K 
16
17
T = int(input().strip()) 
18
for _ in range(T):
19
    N, K = map(int, input().strip().split()) 
20
    energy = list(map(int, input().strip().split()))
21
    print(min_operations_to_equalize(N, K, energy))
22",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832885
1387832883,prathameshbhoit1,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # Check if it's possible to equalize
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target = total_energy // N
9
    operations = 0
10
    11
    for i in range(N):
12
        diff = energy[i] - target
13
        14
        # If the difference is not divisible by K, it's impossible
15
        if diff % K != 0:
16
            return -1
17
        18
        # Accumulate the number of operations
19
        operations += abs(diff) // K
20
    21
    # Since each operation transfers K units, divide by 2 to avoid double-counting
22
    return operations // 2
23
24
25
def main():
26
    import sys
27
    input = sys.stdin.read
28
    data = input().split()
29
    30
    idx = 0
31
    T = int(data[idx])
32
    idx += 1
33
    34
    for _ in range(T):
35
        N = int(data[idx])
36
        K = int(data[idx + 1])
37
        idx += 2
38
        39
        energy = list(map(int, data[idx:idx + N]))
40
        idx += N
41
        42
        result = min_operations_to_equalize(N, K, energy)
43
        print(result)
44
45
46
if __name__ == ""__main__"":
47
    main()",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832883
1387832886,h1032220403,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, values = case
6
        result = [1] * n
7
8
        # Calculate prefix products
9
        prefix = 1
10
        for i in range(n):
11
            result[i] = prefix
12
            prefix *= values[i]
13
14
        # Calculate suffix products and combine with prefix products
15
        suffix = 1
16
        for i in range(n - 1, -1, -1):
17
            result[i] *= suffix
18
            suffix *= values[i]
19
20
        results.append(result)
21
22
    return results
23
24
# Input
25
T = int(input())
26
test_cases = []
27
for _ in range(T):
28
    n = int(input())
29
    values = list(map(int, input().split()))
30
    test_cases.append((n, values))
31
32
# Process
33
results = product_except_self(test_cases)
34
35
# Output
36
for result in results:
37
    print("" "".join(map(str, result)))",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832886
1387832882,Sanika2112,unknown,unknown,"1
def min_operations_to_equalize_energy(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    if total_energy % N != 0:
5
        return -1
6
    7
    target_energy = total_energy // N
8
    prefix_sum = 0
9
    operations = 0
10
    11
    for i in range(N):
12
        prefix_sum += energy[i] - target_energy
13
        if prefix_sum % K != 0:
14
            return -1
15
        operations += abs(prefix_sum) // K
16
    17
    return operations
18
19
# Reading input
20
T = int(input().strip())
21
results = []
22
23
for _ in range(T):
24
    N, K = map(int, input().strip().split())
25
    energy = list(map(int, input().strip().split()))
26
    result = min_operations_to_equalize_energy(N, K, energy)
27
    results.append(result)
28
29
# Output the results
30
for result in results:
31
    print(result)
32",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832882
1387832876,vishpratik5,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
    5
    # Calculate the product of all elements to the left of each index
6
    left_product = 1
7
    for i in range(n):
8
        result[i] = left_product
9
        left_product *= values[i]
10
    11
    # Calculate the product of all elements to the right of each index and multiply with the left product
12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    return result
18
19
def main():
20
    import sys
21
    input = sys.stdin.read
22
    data = input().split()
23
    24
    idx = 0
25
    T = int(data[idx])
26
    idx += 1
27
    28
    for _ in range(T):
29
        n = int(data[idx])
30
        idx += 1
31
        values = list(map(int, data[idx:idx+n]))
32
        idx += n
33
        34
        result = product_except_self(values)
35
        print(' '.join(map(str, result)))
36
37
if __name__ == ""__main__"":
38
    main()",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832876
1387832877,suman197960,unknown,unknown,"1
def min_operations_to_equalize(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
        8
        total_energy = sum(energy)
9
        10
        # If total energy is not divisible by N, it's impossible to equalize
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target = total_energy // N
16
        balance = 0
17
        total_moves = 0
18
        19
        possible = True
20
        for e in energy:
21
            # Calculate balance for the current station
22
            balance += (e - target)
23
            24
            # Check divisibility of balance by K
25
            if abs(balance) % K != 0:
26
                possible = False
27
                break
28
            29
            # Total moves accumulate the absolute balance
30
            total_moves += abs(balance)
31
        32
        # Append the result
33
        results.append(total_moves // K if possible else -1)
34
    35
    return results
36
37
# Input handling
38
T = int(input())
39
test_cases = []
40
41
for _ in range(T):
42
    N, K = map(int, input().split())
43
    energy = list(map(int, input().split()))
44
    test_cases.append(((N, K), energy))
45
46
# Solve the problem
47
results = min_operations_to_equalize(T, test_cases)
48
49
# Output the results
50
for res in results:
51
    print(res)
52",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832877
1387832880,aryanrrsingh_04,unknown,unknown,"1
def calculate_result(test_cases):
2
    results = []
3
    for t in range(test_cases):
4
        n = int(input())  # Number of nodes in the current test case
5
        values = list(map(int, input().split()))
6
        7
        # Calculate prefix and suffix products
8
        prefix = [1] * n
9
        suffix = [1] * n
10
        11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] * values[i + 1]
16
        17
        # Calculate the result for the current test case
18
        result = [prefix[i] * suffix[i] for i in range(n)]
19
        results.append(result)
20
    21
    return results
22
23
# Read input
24
T = int(input())  # Number of test cases
25
output = calculate_result(T)
26
27
# Print the results
28
for res in output:
29
    print("" "".join(map(str, res)))",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832880
1387832872,a_redij04,unknown,unknown,"1
def solve():
2
    # Read number of test cases
3
    T = int(input())
4
    5
    # Iterate through each test case
6
    for _ in range(T):
7
        # Read N and K
8
        N, K = map(int, input().split())
9
        10
        # Read the energy levels of the power stations
11
        energy = list(map(int, input().split()))
12
        13
        # Calculate total energy and check divisibility by N
14
        total_energy = sum(energy)
15
        if total_energy % N != 0:
16
            # If total energy is not divisible by N, it's impossible to equalize
17
            print(-1)
18
            continue
19
        20
        # The target energy each station should have
21
        target_energy = total_energy // N
22
        23
        # Variable to track the number of operations
24
        operations = 0
25
        balance = 0
26
        27
        # Traverse through the stations and calculate the operations needed
28
        for i in range(N):
29
            # Calculate the difference from the target
30
            balance += energy[i] - target_energy
31
            32
            # If balance is not a multiple of K at any point, it's impossible
33
            if balance % K != 0:
34
                print(-1)
35
                break
36
            # Count how many operations we have done
37
            operations += abs(balance) // K
38
        else:
39
            # If we complete the loop successfully, print the operations
40
            print(operations)
41
42
# Calling the solve function to execute the logic
43
solve()
44",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832872
1387832875,sohamkadam0012,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
// Function to calculate the minimum operations or check if equalization is impossible
5
int minOperationsToEqualize(int *energy, int n, int k) {
6
    long long totalEnergy = 0;
7
8
    // Calculate total energy
9
    for (int i = 0; i < n; i++) {
10
        totalEnergy += energy[i];
11
    }
12
13
    // Check if total energy is divisible by N
14
    if (totalEnergy % n != 0) {
15
        return -1;
16
    }
17
18
    long long targetEnergy = totalEnergy / n; // Target energy for each station
19
    long long operations = 0;
20
    long long surplus = 0; // Tracks energy surplus or deficit in the cycle
21
22
    for (int i = 0; i < n; i++) {
23
        surplus += energy[i] - targetEnergy;
24
        if (surplus % k != 0) {
25
            return -1; // If the surplus cannot be transferred in multiples of k, it's impossible
26
        }
27
        operations += abs(surplus / k);
28
    }
29
30
    return operations;
31
}
32
33
int main() {
34
    int T;
35
    scanf(""%d"", &T);
36
37
    while (T--) {
38
        int n, k;
39
        scanf(""%d %d"", &n, &k);
40
41
        int *energy = (int *)malloc(n * sizeof(int));
42
        for (int i = 0; i < n; i++) {
43
            scanf(""%d"", &energy[i]);
44
        }
45
46
        int result = minOperationsToEqualize(energy, n, k);
47
        printf(""%d\n"", result);
48
49
        free(energy);
50
    }
51
52
    return 0;
53
}
54
55",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832875
1387832873,cjain1725,unknown,unknown,"1
def solve_product_array(n, values):
2
    """"""
3
    Calculate product of all elements except self for each position
4
    5
    Args:
6
        n (int): Size of the array
7
        values (list): Input array of integers
8
        9
    Returns:
10
        list: Array where each element is product of all numbers except self
11
    """"""
12
    # Edge case - if n < 2
13
    if n < 2:
14
        return values
15
    16
    # Initialize result array with 1s
17
    result = [1] * n
18
    19
    # Calculate products of all elements to the left of each position
20
    left_product = 1
21
    for i in range(n):
22
        result[i] = left_product
23
        left_product *= values[i]
24
    25
    # Calculate products of all elements to the right and multiply with left products
26
    right_product = 1
27
    for i in range(n-1, -1, -1):
28
        result[i] *= right_product
29
        right_product *= values[i]
30
    31
    return result
32
33
def main():
34
    # Read number of test cases
35
    T = int(input())
36
    37
    # Process each test case
38
    for _ in range(T):
39
        # Read array size
40
        n = int(input())
41
        42
        # Read array values
43
        values = list(map(int, input().split()))
44
        45
        # Calculate result
46
        result = solve_product_array(n, values)
47
        48
        # Print result
49
        print(*result)
50
51
if __name__ == ""__main__"":
52
    main()",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832873
1387832867,harikeshyadav161,unknown,unknown,"1
def product_except_self(arr, n):
2
3
    # Step 1: Create prefix and suffix product arrays
4
5
    prefix = [1] * n
6
7
    suffix = [1] * n
8
9
    result = [1] * n
10
11
    # Step 2: Compute prefix product
12
13
    for i in range(1, n):
14
15
        prefix[i] = prefix[i - 1] * arr[i - 1]
16
17
    # Step 3: Compute suffix product
18
19
    for i in range(n - 2, -1, -1):
20
21
        suffix[i] = suffix[i + 1] * arr[i + 1]
22
23
    # Step 4: Compute result[i] as prefix[i] * suffix[i]
24
25
    for i in range(n):
26
27
        result[i] = prefix[i] * suffix[i]
28
29
    return result
30
31
# Reading input
32
33
T = int(input().strip())  # Number of test cases
34
35
for _ in range(T):
36
37
    n = int(input().strip())  # Size of array
38
39
    arr = list(map(int, input().strip().split()))  # Array elements
40
41
    print(*product_except_self(arr, n))  # Print result",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832867
1387832868,h1032221730,unknown,unknown,"1
def solve_testcase(n, nums):
2
    # If array has only 2 elements, return their absolute difference
3
    if n == 2:
4
        return abs(nums[0] - nums[1])
5
    6
    # Calculate the total sum of the array
7
    total_sum = sum(nums)
8
    9
    max_diff = 0
10
    left_sum = 0
11
    12
    # Try each possible partition point
13
    # We need to ensure both subarrays are non-empty,
14
    # so we only go up to n-1 (leaving at least one element for the right subarray)
15
    for i in range(n-1):
16
        # Add current element to left sum
17
        left_sum += nums[i]
18
        # Right sum is the remaining elements
19
        right_sum = total_sum - left_sum
20
        # Calculate absolute difference
21
        curr_diff = abs(left_sum - right_sum)
22
        # Update max_diff if current difference is larger
23
        max_diff = max(max_diff, curr_diff)
24
    25
    return max_diff
26
27
def main():
28
    # Read number of test cases
29
    t = int(input())
30
    31
    # Process each test case
32
    for _ in range(t):
33
        # Read array size
34
        n = int(input())
35
        # Read array elements
36
        nums = list(map(int, input().split()))
37
        38
        # Solve current test case
39
        result = solve_testcase(n, nums)
40
        41
        # Print result
42
        print(result)
43
44
if __name__ == ""__main__"":
45
    main()",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387832868
1387832871,anushanchan33,unknown,unknown,"1
def compute_product_array(n, values):
2
    prefix = [1] * n
3
    for i in range(1, n):
4
        prefix[i] = prefix[i - 1] * values[i - 1]
5
    6
    suffix = [1] * n
7
    for i in range(n - 2, -1, -1):
8
        suffix[i] = suffix[i + 1] * values[i + 1]
9
    10
    result = [prefix[i] * suffix[i] for i in range(n)]
11
    12
    return result
13
14
T = int(input().strip()) 
15
for _ in range(T):
16
    n = int(input().strip()) 
17
    values = list(map(int, input().strip().split()))
18
    print("" "".join(map(str, compute_product_array(n, values))))",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832871
1387832866,h1032221377,unknown,unknown,"1
def compute_products(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
8
        # Initialize prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
12
        # Compute prefix products
13
        for i in range(1, n):
14
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
15
16
        # Compute suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
19
20
        # Compute result for each node
21
        result = [prefix_products[i] * suffix_products[i] for i in range(n)]
22
        results.append(result)
23
24
    return results
25
26
# Input handling
27
T = int(input())
28
test_cases = []
29
30
for _ in range(T):
31
    n = int(input())
32
    values = list(map(int, input().split()))
33
    test_cases.append((n, values))
34
35
# Compute results
36
results = compute_products(T, test_cases)
37
38
# Output results
39
for result in results:
40
    print("" "".join(map(str, result)))
41",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832866
1387832860,h1032231248,unknown,unknown,"1
def minimum_operations(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        N, K = test_cases[t][0]
5
        energy = test_cases[t][1]
6
        7
        total_energy = sum(energy)
8
        9
        # Check divisibility of total energy
10
        if total_energy % N != 0:
11
            results.append(-1)
12
            continue
13
        14
        target = total_energy // N
15
        imbalances = [energy[i] - target for i in range(N)]
16
        17
        # Check if imbalances are divisible by K
18
        if any(imbalance % K != 0 for imbalance in imbalances):
19
            results.append(-1)
20
            continue
21
        22
        # Calculate minimum operations
23
        operations = 0
24
        running_sum = 0
25
        for imbalance in imbalances:
26
            running_sum += imbalance
27
            operations += abs(running_sum // K)
28
        29
        results.append(operations)
30
    31
    return results
32
33
# Input and Output Handling
34
if __name__ == ""__main__"":
35
    T = int(input().strip())
36
    test_cases = []
37
    for _ in range(T):
38
        N, K = map(int, input().strip().split())
39
        energy = list(map(int, input().strip().split()))
40
        test_cases.append(((N, K), energy))
41
    42
    results = minimum_operations(T, test_cases)
43
    print(""\n"".join(map(str, results)))
44",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832860
1387832862,yashkchaudhari1,unknown,unknown,"1
def main():
2
    import sys
3
    input = sys.stdin.read().split()
4
    idx = 0
5
    T = int(input[idx])
6
    idx += 1
7
    for _ in range(T):
8
        n = int(input[idx])
9
        idx += 1
10
        values = list(map(int, input[idx:idx+n]))
11
        idx += n
12
        13
        left = [1] * n
14
        for i in range(1, n):
15
            left[i] = left[i-1] * values[i-1]
16
        17
        result = [0] * n
18
        right_product = 1
19
        for i in range(n-1, -1, -1):
20
            result[i] = left[i] * right_product
21
            right_product *= values[i]
22
        23
        print(' '.join(map(str, result)))
24
25
if __name__ == ""__main__"":
26
    main()",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832862
1387832865,pankajchaudhar15,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def calculate_product_excluding_self():
3
    T = int(input())  # Number of test cases
4
    results = []
5
    6
    for _ in range(T):
7
        n = int(input())  # Number of nodes
8
        values = list(map(int, input().split()))  # Node values
9
        10
        # Initialize prefix and suffix products
11
        prefix = [1] * n
12
        suffix = [1] * n
13
        result = [1] * n
14
        15
        # Compute prefix products
16
        for i in range(1, n):
17
            prefix[i] = prefix[i - 1] * values[i - 1]
18
        19
        # Compute suffix products
20
        for i in range(n - 2, -1, -1):
21
            suffix[i] = suffix[i + 1] * values[i + 1]
22
        23
        # Compute result array
24
        for i in range(n):
25
            result[i] = prefix[i] * suffix[i]
26
        27
        # Append the result for the current test case
28
        results.append("" "".join(map(str, result)))
29
    30
    # Print all results for the test cases
31
    print(""\n"".join(results))
32
33
# Example Usage
34
# Input provided according to the sample problem
35
calculate_product_excluding_self()
36",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832865
1387832858,sohamkadam0012,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
// Function to calculate the minimum operations or check if equalization is impossible
5
int minOperationsToEqualize(int *energy, int n, int k) {
6
    long long totalEnergy = 0;
7
8
    // Calculate total energy
9
    for (int i = 0; i < n; i++) {
10
        totalEnergy += energy[i];
11
    }
12
13
    // Check if total energy is divisible by N
14
    if (totalEnergy % n != 0) {
15
        return -1;
16
    }
17
18
    long long targetEnergy = totalEnergy / n; // Target energy for each station
19
    long long operations = 0;
20
    long long surplus = 0; // Tracks energy surplus or deficit in the cycle
21
22
    for (int i = 0; i < n; i++) {
23
        surplus += energy[i] - targetEnergy;
24
        if (surplus % k != 0) {
25
            return -1; // If the surplus cannot be transferred in multiples of k, it's impossible
26
        }
27
        operations += abs(surplus / k);
28
    }
29
30
    return operations;
31
}
32
33
int main() {
34
    int T;
35
    scanf(""%d"", &T);
36
37
    while (T--) {
38
        int n, k;
39
        scanf(""%d %d"", &n, &k);
40
41
        int *energy = (int *)malloc(n * sizeof(int));
42
        for (int i = 0; i < n; i++) {
43
            scanf(""%d"", &energy[i]);
44
        }
45
46
        int result = minOperationsToEqualize(energy, n, k);
47
        printf(""%d\n"", result);
48
49
        free(energy);
50
    }
51
52
    return 0;
53
}
54",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832858
1387832859,dhruvppaste20,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
int main() {
6
    int T;
7
    cin >> T;
8
    while (T--) {
9
        int n;
10
        cin >> n;
11
        vector<int> values(n);
12
        for (int i = 0; i < n; ++i) {
13
            cin >> values[i];
14
        }
15
        vector<long long> result(n, 1);
16
        17
        18
        for (int i = 1; i < n; ++i) {
19
            result[i] = result[i-1] * values[i-1];
20
        }
21
        22
    23
        long long right_product = 1;
24
        for (int i = n-1; i >= 0; --i) {
25
            result[i] *= right_product;
26
            right_product *= values[i];
27
        }
28
        29
    30
        for (int i = 0; i < n; ++i) {
31
            cout << result[i];
32
            if (i != n-1) cout << "" "";
33
        }
34
        cout << endl;
35
    }
36
    return 0;
37
}",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832859
1387832857,warangsmit,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n=int(input())
4
    arr=list(map(int,input().split()))
5
    prod=1
6
    for i in arr:prod*=i
7
    for i in range(n):print(prod//arr[i],end=' ')
8
    print()",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832857
1387832853,h1032221480,unknown,unknown,"1
def solve_product_except_self():
2
    T = int(input())  # Number of test cases
3
    results = []
4
5
    for _ in range(T):
6
        n = int(input())  # Number of nodes
7
        values = list(map(int, input().split()))
8
        9
        # Initialize result array
10
        result = [1] * n
11
12
        # Compute prefix products
13
        prefix = 1
14
        for i in range(n):
15
            result[i] = prefix
16
            prefix *= values[i]
17
18
        # Compute suffix products and update result
19
        suffix = 1
20
        for i in range(n - 1, -1, -1):
21
            result[i] *= suffix
22
            suffix *= values[i]
23
24
        results.append("" "".join(map(str, result)))
25
26
    print(""\n"".join(results))
27
28
29
# Call the function to execute
30
solve_product_except_self()
31",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832853
1387832855,isha_bhosale04,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        N, K = test_cases[t][:2]
6
        energy = test_cases[t][2]
7
        8
        total_energy = sum(energy)
9
        10
        # If the total energy is not divisible by N, it's impossible to equalize
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target = total_energy // N
16
        operations = 0
17
        excess_energy = 0
18
        19
        # Traverse the array, simulating the circular transfer
20
        for i in range(N):
21
            # Calculate the difference between current station energy and target
22
            excess_energy += energy[i] - target
23
            24
            # The number of operations required for this difference to propagate
25
            if excess_energy % K != 0:
26
                operations = -1
27
                break
28
            29
            operations += abs(excess_energy) // K
30
        31
        results.append(operations if operations != -1 else -1)
32
    33
    return results
34
35
36
# Input handling
37
T = int(input())
38
test_cases = []
39
for _ in range(T):
40
    N, K = map(int, input().split())
41
    energy = list(map(int, input().split()))
42
    test_cases.append((N, K, energy))
43
44
# Output the results
45
results = minimum_operations_to_equalize(T, test_cases)
46
for res in results:
47
    print(res)",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832855
1387832856,ankitayadav25310,unknown,unknown,"1
def solve_testcase(n, values):
2
    # Initialize result array
3
    result = [1] * n
4
    5
    # Calculate prefix products
6
    # result[i] will first store product of all elements to the left of i
7
    prefix = 1
8
    for i in range(n):
9
        result[i] = prefix
10
        prefix *= values[i]
11
    12
    # Calculate suffix products and combine with prefix products
13
    # For each position, multiply its prefix product with suffix product
14
    suffix = 1
15
    for i in range(n-1, -1, -1):
16
        result[i] *= suffix
17
        suffix *= values[i]
18
    19
    return result
20
21
def main():
22
    # Read number of test cases
23
    T = int(input())
24
    25
    # Process each test case
26
    for _ in range(T):
27
        # Read input for current test case
28
        n = int(input())
29
        values = list(map(int, input().split()))
30
        31
        # Solve current test case
32
        result = solve_testcase(n, values)
33
        34
        # Print result
35
        print(*result)
36
37
if __name__ == ""__main__"":  # Fixed the typo here
38
    main()
39",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832856
1387832852,dhuvesh_salian,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
int main() {
6
    int T; 
7
    cin >> T;
8
    9
    while (T--) {
10
        int n;
11
        cin >> n;
12
        13
        vector<int> values(n);
14
        for (int i = 0; i < n; ++i) {
15
            cin >> values[i];
16
        }
17
        18
        vector<int> prefix(n, 1);
19
        vector<int> suffix(n, 1);
20
        vector<int> result(n);
21
22
        for (int i = 1; i < n; ++i) {
23
            prefix[i] = prefix[i - 1] * values[i - 1];
24
        }
25
        26
27
        for (int i = n - 2; i >= 0; --i) {
28
            suffix[i] = suffix[i + 1] * values[i + 1];
29
        }
30
        31
32
        for (int i = 0; i < n; ++i) {
33
            result[i] = prefix[i] * suffix[i];
34
        }
35
        36
   37
        for (int i = 0; i < n; ++i) {
38
            cout << result[i] << "" "";
39
        }
40
        cout << endl;
41
    }
42
    43
    return 0;
44
}
45",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832852
1387832841,h1032231318,unknown,unknown,"1
def network_product(test_cases):
2
    results = []
3
4
    for t in range(test_cases):
5
        n = int(input())  # Number of nodes
6
        values = list(map(int, input().split()))
7
        result = [0] * n
8
9
        product = 1
10
        zero_count = 0
11
12
        for value in values:
13
            if value != 0:
14
                product *= value
15
            else:
16
                zero_count += 1
17
18
        for i in range(n):
19
            if zero_count > 1:
20
                result[i] = 0  
21
            elif zero_count == 1:
22
                result[i] = product if values[i] == 0 else 0
23
            else:
24
                result[i] = product // values[i] 
25
26
        results.append(result)
27
28
    for res in results:
29
        print("" "".join(map(str, res)))
30
31
32
if __name__ == ""__main__"":
33
    T = int(input())  
34
    network_product(T)
35",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832841
1387832849,mahekjitu20,unknown,unknown,"1
def compute_products(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
8
        # Initialize prefix and suffix products
9
        prefix_products = [1] * n
10
        suffix_products = [1] * n
11
12
        # Compute prefix products
13
        for i in range(1, n):
14
            prefix_products[i] = prefix_products[i - 1] * values[i - 1]
15
16
        # Compute suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix_products[i] = suffix_products[i + 1] * values[i + 1]
19
20
        # Compute result for each node
21
        result = [prefix_products[i] * suffix_products[i] for i in range(n)]
22
        results.append(result)
23
24
    return results
25
26
# Input handling
27
T = int(input())
28
test_cases = []
29
30
for _ in range(T):
31
    n = int(input())
32
    values = list(map(int, input().split()))
33
    test_cases.append((n, values))
34
35
# Compute results
36
results = compute_products(T, test_cases)
37
38
# Output results
39
for result in results:
40
    print("" "".join(map(str, result)))",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832849
1387832850,h1032221473,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
8
        total_energy = sum(energy)
9
10
        # If total energy is not divisible by N, equalization is impossible
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
15
        target_energy = total_energy // N
16
        17
        # Calculate the net energy transfer needed at each station
18
        transfers = [energy[i] - target_energy for i in range(N)]
19
20
        # Check if the transfers can be achieved with the given K
21
        cumulative_transfer = 0
22
        possible = True
23
        operations = 0
24
25
        for transfer in transfers:
26
            cumulative_transfer += transfer
27
            if cumulative_transfer % K != 0:
28
                possible = False
29
                break
30
            operations += abs(cumulative_transfer // K)
31
32
        results.append(operations if possible else -1)
33
34
    return results
35
36
def main():
37
    T = int(input())
38
    test_cases = []
39
40
    for _ in range(T):
41
        N, K = map(int, input().split())
42
        energy = list(map(int, input().split()))
43
        test_cases.append(((N, K), energy))
44
45
    results = min_operations_to_equalize_energy(T, test_cases)
46
    for result in results:
47
        print(result)
48
49
if __name__ == ""__main__"":
50
    main()",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832850
1387832836,aditya_jha027,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, values = case
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [1] * n
9
10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] * values[i - 1]
12
        13
        for i in range(n - 2, -1, -1):
14
            suffix[i] = suffix[i + 1] * values[i + 1]
15
        16
        for i in range(n):
17
            result[i] = prefix[i] * suffix[i]
18
        19
        results.append(result)
20
    21
    return results
22
23
T = int(input())
24
test_cases = []
25
26
for _ in range(T):
27
    n = int(input())
28
    values = list(map(int, input().split()))
29
    test_cases.append((n, values))
30
31
output = product_except_self(test_cases)
32
for res in output:
33
    print("" "".join(map(str, res)))",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832836
1387832838,maurya_anjali061,unknown,unknown,"1
def max_absolute_difference(nums):
2
    total_sum = sum(nums)
3
    left_sum = 0
4
    max_diff = 0
5
    6
    for i in range(1, len(nums)):
7
        left_sum += nums[i-1]
8
        right_sum = total_sum - left_sum
9
        max_diff = max(max_diff, abs(left_sum - right_sum))
10
    11
    return max_diff
12
13
t = int(input())  
14
for _ in range(t):
15
    n = int(input())
16
    nums = list(map(int, input().split()))
17
    result = max_absolute_difference(nums)
18
    print(result)
19",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387832838
1387832839,yashasharma21005,unknown,unknown,"1
def solve_product_excluding_self(test_cases):
2
    results = []
3
    for t in range(test_cases):
4
        n = int(input())
5
        values = list(map(int, input().split()))
6
        if n == 1:
7
            results.append([1])
8
            continue
9
10
        prefix = [1] * n
11
        suffix = [1] * n
12
        result = [0] * n
13
        for i in range(1, n):
14
            prefix[i] = prefix[i - 1] * values[i - 1]
15
16
        for i in range(n - 2, -1, -1):
17
            suffix[i] = suffix[i + 1] * values[i + 1]
18
        for i in range(n):
19
            result[i] = prefix[i] * suffix[i]
20
21
        results.append(result)
22
    for res in results:
23
        print("" "".join(map(str, res)))
24
T = int(input())
25
solve_product_excluding_self(T)
26",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832839
1387832830,yashrajverma0805,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) throws IOException {
7
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
8
        StringBuilder resultBuilder = new StringBuilder();
9
        10
        int T = Integer.parseInt(br.readLine().trim()); // Number of test cases
11
        while (T-- > 0) {
12
            int n = Integer.parseInt(br.readLine().trim()); // Number of nodes
13
            String[] valuesInput = br.readLine().trim().split("" "");
14
            int[] values = new int[n];
15
            16
            for (int i = 0; i < n; i++) {
17
                values[i] = Integer.parseInt(valuesInput[i]);
18
            }
19
            20
            // Compute the prefix and suffix products
21
            long[] prefix = new long[n];
22
            long[] suffix = new long[n];
23
            long[] result = new long[n];
24
            25
            prefix[0] = 1; // Initialize prefix product
26
            for (int i = 1; i < n; i++) {
27
                prefix[i] = prefix[i - 1] * values[i - 1];
28
            }
29
            30
            suffix[n - 1] = 1; // Initialize suffix product
31
            for (int i = n - 2; i >= 0; i--) {
32
                suffix[i] = suffix[i + 1] * values[i + 1];
33
            }
34
            35
            // Calculate result[i] as prefix[i] * suffix[i]
36
            for (int i = 0; i < n; i++) {
37
                result[i] = prefix[i] * suffix[i];
38
            }
39
            40
            // Append result to output
41
            for (int i = 0; i < n; i++) {
42
                resultBuilder.append(result[i]).append("" "");
43
            }
44
            resultBuilder.append(""\n"");
45
        }
46
        47
        // Print the final result
48
        System.out.print(resultBuilder.toString());
49
    }
50
}
51",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832830
1387832831,shivamthakur0201,unknown,unknown,"1
def solve_testcase(n, values):
2
    # Initialize result array with 1s
3
    result = [1] * n
4
    5
    # Calculate products of all elements to the left
6
    left_product = 1
7
    for i in range(n):
8
        result[i] = left_product
9
        left_product *= values[i]
10
    11
    # Calculate products of all elements to the right and combine with left products
12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    # Convert result to space-separated string
18
    return "" "".join(map(str, result))
19
20
def main():
21
22
    T = int(input())
23
24
    for _ in range(T):
25
  26
        n = int(input())
27
        values = list(map(int, input().split()))
28
29
        print(solve_testcase(n, values))
30
31
if __name__ == ""__main__"":
32
    main()",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832831
1387832835,mtsn9699,unknown,unknown,"1
def compute_result(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        prefix = [1] * n
6
        suffix = [1] * n
7
        result = [1] * n
8
9
        for i in range(1, n):
10
            prefix[i] = prefix[i - 1] * values[i - 1]
11
12
        for i in range(n - 2, -1, -1):
13
            suffix[i] = suffix[i + 1] * values[i + 1]
14
15
        for i in range(n):
16
            result[i] = prefix[i] * suffix[i]
17
18
        results.append(result)
19
20
    return results
21
22
def main():
23
    T = int(input())  
24
    test_cases = []
25
26
    for _ in range(T):
27
        n = int(input())  
28
        values = list(map(int, input().split()))  
29
        test_cases.append((n, values))
30
31
    results = compute_result(test_cases)
32
33
    for result in results:
34
        print("" "".join(map(str, result)))
35
36
if __name__ == ""__main__"":
37
    main()
38",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832835
1387832829,darekarisha13,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
5
    # Calculate prefix products
6
    prefix = 1
7
    for i in range(n):
8
        result[i] = prefix
9
        prefix *= values[i]
10
11
    # Calculate suffix products and combine with prefix products
12
    suffix = 1
13
    for i in range(n - 1, -1, -1):
14
        result[i] *= suffix
15
        suffix *= values[i]
16
17
    return result
18
19
# Input handling
20
def main():
21
    T = int(input())  # Number of test cases
22
    results = []
23
24
    for _ in range(T):
25
        n = int(input())  # Number of nodes
26
        values = list(map(int, input().split()))  # Values of the nodes
27
        results.append(product_except_self(values))
28
29
    # Print results for all test cases
30
    for res in results:
31
        print("" "".join(map(str, res)))
32
33
# Execute the program
34
if __name__ == ""__main__"":
35
    main()
36",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832829
1387832821,Sanika2112,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
    4
    for test_case in test_cases:
5
        N, K, energy = test_case
6
        total_energy = sum(energy)
7
        8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
        12
        target_energy = total_energy // N
13
        operations = 0
14
        15
        for i in range(N):
16
            if (energy[i] - target_energy) % K != 0:
17
                results.append(-1)
18
                break
19
            operations += abs(energy[i] - target_energy) // K
20
        21
        if len(results) != len(test_cases):
22
            results.append(operations // 2)  # Each operation affects two stations
23
    24
    return results
25
26
# Reading input
27
T = int(input())
28
test_cases = []
29
30
for _ in range(T):
31
    N, K = map(int, input().split())
32
    energy = list(map(int, input().strip().split()))
33
    test_cases.append((N, K, energy))
34
35
# Calculating the results
36
results = min_operations_to_equalize_energy(T, test_cases)
37
38
# Output the results
39
for result in results:
40
    print(result)
41",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832821
1387832825,atharvjadhav2910,unknown,unknown,"1
def calculate_result(t, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, values = case
6
        7
        # Arrays for prefix and suffix products
8
        prefix = [1] * n
9
        suffix = [1] * n
10
        result = [0] * n
11
12
        # Compute prefix products
13
        for i in range(1, n):
14
            prefix[i] = prefix[i - 1] * values[i - 1]
15
16
        # Compute suffix products
17
        for i in range(n - 2, -1, -1):
18
            suffix[i] = suffix[i + 1] * values[i + 1]
19
20
        # Compute result array
21
        for i in range(n):
22
            result[i] = prefix[i] * suffix[i]
23
24
        results.append(result)
25
26
    return results
27
28
# Input processing
29
def main():
30
    T = int(input())  # Number of test cases
31
    test_cases = []
32
33
    for _ in range(T):
34
        n = int(input())  # Number of nodes
35
        values = list(map(int, input().split()))  # Node values
36
        test_cases.append((n, values))
37
38
    results = calculate_result(T, test_cases)
39
40
    # Print results
41
    for res in results:
42
        print("" "".join(map(str, res)))
43
44
# Run the program
45
if __name__ == ""__main__"":
46
    main()",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832825
1387832828,cooljaychaudhary,unknown,unknown,"1
function productExceptSelf(nums) {
2
    const n = nums.length;
3
    const result = new Array(n).fill(1);
4
    5
    let prefix = 1; // Prefix product
6
    for (let i = 0; i < n; i++) {
7
        result[i] = prefix;
8
        prefix *= nums[i];
9
    }
10
    11
    let suffix = 1; // Suffix product
12
    for (let i = n - 1; i >= 0; i--) {
13
        result[i] *= suffix;
14
        suffix *= nums[i];
15
    }
16
    17
    return result;
18
}
19
20
// Input handling
21
function main(input) {
22
    const lines = input.trim().split('\n');
23
    const t = parseInt(lines[0]); // Number of test cases
24
    let index = 1;
25
26
    const results = [];
27
    for (let test = 0; test < t; test++) {
28
        const n = parseInt(lines[index]); // Length of array
29
        const nums = lines[index + 1].split(' ').map(Number);
30
        index += 2;
31
32
        const result = productExceptSelf(nums);
33
        results.push(result.join(' ')); // Space-separated output
34
    }
35
36
    console.log(results.join('\n')); // Each test case on a new line
37
}
38
39
// Example usage
40
const input = `2
41
5
42
1 2 3 4 5
43
5
44
10 3 5 6 2`;
45
main(input);
46
47
// Expected Output:
48
// 120 60 40 30 24
49
// 180 600 360 300 900
50",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832828
1387832813,mahakantsingh113,unknown,unknown,"1
def calculate_result(test_cases):
2
    results = []
3
    for t in range(test_cases):
4
        n = int(input())  # Number of nodes in the current test case
5
        values = list(map(int, input().split()))
6
        7
        # Calculate prefix and suffix products
8
        prefix = [1] * n
9
        suffix = [1] * n
10
        11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
        14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] * values[i + 1]
16
        17
        # Calculate the result for the current test case
18
        result = [prefix[i] * suffix[i] for i in range(n)]
19
        results.append(result)
20
    21
    return results
22
23
# Read input
24
T = int(input())  # Number of test cases
25
output = calculate_result(T)
26
27
# Print the results
28
for res in output:
29
    print("" "".join(map(str, res)))
30",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832813
1387832817,nit_mishra3,unknown,unknown,"1
def max_absolute_difference(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, nums = case
5
        total_sum = sum(nums)
6
        prefix_sum = 0
7
        max_abs_diff = 0
8
        9
        # Iterate through possible partition points
10
        for i in range(n - 1):
11
            prefix_sum += nums[i]
12
            second_sum = total_sum - prefix_sum
13
            abs_diff = abs(prefix_sum - second_sum)
14
            max_abs_diff = max(max_abs_diff, abs_diff)
15
        16
        results.append(max_abs_diff)
17
    return results
18
19
20
# Input handling
21
t = int(input())  # Number of test cases
22
test_cases = []
23
for _ in range(t):
24
    n = int(input())
25
    nums = list(map(int, input().split()))
26
    test_cases.append((n, nums))
27
28
# Process and output results
29
outputs = max_absolute_difference(test_cases)
30
for output in outputs:
31
    print(output)
32",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387832817
1387832819,prathameshbhoit1,unknown,unknown,"1
def min_operations_to_equalize(N, K, energy):
2
    total_energy = sum(energy)
3
    4
    # Check if it's possible to equalize
5
    if total_energy % N != 0:
6
        return -1
7
    8
    target = total_energy // N
9
    operations = 0
10
    11
    for i in range(N):
12
        diff = energy[i] - target
13
        14
        # If the difference is not divisible by K, it's impossible
15
        if diff % K != 0:
16
            return -1
17
        18
        # Accumulate the number of operations
19
        operations += abs(diff) // K
20
    21
    # Since each operation transfers K units, divide by 2 to avoid double-counting
22
    return operations // 2
23
24
25
def main():
26
    import sys
27
    input = sys.stdin.read
28
    data = input().split()
29
    30
    idx = 0
31
    T = int(data[idx])
32
    idx += 1
33
    34
    for _ in range(T):
35
        N = int(data[idx])
36
        K = int(data[idx + 1])
37
        idx += 2
38
        39
        energy = list(map(int, data[idx:idx + N]))
40
        idx += N
41
        42
        result = min_operations_to_equalize(N, K, energy)
43
        print(result)
44
45
46
if __name__ == ""__main__"":
47
    main()",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832819
1387832804,h1032221562,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, values = case
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [0] * n
9
10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] * values[i - 1]
12
       13
        for i in range(n - 2, -1, -1):
14
            suffix[i] = suffix[i + 1] * values[i + 1]
15
        16
        for i in range(n):
17
            result[i] = prefix[i] * suffix[i]
18
19
        results.append(result)
20
21
    return results
22
23
T = int(input())
24
test_cases = []
25
for _ in range(T):
26
    n = int(input())
27
    values = list(map(int, input().split()))
28
    test_cases.append((n, values))
29
30
output = product_except_self(test_cases)
31
for res in output:
32
    print("" "".join(map(str, res)))",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832804
1387832806,suman197960,unknown,unknown,"1
def min_operations_to_equalize_energy(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        N, K = test_cases[t][0]
6
        energy = test_cases[t][1]
7
        8
        total_energy = sum(energy)
9
        10
        # Check if equal distribution is possible
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target = total_energy // N
16
        balance = 0
17
        operations = 0
18
        19
        # Iterate through the stations to calculate operations
20
        for i in range(N):
21
            balance += energy[i] - target
22
            # Count how many K-transfers are needed for the imbalance
23
            operations += abs(balance) // K
24
        25
        results.append(operations)
26
    27
    return results
28
29
# Input reading
30
T = int(input())
31
test_cases = []
32
33
for _ in range(T):
34
    N, K = map(int, input().split())
35
    energy = list(map(int, input().split()))
36
    test_cases.append(((N, K), energy))
37
38
# Calculate results
39
results = min_operations_to_equalize_energy(T, test_cases)
40
41
# Output results
42
for res in results:
43
    print(res)
44",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832806
1387832811,h1032221730,unknown,unknown,"1
def solve_testcase(N, K, energy):
2
    # Calculate total energy and target
3
    total_energy = sum(energy)
4
    5
    # Check if equal distribution is possible
6
    if total_energy % N != 0:
7
        return -1
8
    9
    target = total_energy // N
10
    11
    # If already equalized
12
    if all(e == target for e in energy):
13
        return 0
14
    15
    # For each position, calculate how many transfers are needed
16
    total_transfers = 0
17
    excess = 0  # Keep track of excess/deficit as we go around the circle
18
    19
    for i in range(N):
20
        # Current position's excess/deficit including previous remainder
21
        curr_with_excess = energy[i] + excess
22
        23
        # How far are we from target at this position
24
        diff_from_target = curr_with_excess - target
25
        26
        # This difference will need to be transferred to next position
27
        excess = diff_from_target
28
        29
        # If we need to make transfers
30
        if diff_from_target != 0:
31
            # If we can't transfer in K-unit chunks
32
            if abs(diff_from_target) % K != 0:
33
                return -1
34
                35
            # Add number of K-unit transfers needed
36
            total_transfers += abs(diff_from_target) // K
37
    38
    # After going around the circle, if there's any remainder, it's impossible
39
    if excess != 0:
40
        return -1
41
        42
    return total_transfers
43
44
def main():
45
    # Read number of test cases
46
    T = int(input())
47
    48
    # Process each test case
49
    for _ in range(T):
50
        # Read N and K
51
        N, K = map(int, input().split())
52
        53
        # Read energy array
54
        energy = list(map(int, input().split()))
55
        56
        # Solve current test case
57
        result = solve_testcase(N, K, energy)
58
        59
        # Print result
60
        print(result)
61
62
if __name__ == ""__main__"":
63
    main()",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832811
1387832802,a_redij04,unknown,unknown,"1
def solve():
2
    # Read the number of test cases
3
    T = int(input())
4
    5
    # Process each test case
6
    for _ in range(T):
7
        # Read the size of the network
8
        n = int(input())
9
        10
        # Read the values for the current test case
11
        values = list(map(int, input().split()))
12
        13
        # Initialize the result array and prefix/suffix arrays
14
        result = [1] * n
15
        prefix = [1] * n
16
        suffix = [1] * n
17
        18
        # Compute the prefix products
19
        prefix[0] = values[0]
20
        for i in range(1, n):
21
            prefix[i] = prefix[i-1] * values[i]
22
        23
        # Compute the suffix products
24
        suffix[n-1] = values[n-1]
25
        for i in range(n-2, -1, -1):
26
            suffix[i] = suffix[i+1] * values[i]
27
        28
        # Construct the result array using prefix and suffix products
29
        result[0] = suffix[1]
30
        result[n-1] = prefix[n-2]
31
        for i in range(1, n-1):
32
            result[i] = prefix[i-1] * suffix[i+1]
33
        34
        # Output the result for the current test case
35
        print(*result)
36
37
# Calling solve() to test the function
38
solve()
39",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832802
1387832796,harishpandey1704,unknown,unknown,"1
def min_operations_to_equalize_energy(t, test_cases):
2
    results = []
3
    for n, k, energy in test_cases:
4
        total_energy = sum(energy)
5
        if total_energy % n != 0:
6
            results.append(-1)
7
            continue
8
        target = total_energy // n
9
        operations = 0
10
        for i in range(n):
11
            diff = energy[i] - target
12
            if diff % k != 0:
13
                operations = -1
14
                break
15
            operations += abs(diff) // k
16
        results.append(operations // 2 if operations != -1 else -1)
17
    return results
18
19
t = int(input())
20
test_cases = []
21
for _ in range(t):
22
    n, k = map(int, input().split())
23
    energy = list(map(int, input().split()))
24
    test_cases.append((n, k, energy))
25
26
for res in min_operations_to_equalize_energy(t, test_cases):
27
    print(res)
28",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832796
1387832800,h1032220167,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
    5
    # Calculate the product of all elements to the left of each index
6
    left_product = 1
7
    for i in range(n):
8
        result[i] = left_product
9
        left_product *= values[i]
10
    11
    # Calculate the product of all elements to the right of each index and multiply with the left product
12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    return result
18
19
def main():
20
    import sys
21
    input = sys.stdin.read
22
    data = input().split()
23
    24
    idx = 0
25
    T = int(data[idx])
26
    idx += 1
27
    28
    for _ in range(T):
29
        n = int(data[idx])
30
        idx += 1
31
        values = list(map(int, data[idx:idx+n]))
32
        idx += n
33
        34
        result = product_except_self(values)
35
        print(' '.join(map(str, result)))
36
37
if __name__ == ""__main__"":
38
    main()",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832800
1387832799,aayushkrishnaut,unknown,unknown,"1
def solve_product_distribution():
2
    # Read number of test cases
3
    T = int(input())
4
    5
    for _ in range(T):
6
        # Read number of nodes
7
        n = int(input())
8
        9
        # Read values array
10
        values = list(map(int, input().split()))
11
        12
        # Calculate result array
13
        result = []
14
        for i in range(n):
15
            # Initialize product as 1
16
            product = 1
17
            18
            # Multiply all values except the current position
19
            for j in range(n):
20
                if j != i:
21
                    product *= values[j]
22
            23
            result.append(product)
24
        25
        # Print result array for this test case
26
        print("" "".join(map(str, result)))
27
28
# Run the solution
29
if __name__ == ""__main__"":
30
    solve_product_distribution()",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832799
1387832794,h1032231268,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left = [1] * n
4
    right = [1] * n
5
6
    # Calculate left product array
7
    for i in range(1, n):
8
        left[i] = left[i-1] * arr[i-1]
9
10
    # Calculate right product array
11
    for i in range(n-2, -1, -1):
12
        right[i] = right[i+1] * arr[i+1]
13
14
    # Calculate result array
15
    result = [left[i] * right[i] for i in range(n)]
16
17
    return result
18
19
# Get number of test cases
20
t = int(input())
21
22
for _ in range(t):
23
    n = int(input())
24
    arr = list(map(int, input().split()))
25
    result = product_array(arr)
26
    print(*result) 
27",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832794
1387832793,sohamkadam0012,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void calculateProductArray(int *values, int n) {
5
    int *prefix = (int *)malloc(n * sizeof(int));
6
    int *suffix = (int *)malloc(n * sizeof(int));
7
    int *result = (int *)malloc(n * sizeof(int));
8
    9
    // Calculate prefix products
10
    prefix[0] = 1; // No element before the first element
11
    for (int i = 1; i < n; i++) {
12
        prefix[i] = prefix[i - 1] * values[i - 1];
13
    }
14
    15
    // Calculate suffix products
16
    suffix[n - 1] = 1; // No element after the last element
17
    for (int i = n - 2; i >= 0; i--) {
18
        suffix[i] = suffix[i + 1] * values[i + 1];
19
    }
20
    21
    // Calculate the result array
22
    for (int i = 0; i < n; i++) {
23
        result[i] = prefix[i] * suffix[i];
24
    }
25
    26
    // Print the result array
27
    for (int i = 0; i < n; i++) {
28
        printf(""%d "", result[i]);
29
    }
30
    printf(""\n"");
31
    32
    // Free allocated memory
33
    free(prefix);
34
    free(suffix);
35
    free(result);
36
}
37
38
int main() {
39
    int T;
40
    scanf(""%d"", &T);
41
    42
    while (T--) {
43
        int n;
44
        scanf(""%d"", &n);
45
        46
        int *values = (int *)malloc(n * sizeof(int));
47
        for (int i = 0; i < n; i++) {
48
            scanf(""%d"", &values[i]);
49
        }
50
        51
        calculateProductArray(values, n);
52
        free(values);
53
    }
54
    55
    return 0;
56
}
57
58",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832793
1387832795,krishjain,unknown,unknown,"1
def solve():
2
    # Reading number of test cases
3
    T = int(input())
4
    5
    for _ in range(T):
6
        # Reading the size of the network
7
        n = int(input())
8
        # Reading the values of the nodes
9
        values = list(map(int, input().split()))
10
        11
        # Initialize result array where we will store the final product values
12
        result = [1] * n
13
        14
        # Step 1: Calculate prefix product
15
        prefix_product = 1
16
        for i in range(n):
17
            result[i] = prefix_product
18
            prefix_product *= values[i]
19
        20
        # Step 2: Calculate suffix product and multiply with the result array
21
        suffix_product = 1
22
        for i in range(n - 1, -1, -1):
23
            result[i] *= suffix_product
24
            suffix_product *= values[i]
25
        26
        # Output the result for the current test case
27
        print("" "".join(map(str, result)))
28
29
# Call the solve function
30
solve()
31",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832795
1387832785,h1032231317,unknown,unknown,"1
def max_absolute_difference(t, test_cases):
2
    results = []
3
4
    for case in test_cases:
5
        n, nums = case
6
        7
        prefix_sum = [0] * n
8
        prefix_sum[0] = nums[0]
9
10
        for i in range(1, n):
11
            prefix_sum[i] = prefix_sum[i - 1] + nums[i]
12
13
        total_sum = prefix_sum[-1]
14
        max_diff = 0
15
16
        for i in range(n - 1):
17
            left_sum = prefix_sum[i]
18
            right_sum = total_sum - left_sum
19
            max_diff = max(max_diff, abs(left_sum - right_sum))
20
21
        results.append(max_diff)
22
23
    return results
24
25
def main():
26
    t = int(input())
27
    test_cases = []
28
29
    for _ in range(t):
30
        n = int(input())
31
        nums = list(map(int, input().split()))
32
        test_cases.append((n, nums))
33
34
    results = max_absolute_difference(t, test_cases)
35
36
    for res in results:
37
        print(res)
38
39
if __name__ == ""__main__"":
40
    main()",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/optimizing-the-difference-of-subarray-sums/submissions/code/1387832785
1387832788,hrichamehra11,unknown,unknown,"1
def product_except_self(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        # Initialize prefix and suffix product arrays
6
        prefix = [1] * n
7
        suffix = [1] * n
8
        result = [1] * n
9
10
        # Compute prefix products
11
        for i in range(1, n):
12
            prefix[i] = prefix[i - 1] * values[i - 1]
13
14
        # Compute suffix products
15
        for i in range(n - 2, -1, -1):
16
            suffix[i] = suffix[i + 1] * values[i + 1]
17
18
        # Compute result as prefix[i] * suffix[i]
19
        for i in range(n):
20
            result[i] = prefix[i] * suffix[i]
21
22
        results.append(result)
23
    24
    return results
25
26
27
# Input Handling
28
T = int(input())
29
test_cases = []
30
for _ in range(T):
31
    n = int(input())
32
    values = list(map(int, input().split()))
33
    test_cases.append((n, values))
34
35
# Processing
36
output = product_except_self(test_cases)
37
38
# Output Results
39
for res in output:
40
    print("" "".join(map(str, res)))
41",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832788
1387832791,pranalipahurkar,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
5
    # Prefix product
6
    prefix = 1
7
    for i in range(n):
8
        result[i] = prefix
9
        prefix *= values[i]
10
11
    # Suffix product
12
    suffix = 1
13
    for i in range(n - 1, -1, -1):
14
        result[i] *= suffix
15
        suffix *= values[i]
16
17
    return result
18
19
# Input handling
20
T = int(input())
21
for _ in range(T):
22
    n = int(input())
23
    values = list(map(int, input().split()))
24
    result = product_except_self(values)
25
    print(*result)
26",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832791
1387832784,singhark94,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
vector<vector<long long>> computeProducts(int T, vector<pair<int, vector<int>>>& testCases) {
6
    vector<vector<long long>> results;
7
8
    for (int t = 0; t < T; ++t) {
9
        int n = testCases[t].first;
10
        vector<int>& values = testCases[t].second;
11
        12
        // Result vector
13
        vector<long long> result(n, 1);
14
15
        // Compute prefix products
16
        long long prefix = 1;
17
        for (int i = 0; i < n; ++i) {
18
            result[i] = prefix;
19
            prefix *= values[i];
20
        }
21
22
        // Compute suffix products and multiply with prefix
23
        long long suffix = 1;
24
        for (int i = n - 1; i >= 0; --i) {
25
            result[i] *= suffix;
26
            suffix *= values[i];
27
        }
28
29
        results.push_back(result);
30
    }
31
32
    return results;
33
}
34
35
int main() {
36
    int T;
37
    cin >> T;  // Number of test cases
38
    vector<pair<int, vector<int>>> testCases;
39
40
    for (int t = 0; t < T; ++t) {
41
        int n;
42
        cin >> n;  // Number of nodes
43
        vector<int> values(n);
44
        for (int i = 0; i < n; ++i) {
45
            cin >> values[i];
46
        }
47
        testCases.emplace_back(n, values);
48
    }
49
50
    // Compute results
51
    vector<vector<long long>> results = computeProducts(T, testCases);
52
53
    // Output results
54
    for (const auto& result : results) {
55
        for (size_t i = 0; i < result.size(); ++i) {
56
            if (i > 0) cout << "" "";
57
            cout << result[i];
58
        }
59
        cout << endl;
60
    }
61
62
    return 0;
63
}
64
65",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832784
1387832774,h1032231248,unknown,unknown,"1
def compute_product_except_self(test_cases):
2
    results = []
3
    for t in range(test_cases):
4
        n = int(input().strip())
5
        values = list(map(int, input().strip().split()))
6
        7
        # Step 1: Compute prefix and suffix products
8
        prefix_product = [1] * n
9
        suffix_product = [1] * n
10
        11
        for i in range(1, n):
12
            prefix_product[i] = prefix_product[i - 1] * values[i - 1]
13
        14
        for i in range(n - 2, -1, -1):
15
            suffix_product[i] = suffix_product[i + 1] * values[i + 1]
16
        17
        # Step 2: Compute result array
18
        result = [prefix_product[i] * suffix_product[i] for i in range(n)]
19
        results.append("" "".join(map(str, result)))
20
    21
    return results
22
23
# Input and output handling
24
if __name__ == ""__main__"":
25
    T = int(input().strip())
26
    outputs = compute_product_except_self(T)
27
    print(""\n"".join(outputs))
28",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832774
1387832778,mahekjitu20,unknown,unknown,"1
def minimum_operations_to_equalize(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        N, K = test_cases[t][:2]
6
        energy = test_cases[t][2]
7
        8
        total_energy = sum(energy)
9
        10
        # If the total energy is not divisible by N, it's impossible to equalize
11
        if total_energy % N != 0:
12
            results.append(-1)
13
            continue
14
        15
        target = total_energy // N
16
        operations = 0
17
        excess_energy = 0
18
        19
        # Traverse the array, simulating the circular transfer
20
        for i in range(N):
21
            # Calculate the difference between current station energy and target
22
            excess_energy += energy[i] - target
23
            24
            # The number of operations required for this difference to propagate
25
            if excess_energy % K != 0:
26
                operations = -1
27
                break
28
            29
            operations += abs(excess_energy) // K
30
        31
        results.append(operations if operations != -1 else -1)
32
    33
    return results
34
35
36
# Input handling
37
T = int(input())
38
test_cases = []
39
for _ in range(T):
40
    N, K = map(int, input().split())
41
    energy = list(map(int, input().split()))
42
    test_cases.append((N, K, energy))
43
44
# Output the results
45
results = minimum_operations_to_equalize(T, test_cases)
46
for res in results:
47
    print(res)
48",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832778
1387832775,23jyotigaud,unknown,unknown,"1
def product_array(arr):
2
    n = len(arr)
3
    left_product = [1] * n
4
    right_product = [1] * n
5
6
    for i in range(1, n):
7
        left_product[i] = left_product[i-1] * arr[i-1]
8
9
10
    for i in range(n-2, -1, -1):
11
        right_product[i] = right_product[i+1] * arr[i+1]
12
13
    result = [left_product[i] * right_product[i] for i in range(n)]
14
15
    return result
16
17
if __name__ == ""__main__"":
18
    t = int(input())
19
    for _ in range(t):
20
        n = int(input())
21
        arr = list(map(int, input().split()))
22
        result = product_array(arr)
23
        print(*result)",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832775
1387832767,nit_mishra3,unknown,unknown,"1
def minimum_operations(test_cases):
2
    results = []
3
    for case in test_cases:
4
        N, K, energy = case
5
        total_energy = sum(energy)
6
        7
        # Check if total energy is divisible by N
8
        if total_energy % N != 0:
9
            results.append(-1)
10
            continue
11
        12
        target = total_energy // N
13
        delta = [energy[i] - target for i in range(N)]
14
        15
        # Check if all deltas are divisible by K
16
        if any(d % K != 0 for d in delta):
17
            results.append(-1)
18
            continue
19
        20
        # Calculate minimum operations
21
        operations = 0
22
        prefix_sum = 0
23
        for d in delta:
24
            prefix_sum += d
25
            operations += abs(prefix_sum // K)
26
        27
        results.append(operations)
28
    return results
29
30
31
# Input handling
32
T = int(input())  # Number of test cases
33
test_cases = []
34
for _ in range(T):
35
    N, K = map(int, input().split())
36
    energy = list(map(int, input().split()))
37
    test_cases.append((N, K, energy))
38
39
# Process and output results
40
outputs = minimum_operations(test_cases)
41
for output in outputs:
42
    print(output)
43",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832767
1387832768,prathameshbhoit1,unknown,unknown,"1
def compute_product_array(n, values):
2
    prefix = [1] * n
3
    for i in range(1, n):
4
        prefix[i] = prefix[i - 1] * values[i - 1]
5
    6
    suffix = [1] * n
7
    for i in range(n - 2, -1, -1):
8
        suffix[i] = suffix[i + 1] * values[i + 1]
9
    10
    result = [prefix[i] * suffix[i] for i in range(n)]
11
    12
    return result
13
14
T = int(input().strip()) 
15
for _ in range(T):
16
    n = int(input().strip()) 
17
    values = list(map(int, input().strip().split()))
18
    print("" "".join(map(str, compute_product_array(n, values))))",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832768
1387832771,alstonsoares17,unknown,unknown,"1
def calculate_product_distribution(n, values):
2
    if n < 2:
3
        return []
4
    5
    result = [1] * n
6
    7
    left_product = 1
8
    for i in range(n):
9
        result[i] = left_product
10
        left_product *= values[i]
11
    12
    right_product = 1
13
    for i in range(n-1, -1, -1):
14
        result[i] *= right_product
15
        right_product *= values[i]
16
    17
    return result
18
19
T = int(input())
20
for _ in range(T):
21
    n = int(input())
22
    values = list(map(int, input().split()))
23
    result = calculate_product_distribution(n, values)
24
    print("" "".join(map(str, result)))",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832771
1387832762,khushidoshi1978,unknown,unknown,"1
def product_of_all_except_self(test_cases):
2
    for case in test_cases:
3
        n, values = case
4
        result = [1] * n
5
6
        # Create a prefix product array
7
        prefix_product = 1
8
        for i in range(n):
9
            result[i] = prefix_product
10
            prefix_product *= values[i]
11
12
        # Create a suffix product array and update the result
13
        suffix_product = 1
14
        for i in range(n-1, -1, -1):
15
            result[i] *= suffix_product
16
            suffix_product *= values[i]
17
18
        # Print the result for the current test case
19
        print("" "".join(map(str, result)))
20
21
# Input reading
22
T = int(input())  # Number of test cases
23
test_cases = []
24
for _ in range(T):
25
    n = int(input())  # Number of nodes
26
    values = list(map(int, input().split()))  # Values of the nodes
27
    test_cases.append((n, values))
28
29
# Process each test case
30
product_of_all_except_self(test_cases)
31",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832762
1387832765,h1032221730,unknown,unknown,"1
def solve_testcase(N, K, energy):
2
    # Calculate total energy
3
    total_energy = sum(energy)
4
    5
    # Check if equal distribution is possible
6
    if total_energy % N != 0:
7
        return -1
8
    9
    # Target energy for each station
10
    target = total_energy // N
11
    12
    # If already equalized
13
    if all(e == target for e in energy):
14
        return 0
15
    16
    # Check if K can achieve the required transfers
17
    operations = 0
18
    curr_energy = energy.copy()
19
    20
    # We need at most N iterations to detect if it's impossible
21
    for iteration in range(N):
22
        found_transfer = False
23
        24
        # Try to make one complete round of transfers
25
        for i in range(N):
26
            if curr_energy[i] > target:
27
                # Calculate how much energy needs to be transferred
28
                diff = curr_energy[i] - target
29
                30
                # Calculate number of K-unit transfers needed
31
                transfers = (diff + K - 1) // K  # Ceiling division
32
                energy_transferred = min(diff, transfers * K)
33
                34
                if energy_transferred % K != 0:
35
                    return -1  # Cannot transfer with K-unit chunks
36
                37
                # Transfer energy to next station
38
                next_station = (i + 1) % N
39
                curr_energy[i] -= energy_transferred
40
                curr_energy[next_station] += energy_transferred
41
                operations += transfers
42
                found_transfer = True
43
        44
        # Check if equalized
45
        if all(e == target for e in curr_energy):
46
            return operations
47
        48
        # If no transfers were made in this iteration, it's impossible
49
        if not found_transfer:
50
            return -1
51
    52
    # If we exit the loop without returning, it's impossible
53
    return -1
54
55
def main():
56
    # Read number of test cases
57
    T = int(input())
58
    59
    # Process each test case
60
    for _ in range(T):
61
        # Read N and K
62
        N, K = map(int, input().split())
63
        64
        # Read energy array
65
        energy = list(map(int, input().split()))
66
        67
        # Solve current test case
68
        result = solve_testcase(N, K, energy)
69
        70
        # Print result
71
        print(result)
72
73
if __name__ == ""__main__"":
74
    main()",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/minimum-operations-to-equalize-energy/submissions/code/1387832765
1387832766,Sanika2112,unknown,unknown,"1
def product_except_self(nums):
2
    n = len(nums)
3
    if n == 0:
4
        return []
5
    6
    prefix_products = [1] * n
7
    suffix_products = [1] * n
8
    result = [1] * n
9
    10
    for i in range(1, n):
11
        prefix_products[i] = prefix_products[i - 1] * nums[i - 1]
12
    13
    for i in range(n - 2, -1, -1):
14
        suffix_products[i] = suffix_products[i + 1] * nums[i + 1]
15
    16
    for i in range(n):
17
        result[i] = prefix_products[i] * suffix_products[i]
18
    19
    return result
20
21
# Read number of test cases
22
T = int(input())
23
results = []
24
25
for _ in range(T):
26
    n = int(input())
27
    values = list(map(int, input().strip().split()))
28
    results.append(product_except_self(values))
29
30
# Output the results
31
for result in results:
32
    print("" "".join(map(str, result)))
33",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832766
1387832760,h1032221473,unknown,unknown,"1
def product_except_self(values):
2
    n = len(values)
3
    result = [1] * n
4
5
    # Compute prefix products
6
    prefix = 1
7
    for i in range(n):
8
        result[i] = prefix
9
        prefix *= values[i]
10
11
    # Compute suffix products and multiply with prefix products
12
    suffix = 1
13
    for i in range(n - 1, -1, -1):
14
        result[i] *= suffix
15
        suffix *= values[i]
16
17
    return result
18
19
def main():
20
    T = int(input())  # Number of test cases
21
    for _ in range(T):
22
        n = int(input())  # Number of nodes
23
        values = list(map(int, input().split()))
24
        result = product_except_self(values)
25
        print(*result)
26
27
if __name__ == ""__main__"":
28
    main()",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832760
1387832753,suman197960,unknown,unknown,"1
def calculate_result(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n = test_cases[t][0]
6
        values = test_cases[t][1]
7
        8
        # Initialize prefix and suffix arrays
9
        prefix = [1] * n
10
        suffix = [1] * n
11
        result = [1] * n
12
        13
        # Calculate prefix products
14
        for i in range(1, n):
15
            prefix[i] = prefix[i - 1] * values[i - 1]
16
        17
        # Calculate suffix products
18
        for i in range(n - 2, -1, -1):
19
            suffix[i] = suffix[i + 1] * values[i + 1]
20
        21
        # Calculate result using prefix and suffix
22
        for i in range(n):
23
            result[i] = prefix[i] * suffix[i]
24
        25
        results.append(result)
26
    27
    return results
28
29
# Input reading
30
T = int(input())
31
test_cases = []
32
33
for _ in range(T):
34
    n = int(input())
35
    values = list(map(int, input().split()))
36
    test_cases.append((n, values))
37
38
# Calculate results
39
results = calculate_result(T, test_cases)
40
41
# Output results
42
for res in results:
43
    print("" "".join(map(str, res)))
44",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832753
1387832759,aryaprzz1,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    // Function to calculate the product array
5
    public static long[] getProductArray(int[] arr, int n) {
6
        // Create result array to store products
7
        long[] result = new long[n];
8
        9
        // If array has less than 2 elements, return empty array
10
        if (n < 2) return result;
11
        12
        // Initialize the result array with 1
13
        Arrays.fill(result, 1);
14
        15
        // Calculate products of all elements to the left of each element
16
        long leftProduct = 1;
17
        for (int i = 0; i < n; i++) {
18
            result[i] *= leftProduct;
19
            leftProduct *= arr[i];
20
        }
21
        22
        // Calculate products of all elements to the right of each element
23
        // and multiply with existing left products
24
        long rightProduct = 1;
25
        for (int i = n - 1; i >= 0; i--) {
26
            result[i] *= rightProduct;
27
            rightProduct *= arr[i];
28
        }
29
        30
        return result;
31
    }
32
    33
    public static void main(String[] args) {
34
        Scanner scanner = new Scanner(System.in);
35
        36
        // Read number of test cases
37
        int T = scanner.nextInt();
38
        39
        while (T-- > 0) {
40
            // Read size of array
41
            int n = scanner.nextInt();
42
            43
            // Read array elements
44
            int[] arr = new int[n];
45
            for (int i = 0; i < n; i++) {
46
                arr[i] = scanner.nextInt();
47
            }
48
            49
            // Get product array
50
            long[] result = getProductArray(arr, n);
51
            52
            // Print result
53
            for (int i = 0; i < n; i++) {
54
                System.out.print(result[i] + (i < n-1 ? "" "" : """"));
55
            }
56
            System.out.println();
57
        }
58
        59
        scanner.close();
60
    }
61
}",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832759
1387832750,vg2556519,unknown,unknown,"1
def compute_product_array(n, values):
2
    prefix = [1] * n
3
    for i in range(1, n):
4
        prefix[i] = prefix[i - 1] * values[i - 1]
5
    6
    suffix = [1] * n
7
    for i in range(n - 2, -1, -1):
8
        suffix[i] = suffix[i + 1] * values[i + 1]
9
    10
    result = [prefix[i] * suffix[i] for i in range(n)]
11
    12
    return result
13
14
T = int(input().strip()) 
15
for _ in range(T):
16
    n = int(input().strip()) 
17
    values = list(map(int, input().strip().split()))
18
    print("" "".join(map(str, compute_product_array(n, values))))
19",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832750
1387832735,h1032221730,unknown,unknown,"1
def solve_testcase(n, values):
2
    # Initialize result array
3
    result = [1] * n
4
    5
    # Calculate prefix products
6
    # result[i] will first store product of all elements to the left of i
7
    prefix = 1
8
    for i in range(n):
9
        result[i] = prefix
10
        prefix *= values[i]
11
    12
    # Calculate suffix products and combine with prefix products
13
    # For each position, multiply its prefix product with suffix product
14
    suffix = 1
15
    for i in range(n-1, -1, -1):
16
        result[i] *= suffix
17
        suffix *= values[i]
18
    19
    return result
20
21
def main():
22
    # Read number of test cases
23
    T = int(input())
24
    25
    # Process each test case
26
    for _ in range(T):
27
        # Read input for current test case
28
        n = int(input())
29
        values = list(map(int, input().split()))
30
        31
        # Solve current test case
32
        result = solve_testcase(n, values)
33
        34
        # Print result
35
        print(*result)
36
37
if __name__ == ""__main__"":
38
    main()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832735
1387832743,nit_mishra3,unknown,unknown,"1
def calculate_products(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, values = case
5
        prefix = [1] * n
6
        suffix = [1] * n
7
        result = [1] * n
8
9
        # Calculate prefix products
10
        for i in range(1, n):
11
            prefix[i] = prefix[i - 1] * values[i - 1]
12
13
        # Calculate suffix products
14
        for i in range(n - 2, -1, -1):
15
            suffix[i] = suffix[i + 1] * values[i + 1]
16
17
        # Calculate result using prefix and suffix
18
        for i in range(n):
19
            result[i] = prefix[i] * suffix[i]
20
21
        results.append(result)
22
    return results
23
24
25
# Input handling
26
T = int(input())  # Number of test cases
27
test_cases = []
28
for _ in range(T):
29
    n = int(input())
30
    values = list(map(int, input().split()))
31
    test_cases.append((n, values))
32
33
# Process and output results
34
outputs = calculate_products(test_cases)
35
for output in outputs:
36
    print("" "".join(map(str, output)))
37",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-8-a/challenges/product-distribution-3/submissions/code/1387832743
