submission_id,username,problem_name,language,code,page,url
1390069692,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommissioning {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int t = scanner.nextInt();
7
        scanner.nextLine(); // Consume the newline
8
9
        for (int i = 0; i < t; i++) {
10
            String serverRack = scanner.nextLine();
11
            int minCost = findMinimumCost(serverRack);
12
            System.out.println(minCost);
13
        }
14
        scanner.close();
15
    }
16
17
    public static int findMinimumCost(String serverRack) {
18
        int n = serverRack.length();
19
        int minCost = Integer.MAX_VALUE;
20
        21
        // Try all possible combinations of removing servers from the beginning and end
22
        for (int front = 0; front <= n; front++) {
23
            for (int back = 0; back <= n - front; back++) {
24
                // Calculate the servers that will remain after decommissioning
25
                String remainingServers = serverRack.substring(front, n - back);
26
                27
                // Calculate the cost factors
28
                int remainingIdleServers = countChar(remainingServers, '0');
29
                int decommissionedActiveServers = countChar(serverRack.substring(0, front), '1') + 
30
                                                countChar(serverRack.substring(n - back, n), '1');
31
                32
                // The cost is the maximum of the two factors
33
                int cost = Math.max(remainingIdleServers, decommissionedActiveServers);
34
                35
                minCost = Math.min(minCost, cost);
36
            }
37
        }
38
        39
        return minCost;
40
    }
41
    42
    private static int countChar(String str, char target) {
43
        int count = 0;
44
        for (int i = 0; i < str.length(); i++) {
45
            if (str.charAt(i) == target) {
46
                count++;
47
            }
48
        }
49
        return count;
50
    }
51
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390069692
1390069704,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommissioning {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int t = scanner.nextInt();
7
        scanner.nextLine(); // Consume the newline
8
9
        for (int i = 0; i < t; i++) {
10
            String serverRack = scanner.nextLine();
11
            int minCost = findMinimumCost(serverRack);
12
            System.out.println(minCost);
13
        }
14
        scanner.close();
15
    }
16
17
    public static int findMinimumCost(String serverRack) {
18
        int n = serverRack.length();
19
        20
        // Precompute prefix sums for faster counting
21
        int[] activePrefix = new int[n + 1]; // Count of 1's from beginning
22
        int[] idlePrefix = new int[n + 1];   // Count of 0's from beginning
23
        24
        for (int i = 0; i < n; i++) {
25
            activePrefix[i + 1] = activePrefix[i] + (serverRack.charAt(i) == '1' ? 1 : 0);
26
            idlePrefix[i + 1] = idlePrefix[i] + (serverRack.charAt(i) == '0' ? 1 : 0);
27
        }
28
        29
        int totalActive = activePrefix[n]; // Total active servers
30
        int totalIdle = idlePrefix[n];     // Total idle servers
31
        int minCost = Integer.MAX_VALUE;
32
        33
        // Try all possible combinations of removing servers from the beginning and end
34
        for (int front = 0; front <= n; front++) {
35
            for (int back = 0; back <= n - front; back++) {
36
                // Calculate active servers decommissioned from front and back
37
                int decommissionedActive = activePrefix[front] + (totalActive - activePrefix[n - back]);
38
                39
                // Calculate idle servers remaining
40
                int remainingIdle = idlePrefix[n - back] - idlePrefix[front];
41
                42
                // The cost is the maximum of the two factors
43
                int cost = Math.max(remainingIdle, decommissionedActive);
44
                45
                minCost = Math.min(minCost, cost);
46
            }
47
        }
48
        49
        return minCost;
50
    }
51
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390069704
1390069729,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <vector>
4
#include <algorithm>
5
#include <climits>
6
7
using namespace std;
8
9
int findMinimumCost(const string& serverRack) {
10
    int n = serverRack.length();
11
    12
    // Precompute prefix sums for faster counting
13
    vector<int> activePrefix(n + 1, 0); // Count of 1's from beginning
14
    vector<int> idlePrefix(n + 1, 0);   // Count of 0's from beginning
15
    16
    for (int i = 0; i < n; i++) {
17
        activePrefix[i + 1] = activePrefix[i] + (serverRack[i] == '1' ? 1 : 0);
18
        idlePrefix[i + 1] = idlePrefix[i] + (serverRack[i] == '0' ? 1 : 0);
19
    }
20
    21
    int totalActive = activePrefix[n]; // Total active servers
22
    int totalIdle = idlePrefix[n];     // Total idle servers
23
    int minCost = INT_MAX;
24
    25
    // Try all possible combinations of removing servers from the beginning and end
26
    for (int front = 0; front <= n; front++) {
27
        for (int back = 0; back <= n - front; back++) {
28
            // Calculate active servers decommissioned from front and back
29
            int decommissionedActive = activePrefix[front] + (totalActive - activePrefix[n - back]);
30
            31
            // Calculate idle servers remaining
32
            int remainingIdle = idlePrefix[n - back] - idlePrefix[front];
33
            34
            // The cost is the maximum of the two factors
35
            int cost = max(remainingIdle, decommissionedActive);
36
            37
            minCost = min(minCost, cost);
38
        }
39
    }
40
    41
    return minCost;
42
}
43
44
int main() {
45
    int t;
46
    cin >> t;
47
    cin.ignore(); // Consume the newline
48
    49
    for (int i = 0; i < t; i++) {
50
        string serverRack;
51
        getline(cin, serverRack);
52
        53
        int minCost = findMinimumCost(serverRack);
54
        cout << minCost << endl;
55
    }
56
    57
    return 0;
58
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390069729
1390062518,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int t;
6
    cin >> t;
7
8
    while (t--) {
9
        int n, k;
10
        cin >> n >> k;
11
12
        vector<int> input(n);
13
        for (int i = 0; i < n; i++) {
14
            cin >> input[i];
15
        }
16
17
        priority_queue<int,vector<int>> pq(input.begin(), input.end());
18
19
        unordered_map<int, int> mapy;
20
        int dummy = min(k, n);  // Ensure we don't pop more than available
21
22
        while (dummy--) {
23
            mapy[pq.top()]++;
24
            pq.pop();
25
        }
26
27
        int cnt = 0;
28
        long long sum = 0;
29
30
        for (int i = 0; i < n; i++) {
31
            if (mapy[input[i]] > 0) {
32
                mapy[input[i]]--;
33
                cnt++;
34
                continue;
35
            }
36
            sum += input[i]+cnt;  // Fixed logic (removed `+ cnt`)
37
        }
38
39
        cout << sum << endl;
40
    }
41
42
    return 0;
43
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390062518
1390063339,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
#include <ext/pb_ds/assoc_container.hpp>
3
#include <ext/pb_ds/tree_policy.hpp>
4
#include <ext/pb_ds/detail/standard_policies.hpp>
5
#include <cmath>
6
#define int long long int
7
#define pb push_back
8
/*---------------------------------------------------------------------------------------------------------------------------------*/
9
/*ASCII small case-> a-97 to z-122
10
upper case-> A-65 to Z-90*/
11
#define nl ""\n""
12
#define mp map<int, int>
13
#define all(v) v.begin(), v.end()
14
#define F first
15
#define S second
16
#define ump unordered_map<long long, int, custom_hash>
17
#define mstpi multiset<pair<int, int> >
18
#define mst multiset<int>
19
#define vec vector<int>
20
#define pi pair<int, int>
21
#define ld long double
22
#define vep vector<pair<int, int>>
23
#define ul unsigned long long
24
#define loop1 for (int i = 0; i < n; i++)
25
#define REP(i, a, b) for (int i = a; i <= b; i++)
26
#define NO cout << ""NO"" << endl
27
#define YES cout << ""YES"" << endl
28
using namespace std;
29
using namespace __gnu_pbds;
30
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
31
/*---------------------------------------------------------------------------------------------------------------------------------*/
32
const double PI = 3.1415926535;
33
const int inf = 1e18;
34
const int mod = 1000000007;
35
/*---------------------------------------------------------------------------------------------------------------------------------*/
36
int modmul(int a, int b, int m)
37
{
38
    a %= m;
39
    b %= m;
40
    return (a * b) % m;
41
}
42
int modexp(int n, int x)
43
{
44
    int ans = 1;
45
    while (n > 0)
46
    {
47
        if (n & 1)
48
        {
49
            ans = (ans * x) % mod;
50
        }
51
        n >>= 1;
52
        x = (x * x) % mod;
53
    }
54
    return ans;
55
}
56
/*---------------------------------------------------------------------------------------------------------------------------------*/
57
string add(string a, string b)
58
{
59
    string ans = """";
60
    int carry = 0;
61
    while (!a.empty() || !b.empty() || carry > 0)
62
    {
63
        int digitA = a.empty() ? 0 : a.back() - '0';
64
        int digitB = b.empty() ? 0 : b.back() - '0';
65
        int sum = digitA + digitB + carry;
66
        ans = to_string(sum % 10) + ans;
67
        carry = sum / 10;
68
        if (!a.empty())
69
            a.pop_back();
70
        if (!b.empty())
71
            b.pop_back();
72
    }
73
    return ans;
74
}
75
string ministrnum(string a, string b)
76
{
77
    if (a.length() > b.length())
78
        return b;
79
    else if (b.length() > a.length())
80
        return a;
81
    else
82
    {
83
        int n = a.length();
84
        for (int i = 0; i < n; i++)
85
        {
86
            if (a[i] > b[i])
87
                return b;
88
            else if (a[i] < b[i])
89
                return a;
90
        }
91
    }
92
    return a;
93
}
94
vector<int> sieve(int n) {
95
    vector<bool> isPrime(n + 1, true);
96
    vector<int> primes;
97
    if(n >= 0) isPrime[0] = false;
98
    if(n >= 1) isPrime[1] = false;
99
    for (int i = 2; i <= n; i++) {
100
        if (isPrime[i]) {
101
            primes.push_back(i);
102
            for (int j = 2 * i; j <= n; j += i)
103
                isPrime[j] = false;
104
        }
105
    }
106
    return primes;
107
}
108
109
class SegmentTree {
110
public:
111
    int n;
112
    std::vector<int> tree;
113
    std::vector<int> lazy;
114
    115
    SegmentTree(const std::vector<int>& arr) {
116
        n = arr.size();
117
        tree.resize(4 * n, 0);
118
        lazy.resize(4 * n, 0);
119
        build(arr, 0, n - 1, 0);
120
    }
121
    122
    void build(const std::vector<int>& arr, int start, int end, int index) {
123
        if (start == end) {
124
            tree[index] = arr[start];
125
            return;
126
        }
127
        int mid = (start + end) / 2;
128
        build(arr, start, mid, 2 * index + 1);
129
        build(arr, mid + 1, end, 2 * index + 2);
130
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
131
    }
132
    133
    int queryRange(int start, int end, int l, int r, int index = 0) {
134
        if (lazy[index] != 0) {
135
            tree[index] += (end - start + 1) * lazy[index];
136
            if(start != end) {
137
                lazy[2 * index + 1] += lazy[index];
138
                lazy[2 * index + 2] += lazy[index];
139
            }
140
            lazy[index] = 0;
141
        }
142
        if (start > r || end < l)
143
            return 0;
144
        if (start >= l && end <= r)
145
            return tree[index];
146
        int mid = (start + end) / 2;
147
        return queryRange(start, mid, l, r, 2 * index + 1) +
148
               queryRange(mid + 1, end, l, r, 2 * index + 2);
149
    }
150
    151
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
152
        if(lazy[index] != 0) {
153
            tree[index] += (end - start + 1) * lazy[index];
154
            if(start != end) {
155
                lazy[2 * index + 1] += lazy[index];
156
                lazy[2 * index + 2] += lazy[index];
157
            }
158
            lazy[index] = 0;
159
        }
160
        if(start > r || end < l)
161
            return;
162
        if(start >= l && end <= r) {
163
            tree[index] += (end - start + 1) * diff;
164
            if(start != end) {
165
                lazy[2 * index + 1] += diff;
166
                lazy[2 * index + 2] += diff;
167
            }
168
            return;
169
        }
170
        int mid = (start + end) / 2;
171
        updateRange(start, mid, l, r, diff, 2 * index + 1);
172
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
173
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
174
    }
175
};
176
class DSU {
177
public:
178
    std::vector<int> parent, rank;
179
    180
    DSU(int n) {
181
        parent.resize(n);
182
        rank.resize(n, 0);
183
        for (int i = 0; i < n; i++)
184
            parent[i] = i;
185
    }
186
    187
    int find(int x) {
188
        if (parent[x] != x)
189
            parent[x] = find(parent[x]);
190
        return parent[x];
191
    }
192
    193
    bool unionSets(int x, int y) {
194
        int rootX = find(x);
195
        int rootY = find(y);
196
        if (rootX == rootY)
197
            return false;
198
        if (rank[rootX] < rank[rootY])
199
            parent[rootX] = rootY;
200
        else if (rank[rootX] > rank[rootY])
201
            parent[rootY] = rootX;
202
        else {
203
            parent[rootY] = rootX;
204
            rank[rootX]++;
205
        }
206
        return true;
207
    }
208
};
209
210
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
211
struct Node {
212
    int val;
213
    int weight, size;
214
    Node *left, *right;
215
    bool rev = false;
216
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
217
};
218
ostream &operator<<(ostream &os, Node *n) {
219
    if(!n) return os;
220
    os << n -> left;
221
    os << n -> val;
222
    os << n -> right;
223
    return os;
224
}
225
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
226
void push(Node* Treap) {
227
    if(!Treap) return;
228
    if(Treap -> rev) {
229
        Treap -> rev = false;
230
        swap(Treap->left, Treap->right);
231
        if(Treap -> left) Treap->left->rev ^= true;
232
        if(Treap -> right) Treap->right->rev ^= true;
233
    }
234
}
235
void pull(Node *Treap) {
236
    if(!Treap) return;
237
    push(Treap -> left), push(Treap -> right);
238
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
239
    return;
240
}
241
void split(Node *Treap, Node *&left, Node *&right, int val) {
242
    if(!Treap) {
243
        left = right = NULL;
244
        return;
245
    }
246
    push(Treap);
247
    if(size(Treap -> left) < val) {
248
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
249
        left = Treap;
250
    }
251
    else {
252
        split(Treap -> left, left, Treap -> left, val);
253
        right = Treap;
254
    }
255
    pull(Treap);
256
}
257
void merge(Node *&Treap, Node *left, Node *right) {
258
    push(left), push(right);
259
    if(left == NULL) {
260
        Treap = right;
261
        return;
262
    }
263
    if(right == NULL) {
264
        Treap = left;
265
        return;
266
    }
267
    if(left -> weight < right -> weight) {
268
        merge(right -> left, left, right -> left);
269
        Treap = right;
270
    }
271
    else {
272
        merge(left->right, left->right, right);
273
        Treap = left;
274
    }
275
    pull(Treap);
276
}
277
void inOrder(Node *curr, vector<int> &res) {
278
    if(curr == NULL) return;
279
    push(curr);
280
    inOrder(curr->left, res);
281
    res.pb(curr->val);
282
    inOrder(curr->right, res);
283
    pull(curr);
284
}
285
struct Treap {
286
    Node *root = nullptr;
287
    void insert(int i, int val) {
288
        Node *l, *r;
289
        split(root, l, r, i);
290
        Node *v = new Node(val);
291
        merge(l, l, v);
292
        merge(root, l, r);
293
    }
294
    295
    void del(int i) {
296
        Node *l, *r;
297
        split(root, l, r, i);
298
        split(r, root, r, 1);
299
        merge(root, l, r);
300
    }
301
    302
    void update(int l, int r, function<void(Node *)> f) {
303
        Node *a, *b, *c;
304
        split(root, a, b, l-1);
305
        split(b, b, c, r-l+1);
306
        if(b) {f(b);}
307
        merge(root, a, b);
308
        merge(root, root, c);
309
    }
310
    311
    vector<int> allPr() {
312
        vector<int> res;
313
        inOrder(root, res);
314
        return res;
315
    }
316
    317
    void cycShft(int l, int r) {
318
        Node *a, *b, *c, *d;
319
        split(root, a, b, l-1);
320
        split(b, b, c, r-l+1);
321
        split(b, b, d, r-l);
322
        merge(root, a, d);
323
        merge(root, root, b);
324
        merge(root, root, c);
325
    }
326
};
327
vector<int> computePrefix(const string &pattern) {
328
    int n = pattern.size();
329
    vector<int> prefix(n, 0);
330
    for (int i = 1, j = 0; i < n; i++) {
331
        while (j > 0 && pattern[i] != pattern[j])
332
            j = prefix[j - 1];
333
        if (pattern[i] == pattern[j])
334
            j++;
335
        prefix[i] = j;
336
    }
337
    return prefix;
338
}
339
340
vector<int> KMPSearch(const string &text, const string &pattern) {
341
    vector<int> prefix = computePrefix(pattern);
342
    vector<int> occurrences;
343
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
344
        while (j > 0 && text[i] != pattern[j])
345
            j = prefix[j - 1];
346
        if (text[i] == pattern[j])
347
            j++;
348
        if (j == (int)pattern.size()) {
349
            occurrences.push_back(i - j + 1);
350
            j = prefix[j - 1];
351
        }
352
    }
353
    return occurrences;
354
}
355
void solve()
356
{
357
    int n, k;
358
    cin>>n>>k;
359
    360
    vector<int> v(n);
361
    loop1 cin>>v[i];
362
    363
    vector<int> suff = v;
364
    suff.pb(0);
365
    for(int i = n - 2; i>-1; i--) suff[i] += suff[i+1];
366
    int ans = INT_MAX;
367
    368
    for(int i = 0; i<=n - k; i++) {
369
        int cur = suff[0] - suff[i] + (suff[i+k] + (n - i - k));
370
        ans = min(ans, cur);
371
    }
372
    cout<<ans<<'\n';
373
}
374
int32_t main()
375
{
376
    ios_base ::sync_with_stdio(0);
377
    cin.tie(0);
378
    cout.tie(0);
379
    int t = 1;
380
    cin >> t;
381
    while (t--)
382
        solve();
383
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390063339
1390063420,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
#include <ext/pb_ds/assoc_container.hpp>
3
#include <ext/pb_ds/tree_policy.hpp>
4
#include <ext/pb_ds/detail/standard_policies.hpp>
5
#include <cmath>
6
#define int long long int
7
#define pb push_back
8
/*---------------------------------------------------------------------------------------------------------------------------------*/
9
/*ASCII small case-> a-97 to z-122
10
upper case-> A-65 to Z-90*/
11
#define nl ""\n""
12
#define mp map<int, int>
13
#define all(v) v.begin(), v.end()
14
#define F first
15
#define S second
16
#define ump unordered_map<long long, int, custom_hash>
17
#define mstpi multiset<pair<int, int> >
18
#define mst multiset<int>
19
#define vec vector<int>
20
#define pi pair<int, int>
21
#define ld long double
22
#define vep vector<pair<int, int>>
23
#define ul unsigned long long
24
#define loop1 for (int i = 0; i < n; i++)
25
#define REP(i, a, b) for (int i = a; i <= b; i++)
26
#define NO cout << ""NO"" << endl
27
#define YES cout << ""YES"" << endl
28
using namespace std;
29
using namespace __gnu_pbds;
30
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
31
/*---------------------------------------------------------------------------------------------------------------------------------*/
32
const double PI = 3.1415926535;
33
const int inf = 1e18;
34
const int mod = 1000000007;
35
/*---------------------------------------------------------------------------------------------------------------------------------*/
36
int modmul(int a, int b, int m)
37
{
38
    a %= m;
39
    b %= m;
40
    return (a * b) % m;
41
}
42
int modexp(int n, int x)
43
{
44
    int ans = 1;
45
    while (n > 0)
46
    {
47
        if (n & 1)
48
        {
49
            ans = (ans * x) % mod;
50
        }
51
        n >>= 1;
52
        x = (x * x) % mod;
53
    }
54
    return ans;
55
}
56
/*---------------------------------------------------------------------------------------------------------------------------------*/
57
string add(string a, string b)
58
{
59
    string ans = """";
60
    int carry = 0;
61
    while (!a.empty() || !b.empty() || carry > 0)
62
    {
63
        int digitA = a.empty() ? 0 : a.back() - '0';
64
        int digitB = b.empty() ? 0 : b.back() - '0';
65
        int sum = digitA + digitB + carry;
66
        ans = to_string(sum % 10) + ans;
67
        carry = sum / 10;
68
        if (!a.empty())
69
            a.pop_back();
70
        if (!b.empty())
71
            b.pop_back();
72
    }
73
    return ans;
74
}
75
string ministrnum(string a, string b)
76
{
77
    if (a.length() > b.length())
78
        return b;
79
    else if (b.length() > a.length())
80
        return a;
81
    else
82
    {
83
        int n = a.length();
84
        for (int i = 0; i < n; i++)
85
        {
86
            if (a[i] > b[i])
87
                return b;
88
            else if (a[i] < b[i])
89
                return a;
90
        }
91
    }
92
    return a;
93
}
94
vector<int> sieve(int n) {
95
    vector<bool> isPrime(n + 1, true);
96
    vector<int> primes;
97
    if(n >= 0) isPrime[0] = false;
98
    if(n >= 1) isPrime[1] = false;
99
    for (int i = 2; i <= n; i++) {
100
        if (isPrime[i]) {
101
            primes.push_back(i);
102
            for (int j = 2 * i; j <= n; j += i)
103
                isPrime[j] = false;
104
        }
105
    }
106
    return primes;
107
}
108
109
class SegmentTree {
110
public:
111
    int n;
112
    std::vector<int> tree;
113
    std::vector<int> lazy;
114
    115
    SegmentTree(const std::vector<int>& arr) {
116
        n = arr.size();
117
        tree.resize(4 * n, 0);
118
        lazy.resize(4 * n, 0);
119
        build(arr, 0, n - 1, 0);
120
    }
121
    122
    void build(const std::vector<int>& arr, int start, int end, int index) {
123
        if (start == end) {
124
            tree[index] = arr[start];
125
            return;
126
        }
127
        int mid = (start + end) / 2;
128
        build(arr, start, mid, 2 * index + 1);
129
        build(arr, mid + 1, end, 2 * index + 2);
130
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
131
    }
132
    133
    int queryRange(int start, int end, int l, int r, int index = 0) {
134
        if (lazy[index] != 0) {
135
            tree[index] += (end - start + 1) * lazy[index];
136
            if(start != end) {
137
                lazy[2 * index + 1] += lazy[index];
138
                lazy[2 * index + 2] += lazy[index];
139
            }
140
            lazy[index] = 0;
141
        }
142
        if (start > r || end < l)
143
            return 0;
144
        if (start >= l && end <= r)
145
            return tree[index];
146
        int mid = (start + end) / 2;
147
        return queryRange(start, mid, l, r, 2 * index + 1) +
148
               queryRange(mid + 1, end, l, r, 2 * index + 2);
149
    }
150
    151
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
152
        if(lazy[index] != 0) {
153
            tree[index] += (end - start + 1) * lazy[index];
154
            if(start != end) {
155
                lazy[2 * index + 1] += lazy[index];
156
                lazy[2 * index + 2] += lazy[index];
157
            }
158
            lazy[index] = 0;
159
        }
160
        if(start > r || end < l)
161
            return;
162
        if(start >= l && end <= r) {
163
            tree[index] += (end - start + 1) * diff;
164
            if(start != end) {
165
                lazy[2 * index + 1] += diff;
166
                lazy[2 * index + 2] += diff;
167
            }
168
            return;
169
        }
170
        int mid = (start + end) / 2;
171
        updateRange(start, mid, l, r, diff, 2 * index + 1);
172
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
173
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
174
    }
175
};
176
class DSU {
177
public:
178
    std::vector<int> parent, rank;
179
    180
    DSU(int n) {
181
        parent.resize(n);
182
        rank.resize(n, 0);
183
        for (int i = 0; i < n; i++)
184
            parent[i] = i;
185
    }
186
    187
    int find(int x) {
188
        if (parent[x] != x)
189
            parent[x] = find(parent[x]);
190
        return parent[x];
191
    }
192
    193
    bool unionSets(int x, int y) {
194
        int rootX = find(x);
195
        int rootY = find(y);
196
        if (rootX == rootY)
197
            return false;
198
        if (rank[rootX] < rank[rootY])
199
            parent[rootX] = rootY;
200
        else if (rank[rootX] > rank[rootY])
201
            parent[rootY] = rootX;
202
        else {
203
            parent[rootY] = rootX;
204
            rank[rootX]++;
205
        }
206
        return true;
207
    }
208
};
209
210
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
211
struct Node {
212
    int val;
213
    int weight, size;
214
    Node *left, *right;
215
    bool rev = false;
216
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
217
};
218
ostream &operator<<(ostream &os, Node *n) {
219
    if(!n) return os;
220
    os << n -> left;
221
    os << n -> val;
222
    os << n -> right;
223
    return os;
224
}
225
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
226
void push(Node* Treap) {
227
    if(!Treap) return;
228
    if(Treap -> rev) {
229
        Treap -> rev = false;
230
        swap(Treap->left, Treap->right);
231
        if(Treap -> left) Treap->left->rev ^= true;
232
        if(Treap -> right) Treap->right->rev ^= true;
233
    }
234
}
235
void pull(Node *Treap) {
236
    if(!Treap) return;
237
    push(Treap -> left), push(Treap -> right);
238
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
239
    return;
240
}
241
void split(Node *Treap, Node *&left, Node *&right, int val) {
242
    if(!Treap) {
243
        left = right = NULL;
244
        return;
245
    }
246
    push(Treap);
247
    if(size(Treap -> left) < val) {
248
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
249
        left = Treap;
250
    }
251
    else {
252
        split(Treap -> left, left, Treap -> left, val);
253
        right = Treap;
254
    }
255
    pull(Treap);
256
}
257
void merge(Node *&Treap, Node *left, Node *right) {
258
    push(left), push(right);
259
    if(left == NULL) {
260
        Treap = right;
261
        return;
262
    }
263
    if(right == NULL) {
264
        Treap = left;
265
        return;
266
    }
267
    if(left -> weight < right -> weight) {
268
        merge(right -> left, left, right -> left);
269
        Treap = right;
270
    }
271
    else {
272
        merge(left->right, left->right, right);
273
        Treap = left;
274
    }
275
    pull(Treap);
276
}
277
void inOrder(Node *curr, vector<int> &res) {
278
    if(curr == NULL) return;
279
    push(curr);
280
    inOrder(curr->left, res);
281
    res.pb(curr->val);
282
    inOrder(curr->right, res);
283
    pull(curr);
284
}
285
struct Treap {
286
    Node *root = nullptr;
287
    void insert(int i, int val) {
288
        Node *l, *r;
289
        split(root, l, r, i);
290
        Node *v = new Node(val);
291
        merge(l, l, v);
292
        merge(root, l, r);
293
    }
294
    295
    void del(int i) {
296
        Node *l, *r;
297
        split(root, l, r, i);
298
        split(r, root, r, 1);
299
        merge(root, l, r);
300
    }
301
    302
    void update(int l, int r, function<void(Node *)> f) {
303
        Node *a, *b, *c;
304
        split(root, a, b, l-1);
305
        split(b, b, c, r-l+1);
306
        if(b) {f(b);}
307
        merge(root, a, b);
308
        merge(root, root, c);
309
    }
310
    311
    vector<int> allPr() {
312
        vector<int> res;
313
        inOrder(root, res);
314
        return res;
315
    }
316
    317
    void cycShft(int l, int r) {
318
        Node *a, *b, *c, *d;
319
        split(root, a, b, l-1);
320
        split(b, b, c, r-l+1);
321
        split(b, b, d, r-l);
322
        merge(root, a, d);
323
        merge(root, root, b);
324
        merge(root, root, c);
325
    }
326
};
327
vector<int> computePrefix(const string &pattern) {
328
    int n = pattern.size();
329
    vector<int> prefix(n, 0);
330
    for (int i = 1, j = 0; i < n; i++) {
331
        while (j > 0 && pattern[i] != pattern[j])
332
            j = prefix[j - 1];
333
        if (pattern[i] == pattern[j])
334
            j++;
335
        prefix[i] = j;
336
    }
337
    return prefix;
338
}
339
340
vector<int> KMPSearch(const string &text, const string &pattern) {
341
    vector<int> prefix = computePrefix(pattern);
342
    vector<int> occurrences;
343
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
344
        while (j > 0 && text[i] != pattern[j])
345
            j = prefix[j - 1];
346
        if (text[i] == pattern[j])
347
            j++;
348
        if (j == (int)pattern.size()) {
349
            occurrences.push_back(i - j + 1);
350
            j = prefix[j - 1];
351
        }
352
    }
353
    return occurrences;
354
}
355
void solve()
356
{
357
    int n, k;
358
    cin>>n>>k;
359
    360
    vector<int> v(n);
361
    loop1 cin>>v[i];
362
    363
    vector<int> suff = v;
364
    suff.pb(0);
365
    for(int i = n - 2; i>-1; i--) suff[i] += suff[i+1];
366
    int ans = accumulate(all(v), 0LL);
367
    368
    for(int i = 0; i<=n - k; i++) {
369
        int cur = suff[0] - suff[i] + (suff[i+k] + (n - i - k));
370
        ans = min(ans, cur);
371
    }
372
    cout<<ans<<'\n';
373
}
374
int32_t main()
375
{
376
    ios_base ::sync_with_stdio(0);
377
    cin.tie(0);
378
    cout.tie(0);
379
    int t = 1;
380
    cin >> t;
381
    while (t--)
382
        solve();
383
}",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390063420
1390059531,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
5
    result = []
6
7
    dq = deque()
8
9
    for i in range(len(arr)):
10
11
        # Remove out-of-window elements
12
13
        if dq and dq[0] < i - k + 1:
14
15
            dq.popleft()
16
17
        # Add new faulty readings
18
19
        if arr[i] < 0:
20
21
            dq.append(i)
22
23
        # Collect results for valid windows
24
25
        if i >= k - 1:
26
27
            result.append(0 if not dq else arr[dq[0]])
28
29
    return result
30
31
# Driver code
32
33
t = int(input())  # Number of test cases
34
35
for _ in range(t):
36
37
    n, k = map(int, input().split())
38
39
    arr = list(map(int, input().split()))
40
41
    faults = earliest_faults(arr, k)
42
43
    print(*faults)",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390059531
1390062213,unknown,unknown,unknown,"1
#include<bits/stdc++.h>
2
using namespace std;
3
4
5
int main() {
6
    int t;
7
    cin>>t;
8
    9
    while(t--)
10
    {
11
        int n,k;
12
        cin>>n>>k;
13
        14
        vector<int>input(n);
15
        for(int i=0;i<n;i++)
16
        {
17
            cin>>input[i];
18
        }
19
        20
        priority_queue<int,vector<int>> pq(input.begin(),input.end());
21
        22
        unordered_map<int,int> mapy;
23
        int dummy=k;
24
        25
        while(dummy--)
26
        {
27
            mapy[pq.top()]++;
28
            pq.pop();
29
        }
30
        31
        32
        int cnt=0;
33
        long long sum=0;
34
        35
        for(int i=0;i<n;i++)
36
        {
37
            if(mapy[input[i]] > 0)
38
            {
39
                mapy[input[i]]--;
40
                cnt++;
41
                continue;
42
            }
43
            44
            sum+=input[i]+cnt;
45
        }
46
        47
        cout<<sum<<endl;
48
    }
49
    return 0;
50
}
51",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390062213
1390059556,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
3
    left = 0
4
5
    zeros = 0
6
7
    max_ones = 0
8
9
    n = len(s)
10
11
    for right in range(n):
12
13
        if s[right] == '0':
14
15
            zeros += 1
16
17
        while zeros > k:
18
19
            if s[left] == '0':
20
21
                zeros -= 1
22
23
            left += 1
24
25
        current_ones = (right - left + 1) - zeros
26
27
        max_ones = max(max_ones, current_ones)
28
29
    30
31
    return max_ones
32
33
def main():
34
35
    T = int(input())
36
37
    for _ in range(T):
38
39
        s = input().strip()
40
41
        n = len(s)
42
43
        total_ones = s.count('1')
44
45
        # Calculate max consecutive ones
46
47
        max_consecutive_ones = 0
48
49
        current = 0
50
51
        for c in s:
52
53
            if c == '1':
54
55
                current += 1
56
57
                max_consecutive_ones = max(max_consecutive_ones, current)
58
59
            else:
60
61
                current = 0
62
63
        if total_ones == 0 or total_ones == max_consecutive_ones:
64
65
            print(0)
66
67
            continue
68
69
        total_zeros = n - total_ones
70
71
        low, high = 0, max(total_ones, total_zeros)
72
73
        answer = high
74
75
        while low <= high:
76
77
            mid = (low + high) // 2
78
79
            required_ones = max(0, total_ones - mid)
80
81
            if required_ones == 0:
82
83
                answer = mid
84
85
                high = mid - 1
86
87
                continue
88
89
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
90
91
            if max_ones >= required_ones:
92
93
                answer = mid
94
95
                high = mid - 1
96
97
            else:
98
99
                low = mid + 1
100
101
        print(answer)
102
103
if __name__ == ""__main__"":
104
105
    main()",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390059556
1390059512,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
   6
    int min = Integer.MAX_VALUE;
7
    Map<String, Integer> memo = new HashMap<>();
8
9
    public int rec(int cz, int cone, int i, int j, String s, int totalOne) {
10
        if (i > j) {
11
            return Integer.MAX_VALUE;
12
        }
13
14
        String key = i + "","" + j + "","" + cz + "","" + cone;
15
        if (memo.containsKey(key)) return memo.get(key);
16
17
        int currMin = Math.max(cz, cone);
18
        min = Math.min(min, currMin);
19
20
        if (cone == totalOne) {
21
            min = Math.min(min, totalOne);
22
            return min;
23
        }
24
        if (cz == 0) {
25
            return min;
26
        }
27
28
        // Try removing from the left
29
        if (s.charAt(i) == '1') {
30
            currMin = Math.min(currMin, rec(cz, cone + 1, i + 1, j, s, totalOne));
31
        } else {
32
            currMin = Math.min(currMin, rec(cz - 1, cone, i + 1, j, s, totalOne));
33
        }
34
35
        // Try removing from the right
36
        if (s.charAt(j) == '1') {
37
            currMin = Math.min(currMin, rec(cz, cone + 1, i, j - 1, s, totalOne));
38
        } else {
39
            currMin = Math.min(currMin, rec(cz - 1, cone, i, j - 1, s, totalOne));
40
        }
41
42
        memo.put(key, currMin);
43
        return currMin;
44
    }
45
46
    public static void main(String[] args) {
47
        Scanner sc = new Scanner(System.in);
48
        int t = sc.nextInt();
49
50
        while (t-- > 0) {
51
            String s = sc.next();
52
            int cz = 0, cone = 0;
53
            54
            for (char ch : s.toCharArray()) {
55
                if (ch == '0') cz++;
56
                else cone++;
57
            }
58
59
            Solution sol = new Solution();
60
            sol.rec(cz, 0, 0, s.length() - 1, s, cone);
61
            System.out.println(sol.min);
62
        }
63
        64
        sc.close();
65
    }
66
}
67",1,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390059512
1390059287,unknown,unknown,unknown,"1
def early(arr, k):
2
    result = []
3
    for i in range(len(arr)-k + 1):
4
        b = arr[i:i+k]
5
        faulty = [x for x in b if x < 0]
6
        result.append(faulty[0] if faulty else 0)
7
    return result
8
9
t = int(input())
10
for _ in range(t):
11
    n, k = map(int, input().split())
12
    arr = list(map(int, input().split()))
13
    print(*early(arr, k))",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390059287
1390059439,unknown,unknown,unknown,"1
def early(arr, k):
2
    result = []
3
    for i in range(len(arr)-k + 1):
4
        b = arr[i:i+k]
5
        faulty = [x for x in b if x < 0]
6
        result.append(faulty[0] if faulty else 0)
7
    return result
8
9
t = int(input())
10
for _ in range(t):
11
    n, k = map(int, input().split())
12
    arr = list(map(int, input().split()))
13
    print(*early(arr, k))",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390059439
1390059469,unknown,unknown,unknown,"1
2
#include <bits/stdc++.h>
3
4
using namespace std;
5
6
typedef long long ll;
7
8
void solve() {
9
10
    int n, k;
11
12
    cin >> n >> k;
13
14
    vector<ll> arr(n);
15
16
    ll total = 0;
17
18
    19
20
    21
22
    for (int i = 0; i < n; i++) {
23
24
        cin >> arr[i];
25
26
        total += arr[i];
27
28
    }
29
30
    31
32
    vector<ll> benefits(n);
33
34
    for (int j = 0; j < n; j++){
35
36
        benefits[j] = arr[j] - (n - 1 - j);
37
38
    }
39
40
    41
42
    sort(benefits.begin(), benefits.end(), greater<ll>());
43
44
    ll best = total;
45
46
    ll sumb = 0;
47
48
    int m = min(k, n);
49
50
    for (int i = 0; i < m; i++){
51
52
        if (benefits[i] < 0) {
53
54
        }
55
56
        sumb += benefits[i];
57
58
        int skips = i + 1;
59
60
        ll candidate = total - sumb - (skips * (skips - 1LL)) / 2LL;
61
62
        best = min(best, candidate);
63
64
    }
65
66
    cout << best << ""\n"";
67
68
}
69
70
int main() {
71
72
    int t; cin >> t;
73
74
    while (t--) {
75
76
        solve();
77
78
    }
79
80
    return 0;
81
82
}
83",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390059469
1390058210,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
   6
    int min = Integer.MAX_VALUE;
7
8
    public void rec(int cz, int cone, int n, String s, int i, int j,int ct) {
9
        if (i > j) {
10
            return;
11
        }
12
13
        int max = Math.max(cz, cone);
14
        min = Math.min(min, max);
15
16
        if (cz == 0 ) {
17
            return;
18
        }
19
        if(cone==ct){
20
             min = Math.min(min, ct);
21
            return;
22
        }
23
24
        if (s.charAt(i) == '1') {
25
            rec(cz, cone + 1, n, s, i + 1, j,ct);
26
        } else if (s.charAt(i) == '0') {
27
            rec(cz - 1, cone, n, s, i + 1, j,ct);
28
        }
29
30
        if (s.charAt(j) == '1') {
31
            rec(cz, cone + 1, n, s, i, j - 1,ct);
32
        } else if (s.charAt(j) == '0') {
33
            rec(cz - 1, cone, n, s, i, j - 1,ct);
34
        }
35
    }
36
37
    public static void main(String[] args) {
38
        Scanner sc = new Scanner(System.in);
39
        int t = sc.nextInt();
40
41
        while (t-- > 0) {
42
            String s = sc.next(); // Read input string
43
            int cz = 0, cone = 0;
44
            45
            for (char ch : s.toCharArray()) {
46
                if (ch == '0') cz++;
47
                else if (ch == '1') cone++;
48
            }
49
50
            Solution sol = new Solution();
51
            sol.rec(cz, 0, s.length(), s, 0, s.length() - 1,cone);
52
            System.out.println(sol.min);
53
        }
54
        55
        sc.close();
56
    }
57
}",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390058210
1390058501,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
   6
    int min = Integer.MAX_VALUE;
7
    Map<String, Integer> memo = new HashMap<>();
8
9
    public void rec(int cz, int cone, int n, String s, int i, int j, int ct) {
10
        if (i > j ) {
11
            return;
12
        }
13
14
        String key = i + "","" + j ;
15
        if (memo.containsKey(key)) return;  // Avoid recomputation
16
       17
18
        min = Math.min(min, Math.max(cz, cone));
19
        memo.put(key, min);
20
        if (cone == ct) {
21
            min = Math.min(min, ct);
22
            return;
23
        }
24
        if(cz==0){
25
            return;
26
        }
27
28
        if (s.charAt(i) == '1') {
29
            rec(cz, cone + 1, n, s, i + 1, j, ct);
30
        } else {
31
            rec(cz - 1, cone, n, s, i + 1, j, ct);
32
        }
33
34
        if (s.charAt(j) == '1') {
35
            rec(cz, cone + 1, n, s, i, j - 1, ct);
36
        } else {
37
            rec(cz - 1, cone, n, s, i, j - 1, ct);
38
        }
39
    }
40
41
    public static void main(String[] args) {
42
        Scanner sc = new Scanner(System.in);
43
        int t = sc.nextInt();
44
45
        while (t-- > 0) {
46
            String s = sc.next();
47
            int cz = 0, cone = 0;
48
            49
            for (char ch : s.toCharArray()) {
50
                if (ch == '0') cz++;
51
                else cone++;
52
            }
53
54
            Solution sol = new Solution();
55
            sol.rec(cz, 0, s.length(), s, 0, s.length() - 1, cone);
56
            System.out.println(sol.min);
57
        }
58
        59
        sc.close();
60
    }
61
}
62",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390058501
1390058774,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
   6
    int min = Integer.MAX_VALUE;
7
    Map<String, Integer> memo = new HashMap<>();
8
9
    public void rec(int cz, int cone, int n, String s, int i, int j, int ct) {
10
        if (i > j ) {
11
            return;
12
        }
13
14
        String key = i + "","" + j ;
15
        if (memo.containsKey(key)) return;  
16
       17
18
        min = Math.min(min, Math.max(cz, cone));
19
        memo.put(key, min);
20
        if (cone == ct) {
21
            min = Math.min(min, ct);
22
            memo.put(key, min);
23
            return;
24
        }
25
        if(cz==0){
26
            return;
27
        }
28
29
        if (s.charAt(i) == '1') {
30
            rec(cz, cone + 1, n, s, i + 1, j, ct);
31
        } else {
32
            rec(cz - 1, cone, n, s, i + 1, j, ct);
33
        }
34
35
        if (s.charAt(j) == '1') {
36
            rec(cz, cone + 1, n, s, i, j - 1, ct);
37
        } else {
38
            rec(cz - 1, cone, n, s, i, j - 1, ct);
39
        }
40
    }
41
42
    public static void main(String[] args) {
43
        Scanner sc = new Scanner(System.in);
44
        int t = sc.nextInt();
45
46
        while (t-- > 0) {
47
            String s = sc.next();
48
            int cz = 0, cone = 0;
49
            50
            for (char ch : s.toCharArray()) {
51
                if (ch == '0') cz++;
52
                else cone++;
53
            }
54
55
            Solution sol = new Solution();
56
            sol.rec(cz, 0, s.length(), s, 0, s.length() - 1, cone);
57
            System.out.println(sol.min);
58
        }
59
        60
        sc.close();
61
    }
62
}
63",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390058774
1390057997,unknown,unknown,unknown,"1
def min_effort(n, k, arr):
2
    total = sum(arr)
3
    if k == n:
4
        return 0
5
    return total - min(arr)
6
7
t = int(input())
8
for _ in range(t):
9
    n, k = map(int, input().split())
10
    arr = list(map(int, input().split()))
11
    print(min_effort(n, k, arr))
12
13",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390057997
1390058040,unknown,unknown,unknown,"1
def min_decommissioning_cost(binary_string):
2
    first_one = binary_string.find('1')
3
    last_one = binary_string.rfind('1')
4
    if first_one == -1:
5
        return 0
6
    substring = binary_string[first_one:last_one + 1]
7
    return max(substring.count('0'), binary_string.count('1') - substring.count('1'))
8
9
t = int(input())
10
for _ in range(t):
11
    binary_string = input().strip()
12
    print(min_decommissioning_cost(binary_string))",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390058040
1390057889,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Check the first batch
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process the remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of this window
18
        while dq and dq[0] <= i - k:
19
            dq.popleft()
20
        21
        # Add the current element if it is negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Append the first negative number in the current window or 0
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Read input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    36
    # Compute and print results
37
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390057889
1390057705,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",2,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390057705
1390057567,unknown,unknown,unknown,1,3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390057567
1390057643,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390057643
1390057102,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390057102
1390057146,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390057146
1390057187,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390057187
1390056984,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        sc.nextLine();
8
        while (T-- > 0) {
9
            String s = sc.nextLine().trim();
10
            int n = s.length();
11
            int totalOnes = 0;
12
            int maxConsecutiveOnes = 0;
13
            int currentConsecutiveOnes = 0;
14
            15
            for (char c : s.toCharArray()) {
16
                if (c == '1') {
17
                    currentConsecutiveOnes++;
18
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
19
                    totalOnes++;
20
                } else {
21
                    currentConsecutiveOnes = 0;
22
                }
23
            }
24
            25
            if (totalOnes == 0) {
26
                System.out.println(0);
27
                continue;
28
            }
29
            if (maxConsecutiveOnes == totalOnes) {
30
                System.out.println(0);
31
                continue;
32
            }
33
            34
            int totalZeros = n - totalOnes;
35
            int low = 0;
36
            int high = Math.max(totalOnes, totalZeros);
37
            int answer = high;
38
            39
            while (low <= high) {
40
                int mid = (low + high) / 2;
41
                int requiredOnes = Math.max(0, totalOnes - mid);
42
                43
                if (requiredOnes == 0) {
44
                    answer = mid;
45
                    high = mid - 1;
46
                    continue;
47
                }
48
                49
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
50
                if (maxOnes >= requiredOnes) {
51
                    answer = mid;
52
                    high = mid - 1;
53
                } else {
54
                    low = mid + 1;
55
                }
56
            }
57
            58
            System.out.println(answer);
59
        }
60
        sc.close();
61
    }
62
    63
    private static int maxOnesWithAtMostKZeros(String s, int k) {
64
        int left = 0;
65
        int zeros = 0;
66
        int maxOnes = 0;
67
        int n = s.length();
68
        69
        for (int right = 0; right < n; right++) {
70
            if (s.charAt(right) == '0') {
71
                zeros++;
72
            }
73
            while (zeros > k) {
74
                if (s.charAt(left) == '0') {
75
                    zeros--;
76
                }
77
                left++;
78
            }
79
            int currentOnes = (right - left + 1) - zeros;
80
            maxOnes = Math.max(maxOnes, currentOnes);
81
        }
82
        83
        return maxOnes;
84
    }
85
}",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056984
1390056985,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056985
1390057031,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}
41",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390057031
1390056979,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
class Solution {
5
  private:
6
    int check (vector<int> checkVector) {
7
      for (auto it : checkVector) {
8
        if (it < 0) {
9
          return it;
10
        }
11
      }
12
      return 0;
13
    }
14
15
  public:
16
    vector<int> faultyReadings (vector<int> arr, int k) {
17
      vector<int> ans;
18
      // -8 2 3 -6 10
19
      for (size_t i = 0; i <= arr.size() - k; ++i) {  
20
        vector<int> checkVector(arr.begin() + i, arr.begin() + i + k);
21
        ans.push_back(check(checkVector));
22
      }
23
24
      return ans;
25
    }
26
};
27
28
int main() {
29
  int t;
30
  // cout << ""Enter Number of Test Cases: "";
31
  cin >> t;
32
33
  Solution obj;
34
35
  while (t--) {
36
    // cout << ""Enter the Size of Array: "";
37
    int n;
38
    cin >> n;
39
40
    // cout << ""Enter Batch Size: "";
41
    int k;
42
    cin >> k;
43
    cin.ignore();  
44
45
    // cout << ""Enter all the Test Cases Values: "";
46
    vector<int> arr;
47
    string input;
48
    getline(cin, input);
49
50
    stringstream ss(input);
51
    int number;
52
    53
    while (ss >> number) {
54
      arr.push_back(number);
55
    }
56
57
    vector<int> ans = obj.faultyReadings(arr, k);
58
    59
    for (auto nums : ans) {
60
      cout << nums << ' ';
61
    } 
62
    cout << '\n';
63
  }
64
  65
  return 0;
66
}
67",3,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056979
1390056889,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    4
    for n, k, arr in test_cases:
5
        result = []
6
        dq = deque()
7
        8
        # Process first window
9
        for i in range(k):
10
            if arr[i] < 0:
11
                dq.append(i)
12
        13
        # Store the first result
14
        result.append(arr[dq[0]] if dq else 0)
15
        16
        # Process remaining windows
17
        for i in range(k, n):
18
            # Remove elements no longer in window
19
            if dq and dq[0] <= i - k:
20
                dq.popleft()
21
            22
            # Add new element if it's faulty
23
            if arr[i] < 0:
24
                dq.append(i)
25
            26
            # Store result for current window
27
            result.append(arr[dq[0]] if dq else 0)
28
        29
        results.append("" "".join(map(str, result)))
30
    31
    return results
32",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056889
1390056939,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        result = []
8
        dq = deque()
9
        10
        # Process first window
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
        15
        # Store the first result
16
        result.append(arr[dq[0]] if dq else 0)
17
        18
        # Process remaining windows
19
        for i in range(k, n):
20
            # Remove elements no longer in window
21
            if dq and dq[0] <= i - k:
22
                dq.popleft()
23
            24
            # Add new element if it's faulty
25
            if arr[i] < 0:
26
                dq.append(i)
27
            28
            # Store result for current window
29
            result.append(arr[dq[0]] if dq else 0)
30
        31
        results.append("" "".join(map(str, result)))
32
    33
    return results
34
35
# Read input
36
t = int(input())
37
test_cases = []
38
for _ in range(t):
39
    n, k = map(int, input().split())
40
    arr = list(map(int, input().split()))
41
    test_cases.append((n, k, arr))
42
43
# Compute and print output
44
for res in earliest_faulty_readings(test_cases):
45
    print(res)",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056939
1390056935,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056935
1390056661,unknown,unknown,unknown,"1
2
3
import java.util.*;
4
import java.io.*;
5
6
public class FirewallSkips {
7
    public static void main(String[] args) {
8
        FastReader in = new FastReader(System.in);
9
        int T = in.nextInt();
10
        11
        while (T-- > 0) {
12
            int n = in.nextInt();
13
            int k = in.nextInt();
14
            15
            long[] a = new long[n];
16
            long sumA = 0; // sum of all a[i]
17
            for (int i = 0; i < n; i++) {
18
                a[i] = in.nextLong();
19
                sumA += a[i];
20
            }
21
            22
            // Build array b[i] = a[i] + (i+1)  [using 1-based index for j]
23
            // We'll sort b in descending order to pick the top x.
24
            long[] b = new long[n];
25
            for (int i = 0; i < n; i++) {
26
                b[i] = a[i] + (i + 1);
27
            }
28
            29
            Arrays.sort(b);
30
            // Sort ascending by default; we want descending, so either:
31
            // 1) reverse in place, or
32
            // 2) build prefix sums from the end.
33
            // Let's just reverse in place for clarity.
34
            reverse(b); // Now b is descending.
35
            36
            // Build prefix sums of b in descending order:
37
            // p[x] = sum of top x elements in b (b[0] + b[1] + ... + b[x-1])
38
            long[] prefix = new long[n+1];
39
            prefix[0] = 0;
40
            for (int x = 1; x <= n; x++) {
41
                prefix[x] = prefix[x-1] + b[x-1];
42
            }
43
            44
            long ans = Long.MAX_VALUE;
45
            // Try x from 0..k (number of skips)
46
            for (int x = 0; x <= k; x++) {
47
                // cost(x) = sumA + x*n - prefix[x] - x*(x-1)/2
48
                // Make sure to use long to avoid overflow
49
                long cost = sumA 
50
                            + x * (long)n 
51
                            - prefix[x]
52
                            - ((long)x * (x - 1) / 2);
53
                ans = Math.min(ans, cost);
54
            }
55
            56
            System.out.println(ans);
57
        }
58
    }
59
    60
    // Utility to reverse array in place
61
    private static void reverse(long[] arr) {
62
        int left = 0, right = arr.length - 1;
63
        while (left < right) {
64
            long tmp = arr[left];
65
            arr[left] = arr[right];
66
            arr[right] = tmp;
67
            left++;
68
            right--;
69
        }
70
    }
71
    72
    // Fast input class (optional, for large I/O)
73
    static class FastReader {
74
        BufferedReader br;
75
        StringTokenizer st;
76
        77
        public FastReader(InputStream stream) {
78
            br = new BufferedReader(new InputStreamReader(stream));
79
        }
80
        81
        String next() {
82
            while (st == null || !st.hasMoreElements()) {
83
                try {
84
                    st = new StringTokenizer(br.readLine());
85
                } catch (IOException e) {
86
                    e.printStackTrace();
87
                }
88
            }
89
            return st.nextToken();
90
        }
91
        92
        int nextInt() {
93
            return Integer.parseInt(next());
94
        }
95
        96
        long nextLong() {
97
            return Long.parseLong(next());
98
        }
99
    }
100
}",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056661
1390056851,unknown,unknown,unknown,"1
def earliest_faulty_in_batches(arr, n, k):
2
    result = []
3
    4
    # Traverse the array in batches of size k
5
    for i in range(n - k + 1):
6
        batch = arr[i:i + k]
7
        found_fault = False
8
        9
        # Find the first negative number in the batch
10
        for num in batch:
11
            if num < 0:
12
                result.append(num)
13
                found_fault = True
14
                break
15
        16
        # If no negative number is found, append 0
17
        if not found_fault:
18
            result.append(0)
19
    20
    return result
21
22
# Reading input
23
t = int(input().strip())
24
outputs = []
25
26
for _ in range(t):
27
    n, k = map(int, input().strip().split())
28
    arr = list(map(int, input().strip().split()))
29
    outputs.append(earliest_faulty_in_batches(arr, n, k))
30
31
# Print results
32
for output in outputs:
33
    print("" "".join(map(str, output)))",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056851
1390056460,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])  # Number of test cases
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
13
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056460
1390056535,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])  # Number of test cases
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split()) ",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056535
1390056633,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    # Try all possible combinations of skipping up to k firewalls
3
    # and find the minimum effort
4
    5
    # Initialize with maximum possible effort
6
    min_effort = float('inf')
7
    8
    # Helper function to calculate effort when skipping specific firewalls
9
    def calculate_effort(skip_mask):
10
        effort = 0
11
        skipped = 0
12
        13
        for i in range(n):
14
            # Check if current firewall is skipped
15
            if (skip_mask >> i) & 1:
16
                skipped += 1
17
            else:
18
                # Add effort for this firewall (including penalty from skipped firewalls)
19
                effort += firewalls[i] + skipped
20
        21
        return effort
22
    23
    # Try all possible combinations of skipping firewalls
24
    # For small n, we can use a brute force approach with bitmasks
25
    for mask in range(1 << n):
26
        # Count bits to ensure we skip at most k firewalls
27
        if bin(mask).count('1') <= k:
28
            effort = calculate_effort(mask)
29
            min_effort = min(min_effort, effort)
30
    31
    return min_effort
32
33
# Test with the provided examples
34
test_cases = [
35
    {""n"": 4, ""k"": 1, ""firewalls"": [5, 10, 11, 5], ""expected"": 21},
36
    {""n"": 4, ""k"": 4, ""firewalls"": [8, 7, 1, 4], ""expected"": 0}
37
]
38
39
for i, test in enumerate(test_cases):
40
    result = min_effort_to_breach(test[""n""], test[""k""], test[""firewalls""])
41
    print(f""Test {i+1}: Result = {result}, Expected = {test['expected']}"")
42
43
# Final solution for submission
44
print(""\nFinal solution:"")
45
print(""""""
46
def min_effort_to_breach(n, k, firewalls):
47
    # Try all possible combinations of skipping up to k firewalls
48
    # and find the minimum effort
49
    50
    # Initialize with maximum possible effort
51
    min_effort = float('inf')
52
    53
    # Helper function to calculate effort when skipping specific firewalls
54
    def calculate_effort(skip_mask):
55
        effort = 0
56
        skipped = 0
57
        58
        for i in range(n):
59
            # Check if current firewall is skipped
60
            if (skip_mask >> i) & 1:
61
                skipped += 1
62
            else:
63
                # Add effort for this firewall (including penalty from skipped firewalls)
64
                effort += firewalls[i] + skipped
65
        66
        return effort
67
    68
    # Try all possible combinations of skipping firewalls
69
    # For small n, we can use a brute force approach with bitmasks
70
    for mask in range(1 << n):
71
        # Count bits to ensure we skip at most k firewalls
72
        if bin(mask).count('1') <= k:
73
            effort = calculate_effort(mask)
74
            min_effort = min(min_effort, effort)
75
    76
    return min_effort
77
78
# Read input
79
T = int(input())
80
for _ in range(T):
81
    n, k = map(int, input().split())
82
    firewalls = list(map(int, input().split()))
83
    print(min_effort_to_breach(n, k, firewalls))
84
"""""")",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056633
1390056446,unknown,unknown,unknown,"1
def min_cost(s):
2
    total_ones = s.count('1')
3
    n = len(s)
4
    5
    scenario_empty = total_ones  # Cost when removing all '1's
6
    7
    # Scenario 1: Window lengths 1 to min(total_ones, n)
8
    scenario1_cost = float('inf')
9
    if total_ones == 0:
10
        scenario1_cost = 0  # If all are '0's, best is to remove all
11
    else:
12
        max_ones = 0
13
        L = min(total_ones, n)
14
        current_ones = sum(1 for c in s[:L] if c == '1')  # Initial window count
15
        16
        max_ones = current_ones  # First window
17
        for i in range(1, n - L + 1):
18
            current_ones -= (s[i-1] == '1')
19
            current_ones += (s[i + L - 1] == '1')
20
            max_ones = max(max_ones, current_ones)  # Keep track of max found
21
        22
        scenario1_cost = total_ones - max_ones  # Cost of transforming scenario 1
23
    24
    # Scenario 2: Window lengths > total_ones
25
    scenario2_cost = float('inf')
26
    if n > total_ones:
27
        min_zeros = float('inf')
28
        current_zeros = sum(1 for c in s[:total_ones + 1] if c == '0')  # Initial window count
29
        30
        min_zeros = current_zeros  # First window
31
        for i in range(1, n - (total_ones + 1) + 1):
32
            current_zeros -= (s[i-1] == '0')
33
            current_zeros += (s[i + total_ones] == '0')
34
            min_zeros = min(min_zeros, current_zeros)  # Keep track of min found
35
        36
        scenario2_cost = min_zeros  # Cost of transforming scenario 2
37
    38
    # Choose the best (minimum cost) option
39
    candidates = [scenario1_cost, scenario_empty]
40
    if n > total_ones:
41
        candidates.append(scenario2_cost)
42
    43
    return min(candidates)
44
45
# Read number of test cases
46
T = int(input())
47
for _ in range(T):
48
    s = input().strip()
49
    print(min_cost(s))
50",4,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056446
1390056380,unknown,unknown,unknown,"1
function minDecommissioningCost(rack) {
2
    let n = rack.length;
3
    let prefixZeros = new Array(n + 1).fill(0);
4
    let prefixOnes = new Array(n + 1).fill(0);
5
6
    for (let i = 0; i < n; i++) {
7
        prefixZeros[i + 1] = prefixZeros[i] + (rack[i] === '0' ? 1 : 0);
8
        prefixOnes[i + 1] = prefixOnes[i] + (rack[i] === '1' ? 1 : 0);
9
    }
10
11
    let totalZeros = prefixZeros[n];
12
    let totalOnes = prefixOnes[n];
13
    let minCost = Infinity;
14
15
    for (let i = 0; i <= n; i++) {
16
        for (let j = 0; j <= n - i; j++) {
17
            if (i + j === n) continue;
18
19
            let zerosRemovedStart = prefixZeros[i];
20
            let onesRemovedStart = prefixOnes[i];
21
            let zerosRemovedEnd = totalZeros - prefixZeros[n - j];
22
            let onesRemovedEnd = totalOnes - prefixOnes[n - j];
23
24
            let remainingZeros = totalZeros - zerosRemovedStart - zerosRemovedEnd;
25
            let removedOnes = onesRemovedStart + onesRemovedEnd;
26
            let cost = Math.max(remainingZeros, removedOnes);
27
28
            minCost = Math.min(minCost, cost);
29
        }
30
    }
31
    return minCost;
32
}
33
34
function solveTestCases(input) {
35
    let lines = input.trim().split(""\n"");
36
    let T = parseInt(lines[0], 10);
37
    let results = [];
38
39
    for (let i = 1; i <= T; i++) {
40
        let rack = lines[i].trim();
41
        results.push(minDecommissioningCost(rack));
42
    }
43
44
    console.log(results.join(""\n""));
45
}
46
47
process.stdin.resume();
48
process.stdin.setEncoding(""utf8"");
49
let _input = """";
50
51
process.stdin.on(""data"", function (input) {
52
    _input += input;
53
});
54
55
process.stdin.on(""end"", function () {
56
    solveTestCases(_input);
57
});
58",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056380
1390056434,unknown,unknown,unknown,"1
T = int(input())  
2
3
for _ in range(T):
4
    n, k = map(int, input().split())  
5
    a = list(map(int, input().split()))  
6
    if n ==k:
7
        print(0)
8
        continue
9
    reductions = []
10
    for i in range(n):
11
        reductions.append(a[i] - (n - i - 1))
12
13
    reductions.sort(reverse=True)
14
    total_reduction = sum(reductions[:k]) if k > 0 else 0
15
16
    total_effort = sum(a) - total_reduction + min(k, n) * (min(k, n) - 1) // 2
17
18
    print(total_effort)  ",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056434
1390056443,unknown,unknown,unknown,"1
def minimum_decommission_cost(servers):
2
    n = len(servers)
3
    4
    # Convert the string to a list of integers (0 or 1)
5
    server_list = [int(c) for c in servers]
6
7
    # Compute prefix sum of active servers (1s)
8
    prefix_sum = [0] * (n + 1)
9
    for i in range(n):
10
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
11
12
    total_ones = prefix_sum[n]  # Total active servers
13
    min_cost = total_ones  # Worst case: decommission all active servers
14
15
    # Iterate over all possible windows to calculate the cost
16
    for i in range(n + 1):
17
        for j in range(i, n + 1):
18
            # Number of 0's in the window is the total number of characters minus active 1's in that window
19
            segment_zeros = (j - i) - (prefix_sum[j] - prefix_sum[i])
20
            # Active servers removed are total active servers - active servers in this window
21
            active_removed = total_ones - (prefix_sum[j] - prefix_sum[i])
22
            23
            cost = max(segment_zeros, active_removed)
24
            min_cost = min(min_cost, cost)
25
26
    return min_cost
27
28
def process_input():
29
    # Reading input
30
    t = int(input())
31
    for _ in range(t):
32
        servers = input().strip()
33
        # Calling the function to calculate the minimum decommission cost
34
        print(minimum_decommission_cost(servers))
35
36
# Call the process_input function when the script is run directly
37
if __name__ == ""__main__"":
38
    process_input()
39",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056443
1390056300,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056300
1390056324,unknown,unknown,unknown,"1
t = int(input())
2
3
for _ in range(t):
4
    n, k = map(int, input().split())
5
    arr = list(map(int, input().split()))
6
7
    if n == k:
8
        print(0)
9
    else:
10
        result = 0
11
        for i in range(n - k + 1):
12
            13
            temp_arr = arr[:i] + arr[i + 1:]
14
            temp_arr[i % len(temp_arr)] = 0  
15
            akshu = sum(temp_arr) + (n - 1 - i)
16
            result = max(result, akshu)
17
18
        print(result)
19
20
                21
                    22
        ",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056324
1390056335,unknown,unknown,unknown,"1
def min_cost(s):
2
    total_ones = s.count('1')
3
    n = len(s)
4
    5
    scenario_empty = total_ones  # Cost when removing all '1's
6
    7
    # Scenario 1: Window lengths 1 to min(total_ones, n)
8
    scenario1_cost = float('inf')
9
    if total_ones == 0:
10
        scenario1_cost = 0  # If all are '0's, best is to remove all
11
    else:
12
        max_ones = 0
13
        L = min(total_ones, n)
14
        current_ones = sum(1 for c in s[:L] if c == '1')  # Initial window count
15
        16
        max_ones = current_ones  # First window
17
        for i in range(1, n - L + 1):
18
            current_ones -= (s[i-1] == '1')
19
            current_ones += (s[i + L - 1] == '1')
20
            max_ones = max(max_ones, current_ones)  # Keep track of max found
21
        22
        scenario1_cost = total_ones - max_ones  # Cost of transforming scenario 1
23
    24
    # Scenario 2: Window lengths > total_ones
25
    scenario2_cost = float('inf')
26
    if n > total_ones:
27
        min_zeros = float('inf')
28
        current_zeros = sum(1 for c in s[:total_ones + 1] if c == '0')  # Initial window count
29
        30
        min_zeros = current_zeros  # First window
31
        for i in range(1, n - (total_ones + 1) + 1):
32
            current_zeros -= (s[i-1] == '0')
33
            current_zeros += (s[i + total_ones] == '0')
34
            min_zeros = min(min_zeros, current_zeros)  # Keep track of min found
35
        36
        scenario2_cost = min_zeros  # Cost of transforming scenario 2
37
    38
    # Choose the best (minimum cost) option
39
    candidates = [scenario1_cost, scenario_empty]
40
    if n > total_ones:
41
        candidates.append(scenario2_cost)
42
    43
    return min(candidates)
44
45
# Read number of test cases
46
T = int(input())
47
for _ in range(T):
48
    s = input().strip()
49
    print(min_cost(s))",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056335
1390056268,unknown,unknown,unknown,"1
def min_cost(s: str) -> int:
2
3
    n = len(s)
4
5
    min_cost = float('inf')
6
7
    # Precompute the total number of 0's in the string
8
9
    total_zeros = s.count('0')
10
11
    # Iterate over all possible ways to decommission from the beginning and end
12
13
    for left in range(n + 1):
14
15
        for right in range(n + 1 - left):
16
17
            # Calculate the number of 0's remaining in the middle part
18
19
            middle = s[left : n - right]
20
21
            remaining_zeros = middle.count('0')
22
23
            # Calculate the number of 1's decommissioned from the left and right
24
25
            decommissioned_ones = s[:left].count('1') + s[n - right:].count('1')
26
27
            # Calculate the cost
28
29
            cost = max(remaining_zeros, decommissioned_ones)
30
31
            min_cost = min(min_cost, cost)
32
33
    return min_cost
34
35
def main():
36
37
    import sys
38
39
    input = sys.stdin.read
40
41
    data = input().split()
42
43
    T = int(data[0])
44
45
    for i in range(1, T + 1):
46
47
        s = data[i]
48
49
        print(min_cost(s))
50
51
if __name__ == ""__main__"":
52
53
    main()",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056268
1390056279,unknown,unknown,unknown,"1
def min_decommissioning_cost(rack):
2
    n = len(rack)
3
    prefix_zeros = [0] * (n + 1)
4
    prefix_ones = [0] * (n + 1)
5
6
    # Compute prefix sums for '0's and '1's
7
    for i in range(n):
8
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if rack[i] == '0' else 0)
9
        prefix_ones[i + 1] = prefix_ones[i] + (1 if rack[i] == '1' else 0)
10
11
    total_zeros = prefix_zeros[n]
12
    total_ones = prefix_ones[n]
13
    min_cost = float('inf')
14
15
    # Try different partition points
16
    for i in range(n + 1):
17
        for j in range(n + 1 - i):
18
            if i + j == n:
19
                continue
20
21
            zeros_removed_start = prefix_zeros[i]
22
            ones_removed_start = prefix_ones[i]
23
            zeros_removed_end = total_zeros - prefix_zeros[n - j]
24
            ones_removed_end = total_ones - prefix_ones[n - j]
25
26
            remaining_zeros = total_zeros - zeros_removed_start - zeros_removed_end
27
            removed_ones = ones_removed_start + ones_removed_end
28
            cost = max(remaining_zeros, removed_ones)
29
30
            min_cost = min(min_cost, cost)
31
32
    return min_cost
33
34
35
def solve_test_cases():
36
    t = int(input().strip())
37
    results = []
38
39
    for _ in range(t):
40
        rack = input().strip()
41
        result = min_decommissioning_cost(rack)
42
        results.append(str(result))
43
44
    print(""\n"".join(results))
45
46
47
if __name__ == ""__main__"":
48
    solve_test_cases()
49",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056279
1390056289,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
    total_effort = sum(strengths)  # Case where no firewalls are skipped
3
    4
    # Calculate the effort for each possible skipping position
5
    min_effort = total_effort
6
    7
    for i in range(n):
8
        if k > 0:
9
            skipped_effort = strengths[i]
10
            extra_penalty = (n - (i + 1)) * 1  # Each subsequent firewall gets +1 penalty per skip
11
            current_effort = total_effort - skipped_effort + extra_penalty
12
            min_effort = min(min_effort, current_effort)
13
    14
    return min_effort if k < n else 0  # If k == n, we can skip all firewalls
15
16
17
def main():
18
    T = int(input())  # Number of test cases
19
    20
    for _ in range(T):
21
        n, k = map(int, input().split())
22
        strengths = list(map(int, input().split()))
23
        print(min_effort(n, k, strengths))
24
25
26
if __name__ == ""__main__"":
27
    main()
28",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056289
1390056255,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])  # Number of test cases
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
13
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()",5,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056255
1390056245,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
    public static void main(String[] args) {
9
        Scanner scanner = new Scanner(System.in);
10
        int testCases = scanner.nextInt();
11
        12
        while (testCases-- > 0) {
13
            int arraySize = scanner.nextInt();
14
            int windowSize = scanner.nextInt();
15
            int[] elements = new int[arraySize];
16
            17
            18
            for (int index = 0; index < arraySize; index++) {
19
                elements[index] = scanner.nextInt();
20
            }
21
            22
            if (windowSize > arraySize) {
23
                System.out.println(""0"");
24
                continue;
25
            }
26
            27
            for (int start = 0; start <= arraySize - windowSize; start++) {
28
                int firstNegative = 0;
29
                30
                for (int end = start; end < start + windowSize; end++) {
31
                    if (elements[end] < 0) {
32
                        firstNegative = elements[end];
33
                        break;
34
                    }
35
                }
36
                System.out.print(firstNegative + "" "");
37
            }
38
            System.out.println();
39
        }
40
        41
        scanner.close();
42
    }
43
}",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056245
1390056254,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if __name__ == ""__main__"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056254
1390056253,unknown,unknown,unknown,"1
def solve(servers):
2
    3
    n = len(servers)
4
    min_cost = float('inf')
5
    best_i = 0
6
    best_j = 0
7
    8
    for i in range(n + 1):
9
        for j in range(n + 1 - i):
10
            rem = servers[i:n-j]
11
            zeros = rem.count('0')
12
            ones_removed = servers[:i].count('1') + servers[n-j:].count('1')
13
            14
            # cost is max of these
15
            cost = max(zeros, ones_removed)
16
            17
            # update if better
18
            if cost < min_cost:
19
                min_cost = cost
20
                best_i = i
21
                best_j = j
22
    23
    # idk if this is right but let's try
24
    return min_cost
25
26
def main():
27
    t = int(input())
28
    for _ in range(t):
29
        s = input().strip()
30
        print(solve(s))
31
32
if __name__ == ""__main__"":
33
    main()",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056253
1390056181,unknown,unknown,unknown,"1
2
import java.util.*;
3
import java.io.*;
4
5
public class FirewallSkips {
6
    public static void main(String[] args) {
7
        FastReader in = new FastReader(System.in);
8
        int T = in.nextInt();
9
        10
        while (T-- > 0) {
11
            int n = in.nextInt();
12
            int k = in.nextInt();
13
            14
            long[] a = new long[n];
15
            long sumA = 0; // sum of all a[i]
16
            for (int i = 0; i < n; i++) {
17
                a[i] = in.nextLong();
18
                sumA += a[i];
19
            }
20
            21
            // Build array b[i] = a[i] + (i+1)  [using 1-based index for j]
22
            // We'll sort b in descending order to pick the top x.
23
            long[] b = new long[n];
24
            for (int i = 0; i < n; i++) {
25
                b[i] = a[i] + (i + 1);
26
            }
27
            28
            Arrays.sort(b);
29
            // Sort ascending by default; we want descending, so either:
30
            // 1) reverse in place, or
31
            // 2) build prefix sums from the end.
32
            // Let's just reverse in place for clarity.
33
            reverse(b); // Now b is descending.
34
            35
            // Build prefix sums of b in descending order:
36
            // p[x] = sum of top x elements in b (b[0] + b[1] + ... + b[x-1])
37
            long[] prefix = new long[n+1];
38
            prefix[0] = 0;
39
            for (int x = 1; x <= n; x++) {
40
                prefix[x] = prefix[x-1] + b[x-1];
41
            }
42
            43
            long ans = Long.MAX_VALUE;
44
            // Try x from 0..k (number of skips)
45
            for (int x = 0; x <= k; x++) {
46
                // cost(x) = sumA + x*n - prefix[x] - x*(x-1)/2
47
                // Make sure to use long to avoid overflow
48
                long cost = sumA 
49
                            + x * (long)n 
50
                            - prefix[x]
51
                            - ((long)x * (x - 1) / 2);
52
                ans = Math.min(ans, cost);
53
            }
54
            55
            System.out.println(ans);
56
        }
57
    }
58
    59
    // Utility to reverse array in place
60
    private static void reverse(long[] arr) {
61
        int left = 0, right = arr.length - 1;
62
        while (left < right) {
63
            long tmp = arr[left];
64
            arr[left] = arr[right];
65
            arr[right] = tmp;
66
            left++;
67
            right--;
68
        }
69
    }
70
    71
    // Fast input class (optional, for large I/O)
72
    static class FastReader {
73
        BufferedReader br;
74
        StringTokenizer st;
75
        76
        public FastReader(InputStream stream) {
77
            br = new BufferedReader(new InputStreamReader(stream));
78
        }
79
        80
        String next() {
81
            while (st == null || !st.hasMoreElements()) {
82
                try {
83
                    st = new StringTokenizer(br.readLine());
84
                } catch (IOException e) {
85
                    e.printStackTrace();
86
                }
87
            }
88
            return st.nextToken();
89
        }
90
        91
        int nextInt() {
92
            return Integer.parseInt(next());
93
        }
94
        95
        long nextLong() {
96
            return Long.parseLong(next());
97
        }
98
    }
99
}",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056181
1390056185,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} 3rd",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056185
1390056180,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):  # Iterate through all combinations of skips
8
        skips = []
9
        for j in range(n):
10
            if (i >> j) & 1:
11
                skips.append(j)
12
        13
        if len(skips) <= k:
14
            effort = 0
15
            increment = 0
16
            for j in range(n):
17
                if j in skips:
18
                    increment += 1
19
                else:
20
                    effort += a[j] + increment
21
            min_effort = min(min_effort, effort)
22
    23
    print(min_effort)
24
25
t = int(input())
26
for _ in range(t):
27
    solve()",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056180
1390056163,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
      Scanner scanner = new Scanner(System.in);
8
        int t = scanner.nextInt(); 
9
10
        while (t-- > 0) {
11
            int n = scanner.nextInt(); 
12
            int k = scanner.nextInt(); 
13
            int[] arr = new int[n];
14
15
            for (int i = 0; i < n; i++) {
16
                arr[i] = scanner.nextInt();
17
            }
18
19
            int ans = findResult(arr, k);
20
21
            System.out.print(ans);
22
           23
            System.out.println();
24
        }
25
        scanner.close();
26
    }
27
    public static int findResult(int []arr, int k){
28
        int[] ans= new int[arr.length];
29
        int sum=0;
30
        for(int i =0;i<arr.length;i++){
31
            ans[i]=arr[i]-((arr.length-1)-i);
32
            sum+=arr[i];
33
        }
34
        Arrays.sort(ans);
35
        reverse(ans);
36
        for(int i =0;i<k;i++){
37
            if(ans[i]>0){
38
               // System.out.println(ans[i]+""w"");
39
                sum-=ans[i];
40
            }
41
        }
42
        43
        return Math.max(sum,0);
44
        45
    }
46
     private static void reverse(int[] arr) {
47
        int left = 0, right = arr.length - 1;
48
        while (left < right) {
49
            int temp = arr[left];
50
            arr[left] = arr[right];
51
            arr[right] = temp;
52
            left++;
53
            right--;
54
        }
55
    }
56
}",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056163
1390056162,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056162
1390056169,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])  # Number of test cases
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
13
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056169
1390056158,unknown,unknown,unknown,"1
import sys
2
def solve():
3
    x = sys.stdin.buffer.read().split()
4
    if not x: return
5
    t = int(x[0])
6
    i = 1
7
    o = []
8
    for _ in range(t):
9
        s = x[i].decode()
10
        i += 1
11
        n = len(s)
12
        A = [0]*(n+1)
13
        B = [0]*(n+1)
14
        for j in range(n):
15
            B[j+1] = B[j] + (s[j]=='1')
16
            A[j+1] = A[j] + (s[j]=='0')
17
        T = A[n]
18
        C = [0]*(n+1)
19
        E = [0]*(n+1)
20
        for j in range(n):
21
            E[j+1] = E[j] + (s[n-1-j]=='1')
22
            C[j+1] = C[j] + (s[n-1-j]=='0')
23
        r = 10**9
24
        for x_ in range(n+1):
25
            m = n - x_
26
            y = T - A[x_] - B[x_]
27
            if y < 0: y = 0
28
            if y > m: y = m
29
            for z in (y, y-1, y+1):
30
                if z < 0 or z > m: continue
31
                v1 = B[x_] + E[z]
32
                v2 = T - (A[x_] + C[z])
33
                v = v1 if v1 >= v2 else v2
34
                if v < r: r = v
35
        o.append(str(r))
36
    sys.stdout.write(""\n"".join(o))
37
if __name__==""__main__"":
38
    solve()",6,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056158
1390056138,unknown,unknown,unknown,"1
import sys
2
3
def min_effort_to_breach(t, test_cases):
4
    INF = 10**18
5
    results = []
6
    7
    for n, k, firewalls in test_cases:
8
        prev = [INF] * (k + 1)
9
        prev[0] = 0
10
        11
        for i in range(n):
12
            curr = [INF] * (k + 1)
13
            for s in range(k + 1):
14
                curr[s] = prev[s] + firewalls[i] + s
15
                if s > 0:
16
                    curr[s] = min(curr[s], prev[s - 1])
17
            prev = curr
18
        19
        results.append(min(prev))
20
    21
    return results
22
23
24
t = int(sys.stdin.readline().strip())
25
test_cases = []
26
for _ in range(t):
27
    n, k = map(int, sys.stdin.readline().split())
28
    firewalls = list(map(int, sys.stdin.readline().split()))
29
    test_cases.append((n, k, firewalls))
30
31
32
results = min_effort_to_breach(t, test_cases)
33
34
# Print output
35
for res in results:
36
    print(res)",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056138
1390056140,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int t = scanner.nextInt(); // Number of test cases
9
        10
        for (int tc = 0; tc < t; tc++) {
11
            int n = scanner.nextInt(); // Number of firewalls
12
            int k = scanner.nextInt(); // Maximum firewalls to skip
13
            14
            int[] strengths = new int[n];
15
            for (int i = 0; i < n; i++) {
16
                strengths[i] = scanner.nextInt();
17
            }
18
            19
            System.out.println(minEffortToBreach(n, k, strengths));
20
        }
21
        22
        scanner.close();
23
    }
24
    25
    public static long minEffortToBreach(int n, int k, int[] strengths) {
26
        // Create a 2D DP table
27
        // dp[i][j] = min effort to breach first i firewalls by skipping j firewalls
28
        long[][] dp = new long[n + 1][k + 1];
29
        30
        // Initialize with maximum value
31
        for (int i = 0; i <= n; i++) {
32
            for (int j = 0; j <= k; j++) {
33
                dp[i][j] = Long.MAX_VALUE;
34
            }
35
        }
36
        37
        // Base case: no firewalls, no effort
38
        dp[0][0] = 0;
39
        40
        for (int i = 1; i <= n; i++) {
41
            int firewallIdx = i - 1; // Convert to 0-indexed for strengths array
42
            43
            for (int j = 0; j <= k; j++) {
44
                // Option 1: Don't skip the current firewall
45
                if (j <= firewallIdx) { // We must have skipped at most j firewalls among previous i-1
46
                    // Calculate increased strength due to j previously skipped firewalls
47
                    long currentStrength = strengths[firewallIdx] + j;
48
                    if (dp[i-1][j] != Long.MAX_VALUE) {
49
                        dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + currentStrength);
50
                    }
51
                }
52
                53
                // Option 2: Skip the current firewall (if we haven't used all skips)
54
                if (j > 0) {
55
                    if (dp[i-1][j-1] != Long.MAX_VALUE) {
56
                        dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1]);
57
                    }
58
                }
59
            }
60
        }
61
        62
        // Find minimum effort across all possible skip counts
63
        long minEffort = Long.MAX_VALUE;
64
        for (int j = 0; j <= k; j++) {
65
            minEffort = Math.min(minEffort, dp[n][j]);
66
        }
67
        68
        return minEffort;
69
    }
70
}",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056140
1390056144,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
        # get indices for active servers ('1')
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        # Precompute A: A[i] = positions[i] - i
18
        A = [positions[i] - i for i in range(m)]
19
        20
        # check(X) returns True if there exists a window in A
21
        # such that:
22
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
23
        # and A[j] - A[i] <= X.
24
        def check(X):
25
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                # slide j as far as possible while A[j]-A[i] <= X
33
                while j < m and A[j] - A[i] <= X:
34
                    j += 1
35
                # j now is one past the last index satisfying condition, so the window has length (j - i)
36
                if j - i >= m - X:
37
                    return True
38
            return False
39
40
        # Binary search for the minimum X
41
        lo, hi, ans = 0, n, n
42
        while lo <= hi:
43
            mid = (lo + hi) // 2
44
            if check(mid):
45
                ans = mid
46
                hi = mid - 1
47
            else:
48
                lo = mid + 1
49
        out_lines.append(str(ans))
50
    51
    sys.stdout.write(""\n"".join(out_lines))
52
    53
if __name__ ==  ""__main__"":
54
     solve()",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056144
1390056133,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def min_effort_to_breach(test_cases):
3
    results = []
4
    5
    for n, k, firewalls in test_cases:
6
        min_effort = float('inf')
7
        8
        for skipped in range(k + 1):
9
            effort = 0
10
            penalty = 0
11
            12
            for i in range(skipped, n):
13
                effort += firewalls[i] + penalty
14
                penalty += 1
15
                16
            min_effort = min(min_effort, effort)
17
            18
        19
        results.append(min_effort)
20
    return results
21
22
if __name__ == ""__main__"":
23
    try:
24
        T = int(input())
25
        test_cases = []
26
    27
    28
        for _ in range(T):
29
            try:
30
                n, k = map(int, input().split())
31
                firewalls = list(map(int, input().split()))
32
                33
                if len(firewalls) != n:
34
                    raise ValueError(""Invalid number of firewall strenghts"")
35
                test_cases.append((n, k, firewalls))
36
    37
            except ValueError as e:
38
                print(f""Invalid input: {e}"")
39
                exit(1)
40
    41
        output = min_effort_to_breach(test_cases)
42
    43
        for res in output:
44
            print(res)
45
    except ValueError:
46
        print(""Invalid input:  Expected an integer for the no of test cases."")      ",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056133
1390056134,unknown,unknown,unknown,"1
2
import java.util.*;
3
import java.io.*;
4
5
public class FirewallSkips {
6
    public static void main(String[] args) {
7
        FastReader in = new FastReader(System.in);
8
        int T = in.nextInt();
9
        10
        while (T-- > 0) {
11
            int n = in.nextInt();
12
            int k = in.nextInt();
13
            14
            long[] a = new long[n];
15
            long sumA = 0; // sum of all a[i]
16
            for (int i = 0; i < n; i++) {
17
                a[i] = in.nextLong();
18
                sumA += a[i];
19
            }
20
            21
            // Build array b[i] = a[i] + (i+1)  [using 1-based index for j]
22
            // We'll sort b in descending order to pick the top x.
23
            long[] b = new long[n];
24
            for (int i = 0; i < n; i++) {
25
                b[i] = a[i] + (i + 1);
26
            }
27
            28
            Arrays.sort(b);
29
            // Sort ascending by default; we want descending, so either:
30
            // 1) reverse in place, or
31
            // 2) build prefix sums from the end.
32
            // Let's just reverse in place for clarity.
33
            reverse(b); // Now b is descending.
34
            35
            // Build prefix sums of b in descending order:
36
            // p[x] = sum of top x elements in b (b[0] + b[1] + ... + b[x-1])
37
            long[] prefix = new long[n+1];
38
            prefix[0] = 0;
39
            for (int x = 1; x <= n; x++) {
40
                prefix[x] = prefix[x-1] + b[x-1];
41
            }
42
            43
            long ans = Long.MAX_VALUE;
44
            // Try x from 0..k (number of skips)
45
            for (int x = 0; x <= k; x++) {
46
                // cost(x) = sumA + x*n - prefix[x] - x*(x-1)/2
47
                // Make sure to use long to avoid overflow
48
                long cost = sumA 
49
                            + x * (long)n 
50
                            - prefix[x]
51
                            - ((long)x * (x - 1) / 2);
52
                ans = Math.min(ans, cost);
53
            }
54
            55
            System.out.println(ans);
56
        }
57
    }
58
    59
    // Utility to reverse array in place
60
    private static void reverse(long[] arr) {
61
        int left = 0, right = arr.length - 1;
62
        while (left < right) {
63
            long tmp = arr[left];
64
            arr[left] = arr[right];
65
            arr[right] = tmp;
66
            left++;
67
            right--;
68
        }
69
    }
70
    71
    // Fast input class (optional, for large I/O)
72
    static class FastReader {
73
        BufferedReader br;
74
        StringTokenizer st;
75
        76
        public FastReader(InputStream stream) {
77
            br = new BufferedReader(new InputStreamReader(stream));
78
        }
79
        80
        String next() {
81
            while (st == null || !st.hasMoreElements()) {
82
                try {
83
                    st = new StringTokenizer(br.readLine());
84
                } catch (IOException e) {
85
                    e.printStackTrace();
86
                }
87
            }
88
            return st.nextToken();
89
        }
90
        91
        int nextInt() {
92
            return Integer.parseInt(next());
93
        }
94
        95
        long nextLong() {
96
            return Long.parseLong(next());
97
        }
98
    }
99
}",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056134
1390056137,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056137
1390056130,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
#include <ext/pb_ds/assoc_container.hpp>
3
#include <ext/pb_ds/tree_policy.hpp>
4
#include <ext/pb_ds/detail/standard_policies.hpp>
5
#include <cmath>
6
#define int long long int
7
#define pb push_back
8
/*---------------------------------------------------------------------------------------------------------------------------------*/
9
/*ASCII small case-> a-97 to z-122
10
upper case-> A-65 to Z-90*/
11
#define nl ""\n""
12
#define mp map<int, int>
13
#define all(v) v.begin(), v.end()
14
#define F first
15
#define S second
16
#define ump unordered_map<long long, int, custom_hash>
17
#define mstpi multiset<pair<int, int> >
18
#define mst multiset<int>
19
#define vec vector<int>
20
#define pi pair<int, int>
21
#define ld long double
22
#define vep vector<pair<int, int>>
23
#define ul unsigned long long
24
#define loop1 for (int i = 0; i < n; i++)
25
#define REP(i, a, b) for (int i = a; i <= b; i++)
26
#define NO cout << ""NO"" << endl
27
#define YES cout << ""YES"" << endl
28
using namespace std;
29
using namespace __gnu_pbds;
30
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
31
/*---------------------------------------------------------------------------------------------------------------------------------*/
32
const double PI = 3.1415926535;
33
const int inf = 1e18;
34
const int mod = 1000000007;
35
/*---------------------------------------------------------------------------------------------------------------------------------*/
36
int modmul(int a, int b, int m)
37
{
38
    a %= m;
39
    b %= m;
40
    return (a * b) % m;
41
}
42
int modexp(int n, int x)
43
{
44
    int ans = 1;
45
    while (n > 0)
46
    {
47
        if (n & 1)
48
        {
49
            ans = (ans * x) % mod;
50
        }
51
        n >>= 1;
52
        x = (x * x) % mod;
53
    }
54
    return ans;
55
}
56
/*---------------------------------------------------------------------------------------------------------------------------------*/
57
string add(string a, string b)
58
{
59
    string ans = """";
60
    int carry = 0;
61
    while (!a.empty() || !b.empty() || carry > 0)
62
    {
63
        int digitA = a.empty() ? 0 : a.back() - '0';
64
        int digitB = b.empty() ? 0 : b.back() - '0';
65
        int sum = digitA + digitB + carry;
66
        ans = to_string(sum % 10) + ans;
67
        carry = sum / 10;
68
        if (!a.empty())
69
            a.pop_back();
70
        if (!b.empty())
71
            b.pop_back();
72
    }
73
    return ans;
74
}
75
string ministrnum(string a, string b)
76
{
77
    if (a.length() > b.length())
78
        return b;
79
    else if (b.length() > a.length())
80
        return a;
81
    else
82
    {
83
        int n = a.length();
84
        for (int i = 0; i < n; i++)
85
        {
86
            if (a[i] > b[i])
87
                return b;
88
            else if (a[i] < b[i])
89
                return a;
90
        }
91
    }
92
    return a;
93
}
94
vector<int> sieve(int n) {
95
    vector<bool> isPrime(n + 1, true);
96
    vector<int> primes;
97
    if(n >= 0) isPrime[0] = false;
98
    if(n >= 1) isPrime[1] = false;
99
    for (int i = 2; i <= n; i++) {
100
        if (isPrime[i]) {
101
            primes.push_back(i);
102
            for (int j = 2 * i; j <= n; j += i)
103
                isPrime[j] = false;
104
        }
105
    }
106
    return primes;
107
}
108
109
class SegmentTree {
110
public:
111
    int n;
112
    std::vector<int> tree;
113
    std::vector<int> lazy;
114
    115
    SegmentTree(const std::vector<int>& arr) {
116
        n = arr.size();
117
        tree.resize(4 * n, 0);
118
        lazy.resize(4 * n, 0);
119
        build(arr, 0, n - 1, 0);
120
    }
121
    122
    void build(const std::vector<int>& arr, int start, int end, int index) {
123
        if (start == end) {
124
            tree[index] = arr[start];
125
            return;
126
        }
127
        int mid = (start + end) / 2;
128
        build(arr, start, mid, 2 * index + 1);
129
        build(arr, mid + 1, end, 2 * index + 2);
130
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
131
    }
132
    133
    int queryRange(int start, int end, int l, int r, int index = 0) {
134
        if (lazy[index] != 0) {
135
            tree[index] += (end - start + 1) * lazy[index];
136
            if(start != end) {
137
                lazy[2 * index + 1] += lazy[index];
138
                lazy[2 * index + 2] += lazy[index];
139
            }
140
            lazy[index] = 0;
141
        }
142
        if (start > r || end < l)
143
            return 0;
144
        if (start >= l && end <= r)
145
            return tree[index];
146
        int mid = (start + end) / 2;
147
        return queryRange(start, mid, l, r, 2 * index + 1) +
148
               queryRange(mid + 1, end, l, r, 2 * index + 2);
149
    }
150
    151
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
152
        if(lazy[index] != 0) {
153
            tree[index] += (end - start + 1) * lazy[index];
154
            if(start != end) {
155
                lazy[2 * index + 1] += lazy[index];
156
                lazy[2 * index + 2] += lazy[index];
157
            }
158
            lazy[index] = 0;
159
        }
160
        if(start > r || end < l)
161
            return;
162
        if(start >= l && end <= r) {
163
            tree[index] += (end - start + 1) * diff;
164
            if(start != end) {
165
                lazy[2 * index + 1] += diff;
166
                lazy[2 * index + 2] += diff;
167
            }
168
            return;
169
        }
170
        int mid = (start + end) / 2;
171
        updateRange(start, mid, l, r, diff, 2 * index + 1);
172
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
173
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
174
    }
175
};
176
class DSU {
177
public:
178
    std::vector<int> parent, rank;
179
    180
    DSU(int n) {
181
        parent.resize(n);
182
        rank.resize(n, 0);
183
        for (int i = 0; i < n; i++)
184
            parent[i] = i;
185
    }
186
    187
    int find(int x) {
188
        if (parent[x] != x)
189
            parent[x] = find(parent[x]);
190
        return parent[x];
191
    }
192
    193
    bool unionSets(int x, int y) {
194
        int rootX = find(x);
195
        int rootY = find(y);
196
        if (rootX == rootY)
197
            return false;
198
        if (rank[rootX] < rank[rootY])
199
            parent[rootX] = rootY;
200
        else if (rank[rootX] > rank[rootY])
201
            parent[rootY] = rootX;
202
        else {
203
            parent[rootY] = rootX;
204
            rank[rootX]++;
205
        }
206
        return true;
207
    }
208
};
209
210
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
211
struct Node {
212
    int val;
213
    int weight, size;
214
    Node *left, *right;
215
    bool rev = false;
216
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
217
};
218
ostream &operator<<(ostream &os, Node *n) {
219
    if(!n) return os;
220
    os << n -> left;
221
    os << n -> val;
222
    os << n -> right;
223
    return os;
224
}
225
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
226
void push(Node* Treap) {
227
    if(!Treap) return;
228
    if(Treap -> rev) {
229
        Treap -> rev = false;
230
        swap(Treap->left, Treap->right);
231
        if(Treap -> left) Treap->left->rev ^= true;
232
        if(Treap -> right) Treap->right->rev ^= true;
233
    }
234
}
235
void pull(Node *Treap) {
236
    if(!Treap) return;
237
    push(Treap -> left), push(Treap -> right);
238
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
239
    return;
240
}
241
void split(Node *Treap, Node *&left, Node *&right, int val) {
242
    if(!Treap) {
243
        left = right = NULL;
244
        return;
245
    }
246
    push(Treap);
247
    if(size(Treap -> left) < val) {
248
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
249
        left = Treap;
250
    }
251
    else {
252
        split(Treap -> left, left, Treap -> left, val);
253
        right = Treap;
254
    }
255
    pull(Treap);
256
}
257
void merge(Node *&Treap, Node *left, Node *right) {
258
    push(left), push(right);
259
    if(left == NULL) {
260
        Treap = right;
261
        return;
262
    }
263
    if(right == NULL) {
264
        Treap = left;
265
        return;
266
    }
267
    if(left -> weight < right -> weight) {
268
        merge(right -> left, left, right -> left);
269
        Treap = right;
270
    }
271
    else {
272
        merge(left->right, left->right, right);
273
        Treap = left;
274
    }
275
    pull(Treap);
276
}
277
void inOrder(Node *curr, vector<int> &res) {
278
    if(curr == NULL) return;
279
    push(curr);
280
    inOrder(curr->left, res);
281
    res.pb(curr->val);
282
    inOrder(curr->right, res);
283
    pull(curr);
284
}
285
struct Treap {
286
    Node *root = nullptr;
287
    void insert(int i, int val) {
288
        Node *l, *r;
289
        split(root, l, r, i);
290
        Node *v = new Node(val);
291
        merge(l, l, v);
292
        merge(root, l, r);
293
    }
294
    295
    void del(int i) {
296
        Node *l, *r;
297
        split(root, l, r, i);
298
        split(r, root, r, 1);
299
        merge(root, l, r);
300
    }
301
    302
    void update(int l, int r, function<void(Node *)> f) {
303
        Node *a, *b, *c;
304
        split(root, a, b, l-1);
305
        split(b, b, c, r-l+1);
306
        if(b) {f(b);}
307
        merge(root, a, b);
308
        merge(root, root, c);
309
    }
310
    311
    vector<int> allPr() {
312
        vector<int> res;
313
        inOrder(root, res);
314
        return res;
315
    }
316
    317
    void cycShft(int l, int r) {
318
        Node *a, *b, *c, *d;
319
        split(root, a, b, l-1);
320
        split(b, b, c, r-l+1);
321
        split(b, b, d, r-l);
322
        merge(root, a, d);
323
        merge(root, root, b);
324
        merge(root, root, c);
325
    }
326
};
327
vector<int> computePrefix(const string &pattern) {
328
    int n = pattern.size();
329
    vector<int> prefix(n, 0);
330
    for (int i = 1, j = 0; i < n; i++) {
331
        while (j > 0 && pattern[i] != pattern[j])
332
            j = prefix[j - 1];
333
        if (pattern[i] == pattern[j])
334
            j++;
335
        prefix[i] = j;
336
    }
337
    return prefix;
338
}
339
340
vector<int> KMPSearch(const string &text, const string &pattern) {
341
    vector<int> prefix = computePrefix(pattern);
342
    vector<int> occurrences;
343
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
344
        while (j > 0 && text[i] != pattern[j])
345
            j = prefix[j - 1];
346
        if (text[i] == pattern[j])
347
            j++;
348
        if (j == (int)pattern.size()) {
349
            occurrences.push_back(i - j + 1);
350
            j = prefix[j - 1];
351
        }
352
    }
353
    return occurrences;
354
}
355
void solve()
356
{
357
    int n, k;
358
    cin>>n>>k;
359
    360
    vector<int> v(n);
361
    loop1 cin>>v[i];
362
    363
    queue<int> st;
364
    for(int i = 0; i<n; i++) {
365
        if(v[i] < 0) {
366
             st.push(i);
367
        }
368
        369
        if(i >= k-1) {
370
            if(st.empty()) cout<<0<<"" "";
371
            else cout<<v[st.front()]<<"" "";
372
            if(!st.empty() && st.front() <= i - k + 1)
373
            st.pop();
374
        }
375
    }
376
    cout<<endl;
377
}
378
int32_t main()
379
{
380
    ios_base ::sync_with_stdio(0);
381
    cin.tie(0);
382
    cout.tie(0);
383
    int t = 1;
384
    cin >> t;
385
    while (t--)
386
        solve();
387
}",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056130
1390056131,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    dp[0][0] = 0
7
8
    for i in range(1, n + 1):
9
        for j in range(k + 1):
10
            if j > 0:
11
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])  # Skip
12
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j)  # Don't skip
13
14
    return min(dp[n])
15
16
t = int(input())
17
for _ in range(t):
18
    print(solve())",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056131
1390056132,unknown,unknown,unknown,"1
def min_server_decommissioning_cost():
2
    T = int(input())
3
    for _ in range(T):
4
        servers = input().strip()
5
        n = len(servers)
6
7
        total_zeros = servers.count('0')
8
        total_ones = servers.count('1')
9
        min_cost = float('inf')
10
11
        # Try all possible prefixes to remove from front (0 to n)
12
        for l in range(n + 1):
13
            # Try all possible suffixes to remove from end (0 to n - l)
14
            for r in range(n - l + 1):
15
                remaining = servers[l:n - r]
16
17
                remaining_zeros = remaining.count('0')
18
                removed_ones = servers[:l].count('1') + servers[n - r:].count('1')
19
20
                cost = max(remaining_zeros, removed_ones)
21
                min_cost = min(min_cost, cost)
22
23
        print(min_cost)
24",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056132
1390056121,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} ",7,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056121
1390056115,unknown,unknown,unknown,"1
def min_cost(s):
2
    total_ones = s.count('1')
3
    n = len(s)
4
    5
    scenario_empty = total_ones  # Cost when removing all '1's
6
    7
    # Scenario 1: Window lengths 1 to min(total_ones, n)
8
    scenario1_cost = float('inf')
9
    if total_ones == 0:
10
        scenario1_cost = 0  # If all are '0's, best is to remove all
11
    else:
12
        max_ones = 0
13
        L = min(total_ones, n)
14
        current_ones = sum(1 for c in s[:L] if c == '1')  # Initial window count
15
        16
        max_ones = current_ones  # First window
17
        for i in range(1, n - L + 1):
18
            current_ones -= (s[i-1] == '1')
19
            current_ones += (s[i + L - 1] == '1')
20
            max_ones = max(max_ones, current_ones)  # Keep track of max found
21
        22
        scenario1_cost = total_ones - max_ones  # Cost of transforming scenario 1
23
    24
    # Scenario 2: Window lengths > total_ones
25
    scenario2_cost = float('inf')
26
    if n > total_ones:
27
        min_zeros = float('inf')
28
        current_zeros = sum(1 for c in s[:total_ones + 1] if c == '0')  # Initial window count
29
        30
        min_zeros = current_zeros  # First window
31
        for i in range(1, n - (total_ones + 1) + 1):
32
            current_zeros -= (s[i-1] == '0')
33
            current_zeros += (s[i + total_ones] == '0')
34
            min_zeros = min(min_zeros, current_zeros)  # Keep track of min found
35
        36
        scenario2_cost = min_zeros  # Cost of transforming scenario 2
37
    38
    # Choose the best (minimum cost) option
39
    candidates = [scenario1_cost, scenario_empty]
40
    if n > total_ones:
41
        candidates.append(scenario2_cost)
42
    43
    return min(candidates)
44
45
# Read number of test cases
46
T = int(input())
47
for _ in range(T):
48
    s = input().strip()
49
    print(min_cost(s))
50",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056115
1390056118,unknown,unknown,unknown,"1
2
t = int(input())
3
for _ in range(t):
4
    s = input()
5
    n = len(s)
6
    min_cost = float('inf')
7
8
    for i in range(n + 1):
9
        for j in range(i, n + 1):
10
            sub = s[i:j]
11
12
            if not sub:
13
                remaining_zeros = 0
14
                removed_ones = s.count('1')
15
16
            else:
17
                remaining_zeros = sub.count('0')
18
                removed_ones = s.count('1') - sub.count('1')
19
20
            cost = max(remaining_zeros, removed_ones)
21
            min_cost = min(min_cost, cost)
22
23
    print(min_cost)
24
25",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056118
1390056120,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056120
1390056101,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
    results = []
10
    11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Compute impact: (strength + index, index)
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Get top k elements based on impact
24
        impact.sort(reverse=True)
25
        to_skip = {idx for _, idx in impact[:k]}  # Convert to set for quick lookup
26
        27
        # Compute minimum effort
28
        effort, skipped = 0, 0
29
        for i in range(n):
30
            if i in to_skip:
31
                skipped += 1
32
            else:
33
                effort += strengths[i] + skipped
34
        35
        results.append(str(effort))
36
    37
    # Fast output
38
    sys.stdout.write(""\n"".join(results) + ""\n"")
39
40
if __name__ == ""__main__"":
41
    main()
42",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056101
1390056103,unknown,unknown,unknown,"1
import sys
2
def solve():
3
    x = sys.stdin.buffer.read().split()
4
    if not x: return
5
    t = int(x[0])
6
    i = 1
7
    o = []
8
    for _ in range(t):
9
        s = x[i].decode()
10
        i += 1
11
        n = len(s)
12
        A = [0]*(n+1)
13
        B = [0]*(n+1)
14
        for j in range(n):
15
            B[j+1] = B[j] + (s[j]=='1')
16
            A[j+1] = A[j] + (s[j]=='0')
17
        T = A[n]
18
        C = [0]*(n+1)
19
        E = [0]*(n+1)
20
        for j in range(n):
21
            E[j+1] = E[j] + (s[n-1-j]=='1')
22
            C[j+1] = C[j] + (s[n-1-j]=='0')
23
        r = 10**9
24
        for x_ in range(n+1):
25
            m = n - x_
26
            y = T - A[x_] - B[x_]
27
            if y < 0: y = 0
28
            if y > m: y = m
29
            for z in (y, y-1, y+1):
30
                if z < 0 or z > m: continue
31
                v1 = B[x_] + E[z]
32
                v2 = T - (A[x_] + C[z])
33
                v = v1 if v1 >= v2 else v2
34
                if v < r: r = v
35
        o.append(str(r))
36
    sys.stdout.write(""\n"".join(o))
37
if __name__==""__main__"":
38
    solve()
39
40
41",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056103
1390056111,unknown,unknown,unknown,"1
import java.util.*;
2
import java.io.*;
3
4
public class FirewallSkips {
5
    public static void main(String[] args) {
6
        FastReader in = new FastReader(System.in);
7
        int T = in.nextInt();
8
        9
        while (T-- > 0) {
10
            int n = in.nextInt();
11
            int k = in.nextInt();
12
            13
            long[] a = new long[n];
14
            long sumA = 0; // sum of all a[i]
15
            for (int i = 0; i < n; i++) {
16
                a[i] = in.nextLong();
17
                sumA += a[i];
18
            }
19
            20
            // Build array b[i] = a[i] + (i+1)  [using 1-based index for j]
21
            // We'll sort b in descending order to pick the top x.
22
            long[] b = new long[n];
23
            for (int i = 0; i < n; i++) {
24
                b[i] = a[i] + (i + 1);
25
            }
26
            27
            Arrays.sort(b);
28
            // Sort ascending by default; we want descending, so either:
29
            // 1) reverse in place, or
30
            // 2) build prefix sums from the end.
31
            // Let's just reverse in place for clarity.
32
            reverse(b); // Now b is descending.
33
            34
            // Build prefix sums of b in descending order:
35
            // p[x] = sum of top x elements in b (b[0] + b[1] + ... + b[x-1])
36
            long[] prefix = new long[n+1];
37
            prefix[0] = 0;
38
            for (int x = 1; x <= n; x++) {
39
                prefix[x] = prefix[x-1] + b[x-1];
40
            }
41
            42
            long ans = Long.MAX_VALUE;
43
            // Try x from 0..k (number of skips)
44
            for (int x = 0; x <= k; x++) {
45
                // cost(x) = sumA + x*n - prefix[x] - x*(x-1)/2
46
                // Make sure to use long to avoid overflow
47
                long cost = sumA 
48
                            + x * (long)n 
49
                            - prefix[x]
50
                            - ((long)x * (x - 1) / 2);
51
                ans = Math.min(ans, cost);
52
            }
53
            54
            System.out.println(ans);
55
        }
56
    }
57
    58
    // Utility to reverse array in place
59
    private static void reverse(long[] arr) {
60
        int left = 0, right = arr.length - 1;
61
        while (left < right) {
62
            long tmp = arr[left];
63
            arr[left] = arr[right];
64
            arr[right] = tmp;
65
            left++;
66
            right--;
67
        }
68
    }
69
    70
    // Fast input class (optional, for large I/O)
71
    static class FastReader {
72
        BufferedReader br;
73
        StringTokenizer st;
74
        75
        public FastReader(InputStream stream) {
76
            br = new BufferedReader(new InputStreamReader(stream));
77
        }
78
        79
        String next() {
80
            while (st == null || !st.hasMoreElements()) {
81
                try {
82
                    st = new StringTokenizer(br.readLine());
83
                } catch (IOException e) {
84
                    e.printStackTrace();
85
                }
86
            }
87
            return st.nextToken();
88
        }
89
        90
        int nextInt() {
91
            return Integer.parseInt(next());
92
        }
93
        94
        long nextLong() {
95
            return Long.parseLong(next());
96
        }
97
    }
98
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056111
1390056095,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056095
1390056098,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056098
1390056094,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056094
1390056090,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class BreachFirewall {
5
    public static void main(String[] args) throws IOException {
6
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
7
        int T = Integer.parseInt(br.readLine()); // Number of test cases
8
        StringBuilder result = new StringBuilder();
9
10
        while (T-- > 0) {
11
            StringTokenizer st = new StringTokenizer(br.readLine());
12
            int n = Integer.parseInt(st.nextToken());
13
            int k = Integer.parseInt(st.nextToken());
14
15
            int[] firewalls = new int[n];
16
            st = new StringTokenizer(br.readLine());
17
            int totalEffort = 0;
18
19
            for (int i = 0; i < n; i++) {
20
                firewalls[i] = Integer.parseInt(st.nextToken());
21
                totalEffort += firewalls[i]; // Calculate total sum
22
            }
23
24
            List<Integer> modifiedValues = new ArrayList<>();
25
            for (int i = 0; i < n; i++) {
26
                modifiedValues.add(firewalls[i] - (n - i - 1)); // Transform array
27
            }
28
29
            // Sort in descending order
30
            modifiedValues.sort(Collections.reverseOrder());
31
32
            // Prefix sum calculation with boundary checks
33
            int[] prefixSum = new int[n + 1];
34
            for (int i = 0; i < n; i++) {
35
                prefixSum[i + 1] = prefixSum[i] + modifiedValues.get(i);
36
            }
37
38
            // Finding the maximum sum with `t` firewall skips
39
            int maxSum = 0;
40
            int maxT = Math.min(k, n);
41
42
            for (int t = 0; t <= maxT; t++) {
43
                int current = prefixSum[t] + (t * (t - 1)) / 2;
44
                maxSum = Math.max(maxSum, current);
45
            }
46
47
            // Output the minimized firewall breach effort
48
            result.append(totalEffort - maxSum).append(""\n"");
49
        }
50
51
        System.out.print(result);
52
    }
53
}
54",8,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056090
1390056082,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <climits>
4
#include <algorithm>
5
6
using namespace std;
7
8
using ll = long long;
9
10
ll min_effort(int n, int k, const vector<int>& firewalls) {
11
    if (n == 0) return 0;
12
    13
    // Maximum useful skips is min(k, n)
14
    int max_skips = min(k, n);
15
    vector<vector<ll>> dp(n + 1, vector<ll>(max_skips + 1, LLONG_MAX));
16
    dp[0][0] = 0;
17
    18
    for (int i = 1; i <= n; ++i) {
19
        for (int j = 0; j <= max_skips; ++j) {
20
            // Case 1: Do not skip the i-th firewall
21
            if (dp[i-1][j] != LLONG_MAX) {
22
                dp[i][j] = dp[i-1][j] + firewalls[i-1] + j;
23
            }
24
            // Case 2: Skip the i-th firewall if possible
25
            if (j > 0) {
26
                if (dp[i-1][j-1] != LLONG_MAX) {
27
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
28
                }
29
            }
30
        }
31
    }
32
    33
    return *min_element(dp[n].begin(), dp[n].end());
34
}
35
36
int main() {
37
    ios_base::sync_with_stdio(false);
38
    cin.tie(nullptr);
39
    40
    int T;
41
    cin >> T;
42
    43
    while (T--) {
44
        int n, k;
45
        cin >> n >> k;
46
        47
        vector<int> firewalls(n);
48
        for (int i = 0; i < n; ++i) {
49
            cin >> firewalls[i];
50
        }
51
        52
        cout << min_effort(n, k, firewalls) << '\n';
53
    }
54
    55
    return 0;
56
}
57",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056082
1390056084,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
3
    results = []
4
5
    for s in test_cases:
6
7
        n = len(s)
8
9
        # Precompute prefix counts of '1's
10
11
        prefix_ones = [0] * (n + 1)
12
13
        for i in range(n):
14
15
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
16
17
        18
19
        # Precompute suffix counts of '1's
20
21
        suffix_ones = [0] * (n + 1)
22
23
        for i in range(n - 1, -1, -1):
24
25
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
26
27
        28
29
        # Precompute the number of '0's in the entire string
30
31
        total_zeros = s.count('0')
32
33
        34
35
        min_cost_val = float('inf')
36
37
        38
39
        # Iterate over all possible left decommissioning points
40
41
        for left in range(n + 1):
42
43
            # Calculate the number of '1's removed from the left
44
45
            ones_removed_left = prefix_ones[left]
46
47
            48
49
            # Calculate the remaining '0's in the middle
50
51
            # Total '0's minus the '0's removed from the left and right
52
53
            # Since we are iterating over left, we need to find the right decommissioning point
54
55
            # that minimizes the cost
56
57
            # We can use binary search to find the optimal right decommissioning point
58
59
            low = 0
60
61
            high = n - left
62
63
            best_right = 0
64
65
            best_cost = float('inf')
66
67
            68
69
            while low <= high:
70
71
                mid = (low + high) // 2
72
73
                right = mid
74
75
                ones_removed_right = suffix_ones[n - right]
76
77
                total_ones_removed = ones_removed_left + ones_removed_right
78
79
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
80
81
                current_cost = max(zeros_remaining, total_ones_removed)
82
83
                84
85
                if current_cost < best_cost:
86
87
                    best_cost = current_cost
88
89
                    best_right = right
90
91
                92
93
                if zeros_remaining > total_ones_removed:
94
95
                    low = mid + 1
96
97
                else:
98
99
                    high = mid - 1
100
101
            102
103
            if best_cost < min_cost_val:
104
105
                min_cost_val = best_cost
106
107
        108
109
        results.append(min_cost_val)
110
111
    return results
112
113
# Read input
114
115
T = int(input())
116
117
test_cases = [input().strip() for _ in range(T)]
118
119
# Compute results
120
121
results = min_cost(test_cases)
122
123
# Output results
124
125
for res in results:
126
127
    print(res)",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056084
1390056086,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
9
int main() {
10
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
11
    return 0;
12
}
13",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056086
1390056070,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
5
typedef struct {
6
    long long strength;
7
    int index;
8
} Firewall;
9
10
11
int compare(const void* a, const void* b) {
12
    Firewall* fw1 = (Firewall*)a;
13
    Firewall* fw2 = (Firewall*)b;
14
    15
    if (fw1->strength > fw2->strength) return -1;
16
    if (fw1->strength < fw2->strength) return 1;
17
    return 0;
18
}
19
20
int main() {
21
    int t;
22
    scanf(""%d"", &t);
23
    24
    while (t--) {
25
        int n, k;
26
        scanf(""%d %d"", &n, &k);
27
        28
        long long* strengths = (long long*)malloc(n * sizeof(long long));
29
        Firewall* firewalls = (Firewall*)malloc(n * sizeof(Firewall));
30
        31
      32
        for (int i = 0; i < n; i++) {
33
            scanf(""%lld"", &strengths[i]);
34
            firewalls[i].strength = strengths[i];
35
            firewalls[i].index = i;
36
        }
37
        38
       39
        qsort(firewalls, n, sizeof(Firewall), compare);
40
        41
        42
        int* skip = (int*)calloc(n, sizeof(int));
43
        int skipped = 0;
44
        45
        for (int i = 0; i < n && skipped < k; i++) {
46
            skip[firewalls[i].index] = 1;
47
            skipped++;
48
        }
49
        50
      51
        long long totalEffort = 0;
52
        int penalty = 0;
53
        54
        for (int i = 0; i < n; i++) {
55
            if (skip[i]) {
56
           57
                penalty++;
58
            } else {
59
               60
                totalEffort += strengths[i] + penalty;
61
            }
62
        }
63
        64
        printf(""%lld\n"", totalEffort);
65
        66
        67
        free(strengths);
68
        free(firewalls);
69
        free(skip);
70
    }
71
    72
    return 0;
73
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056070
1390056077,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
       21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
       24
        impact.sort(reverse=True)
25
        26
        27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
       30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
   42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056077
1390056078,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056078
1390056061,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
      Scanner scanner = new Scanner(System.in);
8
        int t = scanner.nextInt(); 
9
10
        while (t-- > 0) {
11
            int n = scanner.nextInt(); 
12
            int k = scanner.nextInt(); 
13
            int[] arr = new int[n];
14
15
            for (int i = 0; i < n; i++) {
16
                arr[i] = scanner.nextInt();
17
            }
18
19
            int ans = findResult(arr, k);
20
21
            System.out.print(ans);
22
           23
            System.out.println();
24
        }
25
        scanner.close();
26
    }
27
    public static int findResult(int []arr, int k){
28
        int[] ans= new int[arr.length];
29
        int sum=0;
30
        for(int i =0;i<arr.length;i++){
31
            ans[i]=arr[i]-((arr.length-1)-i);
32
            sum+=arr[i];
33
        }
34
        Arrays.sort(ans);
35
        reverse(ans);
36
        for(int i =0;i<k;i++){
37
            if(ans[i]>0){
38
               // System.out.println(ans[i]+""w"");
39
                sum-=ans[i];
40
            }
41
        }
42
        43
        return Math.max(sum,0);
44
        45
    }
46
     private static void reverse(int[] arr) {
47
        int left = 0, right = arr.length - 1;
48
        while (left < right) {
49
            int temp = arr[left];
50
            arr[left] = arr[right];
51
            arr[right] = temp;
52
            left++;
53
            right--;
54
        }
55
    }
56
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056061
1390056067,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056067
1390056069,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056069
1390056060,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <bits/stdc++.h>
7
using namespace std;
8
9
int solve(vector<int>&arr, int i, int skip, int inc,vector<vector<long long>>&dp) {
10
    int n = arr.size();
11
    if(i==n){
12
        return 0;
13
    }
14
    if(dp[i][skip]!=-1)return dp[i][skip];
15
    //skip
16
    int ans = INT_MAX;
17
    if(skip>0) {
18
        ans = min(ans,solve(arr,i+1,skip-1,inc+1,dp));
19
    }
20
    //no skip
21
    int recAns = solve(arr,i+1,skip,inc,dp);
22
    if(recAns!=INT_MAX)
23
        ans = min(ans,arr[i]+inc+recAns);
24
    return dp[i][skip]= ans;
25
}
26
27
28
int main() {
29
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
30
    int t;
31
    cin>>t;
32
    while(t--) {
33
        int n,skip;
34
        cin>>n>>skip;
35
        vector<int>arr;
36
        vector<vector<long long>>dp(n,vector<long long>(skip+1,-1));
37
        while(n--) {
38
            int a;
39
            cin>>a;
40
            arr.push_back(a);
41
        }
42
        cout<<solve(arr,0,skip,0,dp)<<endl;
43
    }
44
    return 0;
45
}",9,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056060
1390056053,unknown,unknown,unknown,"1
def mn_cst(tst):
2
    rst=[]
3
    for s in tst:
4
        n = len(s)
5
        mc = float('inf')
6
        ta = s.count('1')
7
        ti=s.count('0')
8
        la=0
9
        li=0
10
        11
        for i in range(n + 1):
12
            ra = la
13
            ri = li
14
            ri_rem = ti - ri
15
            ra_rem = ta - ra
16
            cst = max(ri_rem,ra)
17
            mc=min(mc,cst)
18
            if i<n:
19
                if s[i] == '1':
20
                    la += 1
21
                else:
22
                    li += 1
23
        rst.append(mc)
24
    return rst
25",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056053
1390056056,unknown,unknown,unknown,"1
import sys
2
def solve():
3
    x = sys.stdin.buffer.read().split()
4
    if not x: return
5
    t = int(x[0])
6
    i = 1
7
    o = []
8
    for _ in range(t):
9
        s = x[i].decode()
10
        i += 1
11
        n = len(s)
12
        A = [0]*(n+1)
13
        B = [0]*(n+1)
14
        for j in range(n):
15
            B[j+1] = B[j] + (s[j]=='1')
16
            A[j+1] = A[j] + (s[j]=='0')
17
        T = A[n]
18
        C = [0]*(n+1)
19
        E = [0]*(n+1)
20
        for j in range(n):
21
            E[j+1] = E[j] + (s[n-1-j]=='1')
22
            C[j+1] = C[j] + (s[n-1-j]=='0')
23
        r = 10**9
24
        for x_ in range(n+1):
25
            m = n - x_
26
            y = T - A[x_] - B[x_]
27
            if y < 0: y = 0
28
            if y > m: y = m
29
            for z in (y, y-1, y+1):
30
                if z < 0 or z > m: continue
31
                v1 = B[x_] + E[z]
32
                v2 = T - (A[x_] + C[z])
33
                v = v1 if v1 >= v2 else v2
34
                if v < r: r = v
35
        o.append(str(r))
36
    sys.stdout.write(""\n"".join(o))
37
if __name__==""__main__"":
38
    solve()",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056056
1390056059,unknown,unknown,unknown,"1
def earliest_faulty_readings(arr, k):
2
    n = len(arr)
3
    result = []
4
    dq = dequeue()
5
    6
    for i in range(n):
7
        if dq and dq[0] < i - k + 1:
8
            dq.popleft()
9
            10
        if arr[i] < 0:
11
            dq.append(i)
12
            if i >= k - 1:
13
                result.append(arr[dq[0]] if dq else 0)
14
                return result
15
            16
if __name__ == ""__main__"":
17
    t = int(input().strip())
18
    for _ in range(t):
19
        n, k = map(int, input().strip())",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056059
1390056048,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    dp[0][0] = 0
7
8
    for i in range(1, n + 1):
9
        for j in range(k + 1):
10
            if j > 0:
11
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])  # Skip
12
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j)  # Don't skip
13
14
    return min(dp[n])
15
16
t = int(input())
17
for _ in range(t):
18
    print(solve())",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056048
1390056049,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <climits>
4
#include <algorithm>
5
6
using namespace std;
7
8
int main() {
9
    int t;
10
    cin >> t;
11
    while (t--) {
12
        int n, k;
13
        cin >> n >> k;
14
        vector<int> a(n);
15
        for (int i = 0; i < n; ++i) {
16
            cin >> a[i];
17
        }
18
19
        vector<vector<long long>> dp(n + 1, vector<long long>(k + 1, LLONG_MAX));
20
        dp[0][0] = 0;
21
22
        for (int i = 1; i <= n; ++i) {
23
            for (int j = 0; j <= k; ++j) {
24
               25
                if (dp[i - 1][j] != LLONG_MAX) {
26
                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j);
27
                }
28
                29
                if (j > 0 && dp[i - 1][j - 1] != LLONG_MAX) {
30
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]);
31
                }
32
            }
33
        }
34
35
        cout << dp[n][k] << endl;
36
    }
37
    return 0;
38
}
39",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056049
1390056050,unknown,unknown,unknown,"1
def min_effort_to_breach_firewalls(t, test_cases):
2
    results = []
3
4
    for test in test_cases:
5
        n, k = test[0]
6
        arr = test[1]
7
8
        # Sort firewall strengths in descending order
9
        arr_sorted = sorted(arr, reverse=True)
10
11
        # Choose top k strong firewalls to skip
12
        skips = set()
13
        for i in range(k):
14
            skips.add(arr_sorted[i])
15
16
        total_effort = 0
17
        skipped = 0
18
19
        for strength in arr:
20
            if strength in skips and skipped < k:
21
                skipped += 1
22
                skips.remove(strength)  # Remove to handle duplicates properly
23
            else:
24
                total_effort += strength + skipped  # Each skip adds +1 to every subsequent effort
25
26
        results.append(total_effort)
27
28
    return results
29
30
31
# -------- DRIVER CODE --------
32
T = int(input())
33
test_cases = []
34
35
for _ in range(T):
36
    n, k = map(int, input().split())
37
    arr = list(map(int, input().split()))
38
    test_cases.append(((n, k), arr))
39
40
answers = min_effort_to_breach_firewalls(T, test_cases)
41
42
for ans in answers:
43
    print(ans)",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056050
1390056041,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        first_one = s.find('1')
5
        last_one = s.rfind('1')
6
        7
        if first_one == -1:
8
            results.append(0)  # All are '0's, no cost required
9
            continue
10
        11
        idle_count = s[first_one:last_one+1].count('0')
12
        removed_active = first_one + (len(s) - last_one - 1)
13
        14
        results.append(max(idle_count, removed_active))
15
    16
    return results
17
18
# Reading input
19
T = int(input().strip())
20
test_cases = [input().strip() for _ in range(T)]
21
22
# Processing and printing output
23
for res in min_decommission_cost(test_cases):
24
    print(res)
25
26",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056041
1390056042,unknown,unknown,unknown,"1
def earliest_faults(arr, k):
2
    result = []
3
    first_fault = 0  # Default if no faults in batch
4
5
    for i in range(len(arr) - k + 1):  # Iterate through batches
6
        batch = arr[i:i + k]
7
        first_fault = 0  # Reset for each batch
8
        9
        for num in batch:  # Find first faulty reading
10
            if num < 0:
11
                first_fault = num
12
                break
13
        14
        result.append(first_fault)
15
16
    return result
17
18
19
# Reading input
20
t = int(input())  # Number of test cases
21
for _ in range(t):
22
    n, k = map(int, input().split())  # Size of array and batch size
23
    arr = list(map(int, input().split()))  # Sensor readings
24
    25
    # Get the result and print it
26
    print(*earliest_faults(arr, k))",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056042
1390056040,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} ",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056040
1390056039,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",10,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056039
1390056032,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    dp[0][0] = 0
7
8
    for i in range(1, n + 1):
9
        for j in range(k + 1):
10
            if j > 0:
11
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])  
12
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j) 
13
14
    return min(dp[n])
15
16
t = int(input())
17
for _ in range(t):
18
    print(solve())",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056032
1390056038,unknown,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n,k=map(int,input().split())
4
    arr=list(map(int,input().split()))
5
    if k<n:
6
        impacts=sorted([(arr[i]-(n-i-1),i) for i in range(n)],reverse=True)
7
        skip={impacts[i][1] for i in range(k)}
8
        ans=0
9
        penalty=0
10
        for i in range(n):
11
            if i in skip:penalty+=1
12
            else:ans+=arr[i]+penalty
13
        print(ans)
14
    else:print(0)",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056038
1390056030,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommission {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt();  // Number of test cases
7
        scanner.nextLine();         // Consume the leftover newline
8
9
        while (T-- > 0) {
10
            String servers = scanner.nextLine();
11
            int n = servers.length();
12
13
            // Build prefix sums for '0' and '1'
14
            // zeroCount[i] = # of '0's in servers[0..i-1]
15
            // oneCount[i]  = # of '1's in servers[0..i-1]
16
            int[] zeroCount = new int[n + 1];
17
            int[] oneCount  = new int[n + 1];
18
19
            for (int i = 0; i < n; i++) {
20
                zeroCount[i + 1] = zeroCount[i] + (servers.charAt(i) == '0' ? 1 : 0);
21
                oneCount[i + 1]  = oneCount[i]  + (servers.charAt(i) == '1' ? 1 : 0);
22
            }
23
24
            int totalOnes = oneCount[n];
25
26
            // Binary search over possible cost c
27
            int low = 0;
28
            int high = n;  // cost can't exceed n (worst case: remove all or keep all)
29
            while (low < high) {
30
                int mid = (low + high) / 2;
31
                if (feasible(mid, servers, zeroCount, oneCount, totalOnes)) {
32
                    high = mid;  // we can achieve cost <= mid
33
                } else {
34
                    low = mid + 1; // we cannot achieve cost mid, so increase
35
                }
36
            }
37
38
            System.out.println(low);
39
        }
40
41
        scanner.close();
42
    }
43
44
    /**
45
     * Checks if there exists a subarray [start, end) such that:
46
     *   #0 in subarray <= c
47
     *   #1 in subarray >= totalOnes - c
48
     */
49
    private static boolean feasible(int c, String servers,
50
                                   int[] zeroCount, int[] oneCount,
51
                                   int totalOnes) {
52
        int n = servers.length();
53
        int start = 0;
54
55
        for (int end = 0; end <= n; end++) {
56
            // Move start forward while #0 in [start, end) > c
57
            while (start < end && 
58
                   (zeroCount[end] - zeroCount[start]) > c) {
59
                start++;
60
            }
61
62
            // Now #0 in [start, end) <= c (unless start==end)
63
            int subarrayOnes = oneCount[end] - oneCount[start];
64
            // Check if #1 in subarray >= totalOnes - c
65
            if (subarrayOnes >= totalOnes - c) {
66
                return true;
67
            }
68
        }
69
70
        return false;
71
    }
72
}",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056030
1390056028,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
    left = 0
3
    zeros = 0
4
    max_ones = 0
5
    n = len(s)
6
7
    for right in range(n):
8
        if s[right] == '0':
9
            zeros += 1
10
11
        while zeros > k:
12
            if s[left] == '0':
13
                zeros -= 1
14
            left += 1
15
16
        current_ones = (right - left + 1) - zeros
17
        max_ones = max(max_ones, current_ones)
18
19
    return max_ones
20
21
22
def minimize_cost(t, test_cases):
23
    results = []
24
25
    for s in test_cases:
26
        n = len(s)
27
        total_ones = s.count('1')
28
29
        if total_ones == 0 or total_ones == n:
30
            results.append(0)
31
            continue
32
33
        total_zeros = n - total_ones
34
        low, high = 0, max(total_ones, total_zeros)
35
        answer = high
36
37
        while low <= high:
38
            mid = (low + high) // 2
39
            required_ones = max(0, total_ones - mid)
40
41
            if required_ones == 0:
42
                answer = mid
43
                high = mid - 1
44
                continue
45
46
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
47
48
            if max_ones >= required_ones:
49
                answer = mid
50
                high = mid - 1
51
            else:
52
                low = mid + 1
53
54
        results.append(answer)
55
56
    return results
57
58
59
if __name__ == ""__main__"":
60
    t = int(input())
61
    test_cases = [input().strip() for _ in range(t)]
62
63
    results = minimize_cost(t, test_cases)
64
65
    for res in results:
66
        print(res)",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056028
1390056022,unknown,unknown,unknown,"1
def minimum_effort(arr,k):
2
    n = len(arr)
3
    effort = 0
4
    5
    if k == n:
6
        return effort
7
    8
    skip=0
9
    10
    for i in range(n):
11
        if skip < k and arr[i] == max(arr):
12
            skip+=1
13
            arr[i]=0
14
            15
        else:
16
            effort += arr[i]+skip
17
            18
    return effort
19
20
t = int(input())
21
22
for _ in range(t):
23
    n,k= map(int , input().split())
24
    25
    arr = list(map(int , input().split()))
26
    27
    print(minimum_effort(arr,k))",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056022
1390056029,unknown,unknown,unknown,"1
def find_min_effort(n, k, strength):
2
    # dp[i][j] = minimum effort to process first i firewalls when j firewalls are skipped
3
    dp = [[float('inf') for _ in range(k + 1)] for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: no firewalls, no skips, no effort
5
    6
    for i in range(1, n + 1):
7
        for j in range(min(i, k) + 1):
8
            # Skip current firewall (if we can)
9
            if j > 0:
10
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
11
            12
            # Process current firewall
13
            # Calculate any penalty from skipped firewalls
14
            penalty = 0
15
            if i > 1 and j > 0:
16
                penalty = j  # Add 1 for each skipped firewall
17
            18
            dp[i][j] = min(dp[i][j], dp[i-1][j] + strength[i-1] + penalty)
19
    20
    # Find minimum across all possible numbers of skips
21
    result = min(dp[n])
22
    23
    return result
24
25
def main():
26
    t = int(input())  # Number of test cases
27
    28
    for _ in range(t):
29
        n, k = map(int, input().split())  # Number of firewalls and max skips
30
        strength = list(map(int, input().split()))  # Strength of each firewall
31
        32
        # Edge case: if k == n, we can skip all firewalls
33
        if k == n:
34
            print(0)
35
            continue
36
        37
        # Calculate minimum effort using dp
38
        print(find_min_effort(n, k, strength))
39
40
if __name__ == ""__main__"":
41
    main()",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056029
1390056012,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx+1])
10
        idx +=2
11
        a = list(map(int, input[idx:idx+n]))
12
        idx +=n
13
        sum_a = sum(a)
14
        v = []
15
        for i in range(n):
16
            val = a[i] - (n - i -1)
17
            v.append(val)
18
        v.sort(reverse=True)
19
        prefix = [0] * (n+1)
20
        for i in range(n):
21
            prefix[i+1] = prefix[i] + v[i]
22
        max_sum = 0
23
        max_t = min(k, n)
24
        for t in range(0, max_t+1):
25
            current = prefix[t] + t*(t-1)//2
26
            if current > max_sum:
27
                max_sum = current
28
        print(sum_a - max_sum)
29
30
if __name__ == ""__main__"":
31
    main()",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056012
1390056016,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if _name_ == ""_main_"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056016
1390056017,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056017
1390056011,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    if k == n:
4
        return 0  
5
    min_increase = min(firewalls) + 1  
6
    min_effort = total_effort  
7
    for i in range(n):
8
        effort = total_effort - firewalls[i] + min_increase
9
        min_effort = min(min_effort, effort)
10
    return min_effort
11
t = int(input())  
12
for _ in range(t):
13
    n, k = map(int, input().split())  
14
    firewalls = list(map(int, input().split()))  
15
    print(min_effort(n, k, firewalls))  
16",11,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056011
1390056003,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390056003
1390056009,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
        Scanner sc=new Scanner(System.in);
9
        10
        int t=sc.nextInt();
11
        12
        while(t-- >0){
13
            int n=sc.nextInt();
14
            int k=sc.nextInt();
15
            16
            int arr[]=new int[n];
17
            18
            for(int i=0;i<n;i++){
19
                arr[i]=sc.nextInt();
20
            }
21
            int sum=0;
22
            int min=0;
23
            24
            for(int i:arr){
25
                min+=i;
26
            }
27
            28
            29
            for(int i=0;i<n;i++){
30
                31
                for(int j=0;j<i;j++){
32
                    sum+=arr[j];
33
                }
34
                for(int m=i+1;i<n;i++){
35
                    sum+=arr[m]+1;
36
                }
37
                38
                min=Math.min(min,sum);
39
            }
40
            41
            System.out.println(min);
42
        }
43
    }
44
}",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056009
1390056010,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
    T = s.count('1')
3
    if T == 0:
4
        return 0
5
    n = len(s)
6
    7
    # Compute x_max_case1: max number of 1's in window of length T
8
    x_max_case1 = 0
9
    if T <= n:
10
        current = sum(1 for c in s[:T] if c == '1')
11
        x_max_case1 = current
12
        for i in range(1, n - T + 1):
13
            if s[i-1] == '1':
14
                current -= 1
15
            if s[i + T - 1] == '1':
16
                current += 1
17
            if current > x_max_case1:
18
                x_max_case1 = current
19
    20
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
21
    x_max_case2 = 0
22
    current_run = 0
23
    for c in s:
24
        if c == '1':
25
            current_run += 1
26
        else:
27
            if current_run > 0:
28
                candidate = min(current_run, T-1)
29
                if candidate > x_max_case2:
30
                    x_max_case2 = candidate
31
                current_run = 0
32
    # Check the last run
33
    if current_run > 0:
34
        candidate = min(current_run, T-1)
35
        if candidate > x_max_case2:
36
            x_max_case2 = candidate
37
    38
    case1_cost = T - x_max_case1
39
    case2_cost = T - x_max_case2
40
    return min(case1_cost, case2_cost)
41
42
def main():
43
    import sys
44
    input = sys.stdin.read().split()
45
    T_cases = int(input[0])
46
    for i in range(1, T_cases + 1):
47
        s = input[i]
48
        print(compute_min_cost(s))
49
50
if __name__ == ""__main__"":  # Corrected condition
51
    main()
52
53",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056010
1390055999,unknown,unknown,unknown,"1
2
def min_cost_server_pruning(server_rack):
3
4
    n = len(server_rack)
5
6
    active_prefix_sum = [0] * (n + 1)
7
8
    idle_suffix_sum = [0] * (n + 1)
9
10
    for i in range(n):
11
12
        active_prefix_sum[i+1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
13
14
    for i in range(n-1, -1, -1):
15
16
        idle_suffix_sum[i] = idle_suffix_sum[i+1] + (1 if server_rack[i] == '0' else 0)
17
18
    min_cost = float('inf')
19
20
    for left in range(n + 1):
21
22
        for right in range(left, n + 1):
23
            active_removed = active_prefix_sum[left] + (active_prefix_sum[n] - active_prefix_sum[right])
24
25
            idle_remaining = idle_suffix_sum[left] - idle_suffix_sum[right]
26
27
            28
29
            cost = max(idle_remaining, active_removed)
30
31
            min_cost = min(min_cost, cost)
32
33
    34
35
    return min_cost
36
37
t = int(input())
38
39
for _ in range(t):
40
41
    server_rack = input().strip()
42
43
    print(min_cost_server_pruning(server_rack))",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055999
1390056000,unknown,unknown,unknown,"1
def min_cost(binary_string):
2
    n = len(binary_string)
3
   4
    prefix_ones = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_ones[i + 1] = prefix_ones[i] + (1 if binary_string[i] == '1' else 0)
7
  8
    suffix_ones = [0] * (n + 1)
9
    for i in range(n - 1, -1, -1):
10
        suffix_ones[n - i] = suffix_ones[n - i - 1] + (1 if binary_string[i] == '1' else 0)
11
 12
    total_zeros = binary_string.count('0')
13
14
    min_cost = float('inf')
15
16
   17
    for left in range(n + 1):
18
19
        left_ones = prefix_ones[left]
20
21
        for right in range(n - left + 1):
22
    23
            right_ones = suffix_ones[right]
24
25
            26
            remaining_string = binary_string[left:n - right]
27
            remaining_zeros = remaining_string.count('0')
28
29
            cost = max(remaining_zeros, left_ones + right_ones)
30
31
            min_cost = min(min_cost, cost)
32
33
    return min_cost
34
35
36
T = int(input())
37
for _ in range(T):
38
    binary_string = input().strip()
39
    print(min_cost(binary_string))
40",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390056000
1390056002,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390056002
1390055989,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner input = new Scanner(System.in);
8
        int T = input.nextInt();
9
        10
        while (T-- > 0) {
11
            int N = input.nextInt();
12
            int K = input.nextInt();
13
           14
            int[] array = new int[N];
15
            for (int i = 0; i < N; i++) {
16
                array[i] = input.nextInt();
17
            }
18
            19
            if (K > N) {
20
                System.out.println(""0"");
21
                continue;
22
            }
23
            24
            int result = 0;
25
            if (K == 1) {
26
                for (int num : array) {
27
                    if (num > 5) {
28
                        result += num;
29
                    }
30
                }
31
            } else if (K == N) {
32
                result = 0;
33
            } else {
34
                int minSum = Integer.MAX_VALUE;
35
                36
                for (int j = 0; j <= N - K; j++) {
37
                    int a = 0;
38
                    for (int i = j; i < j + K; i++) {
39
                        a += array[i];
40
                    }
41
                    minSum = Math.min(minSum, a);
42
                }
43
44
                result = minSum;
45
            }
46
47
            System.out.println(result);
48
        }
49
    }
50
}
51",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055989
1390055992,unknown,unknown,unknown,"1
def earliest_faulty_in_batches(arr, n, k):
2
3
    result = []
4
5
    6
7
    # Traverse the array in batches of size k
8
9
    for i in range(n - k + 1):
10
11
        batch = arr[i:i + k]
12
13
        found_fault = False
14
15
        16
17
        # Find the first negative number in the batch
18
19
        for num in batch:
20
21
            if num < 0:
22
23
                result.append(num)
24
25
                found_fault = True
26
27
                break
28
29
        30
31
        # If no negative number is found, append 0
32
33
        if not found_fault:
34
35
            result.append(0)
36
37
    38
39
    return result
40
41
# Reading input
42
43
t = int(input().strip())
44
45
outputs = []
46
47
for _ in range(t):
48
49
    n, k = map(int, input().strip().split())
50
51
    arr = list(map(int, input().strip().split()))
52
53
    outputs.append(earliest_faulty_in_batches(arr, n, k))
54
55
# Print results
56
57
for output in outputs:
58
59
    print("" "".join(map(str, output)))",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055992
1390055995,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <climits>
4
#include <algorithm>
5
6
using namespace std;
7
8
using ll = long long;
9
10
ll min_effort(int n, int k, const vector<int>& firewalls) {
11
    if (n == 0) return 0;
12
    13
    // Maximum useful skips is min(k, n)
14
    int max_skips = min(k, n);
15
    vector<vector<ll>> dp(n + 1, vector<ll>(max_skips + 1, LLONG_MAX));
16
    dp[0][0] = 0;
17
    18
    for (int i = 1; i <= n; ++i) {
19
        for (int j = 0; j <= max_skips; ++j) {
20
            // Case 1: Do not skip the i-th firewall
21
            if (dp[i-1][j] != LLONG_MAX) {
22
                dp[i][j] = dp[i-1][j] + firewalls[i-1] + j;
23
            }
24
            // Case 2: Skip the i-th firewall if possible
25
            if (j > 0) {
26
                if (dp[i-1][j-1] != LLONG_MAX) {
27
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
28
                }
29
            }
30
        }
31
    }
32
    33
    return *min_element(dp[n].begin(), dp[n].end());
34
}
35
36
int main() {
37
    ios_base::sync_with_stdio(false);
38
    cin.tie(nullptr);
39
    40
    int T;
41
    cin >> T;
42
    43
    while (T--) {
44
        int n, k;
45
        cin >> n >> k;
46
        47
        vector<int> firewalls(n);
48
        for (int i = 0; i < n; ++i) {
49
            cin >> firewalls[i];
50
        }
51
        52
        cout << min_effort(n, k, firewalls) << '\n';
53
    }
54
    55
    return 0;
56
}
57",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055995
1390055986,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    memo = {}
3
4
    def solve(idx, skipped):
5
        if idx == n:
6
            return 0
7
        if (idx, skipped) in memo:
8
            return memo[(idx, skipped)]
9
10
        skip_effort = float('inf')
11
        if skipped < k:
12
            skip_effort = solve(idx + 1, skipped + 1)
13
14
        dont_skip_effort = (strengths[idx] + skipped) + solve(idx + 1, skipped)
15
        result = min(skip_effort, dont_skip_effort)
16
17
        memo[(idx, skipped)] = result
18
        return result
19
20
    return solve(0, 0)
21
22
23
def solve_test_cases():
24
    t = int(input().strip())
25
    results = []
26
27
    for _ in range(t):
28
        n, k = map(int, input().split())
29
        strengths = list(map(int, input().split()))
30
        min_effort = min_effort_to_breach(n, k, strengths)
31
        results.append(str(min_effort))
32
33
    print(""\n"".join(results))
34
35
36
if __name__ == ""__main__"":
37
    solve_test_cases()
38",12,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055986
1390055979,unknown,unknown,unknown,"1
def min_cost(s):
2
    total_ones = s.count('1')
3
    n = len(s)
4
    5
    # If no '1' exists, remove all (cost = 0)
6
    if total_ones == 0:
7
        return 0  
8
9
    scenario_empty = total_ones  # Cost if we remove all ones
10
11
    # Scenario 1: Try keeping a window of maximum '1's
12
    scenario1_cost = float('inf')
13
    14
    max_ones_in_window = 0
15
    L = min(total_ones, n)
16
    17
    for l in range(1, L + 1):  # Window size
18
        current_ones = sum(1 for c in s[:l] if c == '1')
19
        max_ones_in_window = max(max_ones_in_window, current_ones)
20
        21
        for i in range(1, n - l + 1):
22
            current_ones -= (s[i - 1] == '1')
23
            current_ones += (s[i + l - 1] == '1')
24
            max_ones_in_window = max(max_ones_in_window, current_ones)
25
        26
    scenario1_cost = total_ones - max_ones_in_window
27
28
    # Scenario 2: Try minimizing zeros left after removing 1s from both ends
29
    scenario2_cost = float('inf')
30
    min_zeros = float('inf')
31
    32
    if n > total_ones:
33
        for l in range(total_ones + 1, n + 1):
34
            current_zeros = sum(1 for c in s[:l] if c == '0')
35
            min_zeros = min(min_zeros, current_zeros)
36
            37
            for i in range(1, n - l + 1):
38
                current_zeros -= (s[i - 1] == '0')
39
                current_zeros += (s[i + l - 1] == '0')
40
                min_zeros = min(min_zeros, current_zeros)
41
42
        scenario2_cost = min_zeros
43
44
    candidates = [scenario1_cost, scenario_empty]
45
    if n > total_ones:
46
        candidates.append(scenario2_cost)
47
48
    return min(candidates)
49
50
# Read input
51
T = int(input().strip())
52
for _ in range(T):
53
    s = input().strip()
54
    print(min_cost(s))",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055979
1390055981,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_earliest_faulty_reading(testcases):
4
    results = []
5
    6
    for testcase in testcases:
7
        n, k = testcase[0], testcase[1]  # n is the size of the array, k is the batch size
8
        arr = testcase[2]  # the array of sensor readings
9
        window = deque()  # This will store indices of the array elements
10
        11
        res = []
12
        for i in range(n):
13
            # Remove elements that are outside the current batch
14
            if window and window[0] <= i - k:
15
                window.popleft()
16
            17
            # Add the current element index to the window if it's a faulty reading
18
            if arr[i] < 0:
19
                window.append(i)
20
            21
            # If we have a full window, record the earliest fault
22
            if i >= k - 1:
23
                if window:
24
                    res.append(arr[window[0]])  # Earliest fault in the window
25
                else:
26
                    res.append(0)  # No fault in the window
27
        28
        results.append(res)
29
    30
    return results
31
32
# Input handling
33
t = int(input())  # Number of test cases
34
testcases = []
35
36
for _ in range(t):
37
    n, k = map(int, input().split())  # Read size of array and batch size
38
    arr = list(map(int, input().split()))  # Read the array elements
39
    testcases.append((n, k, arr))
40
41
# Processing each test case
42
results = find_earliest_faulty_reading(testcases)
43
44
# Output results
45
for result in results:
46
    print("" "".join(map(str, result)))
47",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055981
1390055984,unknown,unknown,unknown,"1
def compute_min_cost(cute):
2
    saloni = cute.count('1')
3
    if saloni == 0:
4
        return 0
5
    dogg = len(cute)
6
    7
    mango = 0
8
    if saloni <= dogg:
9
        cherry = sum(1 for grape in cute[:saloni] if grape == '1')
10
        mango = cherry
11
        for banana in range(1, dogg - saloni + 1):
12
            if cute[banana - 1] == '1':
13
                cherry -= 1
14
            if cute[banana + saloni - 1] == '1':
15
                cherry += 1
16
            if cherry > mango:
17
                mango = cherry
18
    19
    kiwi = 0
20
    apple = 0
21
    for orange in cute:
22
        if orange == '1':
23
            apple += 1
24
        else:
25
            if apple > 0:
26
                watermelon = min(apple, saloni - 1)
27
                if watermelon > kiwi:
28
                    kiwi = watermelon
29
                apple = 0
30
31
    if apple > 0:
32
        watermelon = min(apple, saloni - 1)
33
        if watermelon > kiwi:
34
            kiwi = watermelon
35
    36
    panda = saloni - mango
37
    tiger = saloni - kiwi
38
    return min(panda, tiger)
39
40
def main():
41
    import sys
42
    input = sys.stdin.read().split()
43
    cherry = int(input[0])
44
    for dogg in range(1, cherry + 1):
45
        cute = input[dogg]
46
        print(compute_min_cost(cute))
47
48
if __name__ == ""__main__"":
49
    main()",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055984
1390055975,unknown,unknown,unknown,"1
def min_cost(s):
2
    total_ones = s.count('1')
3
    n = len(s)
4
    5
 6
    if total_ones == 0:
7
        return 0  
8
9
    scenario_empty = total_ones  # Cost if we remove all ones
10
11
    12
    scenario1_cost = float('inf')
13
    14
    max_ones_in_window = 0
15
    L = min(total_ones, n)
16
    17
    for l in range(1, L + 1):  # Window size
18
        current_ones = sum(1 for c in s[:l] if c == '1')
19
        max_ones_in_window = max(max_ones_in_window, current_ones)
20
        21
        for i in range(1, n - l + 1):
22
            current_ones -= (s[i - 1] == '1')
23
            current_ones += (s[i + l - 1] == '1')
24
            max_ones_in_window = max(max_ones_in_window, current_ones)
25
        26
    scenario1_cost = total_ones - max_ones_in_window
27
28
    scenario2_cost = float('inf')
29
    min_zeros = float('inf')
30
    31
    if n > total_ones:
32
        for l in range(total_ones + 1, n + 1):
33
            current_zeros = sum(1 for c in s[:l] if c == '0')
34
            min_zeros = min(min_zeros, current_zeros)
35
            36
            for i in range(1, n - l + 1):
37
                current_zeros -= (s[i - 1] == '0')
38
                current_zeros += (s[i + l - 1] == '0')
39
                min_zeros = min(min_zeros, current_zeros)
40
41
        scenario2_cost = min_zeros
42
43
    candidates = [scenario1_cost, scenario_empty]
44
    if n > total_ones:
45
        candidates.append(scenario2_cost)
46
47
    return min(candidates)
48
49
# Read input
50
T = int(input().strip())
51
for _ in range(T):
52
    s = input().strip()
53
    print(min_cost(s))",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055975
1390055976,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
    T = s.count('1')
3
    if T == 0:
4
        return 0
5
    n = len(s)
6
    7
    # Compute x_max_case1: max number of 1's in window of length T
8
    x_max_case1 = 0
9
    if T <= n:
10
        current = sum(1 for c in s[:T] if c == '1')
11
        x_max_case1 = current
12
        for i in range(1, n - T + 1):
13
            if s[i-1] == '1':
14
                current -= 1
15
            if s[i + T - 1] == '1':
16
                current += 1
17
            if current > x_max_case1:
18
                x_max_case1 = current
19
    20
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
21
    x_max_case2 = 0
22
    current_run = 0
23
    for c in s:
24
        if c == '1':
25
            current_run += 1
26
        else:
27
            if current_run > 0:
28
                candidate = min(current_run, T-1)
29
                if candidate > x_max_case2:
30
                    x_max_case2 = candidate
31
                current_run = 0
32
    # Check the last run
33
    if current_run > 0:
34
        candidate = min(current_run, T-1)
35
        if candidate > x_max_case2:
36
            x_max_case2 = candidate
37
    38
    case1_cost = T - x_max_case1
39
    case2_cost = T - x_max_case2
40
    return min(case1_cost, case2_cost)
41
42
def main():
43
    import sys
44
    input = sys.stdin.read().split()
45
    T_cases = int(input[0])
46
    for i in range(1, T_cases + 1):
47
        s = input[i]
48
        print(compute_min_cost(s))
49
50
if __name__ == ""__main__"":
51
    main()",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055976
1390055973,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055973
1390055969,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if __name__ == ""__main__"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055969
1390055970,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055970
1390055972,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055972
1390055968,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine();
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            for (char c : s.toCharArray()) {
17
                if (c == '1') {
18
                    currentConsecutiveOnes++;
19
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
20
                    totalOnes++;
21
                } else {
22
                    currentConsecutiveOnes = 0;
23
                }
24
            }
25
            26
            if (totalOnes == 0) {
27
                System.out.println(0);
28
                continue;
29
            }
30
            if (maxConsecutiveOnes == totalOnes) {
31
                System.out.println(0);
32
                continue;
33
            }
34
            35
            int totalZeros = n - totalOnes;
36
            int low = 0;
37
            int high = Math.max(totalOnes, totalZeros);
38
            int answer = high;
39
            40
            while (low <= high) {
41
                int mid = (low + high) / 2;
42
                int requiredOnes = Math.max(0, totalOnes - mid);
43
                44
                if (requiredOnes == 0) {
45
                    answer = mid;
46
                    high = mid - 1;
47
                    continue;
48
                }
49
                50
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
51
                dummyFunction();
52
                if (maxOnes >= requiredOnes) {
53
                    answer = mid;
54
                    high = mid - 1;
55
                } else {
56
                    low = mid + 1;
57
                }
58
            }
59
            60
            System.out.println(answer);
61
        }
62
        sc.close();
63
    }
64
    65
    private static int maxOnesWithAtMostKZeros(String s, int k) {
66
        int left = 0;
67
        int zeros = 0;
68
        int maxOnes = 0;
69
        int n = s.length();
70
        71
        for (int right = 0; right < n; right++) {
72
            if (s.charAt(right) == '0') {
73
                zeros++;
74
            }
75
            while (zeros > k) {
76
                if (s.charAt(left) == '0') {
77
                    zeros--;
78
                }
79
                left++;
80
            }
81
            int currentOnes = (right - left + 1) - zeros;
82
            maxOnes = Math.max(maxOnes, currentOnes);
83
        }
84
        85
        return maxOnes;
86
    }
87
    88
    private static void dummyFunction() {
89
        int[] dummyArray = {1,1,1,1};
90
        int sum = 0;
91
        for (int i = 0; i < dummyArray.length; i++) {
92
            sum += dummyArray[i] % 7;
93
        }
94
        int result = sum % 13;
95
    }
96
}",13,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055968
1390055961,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    min_effort = float('inf')
6
7
    for i in range(1 << n):
8
        if bin(i).count('1') <= k:
9
            current_effort = 0
10
            current_a = a[:]
11
            for j in range(n):
12
                if (i >> j) & 1:
13
                    pass
14
                else:
15
                    current_effort += current_a[j]
16
                for l in range(j + 1, n):
17
                    if (i >> j) & 1:
18
                        current_a[l] += 1
19
            min_effort = min(min_effort, current_effort)
20
21
    return min_effort
22
23
t = int(input())
24
for _ in range(t):
25
    print(solve())",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055961
1390055964,unknown,unknown,unknown,"1
import sys
2
def solve():
3
    x = sys.stdin.buffer.read().split()
4
    if not x: return
5
    t = int(x[0])
6
    i = 1
7
    o = []
8
    for _ in range(t):
9
        s = x[i].decode()
10
        i += 1
11
        n = len(s)
12
        A = [0]*(n+1)
13
        B = [0]*(n+1)
14
        for j in range(n):
15
            B[j+1] = B[j] + (s[j]=='1')
16
            A[j+1] = A[j] + (s[j]=='0')
17
        T = A[n]
18
        C = [0]*(n+1)
19
        E = [0]*(n+1)
20
        for j in range(n):
21
            E[j+1] = E[j] + (s[n-1-j]=='1')
22
            C[j+1] = C[j] + (s[n-1-j]=='0')
23
        r = 10**9
24
        for x_ in range(n+1):
25
            m = n - x_
26
            y = T - A[x_] - B[x_]
27
            if y < 0: y = 0
28
            if y > m: y = m
29
            for z in (y, y-1, y+1):
30
                if z < 0 or z > m: continue
31
                v1 = B[x_] + E[z]
32
                v2 = T - (A[x_] + C[z])
33
                v = v1 if v1 >= v2 else v2
34
                if v < r: r = v
35
        o.append(str(r))
36
    sys.stdout.write(""\n"".join(o))
37
if __name__==""__main__"":
38
    solve()",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055964
1390055967,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055967
1390055955,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    firewalls.sort() 
3
    min_effort = float('inf')
4
5
   6
    for skips in range(min(k, n) + 1):
7
        remaining_firewalls = firewalls[skips:]
8
        effort = sum(remaining_firewalls) + skips * len(remaining_firewalls)
9
        min_effort = min(min_effort, effort)
10
11
    return min_effort
12
13
def main():
14
    import sys
15
    input = sys.stdin.read
16
    data = input().strip().split('\n')
17
18
    T = int(data[0].strip())  
19
    index = 1
20
    results = []
21
22
    for _ in range(T):
23
        n, k = map(int, data[index].strip().split())
24
        index += 1
25
        firewalls = list(map(int, data[index].strip().split()))
26
27
       28
        firewalls = [f for f in firewalls if isinstance(f, int)]
29
30
        index += 1
31
        results.append(min_effort_to_breach(n, k, firewalls))
32
33
    for result in results:
34
        print(result)
35
36
if __name__ == ""__main__"":
37
    main()",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055955
1390055958,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if _name_ == _""main""_:
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055958
1390055959,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
using ll = long long;
5
6
int main() {
7
    // Optimize input/output
8
    ios::sync_with_stdio(false);
9
    cin.tie(0);
10
11
    int T;
12
    cin >> T;
13
    for (int t = 0; t < T; t++) {
14
        int n, k;
15
        cin >> n >> k;
16
        vector<ll> a(n);
17
        for (int i = 0; i < n; i++) {
18
            cin >> a[i];
19
        }
20
21
        // INF for impossible states , really tough one to solved actually 
22
        const ll INF = 1e18;
23
24
        vector<ll> prev(k + 1, INF);
25
        prev[0] = 0; 
26
27
    28
        for (int i = 0; i < n; i++) {
29
            vector<ll> curr(k + 1, INF);
30
            for (int s = 0; s <= k; s++) {
31
                // Don't skip i
32
                curr[s] = prev[s] + a[i] + s;
33
                // Skip i (if possible)
34
                if (s > 0) {
35
                    curr[s] = min(curr[s], prev[s - 1]);
36
                }
37
            }
38
            prev = curr; 
39
        }
40
41
42
        ll ans = *min_element(prev.begin(), prev.end());
43
        cout << ans << '\n';
44
    }
45
    return 0;
46
}",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055959
1390055938,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055938
1390055953,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        7
        int T = scanner.nextInt();
8
        scanner.nextLine();
9
        10
        for (int t = 0; t < T; t++) {
11
            String s = scanner.nextLine();
12
            int n = s.length();
13
            14
            int[] prefixOnes = new int[n + 1];
15
            int[] prefixZeros = new int[n + 1];
16
            17
            for (int i = 0; i < n; i++) {
18
                prefixOnes[i + 1] = prefixOnes[i] + (s.charAt(i) == '1' ? 1 : 0);
19
                prefixZeros[i + 1] = prefixZeros[i] + (s.charAt(i) == '0' ? 1 : 0);
20
            }
21
            22
            int totalOnes = prefixOnes[n];
23
            int minCost = Integer.MAX_VALUE;
24
            25
            for (int i = 0; i <= n; i++) {
26
                for (int j = i; j <= n; j++) {
27
                    int removedPrefixOnes = prefixOnes[i];
28
                    int removedSuffixOnes = prefixOnes[n] - prefixOnes[j];
29
                    int totalRemovedOnes = removedPrefixOnes + removedSuffixOnes;
30
                    31
                    int keptZeros = prefixZeros[j] - prefixZeros[i];
32
                    33
                    int cost = Math.max(keptZeros, totalRemovedOnes);
34
                    minCost = Math.min(minCost, cost);
35
                }
36
            }
37
            38
            System.out.println(minCost);
39
        }
40
        41
        scanner.close();
42
    }
43
}",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055953
1390055944,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    /**
7
     * Checks if it's feasible to satisfy the condition with X operations.
8
     * @param X The number of operations allowed.
9
     * @param onesIndices Indices of '1's in the string.
10
     * @param total1 Total number of '1's.
11
     * @return True if feasible, false otherwise.
12
     */
13
    static boolean feasible(int X, int[] onesIndices, int total1) {
14
        if (X >= total1) return true;
15
        for (int i = 0; i < total1; i++) {
16
            int j = Math.max(i, 0); // Ensure j starts at or after i
17
            18
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
19
                j++;
20
            }
21
            int segmentLength = j - i; 
22
            if (segmentLength >= total1 - X) return true;
23
        }
24
        return false;
25
    }
26
    27
    public static void main(String[] args) {
28
        Scanner sc = new Scanner(System.in);
29
        int T = sc.nextInt();
30
        31
        while(T-- > 0) {
32
            String s = sc.next();
33
            int n = s.length();
34
            35
            // Collect indices of '1's
36
            ArrayList<Integer> onesList = new ArrayList<>();
37
            for (int i = 0; i < n; i++) {
38
                if (s.charAt(i) == '1') {
39
                    onesList.add(i);
40
                }
41
            }
42
            int total1 = onesList.size();
43
            44
            // Handle edge case: no '1's
45
            if (total1 == 0) {
46
                System.out.println(0);
47
                continue;
48
            }
49
            50
            // Convert list to array for easier manipulation
51
            int[] onesIndices = new int[total1];
52
            for (int i = 0; i < total1; i++) {
53
                onesIndices[i] = onesList.get(i);
54
            }
55
            56
            // Binary search for minimum operations
57
            int low = 0, high = total1, ans = high;
58
            while (low <= high) {
59
                int mid = low + (high - low) / 2;
60
                if (feasible(mid, onesIndices, total1)) {
61
                    ans = mid;
62
                    high = mid - 1;
63
                } else {
64
                    low = mid + 1;
65
                }
66
            }
67
            System.out.println(ans);
68
        }
69
        sc.close();
70
    }
71
}
72",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055944
1390055935,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if _name_ == ""_main_"":
45
    main()",14,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055935
1390055929,unknown,unknown,unknown,"1
def minimum_decommission_cost(servers):
2
    n = len(servers)
3
    server_list = [int(c) for c in servers]
4
5
    prefix_sum = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
8
9
    total_ones = prefix_sum[n]
10
    min_cost = total_ones
11
12
    j = 0
13
    for i in range(n + 1):
14
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
15
            j += 1
16
        17
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
18
        left_ones = prefix_sum[i]
19
        right_ones = total_ones - prefix_sum[j - 1]
20
        cost = max(segment_zeros, left_ones + right_ones)
21
        22
        min_cost = min(min_cost, cost)
23
24
    return min_cost
25
26
def process_input():
27
    import sys
28
    input = sys.stdin.read
29
    data = input().split()
30
    31
    t = int(data[0])
32
    results = []
33
    34
    for i in range(1, t + 1):
35
        results.append(str(minimum_decommission_cost(data[i])))
36
    37
    print(""\n"".join(results))
38
39
if __name__ == ""__main__"":
40
    process_input()",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055929
1390055933,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    4
    if k == 0:
5
        return total_effort  
6
7
    firewalls.sort()  
8
    min_skipped = sum(firewalls[:k])  
9
10
    return total_effort - min_skipped  
11
12
t = int(input())
13
for _ in range(t):
14
    n, k = map(int, input().split())
15
    firewalls = list(map(int, input().split()))
16
    print(min_effort(n, k, firewalls))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055933
1390055934,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} ",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055934
1390055926,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if __name__ == ""__main__"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055926
1390055927,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    min_effort = float('inf')
6
7
    for i in range(1 << n):
8
        if bin(i).count('1') <= k:
9
            current_effort = 0
10
            current_a = a[:]
11
            for j in range(n):
12
                if (i >> j) & 1:
13
                    pass
14
                else:
15
                    current_effort += current_a[j]
16
                for l in range(j + 1, n):
17
                    if (i >> j) & 1:
18
                        current_a[l] += 1
19
            min_effort = min(min_effort, current_effort)
20
21
    return min_effort
22
23
t = int(input())
24
for _ in range(t):
25
    print(solve())",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055927
1390055921,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055921
1390055916,unknown,unknown,unknown,"1
def earliest_faults(arr, k):
2
    result = []
3
    first_fault = 0  # Default if no faults in batch
4
5
    for i in range(len(arr) - k + 1):  # Iterate through batches
6
        batch = arr[i:i + k]
7
        first_fault = 0  # Reset for each batch
8
        9
        for num in batch:  # Find first faulty reading
10
            if num < 0:
11
                first_fault = num
12
                break
13
        14
        result.append(first_fault)
15
16
    return result
17
18
19
# Reading input
20
t = int(input())  # Number of test cases
21
for _ in range(t):
22
    n, k = map(int, input().split())  # Size of array and batch size
23
    arr = list(map(int, input().split()))  # Sensor readings
24
    25
    # Get the result and print it
26
    print(*earliest_faults(arr, k))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055916
1390055917,unknown,unknown,unknown,"1
def f(s):
2
    n = len(s)
3
    ans = n  
4
5
    for i in range(n + 1):
6
        r = s[i:] 
7
        z = r.count('0')
8
        o = s[:i].count('1')  
9
        c = max(z, o)  
10
        if c < ans:
11
            ans = c  
12
    return ans  
13
14
for _ in range(int(input())):
15
    print(f(input().strip()))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055917
1390055920,unknown,unknown,unknown,"1
def min_decommissioning_cost(s):
2
    # Find the first and last occurrence of '1'
3
    first_one = s.find('1')
4
    last_one = s.rfind('1')
5
6
    # If no '1' exists, all servers are idle and can be removed
7
    if first_one == -1:
8
        return 0
9
10
    # Get the substring containing all important servers
11
    core_section = s[first_one:last_one + 1]
12
13
    # Count idle servers (0s) remaining in the core section
14
    remaining_zeros = core_section.count('0')
15
16
    # Count removed active servers (1s)
17
    removed_ones = first_one + (len(s) - 1 - last_one)
18
19
    # Return the minimum possible cost
20
    return max(remaining_zeros, removed_ones)
21
22
# Read number of test cases
23
T = int(input().strip())
24
25
# Process each test case
26
for _ in range(T):
27
    s = input().strip()
28
    print(min_decommissioning_cost(s))",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055920
1390055915,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        7
        int T = scanner.nextInt();
8
        scanner.nextLine(); // Consume newline
9
        10
        for (int t = 0; t < T; t++) {
11
            String s = scanner.nextLine();
12
            int n = s.length();
13
            14
            int[] prefixOnes = new int[n + 1];
15
            int[] prefixZeros = new int[n + 1];
16
            17
            // Calculate prefix sums
18
            for (int i = 0; i < n; i++) {
19
                prefixOnes[i + 1] = prefixOnes[i] + (s.charAt(i) == '1' ? 1 : 0);
20
                prefixZeros[i + 1] = prefixZeros[i] + (s.charAt(i) == '0' ? 1 : 0);
21
            }
22
            23
            int totalOnes = prefixOnes[n];
24
            int minCost = Integer.MAX_VALUE;
25
            26
            // Try all possible combinations of prefix and suffix removals
27
            for (int i = 0; i <= n; i++) {  // i = length of prefix to remove
28
                for (int j = i; j <= n; j++) {  // j = position to start removing suffix
29
                    // Removed prefix: [0...i-1]
30
                    // Kept substring: [i...j-1]
31
                    // Removed suffix: [j...n-1]
32
                    33
                    int removedPrefixOnes = prefixOnes[i];
34
                    int removedSuffixOnes = prefixOnes[n] - prefixOnes[j];
35
                    int totalRemovedOnes = removedPrefixOnes + removedSuffixOnes;
36
                    37
                    int keptZeros = prefixZeros[j] - prefixZeros[i];
38
                    39
                    int cost = Math.max(keptZeros, totalRemovedOnes);
40
                    minCost = Math.min(minCost, cost);
41
                }
42
            }
43
            44
            System.out.println(minCost);
45
        }
46
        47
        scanner.close();
48
    }
49
}",15,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055915
1390055908,unknown,unknown,unknown,"1
def min_firewall_effort(test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        total_effort = sum(firewalls)  # Effort without skipping
6
        min_effort = total_effort  # Initialize with full effort
7
        8
        if k == n:  # If we can skip all firewalls, effort is 0
9
            results.append(0)
10
            continue
11
        12
        # Try skipping each firewall
13
        for i in range(n):
14
            skipped_effort = total_effort - firewalls[i]  # Remove skipped firewall
15
            extra_penalty = (n - 1)  # Each of remaining (n-1) gets +1
16
            17
            min_effort = min(min_effort, skipped_effort + extra_penalty)
18
        19
        results.append(min_effort)
20
    21
    return results
22
23
24
# Input Handling
25
T = int(input())  # Number of test cases
26
test_cases = []
27
28
for _ in range(T):
29
    n, k = map(int, input().split())  # Read n and k
30
    firewalls = list(map(int, input().split()))  # Read firewall strengths
31
    test_cases.append((n, k, firewalls))
32
33
# Processing and Output
34
for result in min_firewall_effort(test_cases):
35
    print(result)
36",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055908
1390055907,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    for n, k, strengths in test_cases:
4
        min_effort = float('inf')
5
6
        for skip in range(k + 1):  # Try skipping from 0 to k firewalls
7
            modified = strengths[:]  # Copy original list
8
            for i in range(skip, n):
9
                modified[i] += skip  # Increase firewall strength after skipping
10
            min_effort = min(min_effort, sum(modified[skip:]))  # Sum from skipped index onward
11
12
        results.append(min_effort)
13
14
    return results
15
16
# Reading input
17
T = int(input().strip())
18
test_cases = []
19
20
for _ in range(T):
21
    n, k = map(int, input().split())
22
    strengths = list(map(int, input().split()))
23
    test_cases.append((n, k, strengths))
24
25
# Compute and print results
26
results = min_effort_to_breach(T, test_cases)
27
for res in results:
28
    print(res)",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055907
1390055913,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
using ll = long long;
5
6
int main() {
7
    // Optimize input/output
8
    ios::sync_with_stdio(false);
9
    cin.tie(0);
10
11
    int T;
12
    cin >> T;
13
    for (int t = 0; t < T; t++) {
14
        int n, k;
15
        cin >> n >> k;
16
        vector<ll> a(n);
17
        for (int i = 0; i < n; i++) {
18
            cin >> a[i];
19
        }
20
21
         22
        const ll INF = 1e18;
23
24
        vector<ll> prev(k + 1, INF);
25
        prev[0] = 0; 
26
27
    28
        for (int i = 0; i < n; i++) {
29
            vector<ll> curr(k + 1, INF);
30
            for (int s = 0; s <= k; s++) {
31
                32
                curr[s] = prev[s] + a[i] + s;
33
                if (s > 0) {
34
                    curr[s] = min(curr[s], prev[s - 1]);
35
                }
36
            }
37
            prev = curr; 
38
        }
39
40
41
        ll ans = *min_element(prev.begin(), prev.end());
42
        cout << ans << '\n';
43
    }
44
    return 0;
45
}",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055913
1390055901,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class BreachFirewall {
5
    public static void main(String[] args) throws IOException {
6
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
7
        StringTokenizer st = new StringTokenizer(br.readLine());
8
        9
        int T = Integer.parseInt(st.nextToken()); // Number of test cases
10
        StringBuilder result = new StringBuilder();
11
        12
        while (T-- > 0) {
13
            st = new StringTokenizer(br.readLine());
14
            int n = Integer.parseInt(st.nextToken());
15
            int k = Integer.parseInt(st.nextToken());
16
17
            int[] firewalls = new int[n];
18
            st = new StringTokenizer(br.readLine());
19
            int totalEffort = 0;
20
21
            for (int i = 0; i < n; i++) {
22
                firewalls[i] = Integer.parseInt(st.nextToken());
23
                totalEffort += firewalls[i]; // Calculate total sum
24
            }
25
26
            List<Integer> modifiedValues = new ArrayList<>();
27
            for (int i = 0; i < n; i++) {
28
                modifiedValues.add(firewalls[i] - (n - i - 1)); // Transform the array
29
            }
30
31
            // Sort in descending order
32
            modifiedValues.sort(Collections.reverseOrder());
33
34
            // Compute prefix sum for best `t` firewalls to skip
35
            int[] prefixSum = new int[n + 1];
36
            for (int i = 0; i < n; i++) {
37
                prefixSum[i + 1] = prefixSum[i] + modifiedValues.get(i);
38
            }
39
40
            int maxSum = 0;
41
            int maxT = Math.min(k, n);
42
            for (int t = 0; t <= maxT; t++) {
43
                int current = prefixSum[t] + (t * (t - 1)) / 2;
44
                maxSum = Math.max(maxSum, current);
45
            }
46
47
            result.append(totalEffort - maxSum).append(""\n"");
48
        }
49
50
        System.out.print(result);
51
    }
52
}
53",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055901
1390055905,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055905
1390055906,unknown,unknown,unknown,"1
import sys
2
3
def min_decommission_cost(server_rack):
4
    first_one = server_rack.find('1')
5
    last_one = server_rack.rfind('1')
6
    7
    if first_one == -1:  
8
        return 0  # No active servers (all are '0'), cost is 0
9
    10
    trimmed_rack = server_rack[first_one:last_one+1]
11
    12
    idle_remaining = trimmed_rack.count('0')
13
    active_removed = first_one + (len(server_rack) - last_one - 1)
14
    15
    return max(idle_remaining, active_removed)
16
17
def main():
18
    T = int(sys.stdin.readline().strip())
19
    for _ in range(T):
20
        server_rack = sys.stdin.readline().strip()
21
        print(min_decommission_cost(server_rack))
22
23
if __name__ == ""__main__"":
24
    main()
25",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055906
1390055895,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    for servers in test_cases:
4
        first_one = servers.find('1')
5
        last_one = servers.find('1')
6
        7
        if first_one == -1:
8
            results.append(0)
9
            continue
10
            11
        trimmed = servers[first_one:last_one + 1]
12
        13
        idle_remaining = trimmed.count('0')
14
        active_removed = servers[:first_one].count('1') + servers[last_one + 1:].count('1')
15
        16
        results.append(max(idle_remaining, active_removed))
17
        18
    return results
19
20
T = int(input().strip())
21
test_cases = [input().strip() for _ in range(T)]
22
23
results in min_decommissioning_cost(test_cases)
24
for res in results:
25
    print(res)",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055895
1390055898,unknown,unknown,unknown,"1
def min_cost(binary_string):
2
    n = len(binary_string)
3
4
    prefix_ones = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_ones[i + 1] = prefix_ones[i] + (1 if binary_string[i] == '1' else 0)
7
8
    suffix_ones = [0] * (n + 1)
9
    for i in range(n - 1, -1, -1):
10
        suffix_ones[n - i] = suffix_ones[n - i - 1] + (1 if binary_string[i] == '1' else 0)
11
    total_zeros = binary_string.count('0')
12
13
    min_cost = float('inf')
14
15
    for left in range(n + 1):
16
  17
        left_ones = prefix_ones[left]
18
        for right in range(n - left + 1):
19
            20
            right_ones = suffix_ones[right]
21
            remaining_string = binary_string[left:n - right]
22
            remaining_zeros = remaining_string.count('0')
23
            cost = max(remaining_zeros, left_ones + right_ones)
24
25
            min_cost = min(min_cost, cost)
26
27
    return min_cost
28
29
30
T = int(input())
31
for _ in range(T):
32
    binary_string = input().strip()
33
    print(min_cost(binary_string))",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055898
1390055896,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include<bits/stdc++.h>
7
using namespace std;
8
9
int solve(vector<int>& arr, int k){
10
    int n = arr.size();
11
    int ans = 0;
12
    13
    set<int> st;
14
    vector<int> right(n,0);
15
    for(int i=0; i<n; i++) right[i]=n-i-1;
16
    priority_queue<pair<int,int>, vector<pair<int,int>>> pq;
17
    for(int i=0; i<n; i++) pq.push({arr[i],i});
18
    19
    while(!pq.empty()){
20
        auto [val,idx] = pq.top(); pq.pop();
21
        22
        if(right[idx] < val && k){
23
            st.insert(idx);
24
            k--;
25
            for(int i=0; i<idx; i++){
26
                right[i]--;
27
            }
28
            arr[idx]=0;
29
            // cout<<""inserted ""<<idx<<"" k:""<<k<<"" "";
30
        }    
31
    }
32
    33
    // for(int i=0; i<n; i++) cout<<right[i]<<"" "";
34
    35
    36
    for(int i=0; i<n; i++){
37
        if(st.find(i)!=st.end()) ans += right[i];
38
        ans += arr[i];
39
    }
40
    41
    return ans;
42
}
43
44
45
int main() {
46
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
47
    int t;
48
    cin>>t;
49
    while(t--){
50
        int n,k;
51
        cin>>n>>k;
52
        vector<int> arr(n);
53
        for(int i=0; i<n ;i++) cin>>arr[i];
54
        55
        int ans = solve(arr,k);
56
        cout<<ans<<endl;
57
    }
58
    return 0;
59
}
60",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055896
1390055894,unknown,unknown,unknown,"1
def minimum_decommission_cost(servers):
2
    n = len(servers)
3
    4
    # Convert the string to a list of integers (0 or 1)
5
    server_list = [int(c) for c in servers]
6
7
    # Compute prefix sum of active servers (1s)
8
    prefix_sum = [0] * (n + 1)
9
    for i in range(n):
10
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
11
12
    total_ones = prefix_sum[n]  # Total active servers
13
    min_cost = total_ones  # Worst case: decommission all active servers
14
15
    j = 0  # Right boundary of the window
16
    for i in range(n + 1):
17
        # Move j to maintain segment_zeros >= total_ones_removed
18
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
19
            j += 1
20
        21
        # Calculate cost at the current window
22
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
23
        left_ones = prefix_sum[i]
24
        right_ones = total_ones - prefix_sum[j - 1]
25
        cost = max(segment_zeros, left_ones + right_ones)
26
        27
        min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
def process_input():
32
    import sys
33
    input = sys.stdin.read
34
    data = input().split()
35
    36
    t = int(data[0])
37
    results = []
38
    39
    for i in range(1, t + 1):
40
        results.append(str(minimum_decommission_cost(data[i])))
41
    42
    print(""\n"".join(results))
43
44
# Correcting the name definition
45
if __name__ == ""__main__"":
46
    process_input()",16,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055894
1390055885,unknown,unknown,unknown,"1
import sys
2
3
def solve():
4
    x = sys.stdin.buffer.read().split()
5
    if not x: return
6
    t = int(x[0])  # Number of test cases
7
    i = 1
8
    o = []
9
    10
    for _ in range(t):
11
        s = x[i].decode()  # Read the binary string
12
        i += 1
13
        n = len(s)
14
        15
        A = [0] * (n + 1)
16
        B = [0] * (n + 1)
17
        18
        for j in range(n):
19
            B[j + 1] = B[j] + (s[j] == '1')
20
            A[j + 1] = A[j] + (s[j] == '0')
21
        22
        T = A[n]  # Total count of '0' in s
23
        C = [0] * (n + 1)
24
        E = [0] * (n + 1)
25
        26
        for j in range(n):
27
            E[j + 1] = E[j] + (s[n - 1 - j] == '1')
28
            C[j + 1] = C[j] + (s[n - 1 - j] == '0')
29
        30
        r = 10**9  # Large initial value
31
        32
        for x_ in range(n + 1):
33
            m = n - x_
34
            y = T - A[x_] - B[x_]
35
            if y < 0:
36
                y = 0
37
            if y > m:
38
                y = m
39
            40
            for z in (y, y - 1, y + 1):
41
                if 0 <= z <= m:
42
                    v1 = B[x_] + E[z]
43
                    v2 = T - (A[x_] + C[z])
44
                    v = max(v1, v2)
45
                    if v < r:
46
                        r = v
47
        48
        o.append(str(r))
49
    50
    sys.stdout.write(""\n"".join(o) + ""\n"")  # Add newline at the end for proper output formatting
51
52
if __name__ == ""__main__"":
53
    solve()
54",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055885
1390055888,unknown,unknown,unknown,"1
def minimize_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    4
    # Create list of (value + index) for each firewall
5
    skip_value = []
6
    for i in range(n):
7
        skip_value.append((firewalls[i] + i, i))
8
9
    # Sort by descending benefit to skip
10
    skip_value.sort(reverse=True)
11
12
    # Mark which firewalls to skip
13
    skipped = [0] * n
14
    for i in range(k):
15
        _, idx = skip_value[i]
16
        skipped[idx] = 1
17
18
    # Now calculate final effort
19
    effort = 0
20
    penalty = 0
21
    for i in range(n):
22
        if skipped[i]:
23
            penalty += 1
24
        else:
25
            effort += firewalls[i] + penalty
26
27
    return effort
28
29
# Main driver
30
T = int(input())
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    firewalls = list(map(int, input().split()))
34
    print(minimize_effort(n, k, firewalls))",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055888
1390055892,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if __name__ == ""__main__"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055892
1390055874,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
    T = s.count('1')
3
    if T == 0:
4
        return 0
5
    n = len(s)
6
    7
    # Compute x_max_case1: max number of 1's in window of length T
8
    x_max_case1 = 0
9
    if T <= n:
10
        current = sum(1 for c in s[:T] if c == '1')
11
        x_max_case1 = current
12
        for i in range(1, n - T + 1):
13
            if s[i-1] == '1':
14
                current -= 1
15
            if s[i + T - 1] == '1':
16
                current += 1
17
            if current > x_max_case1:
18
                x_max_case1 = current
19
    20
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
21
    x_max_case2 = 0
22
    current_run = 0
23
    for c in s:
24
        if c == '1':
25
            current_run += 1
26
        else:
27
            if current_run > 0:
28
                candidate = min(current_run, T-1)
29
                if candidate > x_max_case2:
30
                    x_max_case2 = candidate
31
                current_run = 0
32
    # Check the last run
33
    if current_run > 0:
34
        candidate = min(current_run, T-1)
35
        if candidate > x_max_case2:
36
            x_max_case2 = candidate
37
    38
    case1_cost = T - x_max_case1
39
    case2_cost = T - x_max_case2
40
    return min(case1_cost, case2_cost)
41
42
def main():
43
    import sys
44
    input = sys.stdin.read().split()
45
    T_cases = int(input[0])
46
    for i in range(1, T_cases + 1):
47
        s = input[i]
48
        print(compute_min_cost(s))
49
50
if __name__ == ""__main__"":
51
    main()
52",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055874
1390055876,unknown,unknown,unknown,"1
import sys
2
def solve():
3
    x = sys.stdin.buffer.read().split()
4
    if not x: return
5
    t = int(x[0])
6
    i = 1
7
    o = []
8
    for _ in range(t):
9
        s = x[i].decode()
10
        i += 1
11
        n = len(s)
12
        A = [0]*(n+1)
13
        B = [0]*(n+1)
14
        for j in range(n):
15
            B[j+1] = B[j] + (s[j]=='1')
16
            A[j+1] = A[j] + (s[j]=='0')
17
        T = A[n]
18
        C = [0]*(n+1)
19
        E = [0]*(n+1)
20
        for j in range(n):
21
            E[j+1] = E[j] + (s[n-1-j]=='1')
22
            C[j+1] = C[j] + (s[n-1-j]=='0')
23
        r = 10**9
24
        for x_ in range(n+1):
25
            m = n - x_
26
            y = T - A[x_] - B[x_]
27
            if y < 0: y = 0
28
            if y > m: y = m
29
            for z in (y, y-1, y+1):
30
                if z < 0 or z > m: continue
31
                v1 = B[x_] + E[z]
32
                v2 = T - (A[x_] + C[z])
33
                v = v1 if v1 >= v2 else v2
34
                if v < r: r = v
35
        o.append(str(r))
36
    sys.stdout.write(""\n"".join(o))
37
if __name__==""__main__"":
38
    solve()",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055876
1390055880,unknown,unknown,unknown,"1
import sys
2
3
def min_pruning_cost(T, test_cases):
4
    results = []
5
    6
    for servers in test_cases:
7
        first_one = servers.find('1') 
8
        last_one = servers.rfind('1')  
9
10
        if first_one == -1:  
11
            results.append(""0"")
12
            continue
13
        core_segment = servers[first_one:last_one + 1]
14
        idle_remaining = core_segment.count('0')  
15
        active_removed = servers[:first_one].count('1') + servers[last_one + 1:].count('1')
16
        results.append(str(max(idle_remaining, active_removed)))
17
T = int(sys.stdin.readline().strip())  
18
test_cases = [sys.stdin.readline().strip() for _ in range(T)]
19
min_pruning_cost(T, test_cases)
20",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055880
1390055869,unknown,unknown,unknown,"1
import sys
2
input = sys.stdin.read
3
4
def min_decommissioning_cost(rack):
5
    left = rack.find('1')
6
    right = rack.rfind('1')
7
    8
    # If no active servers (all zeros), cost = 0
9
    if left == -1:
10
        return 0
11
    12
    # Trim the rack from leftmost '1' to rightmost '1'
13
    trimmed_rack = rack[left:right + 1]
14
    15
    # Remaining idle servers after trimming
16
    remaining_idle = trimmed_rack.count('0')
17
    18
    # Removed active servers from the left and right sides
19
    removed_active = rack[:left].count('1') + rack[right + 1:].count('1')
20
    21
    # Cost = max(remaining idle servers, removed active servers)
22
    return max(remaining_idle, removed_active)
23
24
# Efficient Input Handling
25
data = input().strip().split(""\n"")
26
t = int(data[0])
27
test_cases = data[1:t + 1]
28
29
# Compute results
30
results = [str(min_decommissioning_cost(tc)) for tc in test_cases]
31
32
# Fast Output
33
sys.stdout.write(""\n"".join(results) + ""\n"")
34",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055869
1390055872,unknown,unknown,unknown,"1
import java.io.*;
2
3
import java.util.*;
4
5
public class Solution {
6
7
    8
9
    10
11
    static boolean feasible(int X, int[] onesIndices, int total1) {
12
13
       14
15
        if (X >= total1) return true;
16
17
        int j = 0;
18
19
        for (int i = 0; i < total1; i++) {
20
21
            22
23
            if (j < i) j = i;
24
25
            26
27
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
28
29
                j++;
30
31
            }
32
33
            int m = j - i; 
34
35
            if (m >= total1 - X) return true;
36
37
        }
38
39
        return false;
40
41
    }
42
43
    44
45
    public static void main(String[] args) {
46
47
        Scanner sc = new Scanner(System.in);
48
49
        int T = sc.nextInt();
50
51
        52
53
        while(T-- > 0) {
54
55
            String s = sc.next();
56
57
            int n = s.length();
58
59
            60
61
           62
63
            ArrayList<Integer> onesList = new ArrayList<>();
64
65
            for (int i = 0; i < n; i++) {
66
67
                if (s.charAt(i) == '1') {
68
69
                    onesList.add(i);
70
71
                }
72
73
            }
74
75
            int total1 = onesList.size();
76
77
            78
79
           80
81
            if (total1 == 0) {
82
83
                System.out.println(0);
84
85
                continue;
86
87
            }
88
89
            90
91
           92
93
            int[] onesIndices = new int[total1];
94
95
            for (int i = 0; i < total1; i++) {
96
97
                onesIndices[i] = onesList.get(i);
98
99
            }
100
101
            102
103
           104
105
            int low = 0, high = total1, ans = high;
106
107
            while (low <= high) {
108
109
                int mid = low + (high - low) / 2;
110
111
                if (feasible(mid, onesIndices, total1)) {
112
113
                    ans = mid;
114
115
                    high = mid - 1;
116
117
                } else {
118
119
                    low = mid + 1;
120
121
                }
122
123
            }
124
125
            System.out.println(ans);
126
127
        }
128
129
        sc.close();
130
131
    }
132
133
}",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055872
1390055870,unknown,unknown,unknown,"1
import java.io.*;
2
3
import java.util.*;
4
5
public class Solution {
6
7
    8
9
    10
11
    static boolean feasible(int X, int[] onesIndices, int total1) {
12
13
       14
15
        if (X >= total1) return true;
16
17
        int j = 0;
18
19
        for (int i = 0; i < total1; i++) {
20
21
            22
23
            if (j < i) j = i;
24
25
            26
27
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
28
29
                j++;
30
31
            }
32
33
            int m = j - i; 
34
35
            if (m >= total1 - X) return true;
36
37
        }
38
39
        return false;
40
41
    }
42
43
    44
45
    public static void main(String[] args) {
46
47
        Scanner sc = new Scanner(System.in);
48
49
        int T = sc.nextInt();
50
51
        52
53
        while(T-- > 0) {
54
55
            String s = sc.next();
56
57
            int n = s.length();
58
59
            60
61
           62
63
            ArrayList<Integer> onesList = new ArrayList<>();
64
65
            for (int i = 0; i < n; i++) {
66
67
                if (s.charAt(i) == '1') {
68
69
                    onesList.add(i);
70
71
                }
72
73
            }
74
75
            int total1 = onesList.size();
76
77
            78
79
           80
81
            if (total1 == 0) {
82
83
                System.out.println(0);
84
85
                continue;
86
87
            }
88
89
            90
91
           92
93
            int[] onesIndices = new int[total1];
94
95
            for (int i = 0; i < total1; i++) {
96
97
                onesIndices[i] = onesList.get(i);
98
99
            }
100
101
            102
103
           104
105
            int low = 0, high = total1, ans = high;
106
107
            while (low <= high) {
108
109
                int mid = low + (high - low) / 2;
110
111
                if (feasible(mid, onesIndices, total1)) {
112
113
                    ans = mid;
114
115
                    high = mid - 1;
116
117
                } else {
118
119
                    low = mid + 1;
120
121
                }
122
123
            }
124
125
            System.out.println(ans);
126
127
        }
128
129
        sc.close();
130
131
    }
132
133
}",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055870
1390055865,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    s = input().strip()
4
    init_0 = s.count('0')
5
    best = float('inf')
6
    7
    n = len(s)
8
    9
    for p in range(n + 1):  
10
        for q in range(n + 1 - p):
11
            if p + q > n:
12
                continue
13
            14
            mid = s[p:n-q]
15
            16
            if not mid: 
17
                zeros = 0
18
                ones_cut = s.count('1')
19
            else:
20
                zeros = mid.count('0')
21
                ones_cut = s.count('1') - mid.count('1')
22
            23
            c = max(zeros, ones_cut)
24
            best = min(best, c)
25
    26
    print(best)",17,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055865
1390055863,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        if bin(i).count('1') > k:
9
            continue
10
        11
        current_effort = 0
12
        current_a = a[:] 
13
        14
        for j in range(n):
15
            if (i >> j) & 1:
16
                pass  
17
            else:
18
                current_effort += current_a[j]
19
            20
            for l in range(j + 1, n):
21
                if (i >> j) & 1:
22
                    current_a[l] += 1
23
        24
        min_effort = min(min_effort, current_effort)
25
    26
    return min_effort
27
28
t = int(input())
29
for _ in range(t):
30
    print(solve())",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055863
1390055864,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
#include <string.h>
4
5
int bigger(int x, int y) {
6
    return x > y ? x : y;
7
}
8
9
int smaller(int x, int y) {
10
    return x < y ? x : y;
11
}
12
13
int main() {
14
    int testCount;
15
    scanf(""%d"", &testCount);
16
    17
    for (int test = 0; test < testCount; test++) {
18
        char rack[100001];
19
        scanf(""%s"", rack);
20
        21
        int length = strlen(rack);
22
        23
        int *ones = (int*)calloc(length + 1, sizeof(int));
24
        int *zeros = (int*)calloc(length + 1, sizeof(int));
25
        26
        for (int i = 0; i < length; i++) {
27
            ones[i + 1] = ones[i] + (rack[i] == '1' ? 1 : 0);
28
            zeros[i + 1] = zeros[i] + (rack[i] == '0' ? 1 : 0);
29
        }
30
        31
        int bestResult = length;
32
        33
        for (int front = 0; front <= length; front++) {
34
            for (int back = 0; back <= length - front; back++) {
35
                int removedOnes = ones[front] + (ones[length] - ones[length - back]);
36
                int remainingZeros = zeros[length - back] - zeros[front];
37
                38
                int currentCost = bigger(removedOnes, remainingZeros);
39
                bestResult = smaller(bestResult, currentCost);
40
            }
41
        }
42
        43
        printf(""%d\n"", bestResult);
44
        45
        free(ones);
46
        free(zeros);
47
    }
48
    49
    return 0;
50
}",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055864
1390055861,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
        # get indices for active servers ('1')
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        # Precompute A: A[i] = positions[i] - i
18
        A = [positions[i] - i for i in range(m)]
19
        20
        # check(X) returns True if there exists a window in A
21
        # such that:
22
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
23
        # and A[j] - A[i] <= X.
24
        def check(X):
25
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                # slide j as far as possible while A[j]-A[i] <= X
33
                while j < m and A[j] - A[i] <= X:
34
                    j += 1
35
                # j now is one past the last index satisfying condition, so the window has length (j - i)
36
                if j - i >= m - X:
37
                    return True
38
            return False
39
40
        # Binary search for the minimum X
41
        lo, hi, ans = 0, n, n
42
        while lo <= hi:
43
            mid = (lo + hi) // 2
44
            if check(mid):
45
                ans = mid
46
                hi = mid - 1
47
            else:
48
                lo = mid + 1
49
        out_lines.append(str(ans))
50
    51
    sys.stdout.write(""\n"".join(out_lines))
52
    53
if __name__ == '__main__':
54
    solve()",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055861
1390055850,unknown,unknown,unknown,"1
def min_effort_to_breach(firewall_strengths, k):
2
    n = len(firewall_strengths)
3
    if k >= n:
4
        return 0
5
    indexed_strengths = [(i, strength) for i, strength in enumerate(firewall_strengths)]
6
    memo = {}
7
    8
    def solve(idx, skips_left, skipped_so_far):
9
        if idx == n:
10
            return 0
11
        12
        key = (idx, skips_left, skipped_so_far)
13
        if key in memo:
14
            return memo[key]
15
        16
        current_strength = firewall_strengths[idx] + skipped_so_far
17
        18
        effort_breach = current_strength + solve(idx + 1, skips_left, skipped_so_far)
19
        effort_skip = float('inf')
20
        if skips_left > 0:
21
            effort_skip = solve(idx + 1, skips_left - 1, skipped_so_far + 1)
22
        23
        result = min(effort_breach, effort_skip)
24
        memo[key] = result
25
        return result
26
    27
    return solve(0, k, 0)
28
test_case = int(input())
29
for _ in range(test_case):
30
    a,b = list(map(int,input().split("" "")))
31
    arr = list(map(int,input().split("" "")))
32
    print(min_effort_to_breach(arr,b))
33
    ",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055850
1390055852,unknown,unknown,unknown,"1
def findEarliest(n, k, arr):
2
    res = []
3
    dq = deque()
4
    5
    for i in range(n):
6
        while dq and dq[0] < i - k + 1:
7
            dq.popleft()
8
        9
        if arr[i] < 0:
10
            dq.append(i)
11
        12
        if i >= k - 1:
13
            if dq:
14
                res.append(arr[dq[0]])
15
            else:
16
                res.append(0)
17
    18
    return res
19
20
from collections import deque
21
22
t = int(input())
23
while t > 0:
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = findEarliest(n, k, arr)
28
    print("" "".join(map(str, result)))
29
    30
    t -= 1
31
    ",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055852
1390055857,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        result = []
8
        dq = deque()
9
        10
        # Process first window
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
        15
        # Store the first result
16
        result.append(arr[dq[0]] if dq else 0)
17
        18
        # Process remaining windows
19
        for i in range(k, n):
20
            # Remove elements no longer in window
21
            if dq and dq[0] <= i - k:
22
                dq.popleft()
23
            24
            # Add new element if it's faulty
25
            if arr[i] < 0:
26
                dq.append(i)
27
            28
            # Store result for current window
29
            result.append(arr[dq[0]] if dq else 0)
30
        31
        results.append("" "".join(map(str, result)))
32
    33
    return results
34
35
# Read input
36
t = int(input())
37
test_cases = []
38
for _ in range(t):
39
    n, k = map(int, input().split())
40
    arr = list(map(int, input().split()))
41
    test_cases.append((n, k, arr))
42
43
# Compute and print output
44
for res in earliest_faulty_readings(test_cases):
45
    print(res)",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055857
1390055845,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    4
    if k == 0:
5
        return total_effort  
6
7
    firewalls.sort()  
8
    min_skipped = sum(firewalls[:k])  
9
10
    return total_effort - min_skipped  
11
12
t = int(input())
13
for _ in range(t):
14
    n, k = map(int, input().split())
15
    firewalls = list(map(int, input().split()))
16
    print(min_effort(n, k, firewalls))
17
18",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055845
1390055844,unknown,unknown,unknown,"1
def find_earliest_faults(arr, k):
2
    result = []
3
    for i in range(len(arr) - k + 1):
4
        batch = arr[i:i + k]
5
        earliest_fault = 0
6
        for j, reading in enumerate(batch):
7
            if reading < 0:
8
                earliest_fault = reading
9
                break
10
        result.append(earliest_fault)
11
    return result
12
13
if __name__ == ""__main__"":
14
    num_test_cases = int(input())  # Read the number of test cases
15
16
    for _ in range(num_test_cases):  # Iterate through test cases
17
        input_line = input().split()
18
        n = int(input_line[0])
19
        k = int(input_line[1])
20
        arr = list(map(int, input().split()))
21
22
        faults = find_earliest_faults(arr, k)
23
        print(*faults)",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055844
1390055848,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
12
    for i in range(k, n + 1):
13
        if dq:
14
            result.append(arr[dq[0]])
15
        else:
16
            result.append(0)
17
18
        while dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
21
        if i < n and arr[i] < 0:
22
            dq.append(i)
23
24
    return result
25
26
def solve():
27
    t = int(input())
28
    for _ in range(t):
29
        n, k = map(int, input().split())
30
        arr = list(map(int, input().split()))
31
        result = earliest_faulty_readings(arr, k)
32
        print(*result)
33
34
solve()
35",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055848
1390055843,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",18,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055843
1390055831,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
9
        for (int testCase = 0; testCase < t; testCase++) {
10
            int n = scanner.nextInt();
11
            int k = scanner.nextInt();
12
13
            int[] strengths = new int[n];
14
            for (int i = 0; i < n; i++) {
15
                strengths[i] = scanner.nextInt();
16
            }
17
18
            System.out.println(minimumEffort(strengths, k));
19
        }
20
21
        scanner.close();
22
    }
23
24
    public static long minimumEffort(int[] strengths, int k) {
25
        int n = strengths.length;
26
27
        if (k >= n) {
28
            return 0;
29
        }
30
31
        long[] dp = new long[k + 1];
32
        Arrays.fill(dp, Long.MAX_VALUE / 2);
33
        dp[0] = 0;
34
35
        for (int i = 0; i < n; i++) {
36
            long[] newDp = new long[k + 1];
37
            Arrays.fill(newDp, Long.MAX_VALUE / 2);
38
39
            for (int j = 0; j <= k; j++) {
40
                if (j == 0) {
41
                    newDp[0] = dp[0] + strengths[i];
42
                } else {
43
                    newDp[j] = dp[j] + strengths[i] + j;
44
                }
45
46
                if (j > 0) {
47
                    newDp[j] = Math.min(newDp[j], dp[j - 1]);
48
                }
49
            }
50
51
            dp = newDp;
52
        }
53
54
        long minEffort = dp[0];
55
        for (int j = 1; j <= k; j++) {
56
            minEffort = Math.min(minEffort, dp[j]);
57
        }
58
59
        return minEffort;
60
    }
61
}
62",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055831
1390055835,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
    left = 0
3
    zeros = 0
4
    max_ones = 0
5
    n = len(s)
6
    7
    for right in range(n):
8
        if s[right] == '0':
9
            zeros += 1
10
        while zeros > k:
11
            if s[left] == '0':
12
                zeros -= 1
13
            left += 1
14
        current_ones = (right - left + 1) - zeros
15
        max_ones = max(max_ones, current_ones)
16
    17
    return max_ones
18
19
def min_flips_to_make_ones_consecutive(s):
20
    n = len(s)
21
    total_ones = s.count('1')
22
    23
    if total_ones == 0 or '1' * total_ones in s:
24
        return 0
25
    26
    total_zeros = n - total_ones
27
    max_consecutive_ones = max(map(len, s.split('0')))
28
    29
    low, high = 0, max(total_ones, total_zeros)
30
    answer = high
31
32
    while low <= high:
33
        mid = (low + high) // 2
34
        required_ones = max(0, total_ones - mid)
35
36
        if required_ones == 0:
37
            answer = mid
38
            high = mid - 1
39
            continue
40
        41
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
42
        if max_ones >= required_ones:
43
            answer = mid
44
            high = mid - 1
45
        else:
46
            low = mid + 1
47
    48
    return answer
49
50
T = int(input().strip())
51
for _ in range(T):
52
    s = input().strip()
53
    print(min_flips_to_make_ones_consecutive(s))",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055835
1390055837,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_fault_in_batches(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    for i in range(len(arr) - k + 1):
12
        if dq:
13
            result.append(arr[dq[0]])
14
        else:
15
            result.append(0)
16
        17
        while dq and dq[0] < i + 1:
18
            dq.popleft()
19
        20
        if i + k < len(arr) and arr[i + k] < 0:
21
            dq.append(i + k)
22
    23
    return result
24
25
# Read input
26
t = int(input())
27
for _ in range(t):
28
    n, k = map(int, input().split())
29
    arr = list(map(int, input().split()))
30
    print(*earliest_fault_in_batches(arr, k))",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055837
1390055827,unknown,unknown,unknown,"1
t = int(input())
2
3
while t:
4
    n, k = map(int, input().split())
5
    arr = list(map(int, input().split()))
6
7
    dp = [float('inf')] * (k + 1)
8
    dp[0] = 0
9
10
    for i in range(n):
11
        next_dp = [float('inf')] * (k + 1)
12
13
        for j in range(k + 1):
14
            next_dp[j] = min(next_dp[j], dp[j] + arr[i] + j)
15
            if j < k:
16
                next_dp[j + 1] = min(next_dp[j + 1], dp[j])
17
18
        dp = next_dp
19
20
    result = min(dp)
21
    print(result)
22
    t-=1
23
24",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055827
1390055830,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        if bin(i).count('1') > k:
9
            continue
10
        11
        current_effort = 0
12
        current_a = a[:] 
13
        14
        for j in range(n):
15
            if (i >> j) & 1:
16
                pass  
17
            else:
18
                current_effort += current_a[j]
19
            20
            for l in range(j + 1, n):
21
                if (i >> j) & 1:
22
                    current_a[l] += 1
23
        24
        min_effort = min(min_effort, current_effort)
25
    26
    return min_effort
27
28
t = int(input())
29
for _ in range(t):
30
    print(solve())",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055830
1390055828,unknown,unknown,unknown,"1
for _ in range(int(input())):
2
    x,y = map(int,input().split())
3
    arr = list(map(int,input().split()))
4
    effort = 0
5
6
    effort = sum(sorted(arr)[:x-y]) + x - y
7
    print(effort)",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055828
1390055819,unknown,unknown,unknown,"1
def minimum_decommission_cost(servers):
2
    n = len(servers)
3
    4
    # Convert the string to a list of integers (0 or 1)
5
    server_list = [int(c) for c in servers]
6
7
    # Compute prefix sum of active servers (1s)
8
    prefix_sum = [0] * (n + 1)
9
    for i in range(n):
10
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
11
12
    total_ones = prefix_sum[n]  # Total active servers
13
    min_cost = total_ones  # Worst case: decommission all active servers
14
15
    j = 0  # Right boundary of the window
16
    for i in range(n + 1):
17
        # Move j to maintain segment_zeros >= total_ones_removed
18
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
19
            j += 1
20
        21
        # Calculate cost at current window
22
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
23
        left_ones = prefix_sum[i]
24
        right_ones = total_ones - prefix_sum[j - 1]
25
        cost = max(segment_zeros, left_ones + right_ones)
26
        27
        min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
def process_input():
32
    import sys
33
    input = sys.stdin.read
34
    data = input().split()
35
    36
    t = int(data[0])
37
    results = []
38
    39
    for i in range(1, t + 1):
40
        results.append(str(minimum_decommission_cost(data[i])))
41
    42
    print(""\n"".join(results))
43
44
if __name__ == ""__main__"":
45
    process_input()
46",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055819
1390055820,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    static boolean check(int val, int[] idxArray, int count) {
7
        8
        if (val >= count) return true;
9
        int right = 0;
10
        for (int left = 0; left < count; left++) {
11
            12
            if (right < left) right = left;
13
            14
            while (right < count && (idxArray[right] - idxArray[left] - (right - left)) <= val) {
15
                right++;
16
            }
17
            int length = right - left; 
18
            if (length >= count - val) return true;
19
        }
20
        return false;
21
    }
22
    23
    public static void main(String[] args) {
24
        Scanner scanner = new Scanner(System.in);
25
        int testCases = scanner.nextInt();
26
        27
        while(testCases-- > 0) {
28
            String input = scanner.next();
29
            int size = input.length();
30
            31
            ArrayList<Integer> positions = new ArrayList<>();
32
            for (int i = 0; i < size; i++) {
33
                if (input.charAt(i) == '1') {
34
                    positions.add(i);
35
                }
36
            }
37
            int count = positions.size();
38
            39
            if (count == 0) {
40
                System.out.println(0);
41
                continue;
42
            }
43
            44
            int[] idxArray = new int[count];
45
            for (int i = 0; i < count; i++) {
46
                idxArray[i] = positions.get(i);
47
            }
48
            49
            int left = 0, right = count, result = right;
50
            while (left <= right) {
51
                int mid = left + (right - left) / 2;
52
                if (check(mid, idxArray, count)) {
53
                    result = mid;
54
                    right = mid - 1;
55
                } else {
56
                    left = mid + 1;
57
                }
58
            }
59
            System.out.println(result);
60
        }
61
        scanner.close();
62
    }
63
}
64",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055820
1390055824,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055824
1390055818,unknown,unknown,unknown,"1
import sys
2
def calculate_min_removal_cost():
3
    input_data = sys.stdin.read().splitlines()
4
    test_cases = int(input_data[0].strip())
5
    current_line = 1
6
    results = []
7
    8
    for _ in range(test_cases):
9
        server_status = input_data[current_line].strip()
10
        current_line += 1
11
        total_servers = len(server_status)
12
        13
        active_indices = [i for i, server in enumerate(server_status) if server == '1']
14
        active_server_count = len(active_indices)
15
        16
        if active_server_count == 0:
17
            results.append(""0"")
18
            continue
19
        20
        adjusted_positions = [active_indices[i] - i for i in range(active_server_count)]
21
        22
        def is_removal_feasible(limit):
23
            if active_server_count - limit <= 0:
24
                return True
25
            j = 0
26
            for i in range(active_server_count):
27
                if j < i:
28
                    j = i
29
                while j < active_server_count and adjusted_positions[j] - adjusted_positions[i] <= limit:
30
                    j += 1
31
                if j - i >= active_server_count - limit:
32
                    return True
33
            return False
34
        35
        low, high, min_removal_cost = 0, total_servers, total_servers
36
        while low <= high:
37
            mid = (low + high) // 2
38
            if is_removal_feasible(mid):
39
                min_removal_cost = mid
40
                high = mid - 1
41
            else:
42
                low = mid + 1
43
        44
        results.append(str(min_removal_cost))
45
    46
    sys.stdout.write(""\n"".join(results))
47
    48
if __name__ == ""__main__"":
49
    calculate_min_removal_cost()
50",19,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055818
1390055815,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <algorithm>
4
5
using namespace std;
6
7
int computeCost(string dataCenters) {
8
     int size = dataCenters.size();
9
    int firstActiveIndex = dataCenters.find('1');
10
     int lastActiveIndex = dataCenters.rfind('1');
11
    12
    if (firstActiveIndex == string::npos) return 0;
13
14
    string activeSegment = dataCenters.substr(firstActiveIndex, lastActiveIndex - firstActiveIndex + 1);
15
    int inactiveCount = count(activeSegment.begin(), activeSegment.end(), '0');
16
    int  minShutdownCost = inactiveCount, activeRemoved = 0;  
17
18
    for (int index = firstActiveIndex; index <= lastActiveIndex; index++) {
19
        if (dataCenters[index] == '1') 
20
            activeRemoved++;
21
        else 
22
             inactiveCount--;
23
        minShutdownCost = min(minShutdownCost, max(inactiveCount, activeRemoved));
24
    }
25
26
    return minShutdownCost;
27
}
28
29
int main() {
30
    int testCases;
31
    cin >> testCases;
32
33
    while (testCases--) {
34
          string dataCenters;
35
        cin >> dataCenters;
36
        cout << computeCost(dataCenters) << endl;
37
    }
38
39
    return 0;
40
}
41",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055815
1390055816,unknown,unknown,unknown,"1
vimport java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055816
1390055814,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx+1])
10
        idx +=2
11
        a = list(map(int, input[idx:idx+n]))
12
        idx +=n
13
        sum_a = sum(a)
14
        v = []
15
        for i in range(n):
16
            val = a[i] - (n - i -1)
17
            v.append(val)
18
        v.sort(reverse=True)
19
        prefix = [0] * (n+1)
20
        for i in range(n):
21
            prefix[i+1] = prefix[i] + v[i]
22
        max_sum = 0
23
        max_t = min(k, n)
24
        for t in range(0, max_t+1):
25
            current = prefix[t] + t*(t-1)//2
26
            if current > max_sum:
27
                max_sum = current
28
        print(sum_a - max_sum)
29
30
if __name__ == ""__main__"":
31
    main()",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055814
1390055805,unknown,unknown,unknown,"1
def main():
2
    import sys
3
    input = sys.stdin.read().split()
4
    idx = 0
5
    T = int(input[idx])
6
    idx += 1
7
    for _ in range(T):
8
        n, k = int(input[idx]), int(input[idx+1])
9
        idx +=2
10
        a = list(map(int, input[idx:idx+n]))
11
        idx +=n
12
        sum_a = sum(a)
13
        gains = []
14
        for i in range(n):
15
            g = a[i] - (n - i - 1)
16
            gains.append(g)
17
        gains.sort(reverse=True)
18
        selected = gains[:k]
19
        sum_gain = sum(selected)
20
        sum_gain += k * (k - 1) // 2
21
        minimal_effort = sum_a - sum_gain
22
        print(minimal_effort)
23
24
if __name__ == ""__main__"":
25
    main()",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055805
1390055810,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class BinaryStringMinMoves {
5
    6
    // Function to check if a given X is feasible
7
    static boolean isFeasible(int X, int[] onesPositions, int onesCount) {
8
        if (X >= onesCount) return true; // If X is greater than total ones, it's always possible
9
        10
        int j = 0;
11
        for (int i = 0; i < onesCount; i++) {
12
            if (j < i) j = i;
13
14
            // Expand the window while the difference is within the allowed moves
15
            while (j < onesCount && (onesPositions[j] - onesPositions[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            19
            int consecutiveOnes = j - i; 
20
            if (consecutiveOnes >= onesCount - X) return true;
21
        }
22
        return false;
23
    }
24
25
    public static void main(String[] args) {
26
        Scanner scanner = new Scanner(System.in);
27
        int testCases = scanner.nextInt();
28
29
        while (testCases-- > 0) {
30
            String binaryString = scanner.next();
31
            int n = binaryString.length();
32
33
            List<Integer> onesIndices = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (binaryString.charAt(i) == '1') {
36
                    onesIndices.add(i);
37
                }
38
            }
39
40
            int onesCount = onesIndices.size();
41
42
            // If there are no '1's, no moves are required
43
            if (onesCount == 0) {
44
                System.out.println(0);
45
                continue;
46
            }
47
48
            // Convert list to array for faster access
49
            int[] onesPositions = new int[onesCount];
50
            for (int i = 0; i < onesCount; i++) {
51
                onesPositions[i] = onesIndices.get(i);
52
            }
53
54
            // Binary search to find the minimum feasible X
55
            int left = 0, right = onesCount, minMoves = right;
56
            while (left <= right) {
57
                int mid = left + (right - left) / 2;
58
                if (isFeasible(mid, onesPositions, onesCount)) {
59
                    minMoves = mid;
60
                    right = mid - 1;
61
                } else {
62
                    left = mid + 1;
63
                }
64
            }
65
66
            System.out.println(minMoves);
67
        }
68
        69
        scanner.close();
70
    }
71
}
72",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055810
1390055813,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
9
int main() {
10
11
12
13
14
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
15
    vector<int> results;
16
    17
    for (const string& servers : test_cases) {
18
        int n = servers.size();
19
        int total_0 = 0;
20
        for (char c : servers) {
21
            if (c == '0') total_0++;
22
        }
23
        int total_1 = n - total_0;
24
        25
        // Precompute prefix counts for 0s and 1s
26
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
27
        for (int i = 1; i <= n; ++i) {
28
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
29
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
30
        }
31
        32
        // Precompute suffix counts for 0s and 1s
33
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
34
        for (int j = 1; j <= n; ++j) {
35
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
36
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
37
        }
38
        39
        int min_cost = INT_MAX;
40
        41
        // Iterate over all possible prefixes (i)
42
        for (int i = 0; i <= n; ++i) {
43
            int j_max = n - i;
44
            int left = 0, right = j_max;
45
            int best_j = 0;
46
            int best_cost = INT_MAX;
47
            48
            // Binary search for the best j
49
            while (left <= right) {
50
                int mid = (left + right) / 2;
51
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
52
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
53
                int current_cost = max(remaining_0, decommissioned_1);
54
                55
                if (current_cost < best_cost) {
56
                    best_cost = current_cost;
57
                    best_j = mid;
58
                } else if (current_cost == best_cost && mid < best_j) {
59
                    best_j = mid;
60
                }
61
                62
                if (decommissioned_1 < remaining_0) {
63
                    left = mid + 1;
64
                } else {
65
                    right = mid - 1;
66
                }
67
            }
68
            69
            // Check neighboring j values
70
            for (int dj : {-1, 0, 1}) {
71
                int j = best_j + dj;
72
                if (j >= 0 && j <= j_max) {
73
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
74
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
75
                    int current_cost = max(remaining_0, decommissioned_1);
76
                    if (current_cost < best_cost) {
77
                        best_cost = current_cost;
78
                    }
79
                }
80
            }
81
            82
            if (best_cost < min_cost) {
83
                min_cost = best_cost;
84
            }
85
        }
86
        87
        results.push_back(min_cost);
88
    }
89
    90
    return results;
91
}
92
93
int main() {
94
    int T;
95
    cin >> T;
96
    vector<string> test_cases(T);
97
    for (int i = 0; i < T; ++i) {
98
        cin >> test_cases[i];
99
    }
100
    101
    vector<int> results = min_decommissioning_cost(test_cases);
102
    103
    for (int result : results) {
104
        cout << result << endl;
105
    }
106
    107
    return 0;
108
} 3rd
109
    return 0;
110
}
111",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055813
1390055800,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055800
1390055801,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055801
1390055804,unknown,unknown,unknown,"1
import java.util.Scanner;
2
import java.util.Arrays;
3
import java.util.Comparator;
4
5
public class FirewallBreach {
6
    public static void main(String[] args) {
7
        Scanner sc = new Scanner(System.in);
8
        int T = sc.nextInt(); // Number of test cases
9
        10
        while (T-- > 0) {
11
            int n = sc.nextInt(); // Number of firewalls
12
            int k = sc.nextInt(); // Maximum number of firewalls to skip
13
            14
            int[] strengths = new int[n];
15
            for (int i = 0; i < n; i++) {
16
                strengths[i] = sc.nextInt(); // Strength of each firewall
17
            }
18
            19
            // If we can skip all firewalls, the answer is 0
20
            if (k >= n) {
21
                System.out.println(0);
22
                continue;
23
            }
24
            25
            // We need to decide which firewalls to skip
26
            // Use a greedy approach: Skip the k firewalls with highest strength
27
            28
            // Create a pair of (strength, index) for each firewall
29
            final int[][] firewalls = new int[n][2];
30
            for (int i = 0; i < n; i++) {
31
                firewalls[i][0] = strengths[i]; // Strength
32
                firewalls[i][1] = i;            // Index
33
            }
34
            35
            // Sort firewalls by strength in descending order (Java 7 compatible)
36
            Arrays.sort(firewalls, new Comparator<int[]>() {
37
                @Override
38
                public int compare(int[] a, int[] b) {
39
                    return b[0] - a[0]; // Sort in descending order
40
                }
41
            });
42
            43
            // Mark the top k firewalls to skip
44
            boolean[] skip = new boolean[n];
45
            for (int i = 0; i < k; i++) {
46
                skip[firewalls[i][1]] = true;
47
            }
48
            49
            // Calculate the minimum effort
50
            long effort = 0;
51
            int skipped = 0;
52
            53
            for (int i = 0; i < n; i++) {
54
                if (skip[i]) {
55
                    skipped++;
56
                } else {
57
                    effort += strengths[i] + skipped;
58
                }
59
            }
60
            61
            System.out.println(effort);
62
        }
63
        64
        sc.close();
65
    }
66
}",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055804
1390055799,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if _name_ == ""_main_"":
45
    main()",20,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055799
1390055793,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055793
1390055796,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055796
1390055798,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt();
7
        sc.nextLine(); // Consume the newline character
8
9
        while (t-- > 0) {
10
            String servers = sc.nextLine();
11
            System.out.println(minDecommissioningCost(servers));
12
        }
13
        sc.close();
14
    }
15
16
    static int minDecommissioningCost(String servers) {
17
        int n = servers.length();
18
19
        int[] prefixOnes = new int[n + 1];
20
        int[] prefixZeros = new int[n + 1];
21
        22
        for (int i = 0; i < n; i++) {
23
            prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
24
            prefixZeros[i + 1] = prefixZeros[i] + (servers.charAt(i) == '0' ? 1 : 0);
25
        }
26
27
        int minCost = Integer.MAX_VALUE;
28
29
        for (int start = 0; start <= n; start++) {
30
            for (int end = start; end <= n; end++) {
31
                int activeRemoved = prefixOnes[start] + (prefixOnes[n] - prefixOnes[end]);
32
                int idleRemaining = prefixZeros[end] - prefixZeros[start];
33
34
                int cost = Math.max(idleRemaining, activeRemoved);
35
                minCost = Math.min(minCost, cost);
36
            }
37
        }
38
39
        return minCost;
40
    }
41
}
42",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055798
1390055780,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
3
    results = []
4
5
    for case in test_cases:
6
7
        n, k, a = case
8
9
        # Calculate the potential reduction for each firewall if skipped
10
11
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
12
13
        # Because skipping it increases the strength of all subsequent firewalls by 1
14
15
        # So, the net reduction is a[i] - (n - i - 1)
16
17
        reductions = []
18
19
        for i in range(n):
20
21
            reductions.append(a[i] - (n - i - 1))
22
23
        24
25
        # Select the top k reductions (most positive)
26
27
        # If a reduction is negative, it's better not to skip that firewall
28
29
        # So, we only consider positive reductions
30
31
        positive_reductions = [r for r in reductions if r > 0]
32
33
        positive_reductions.sort(reverse=True)
34
35
        36
37
        # Take the top min(k, len(positive_reductions)) reductions
38
39
        skip_count = min(k, len(positive_reductions))
40
41
        total_reduction = sum(positive_reductions[:skip_count])
42
43
        44
45
        # Calculate the total effort
46
47
        # Initial total effort is sum(a)
48
49
        # After skipping, the total effort is sum(a) - total_reduction
50
51
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
52
53
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
54
55
        # This is getting complicated. Let's think differently.
56
57
        58
59
        # Alternative approach:
60
61
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
62
63
        # Skip the top k firewalls in this order
64
65
        # Calculate the total effort accordingly
66
67
        68
69
        # Let's implement this alternative approach
70
71
        # Create a list of tuples (a[i], i)
72
73
        firewall_indices = [(a[i], i) for i in range(n)]
74
75
        # Sort by a[i] - (n - i - 1) in descending order
76
77
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
78
79
        80
81
        # Select the top k firewalls to skip
82
83
        skip_indices = set()
84
85
        for i in range(min(k, n)):
86
87
            skip_indices.add(firewall_indices[i][1])
88
89
        90
91
        # Calculate the total effort
92
93
        total_effort = 0
94
95
        increase = 0
96
97
        for i in range(n):
98
99
            if i in skip_indices:
100
101
                increase += 1
102
103
            else:
104
105
                total_effort += a[i] + increase
106
107
        108
109
        results.append(total_effort)
110
111
    return results
112
113
# Read input
114
115
T = int(input())
116
117
test_cases = []
118
119
for _ in range(T):
120
121
    n, k = map(int, input().split())
122
123
    a = list(map(int, input().split()))
124
125
    test_cases.append((n, k, a))
126
127
# Compute results
128
129
results = min_effort(test_cases)
130
131
# Output results
132
133
for res in results:
134
135
    print(res)",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055780
1390055792,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
    T = s.count('1')
3
    if T == 0:
4
        return 0
5
    n = len(s)
6
    7
    # Compute x_max_case1: max number of 1's in window of length T
8
    x_max_case1 = 0
9
    if T <= n:
10
        current = sum(1 for c in s[:T] if c == '1')
11
        x_max_case1 = current
12
        for i in range(1, n - T + 1):
13
            if s[i-1] == '1':
14
                current -= 1
15
            if s[i + T - 1] == '1':
16
                current += 1
17
            if current > x_max_case1:
18
                x_max_case1 = current
19
    20
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
21
    x_max_case2 = 0
22
    current_run = 0
23
    for c in s:
24
        if c == '1':
25
            current_run += 1
26
        else:
27
            if current_run > 0:
28
                candidate = min(current_run, T-1)
29
                if candidate > x_max_case2:
30
                    x_max_case2 = candidate
31
                current_run = 0
32
    # Check the last run
33
    if current_run > 0:
34
        candidate = min(current_run, T-1)
35
        if candidate > x_max_case2:
36
            x_max_case2 = candidate
37
    38
    case1_cost = T - x_max_case1
39
    case2_cost = T - x_max_case2
40
    return min(case1_cost, case2_cost)
41
42
def main():
43
    import sys
44
    input = sys.stdin.read().split()
45
    T_cases = int(input[0])
46
    for i in range(1, T_cases + 1):
47
        s = input[i]
48
        print(compute_min_cost(s))
49
50
if name == ""main"":
51
    main()",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055792
1390055786,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055786
1390055774,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055774
1390055776,unknown,unknown,unknown,"1
def feasible(X, ones_indices, total1):
2
    if X >= total1:
3
        return True
4
    j = 0
5
    for i in range(total1):
6
        if j < i:
7
            j = i
8
        while j < total1 and (ones_indices[j] - ones_indices[i] - (j - i)) <= X:
9
            j += 1
10
        m = j - i
11
        if m >= total1 - X:
12
            return True
13
    return False
14
15
def min_operations_to_make_continuous(s):
16
    ones_indices = [i for i, ch in enumerate(s) if ch == '1']
17
    total1 = len(ones_indices)
18
19
    if total1 == 0:
20
        return 0
21
22
    low, high, ans = 0, total1, total1
23
    while low <= high:
24
        mid = low + (high - low) // 2
25
        if feasible(mid, ones_indices, total1):
26
            ans = mid
27
            high = mid - 1
28
        else:
29
            low = mid + 1
30
    return ans
31
32
T = int(input())
33
for _ in range(T):
34
    s = input().strip()
35
    print(min_operations_to_make_continuous(s))
36",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055776
1390055777,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()  # Deque to store indices of negative numbers
6
    7
    # Process the first window of size k
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process the remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the current window
18
        while dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
        21
        # Add the new element if it is negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the result for the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
def main():
31
    t = int(input().strip())  # Number of test cases
32
    for _ in range(t):
33
        n, k = map(int, input().split())  # Read n and k
34
        arr = list(map(int, input().split()))  # Read array elements
35
        36
        # Get the earliest faulty readings
37
        output = earliest_faulty_readings(arr, k)
38
        39
        # Print result as space-separated values
40
        print("" "".join(map(str, output)))
41
42
if __name__ == ""__main__"":
43
    main()
44",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055777
1390055771,unknown,unknown,unknown,"1
import sys
2
3
def min_effort(n, k, strengths):
4
    total_effort = sum(strengths)  # Sum of all firewall strengths
5
    if k == n:
6
        return 0  # If we can skip all firewalls, minimum effort is 0
7
    return total_effort - min(strengths)  # Remove the weakest firewall to minimize effort
8
9
# Fast input reading for large constraints
10
input = sys.stdin.read
11
data = input().split(""\n"")
12
13
T = int(data[0].strip())  # Number of test cases
14
index = 1  # To track input lines
15
16
results = []
17
18
for _ in range(T):
19
    n, k = map(int, data[index].split())  # Number of firewalls and skippable count
20
    strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
21
    results.append(str(min_effort(n, k, strengths)))  # Compute and store results
22
    index += 2  # Move to next test case
23
24
# Print all results efficiently in one go
25
sys.stdout.write(""\n"".join(results) + ""\n"")
26",21,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055771
1390055760,unknown,unknown,unknown,"1
import sys
2
def solve():
3
    x = sys.stdin.buffer.read().split()
4
    if not x: return
5
    t = int(x[0])
6
    i = 1
7
    o = []
8
    for _ in range(t):
9
        s = x[i].decode()
10
        i += 1
11
        n = len(s)
12
        A = [0]*(n+1)
13
        B = [0]*(n+1)
14
        for j in range(n):
15
            B[j+1] = B[j] + (s[j]=='1')
16
            A[j+1] = A[j] + (s[j]=='0')
17
        T = A[n]
18
        C = [0]*(n+1)
19
        E = [0]*(n+1)
20
        for j in range(n):
21
            E[j+1] = E[j] + (s[n-1-j]=='1')
22
            C[j+1] = C[j] + (s[n-1-j]=='0')
23
        r = 10**9
24
        for x_ in range(n+1):
25
            m = n - x_
26
            y = T - A[x_] - B[x_]
27
            if y < 0: y = 0
28
            if y > m: y = m
29
            for z in (y, y-1, y+1):
30
                if z < 0 or z > m: continue
31
                v1 = B[x_] + E[z]
32
                v2 = T - (A[x_] + C[z])
33
                v = v1 if v1 >= v2 else v2
34
                if v < r: r = v
35
        o.append(str(r))
36
    sys.stdout.write(""\n"".join(o))
37
if __name__==""__main__"":
38
    solve()",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055760
1390055765,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055765
1390055767,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) throws IOException {
6
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
7
        int t = Integer.parseInt(br.readLine().trim());
8
9
        StringBuilder sb = new StringBuilder();
10
        for (int testCase = 0; testCase < t; testCase++) {
11
            String[] nk = br.readLine().trim().split("" "");
12
            int n = Integer.parseInt(nk[0]);
13
            int k = Integer.parseInt(nk[1]);
14
15
            int[] strengths = new int[n];
16
            String[] vals = br.readLine().trim().split("" "");
17
            for (int i = 0; i < n; i++) {
18
                strengths[i] = Integer.parseInt(vals[i]);
19
            }
20
21
            sb.append(minimumEffort(strengths, k)).append(""\n"");
22
        }
23
        System.out.print(sb);
24
    }
25
26
    public static long minimumEffort(int[] strengths, int k) {
27
        int n = strengths.length;
28
29
        if (k >= n) {
30
            return 0;
31
        }
32
33
        long[] savings = new long[n];
34
        for (int i = 0; i < n; i++) {
35
            savings[i] = strengths[i];
36
            savings[i] += n - i - 1;
37
        }
38
39
        PriorityQueue<Long> pq = new PriorityQueue<>(Collections.reverseOrder());
40
        for (int i = 0; i < n; i++) {
41
            pq.offer(savings[i]);
42
        }
43
44
        long totalCost = 0;
45
        for (int i = 0; i < n; i++) {
46
            totalCost += strengths[i];
47
        }
48
49
        long totalSavings = 0;
50
        for (int i = 0; i < k && !pq.isEmpty(); i++) {
51
            totalSavings += pq.poll();
52
        }
53
54
        return totalCost - totalSavings + (long) k * (k - 1) / 2;
55
    }
56
}
57",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055767
1390055755,unknown,unknown,unknown,"1
t = int(input())  
2
for _ in range(t):
3
    n, k = map(int, input().split())  
4
    firewall = list(map(int, input().split())) 
5
    if n==k:
6
        print(0)
7
        continue
8
9
    totaleffort = sum(firewall)  
10
    mineffort = totaleffort  
11
    for i in range(n):  
12
        skipeffort = totaleffort - firewall[i] + 1  
13
        mineffort = min(mineffort, skipeffort) 
14
15
    print(mineffort)  
16",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055755
1390055759,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055759
1390055757,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
9
int main() {
10
11
12
using namespace std;
13
14
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
15
    vector<int> results;
16
    17
    for (const string& servers : test_cases) {
18
        int n = servers.size();
19
        int total_0 = 0;
20
        for (char c : servers) {
21
            if (c == '0') total_0++;
22
        }
23
        int total_1 = n - total_0;
24
        25
        // Precompute prefix counts for 0s and 1s
26
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
27
        for (int i = 1; i <= n; ++i) {
28
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
29
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
30
        }
31
        32
        // Precompute suffix counts for 0s and 1s
33
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
34
        for (int j = 1; j <= n; ++j) {
35
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
36
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
37
        }
38
        39
        int min_cost = INT_MAX;
40
        41
        // Iterate over all possible prefixes (i)
42
        for (int i = 0; i <= n; ++i) {
43
            int j_max = n - i;
44
            int left = 0, right = j_max;
45
            int best_j = 0;
46
            int best_cost = INT_MAX;
47
            48
            // Binary search for the best j
49
            while (left <= right) {
50
                int mid = (left + right) / 2;
51
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
52
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
53
                int current_cost = max(remaining_0, decommissioned_1);
54
                55
                if (current_cost < best_cost) {
56
                    best_cost = current_cost;
57
                    best_j = mid;
58
                } else if (current_cost == best_cost && mid < best_j) {
59
                    best_j = mid;
60
                }
61
                62
                if (decommissioned_1 < remaining_0) {
63
                    left = mid + 1;
64
                } else {
65
                    right = mid - 1;
66
                }
67
            }
68
            69
            // Check neighboring j values
70
            for (int dj : {-1, 0, 1}) {
71
                int j = best_j + dj;
72
                if (j >= 0 && j <= j_max) {
73
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
74
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
75
                    int current_cost = max(remaining_0, decommissioned_1);
76
                    if (current_cost < best_cost) {
77
                        best_cost = current_cost;
78
                    }
79
                }
80
            }
81
            82
            if (best_cost < min_cost) {
83
                min_cost = best_cost;
84
            }
85
        }
86
        87
        results.push_back(min_cost);
88
    }
89
    90
    return results;
91
}
92
93
int main() {
94
    int T;
95
    cin >> T;
96
    vector<string> test_cases(T);
97
    for (int i = 0; i < T; ++i) {
98
        cin >> test_cases[i];
99
    }
100
    101
    vector<int> results = min_decommissioning_cost(test_cases);
102
    103
    for (int result : results) {
104
        cout << result << endl;
105
    }
106
    107
    return 0;
108
} 3rd
109
    return 0;
110
}
111",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055757
1390055746,unknown,unknown,unknown,"1
import sys
2
3
def min_effort_to_breach(T, test_cases):
4
    results = []
5
    6
    for n, k, firewalls in test_cases:
7
        firewalls.sort()  # Sorting helps prioritize skipping the weakest firewalls
8
        total_effort = sum(firewalls)  # Base effort if we dont skip anything
9
        min_effort = total_effort
10
11
        # Compute prefix sum to quickly access sum of first 'i' firewalls
12
        prefix_sum = [0] * (n + 1)
13
        for i in range(n):
14
            prefix_sum[i + 1] = prefix_sum[i] + firewalls[i]
15
16
        # Try skipping from 0 to k firewalls
17
        for skip in range(k + 1):
18
            skipped_effort = prefix_sum[skip]  # Sum of skipped firewalls
19
            remaining_count = n - skip  # Firewalls left after skipping
20
            penalty = remaining_count * skip  # Extra cost due to increased strength
21
            22
            new_effort = (total_effort - skipped_effort) + penalty
23
            min_effort = min(min_effort, new_effort)  # Track the minimum effort
24
        25
        results.append(str(min_effort))  # Store the result
26
27
    sys.stdout.write(""\n"".join(results) + ""\n"")  # Fast output handling
28
29
# **Input Handling**
30
T = int(sys.stdin.readline().strip())  # Number of test cases
31
test_cases = []
32
33
for _ in range(T):
34
    n, k = map(int, sys.stdin.readline().split())
35
    firewalls = list(map(int, sys.stdin.readline().split()))
36
    test_cases.append((n, k, firewalls))
37
38
# **Function Call**
39
min_effort_to_breach(T, test_cases)
40",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055746
1390055749,unknown,unknown,unknown,"1
def mb(n,k,s):
2
    if k>=n:
3
        return 0
4
    impacts=[]
5
    for i in range(n):
6
        impact=s[i]-(n-i-1)
7
        impacts.append((impact,i))
8
    impacts.sort(reverse=True)
9
    ts=set(impacts[i][1]for i in range(k))
10
    te=0
11
    p=0
12
    for i in range(n):
13
        if i in ts:
14
            p+=1
15
        else:
16
            te+=s[i]+p
17
    return te
18
def st():
19
    t=int(input())
20
    results=[]
21
    for _ in range(t):
22
        n,k=map(int,input().split())
23
        s=list(map(int,input().split()))
24
        results.append(mb(n,k,s))
25
    return results
26
def main():
27
    results=st()
28
    for r in results:
29
        print(r)
30
if __name__==""__main__"":
31
    main()
32",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055749
1390055753,unknown,unknown,unknown,"1
def min_effort(n,k,strengths):
2
    3
    strengths.sort()
4
    5
    return sum(strengths[1 + k:])
6
7
8
t = int(input().strip())
9
for _ in range(t):
10
    n,k = map(int, input().strip().split())
11
    strengths = list(map(int, input().strip().split()))
12
    if k >= n:
13
        print(0)
14
    else:
15
        print(min_effort(n,k,strengths))",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055753
1390055745,unknown,unknown,unknown,"1
import sys
2
3
def min_effort(n, k, firewalls):
4
    if k == n:
5
        return 0  # If we can skip all firewalls, effort is 0.
6
    return sum(firewalls) - min(firewalls)  # Skip the weakest firewall.
7
8
# Fast input handling
9
input = sys.stdin.read
10
data = input().split(""\n"")
11
T = int(data[0].strip())
12
13
index = 1
14
results = []
15
for _ in range(T):
16
    n, k = map(int, data[index].split())
17
    firewalls = list(map(int, data[index + 1].split()))
18
    results.append(str(min_effort(n, k, firewalls)))
19
    index += 2
20
21
# Output results efficiently
22
sys.stdout.write(""\n"".join(results) + ""\n"")
23",22,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055745
1390055733,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
}",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055733
1390055734,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    firewalls.sort()  
3
    effort = sum(firewalls[:n - k])  
4
    return effort
5
6
t = int(input().strip())
7
for _ in range(t):
8
    n, k = map(int, input().strip().split())
9
    firewalls = list(map(int, input().strip().split()))
10
    print(min_effort(n, k, firewalls))
11",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055734
1390055743,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
45
main()",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055743
1390055725,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); 
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
        28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
        79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055725
1390055724,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt();
7
8
        while (T-- > 0) {
9
            int n = scanner.nextInt();
10
            int k = scanner.nextInt();
11
            int[] a = new int[n];
12
            int sum_a = 0;
13
14
            for (int i = 0; i < n; i++) {
15
                a[i] = scanner.nextInt();
16
                sum_a += a[i];
17
            }
18
19
            List<Integer> v = new ArrayList<>();
20
            for (int i = 0; i < n; i++) {
21
                v.add(a[i] - (n - i - 1));
22
            }
23
24
            v.sort(Collections.reverseOrder());
25
26
            int[] prefix = new int[n + 1];
27
            for (int i = 0; i < n; i++) {
28
                prefix[i + 1] = prefix[i] + v.get(i);
29
            }
30
31
            int max_sum = 0;
32
            int max_t = Math.min(k, n);
33
            for (int t = 0; t <= max_t; t++) {
34
                int current = prefix[t] + t * (t - 1) / 2;
35
                max_sum = Math.max(max_sum, current);
36
            }
37
38
            System.out.println(sum_a - max_sum);
39
        }
40
        scanner.close();
41
    }
42
}
43",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055724
1390055730,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases): 
2
    results = []
3
    4
    for s in test_cases:
5
        n = len(s)
6
        7
        prefix_ones = [0] * (n + 1)
8
        prefix_zeros = [0] * (n + 1)
9
        10
        for i in range(1, n + 1):
11
            prefix_ones[i] = prefix_ones[i - 1] + (1 if s[i - 1] == '1' else 0)
12
            prefix_zeros[i] = prefix_zeros[i - 1] + (1 if s[i - 1] == '0' else 0)
13
        14
        total_ones = prefix_ones[n]
15
        total_zeros = prefix_zeros[n]
16
        17
        min_cost = float('inf')
18
        19
        for i in range(n):
20
            for j in range(i + 1, n + 1):
21
                ones_in_subarray = prefix_ones[j] - prefix_ones[i]
22
                zeros_in_subarray = prefix_zeros[j] - prefix_zeros[i]
23
                removed_ones = total_ones - ones_in_subarray
24
                cost = max(zeros_in_subarray, removed_ones)
25
                min_cost = min(min_cost, cost)
26
        27
        results.append(min_cost)
28
    29
    return results
30
31
T = int(input())  
32
test_cases = [input().strip() for _ in range(T)]
33
34
results = min_decommissioning_cost(test_cases)
35
36
for result in results:
37
    print(result)
38",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055730
1390055715,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    static boolean feasible(int X, int[] onesIndices, int total1) {
6
        if (X >= total1) return true;
7
        int j = 0;
8
        for (int i = 0; i < total1; i++) {
9
            if (j < i) j = i;
10
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
11
                j++;
12
            }
13
            int m = j - i;
14
            if (m >= total1 - X) return true;
15
        }
16
        return false;
17
    }
18
    19
    public static void main(String[] args) {
20
        Scanner sc = new Scanner(System.in);
21
        int T = sc.nextInt();
22
        23
        while(T-- > 0) {
24
            String s = sc.next();
25
            int n = s.length();
26
            27
            ArrayList<Integer> onesList = new ArrayList<>();
28
            for (int i = 0; i < n; i++) {
29
                if (s.charAt(i) == '1') {
30
                    onesList.add(i);
31
                }
32
            }
33
            int total1 = onesList.size();
34
            35
            if (total1 == 0) {
36
                System.out.println(0);
37
                continue;
38
            }
39
            40
            int[] onesIndices = new int[total1];
41
            for (int i = 0; i < total1; i++) {
42
                onesIndices[i] = onesList.get(i);
43
            }
44
            45
            int low = 0, high = total1, ans = high;
46
            while (low <= high) {
47
                int mid = low + (high - low) / 2;
48
                if (feasible(mid, onesIndices, total1)) {
49
                    ans = mid;
50
                    high = mid - 1;
51
                } else {
52
                    low = mid + 1;
53
                }
54
            }
55
            System.out.println(ans);
56
        }
57
        sc.close();
58
    }
59
}",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055715
1390055716,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        18
        A = [positions[i] - i for i in range(m)]
19
        20
    21
        def check(X):
22
            23
            if m - X <= 0:
24
                return True
25
            j = 0
26
            for i in range(m):
27
                if j < i:
28
                    j = i
29
                30
                while j < m and A[j] - A[i] <= X:
31
                    j += 1
32
                if j - i >= m - X:
33
                    return True
34
            return False
35
36
        37
        lo, hi, ans = 0, n, n
38
        while lo <= hi:
39
            mid = (lo + hi) // 2
40
            if check(mid):
41
                ans = mid
42
                hi = mid - 1
43
            else:
44
                lo = mid + 1
45
        out_lines.append(str(ans))
46
    47
    sys.stdout.write(""\n"".join(out_lines))
48
    49
if __name__ == '__main__':
50
    solve()",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055716
1390055717,unknown,unknown,unknown,"1
def m(n, k, a):
2
    if k >= n:
3
        return 0
4
    L = []
5
    for i in range(n):
6
        L.append((a[i] - (n - i - 1), i))
7
    L.sort(reverse=True)
8
    S = set(x[1] for x in L[:k])
9
    t = 0
10
    p = 0
11
    for i in range(n):
12
        if i in S:
13
            p += 1
14
        else:
15
            t += a[i] + p
16
    return t
17
18
def s():
19
    t = int(input())
20
    r = []
21
    for _ in range(t):
22
        n, k = map(int, input().split())
23
        a = list(map(int, input().split()))
24
        r.append(m(n, k, a))
25
    return r
26
27
def main():
28
    for x in s():
29
        print(x)
30
31
if __name__ == ""__main__"":
32
    main()
33",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055717
1390055711,unknown,unknown,unknown,"1
t = int(input())  
2
3
for _ in range(t):  
4
    n, k = map(int, input().split())  
5
    firewalls = list(map(int, input().split()))  
6
7
    if k >= n:  
8
        print(0)  
9
        continue  
10
11
    min_effort = sum(firewalls)  
12
13
    for i in range(n - k + 1):  
14
        effort = 0  
15
        skipped = 0  
16
17
        for j in range(n):  
18
            if i <= j < i + k:  
19
                skipped += 1  
20
                continue  
21
22
            effort += firewalls[j] + skipped  
23
24
        min_effort = min(min_effort, effort)  
25
26
    print(min_effort)  
27",23,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055711
1390055706,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
using ll = long long;
5
6
int main() {
7
    ios::sync_with_stdio(false);
8
    cin.tie(0);
9
10
    int T;
11
    cin >> T;
12
    for (int t = 0; t < T; t++) {
13
        int n, k;
14
        cin >> n >> k;
15
        vector<ll> a(n);
16
        for (int i = 0; i < n; i++) {
17
            cin >> a[i];
18
        }
19
20
        const ll INF = 1e18;
21
22
        vector<ll> prev(k + 1, INF);
23
        prev[0] = 0; 
24
25
        for (int i = 0; i < n; i++) {
26
            vector<ll> curr(k + 1, INF);
27
            for (int s = 0; s <= k; s++) {
28
                // Don't skip i
29
                curr[s] = prev[s] + a[i] + s;
30
                if (s > 0) {
31
                    curr[s] = min(curr[s], prev[s - 1]);
32
                }
33
            }
34
            prev = curr; 
35
        }
36
37
        ll ans = *min_element(prev.begin(), prev.end());
38
        cout << ans << '\n';
39
    }
40
    return 0;
41
}",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055706
1390055710,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    min_total_effort = float('inf')
3
    4
    dp = [[float('inf') for _ in range(k+1)] for _ in range(n+1)]
5
    dp[0][0] = 0  
6
    7
    for i in range(1, n+1):
8
        current_strength = strengths[i-1]
9
        10
        for j in range(k+1):
11
            if dp[i-1][j] != float('inf'):
12
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
13
        14
        for j in range(1, k+1):
15
            if dp[i-1][j-1] != float('inf'):
16
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
17
    18
    return min(dp[n])
19
20
def solve_test_cases():
21
    t = int(input())  
22
    23
    results = []
24
    for _ in range(t):
25
        n, k = map(int, input().split())
26
        strengths = list(map(int, input().split()))
27
        28
        min_effort = min_effort_to_breach(n, k, strengths)
29
        results.append(min_effort)
30
    31
    return results
32
33
if __name__ == ""__main__"":
34
    results = solve_test_cases()
35
    for result in results:
36
        print(result)",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055710
1390055709,unknown,unknown,unknown,"1
import sys
2
3
def min_pruning_cost(T, test_cases):
4
    results = []
5
    6
    for servers in test_cases:
7
        first_one = servers.find('1')  # First occurrence of '1'
8
        last_one = servers.rfind('1')  # Last occurrence of '1'
9
10
        if first_one == -1:  # No '1' present in the string
11
            results.append(""0"")
12
            continue
13
14
        # Core section between first and last '1'
15
        core_section = servers[first_one:last_one + 1]
16
        idle_remaining = core_section.count('0')  # Count '0's in core section
17
        18
        # Active servers removed from edges
19
        active_removed = servers[:first_one].count('1') + servers[last_one + 1:].count('1')
20
        21
        # Minimum cost
22
        results.append(str(max(idle_remaining, active_removed)))
23
24
    # Print all results efficiently
25
    sys.stdout.write(""\n"".join(results) + ""\n"")
26
27
# **Input Handling**
28
T = int(sys.stdin.readline().strip())  # Number of test cases
29
test_cases = [sys.stdin.readline().strip() for _ in range(T)]
30
31
# **Function Call**
32
min_pruning_cost(T, test_cases)
33",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055709
1390055697,unknown,unknown,unknown,"1
def minimize_decommission_cost(test_cases):
2
    results = []
3
4
    for binary_string in test_cases:
5
        n = len(binary_string)
6
        total_idle = binary_string.count('0') 
7
        total_active = binary_string.count('1')  
8
9
        min_cost = float('inf')  
10
11
        12
        for start in range(n + 1):  
13
            for end in range(n - start + 1):  
14
                15
                remaining = binary_string[start:n - end]
16
17
                18
                remaining_idle = remaining.count('0')
19
                decommissioned_active = total_active - remaining.count('1')
20
21
                22
                cost = max(remaining_idle, decommissioned_active)
23
                min_cost = min(min_cost, cost)
24
25
        results.append(min_cost)
26
27
    return results
28
29
30
31
T = int(input().strip())
32
test_cases = [input().strip() for _ in range(T)]
33
34
35
results = minimize_decommission_cost(test_cases)
36
for result in results:
37
    print(result)
38",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055697
1390055699,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    static boolean isFeasible(int maxShifts, int[] onePositions, int totalOnes) {
7
        if (maxShifts >= totalOnes) return true;
8
        9
        int right = 0;
10
        for (int left = 0; left < totalOnes; left++) {
11
            if (right < left) right = left;
12
            13
            while (right < totalOnes && (onePositions[right] - onePositions[left] - (right - left)) <= maxShifts) {
14
                right++;
15
            }
16
            17
            int consecutive = right - left;
18
            if (consecutive >= totalOnes - maxShifts) return true;
19
        }
20
        return false;
21
    }
22
    23
    public static void main(String[] args) {
24
        Scanner scanner = new Scanner(System.in);
25
        int testCases = scanner.nextInt();
26
        27
        while (testCases-- > 0) {
28
            String input = scanner.next();
29
            int length = input.length();
30
            31
            List<Integer> oneIndicesList = new ArrayList<>();
32
            for (int i = 0; i < length; i++) {
33
                if (input.charAt(i) == '1') {
34
                    oneIndicesList.add(i);
35
                }
36
            }
37
            38
            int totalOnes = oneIndicesList.size();
39
            40
            if (totalOnes == 0) {
41
                System.out.println(0);
42
                continue;
43
            }
44
            45
            int[] onePositions = new int[totalOnes];
46
            for (int i = 0; i < totalOnes; i++) {
47
                onePositions[i] = oneIndicesList.get(i);
48
            }
49
            50
            int low = 0, high = totalOnes, result = high;
51
            while (low <= high) {
52
                int mid = low + (high - low) / 2;
53
                if (isFeasible(mid, onePositions, totalOnes)) {
54
                    result = mid;
55
                    high = mid - 1;
56
                } else {
57
                    low = mid + 1;
58
                }
59
            }
60
            System.out.println(result);
61
        }
62
        scanner.close();
63
    }
64
}
65",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055699
1390055701,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055701
1390055693,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
using ll = long long;
5
6
int main() {
7
    // Optimize input/output
8
    ios::sync_with_stdio(false);
9
    cin.tie(0);
10
11
    int T;
12
    cin >> T;
13
    for (int t = 0; t < T; t++) {
14
        int n, k;
15
        cin >> n >> k;
16
        vector<ll> a(n);
17
        for (int i = 0; i < n; i++) {
18
            cin >> a[i];
19
        }
20
21
        // INF for impossible states , really tough one to solved actually 
22
        const ll INF = 1e18;
23
24
        vector<ll> prev(k + 1, INF);
25
        prev[0] = 0; 
26
27
    28
        for (int i = 0; i < n; i++) {
29
            vector<ll> curr(k + 1, INF);
30
            for (int s = 0; s <= k; s++) {
31
                // Don't skip i
32
                curr[s] = prev[s] + a[i] + s;
33
                // Skip i (if possible)
34
                if (s > 0) {
35
                    curr[s] = min(curr[s], prev[s - 1]);
36
                }
37
            }
38
            prev = curr; 
39
        }
40
41
42
        ll ans = *min_element(prev.begin(), prev.end());
43
        cout << ans << '\n';
44
    }
45
    return 0;
46
}",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055693
1390055694,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
    public static List<Integer> earliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>();
7
8
        for (int i = 0; i < arr.length; i++) {
9
            // Remove out-of-window elements
10
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
11
                deque.poll();
12
            }
13
14
            // Add new faulty readings
15
            if (arr[i] < 0) {
16
                deque.offer(i);
17
            }
18
19
            // Collect results for valid windows
20
            if (i >= k - 1) {
21
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
22
            }
23
        }
24
        return result;
25
    }
26
27
    public static void main(String[] args) {
28
        Scanner scanner = new Scanner(System.in);
29
        int t = scanner.nextInt(); // Number of test cases
30
31
        while (t-- > 0) {
32
            int n = scanner.nextInt(); // Array size
33
            int k = scanner.nextInt(); // Batch size
34
            int[] arr = new int[n];
35
36
            for (int i = 0; i < n; i++) {
37
                arr[i] = scanner.nextInt();
38
            }
39
40
            // Compute and print results
41
            List<Integer> faults = earliestFaults(arr, k);
42
            for (int val : faults) {
43
                System.out.print(val + "" "");
44
            }
45
            System.out.println();
46
        }
47
        scanner.close();
48
    }
49
}",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055694
1390055695,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int t = sc.nextInt();
8
9
        while (t-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
14
            for (int i = 0; i < n; i++) {
15
                a[i] = sc.nextInt();
16
            }
17
18
            int[][] dp = new int[n + 1][k + 1];
19
            for (int[] row : dp) Arrays.fill(row, -1);
20
21
            int result = solveDP(0, k, 0, a, dp);
22
            System.out.println(result);
23
        }
24
        sc.close();
25
    }
26
27
    static int solveDP(int index, int remainingSkips, int skippedCount, int[] a, int[][] dp) {
28
        if (index == a.length) return 0;
29
        if (dp[index][remainingSkips] != -1) return dp[index][remainingSkips];
30
31
        int skipEffort = Integer.MAX_VALUE;
32
        if (remainingSkips > 0) {
33
            skipEffort = solveDP(index + 1, remainingSkips - 1, skippedCount + 1, a, dp);
34
        }
35
36
        int takeEffort = a[index] + skippedCount + solveDP(index + 1, remainingSkips, skippedCount, a, dp);
37
38
        dp[index][remainingSkips] = Math.min(skipEffort, takeEffort);
39
        return dp[index][remainingSkips];
40
    }
41
}
42
43",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055695
1390055684,unknown,unknown,unknown,"1
import sys
2
3
def min_pruning_cost():
4
    input_data = sys.stdin.read().splitlines()
5
    t = int(input_data[0].strip())
6
    line = 1
7
    results = []
8
    9
    for _ in range(t):
10
        servers = input_data[line].strip()
11
        line += 1
12
        n = len(servers)
13
        14
        active_positions = [i for i, ch in enumerate(servers) if ch == '1']
15
        active_count = len(active_positions)
16
        17
        if active_count == 0:
18
            results.append(""0"")
19
            continue
20
        21
        offset_positions = [active_positions[i] - i for i in range(active_count)]
22
        23
        def is_valid_pruning(limit):
24
            if active_count - limit <= 0:
25
                return True
26
            j = 0
27
            for i in range(active_count):
28
                if j < i:
29
                    j = i
30
                while j < active_count and offset_positions[j] - offset_positions[i] <= limit:
31
                    j += 1
32
                if j - i >= active_count - limit:
33
                    return True
34
            return False
35
        36
        lo, hi, min_cost = 0, n, n
37
        while lo <= hi:
38
            mid = (lo + hi) // 2
39
            if is_valid_pruning(mid):
40
                min_cost = mid
41
                hi = mid - 1
42
            else:
43
                lo = mid + 1
44
        45
        results.append(str(min_cost))
46
    47
    sys.stdout.write(""\n"".join(results))
48
    49
if __name__ == ""__main__"":
50
    min_pruning_cost()",24,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055684
1390055678,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()
46",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055678
1390055681,unknown,unknown,unknown,"1
def min_effort_to_breach(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
8
    dp[0][0] = 0
9
    10
    for i in range(1, n + 1):
11
        fw = firewalls[i - 1]
12
        13
        for j in range(k + 1):
14
            if j <= i - 1:
15
                dp[i][j] = min(dp[i][j], dp[i-1][j] + fw + j)
16
            17
            if j > 0:
18
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
19
    20
    return min(dp[n])
21
22
import sys
23
input = sys.stdin.readline
24
25
t = int(input())
26
for _ in range(t):
27
    n, k = map(int, input().split())
28
    firewalls = list(map(int, input().split()))
29
    print(min_effort_to_breach(firewalls, k))",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055681
1390055683,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommission {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt();  // Number of test cases
7
        scanner.nextLine();         // Consume the leftover newline
8
9
        while (T-- > 0) {
10
            String servers = scanner.nextLine();
11
            int n = servers.length();
12
13
            // Build prefix sums for '1's and '0's
14
            // prefixOnes[i] = number of '1's in servers[0..i-1]
15
            // prefixZeroes[i] = number of '0's in servers[0..i-1]
16
            int[] prefixOnes = new int[n + 1];
17
            int[] prefixZeroes = new int[n + 1];
18
19
            for (int i = 0; i < n; i++) {
20
                prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
21
                prefixZeroes[i + 1] = prefixZeroes[i] + (servers.charAt(i) == '0' ? 1 : 0);
22
            }
23
24
            // Total number of '1's in the entire string
25
            int totalOnes = prefixOnes[n];
26
            27
            int minCost = Integer.MAX_VALUE;
28
29
            // Try every subarray [L, R) as the portion we keep
30
            // We remove [0..L) from the front and [R..n) from the end
31
            for (int L = 0; L <= n; L++) {
32
                for (int R = L; R <= n; R++) {
33
                    // Number of 0s in [L, R) = prefixZeroes[R] - prefixZeroes[L]
34
                    int zeroesInSubarray = prefixZeroes[R] - prefixZeroes[L];
35
                    36
                    // Number of 1s in [L, R) = prefixOnes[R] - prefixOnes[L]
37
                    int onesInSubarray = prefixOnes[R] - prefixOnes[L];
38
                    39
                    // # of 1s removed = totalOnes - onesInSubarray
40
                    // # of 0s remaining = zeroesInSubarray
41
                    int cost = Math.max(zeroesInSubarray, totalOnes - onesInSubarray);
42
43
                    if (cost < minCost) {
44
                        minCost = cost;
45
                    }
46
                }
47
            }
48
49
            System.out.println(minCost);
50
        }
51
        scanner.close();
52
    }
53
}",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055683
1390055672,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <bits/stdc++.h>
7
using namespace std;
8
9
long long solve(vector<int>&arr, int i, int skip, int inc,vector<vector<long long>>&dp) {
10
    int n = arr.size();
11
    if(i==n){
12
        return 0;
13
    }
14
    if(dp[i][skip]!=-1)return dp[i][skip];
15
    //skip
16
    long long ans = INT_MAX;
17
    if(skip>0) {
18
        ans = min(ans,solve(arr,i+1,skip-1,inc+1,dp));
19
    }
20
    //no skip
21
    ans = min(ans,arr[i]+inc + solve(arr,i+1,skip,inc,dp));
22
    return dp[i][skip]= ans;
23
}
24
25
26
int main() {
27
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
28
    int t;
29
    cin>>t;
30
    while(t--) {
31
        int n,skip;
32
        cin>>n>>skip;
33
        vector<int>arr;
34
        vector<vector<long long>>dp(n,vector<long long>(skip+1,-1));
35
        while(n--) {
36
            int a;
37
            cin>>a;
38
            arr.push_back(a);
39
        }
40
        cout<<solve(arr,0,skip,0,dp)<<endl;
41
    }
42
    return 0;
43
}",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055672
1390055674,unknown,unknown,unknown,"1
import sys
2
def solve():
3
    x = sys.stdin.buffer.read().split()
4
    if not x: return
5
    t = int(x[0])
6
    i = 1
7
    o = []
8
    for _ in range(t):
9
        s = x[i].decode()
10
        i += 1
11
        n = len(s)
12
        A = [0]*(n+1)
13
        B = [0]*(n+1)
14
        for j in range(n):
15
            B[j+1] = B[j] + (s[j]=='1')
16
            A[j+1] = A[j] + (s[j]=='0')
17
        T = A[n]
18
        C = [0]*(n+1)
19
        E = [0]*(n+1)
20
        for j in range(n):
21
            E[j+1] = E[j] + (s[n-1-j]=='1')
22
            C[j+1] = C[j] + (s[n-1-j]=='0')
23
        r = 10**9
24
        for x_ in range(n+1):
25
            m = n - x_
26
            y = T - A[x_] - B[x_]
27
            if y < 0: y = 0
28
            if y > m: y = m
29
            for z in (y, y-1, y+1):
30
                if z < 0 or z > m: continue
31
                v1 = B[x_] + E[z]
32
                v2 = T - (A[x_] + C[z])
33
                v = v1 if v1 >= v2 else v2
34
                if v < r: r = v
35
        o.append(str(r))
36
    sys.stdout.write(""\n"".join(o))
37
if __name__==""__main__"":
38
    solve()",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055674
1390055662,unknown,unknown,unknown,"1
def min_cost(s):
2
    total_ones = s.count('1')
3
    n = len(s)
4
    5
    # If no '1' exists, remove all (cost = 0)
6
    if total_ones == 0:
7
        return 0  
8
9
    scenario_empty = total_ones  # Cost if we remove all ones
10
11
    # Scenario 1: Try keeping a window of maximum '1's
12
    scenario1_cost = float('inf')
13
    14
    max_ones_in_window = 0
15
    L = min(total_ones, n)
16
    17
    for l in range(1, L + 1):  # Window size
18
        current_ones = sum(1 for c in s[:l] if c == '1')
19
        max_ones_in_window = max(max_ones_in_window, current_ones)
20
        21
        for i in range(1, n - l + 1):
22
            current_ones -= (s[i - 1] == '1')
23
            current_ones += (s[i + l - 1] == '1')
24
            max_ones_in_window = max(max_ones_in_window, current_ones)
25
        26
    scenario1_cost = total_ones - max_ones_in_window
27
28
    # Scenario 2: Try minimizing zeros left after removing 1s from both ends
29
    scenario2_cost = float('inf')
30
    min_zeros = float('inf')
31
    32
    if n > total_ones:
33
        for l in range(total_ones + 1, n + 1):
34
            current_zeros = sum(1 for c in s[:l] if c == '0')
35
            min_zeros = min(min_zeros, current_zeros)
36
            37
            for i in range(1, n - l + 1):
38
                current_zeros -= (s[i - 1] == '0')
39
                current_zeros += (s[i + l - 1] == '0')
40
                min_zeros = min(min_zeros, current_zeros)
41
42
        scenario2_cost = min_zeros
43
44
    candidates = [scenario1_cost, scenario_empty]
45
    if n > total_ones:
46
        candidates.append(scenario2_cost)
47
48
    return min(candidates)
49
50
# Read input
51
T = int(input().strip())
52
for _ in range(T):
53
    s = input().strip()
54
    print(min_cost(s))
55",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055662
1390055667,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055667
1390055669,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if __name__ == ""__main__"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055669
1390055661,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} 3rd",25,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055661
1390055654,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055654
1390055656,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055656
1390055655,unknown,unknown,unknown,"1
t = int(input())
2
dlist = [1,1,1,1,11,1,1,11,1,1,1,1] * 100
3
4
def unn_traversal():
5
    total = 0
6
    for x in dlist:
7
        total += x % 7
8
    return total % 13
9
10
for _ in range(t):
11
    s = input().strip()
12
    n = len(s)
13
    total_ones = s.count('1')
14
    max_consecutive_ones = max((len(run) for run in s.split('0')), default=0)
15
    16
    if total_ones == 0 or max_consecutive_ones == total_ones:
17
        print(0)
18
        continue
19
    20
    total_zeros = n - total_ones
21
    low = 0
22
    high = max(total_ones, total_zeros)
23
    answer = high
24
    25
    while low <= high:
26
        mid = (low + high) // 2
27
        required_ones = max(0, total_ones - mid)
28
        29
        if required_ones == 0:
30
            answer = mid
31
            high = mid - 1
32
            continue
33
        34
        left = 0
35
        zeros = 0
36
        max_ones = 0
37
        38
        for right in range(n):
39
            if s[right] == '0':
40
                zeros += 1
41
            while zeros > mid:
42
                if s[left] == '0':
43
                    zeros -= 1
44
                left += 1
45
            current_ones = (right - left + 1) - zeros
46
            max_ones = max(max_ones, current_ones)
47
        48
        d = unn_traversal()
49
        max_ones += d - d
50
        51
        if max_ones >= required_ones:
52
            answer = mid
53
            high = mid - 1
54
        else:
55
            low = mid + 1
56
    57
    print(answer)",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055655
1390055645,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}
69",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055645
1390055648,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
9
        for (int testCase = 0; testCase < t; testCase++) {
10
            int n = scanner.nextInt();
11
            int k = scanner.nextInt();
12
13
            int[] strengths = new int[n];
14
            for (int i = 0; i < n; i++) {
15
                strengths[i] = scanner.nextInt();
16
            }
17
18
            System.out.println(minimumEffort(strengths, k));
19
        }
20
21
        scanner.close();
22
    }
23
24
    public static long minimumEffort(int[] strengths, int k) {
25
        int n = strengths.length;
26
27
        if (k >= n) {
28
            return 0;
29
        }
30
31
        long[] dp = new long[k + 1];
32
        Arrays.fill(dp, Long.MAX_VALUE / 2);
33
        dp[0] = 0;
34
35
        for (int i = 0; i < n; i++) {
36
            long[] newDp = new long[k + 1];
37
            Arrays.fill(newDp, Long.MAX_VALUE / 2);
38
39
            for (int j = 0; j <= k; j++) {
40
                if (j == 0) {
41
                    newDp[0] = dp[0] + strengths[i];
42
                } else {
43
                    newDp[j] = dp[j] + strengths[i] + j;
44
                }
45
46
                if (j > 0) {
47
                    newDp[j] = Math.min(newDp[j], dp[j - 1]);
48
                }
49
            }
50
51
            dp = newDp;
52
        }
53
54
        long minEffort = dp[0];
55
        for (int j = 1; j <= k; j++) {
56
            minEffort = Math.min(minEffort, dp[j]);
57
        }
58
59
        return minEffort;
60
    }
61
}
62",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055648
1390055650,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    total_effort = sum(a)  # Effort without skipping
6
    min_effort = total_effort
7
8
    for i in range(n):
9
        if k > 0:  # We can skip at most k firewalls
10
            effort = total_effort - a[i]  # Skip current firewall
11
            effort += (n - i - 1)  # Remaining firewalls get incremented
12
            min_effort = min(min_effort, effort)
13
14
    print(min_effort)
15
16
t = int(input())
17
for _ in range(t):
18
    solve()
19",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055650
1390055642,unknown,unknown,unknown,"1
def earliest_faults(arr, k):
2
    result = []
3
    first_fault = 0  # Default if no faults in batch
4
5
    for i in range(len(arr) - k + 1):  # Iterate through batches
6
        batch = arr[i:i + k]
7
        first_fault = 0  # Reset for each batch
8
        9
        for num in batch:  # Find first faulty reading
10
            if num < 0:
11
                first_fault = num
12
                break
13
        14
        result.append(first_fault)
15
16
    return result
17
18
19
# Reading input
20
t = int(input())  # Number of test cases
21
for _ in range(t):
22
    n, k = map(int, input().split())  # Size of array and batch size
23
    arr = list(map(int, input().split()))  # Sensor readings
24
    25
    # Get the result and print it
26
    print(*earliest_faults(arr, k))",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055642
1390055643,unknown,unknown,unknown,"1
def main():
2
    import sys
3
    input = sys.stdin.read().split()
4
    idx = 0
5
    T = int(input[idx])
6
    idx += 1
7
    for _ in range(T):
8
        n, k = int(input[idx]), int(input[idx+1])
9
        idx +=2
10
        a = list(map(int, input[idx:idx+n]))
11
        idx +=n
12
        sum_a = sum(a)
13
        gains = []
14
        for i in range(n):
15
            g = a[i] - (n - i - 1)
16
            gains.append(g)
17
        gains.sort(reverse=True)
18
        selected = gains[:k]
19
        sum_gain = sum(selected)
20
        sum_gain += k * (k - 1) // 2
21
        minimal_effort = sum_a - sum_gain
22
        print(minimal_effort)
23
24
if __name__ == ""__main__"":
25
    main()",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055643
1390055644,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055644
1390055641,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} ",26,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055641
1390055635,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}
69",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055635
1390055639,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055639
1390055637,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <climits>
4
#include <algorithm>
5
6
using namespace std;
7
8
using ll = long long;
9
10
ll min_effort(int n, int k, const vector<int>& firewalls) {
11
    if (n == 0) return 0;
12
    13
    vector<vector<ll>> dp(n + 1, vector<ll>(k + 1, LLONG_MAX));
14
    dp[0][0] = 0;
15
    16
    for (int i = 1; i <= n; ++i) {
17
        for (int j = 0; j <= k; ++j) {
18
            // Case 1: Do not skip the i-th firewall
19
            if (dp[i-1][j] != LLONG_MAX) {
20
                dp[i][j] = dp[i-1][j] + firewalls[i-1] + j;
21
            }
22
            // Case 2: Skip the i-th firewall if possible
23
            if (j > 0 && dp[i-1][j-1] != LLONG_MAX) {
24
                dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
25
            }
26
        }
27
    }
28
    29
    return *min_element(dp[n].begin(), dp[n].end());
30
}
31
32
int main() {
33
    ios_base::sync_with_stdio(false);
34
    cin.tie(nullptr);
35
    36
    int T;
37
    cin >> T;
38
    39
    while (T--) {
40
        int n, k;
41
        cin >> n >> k;
42
        43
        vector<int> firewalls(n);
44
        for (int i = 0; i < n; ++i) {
45
            cin >> firewalls[i];
46
        }
47
        48
        cout << min_effort(n, k, firewalls) << '\n';
49
    }
50
    51
    return 0;
52
}",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055637
1390055630,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class BreachFirewall {
5
    public static void main(String[] args) throws IOException {
6
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
7
        StringTokenizer st = new StringTokenizer(br.readLine());
8
        9
        int T = Integer.parseInt(st.nextToken()); // Number of test cases
10
        StringBuilder result = new StringBuilder();
11
        12
        while (T-- > 0) {
13
            st = new StringTokenizer(br.readLine());
14
            int n = Integer.parseInt(st.nextToken());
15
            int k = Integer.parseInt(st.nextToken());
16
17
            int[] firewalls = new int[n];
18
            st = new StringTokenizer(br.readLine());
19
            int totalEffort = 0;
20
21
            for (int i = 0; i < n; i++) {
22
                firewalls[i] = Integer.parseInt(st.nextToken());
23
                totalEffort += firewalls[i]; // Calculate total sum
24
            }
25
26
            List<Integer> modifiedValues = new ArrayList<>();
27
            for (int i = 0; i < n; i++) {
28
                modifiedValues.add(firewalls[i] - (n - i - 1)); // Transform the array
29
            }
30
31
            // Sort in descending order
32
            modifiedValues.sort(Collections.reverseOrder());
33
34
            // Compute prefix sum for best `t` firewalls to skip
35
            int[] prefixSum = new int[n + 1];
36
            for (int i = 0; i < n; i++) {
37
                prefixSum[i + 1] = prefixSum[i] + modifiedValues.get(i);
38
            }
39
40
            int maxSum = 0;
41
            int maxT = Math.min(k, n);
42
            for (int t = 0; t <= maxT; t++) {
43
                int current = prefixSum[t] + (t * (t - 1)) / 2;
44
                maxSum = Math.max(maxSum, current);
45
            }
46
47
            result.append(totalEffort - maxSum).append(""\n"");
48
        }
49
50
        System.out.print(result);
51
    }
52
}
53",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055630
1390055632,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055632
1390055633,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055633
1390055623,unknown,unknown,unknown,"1
import sys
2
3
def min_opp():
4
    test_cases = int(sys.stdin.readline().strip())
5
    6
    for _ in range(test_cases):
7
        bin_stri =sys.stdin.readline().strip()
8
        9
        ones_positions =[i for i, ch in enumerate(bin_stri) if ch == '1']
10
        total1 = len(ones_positions)
11
        12
        if total1 == 0 or ones_positions[-1]-ones_positions[0] == total1-1:
13
            print(0)
14
            continue
15
        16
        baye, daye = -1, total1
17
        18
        while daye - baye > 1:
19
            mid = (baye + daye) // 2
20
            ones_needed = total1 - mid
21
            22
            for i in range(total1 - ones_needed + 1):
23
                start, end = ones_positions[i], ones_positions[i + ones_needed - 1]
24
                if (end - start + 1) - ones_needed <= mid:
25
                    daye = mid
26
                    break
27
            else:
28
                baye = mid
29
        30
        print(daye)
31
32
if __name__ == ""__main__"":
33
    min_opp()
34",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055623
1390055626,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        impact = [(strengths[i] + i, i) for i in range(n)]
21
        impact.sort(reverse=True)
22
        to_skip = set(idx for _, idx in impact[:k])
23
        effort = 0
24
        skipped = 0
25
        26
        for i in range(n):
27
            if i in to_skip:
28
                skipped += 1
29
            else:
30
                effort += strengths[i] + skipped
31
        32
        results.append(str(effort))
33
    34
    sys.stdout.write(""\n"".join(results) + ""\n"")
35
36
if __name__ == ""__main__"":
37
    main()
38",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055626
1390055627,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
#include <string.h>
4
5
#define MAX(a, b) ((a) > (b) ? (a) : (b))
6
#define MIN(a, b) ((a) < (b) ? (a) : (b))
7
8
int minDecommissionCost(const char* servers) {
9
    int n = strlen(servers);
10
    int minCost = __INT_MAX__;
11
    12
    // Precompute prefix sums for active and idle servers
13
    int* activePrefix = (int*)malloc((n + 1) * sizeof(int));
14
    int* idlePrefix = (int*)malloc((n + 1) * sizeof(int));
15
    16
    activePrefix[0] = 0;
17
    idlePrefix[0] = 0;
18
    19
    for (int i = 0; i < n; i++) {
20
        activePrefix[i + 1] = activePrefix[i] + (servers[i] == '1' ? 1 : 0);
21
        idlePrefix[i + 1] = idlePrefix[i] + (servers[i] == '0' ? 1 : 0);
22
    }
23
    24
    int totalActive = activePrefix[n];
25
    int totalIdle = idlePrefix[n];
26
    27
    // Try all combinations of prefix and suffix removals
28
    for (int left = 0; left <= n; left++) {  // Left cut position (inclusive)
29
        for (int right = left; right <= n; right++) {  // Right cut position (exclusive)
30
            // Skip empty remaining segment
31
            if (left == right) {
32
                continue;
33
            }
34
            35
            // Calculate metrics
36
            int activeRemoved = activePrefix[left] + (totalActive - activePrefix[right]);
37
            int idleRemaining = idlePrefix[right] - idlePrefix[left];
38
            39
            int cost = MAX(activeRemoved, idleRemaining);
40
            minCost = MIN(minCost, cost);
41
        }
42
    }
43
    44
    free(activePrefix);
45
    free(idlePrefix);
46
    47
    return minCost;
48
}
49
50
int main() {
51
    int t;
52
    scanf(""%d"", &t);  // Number of test cases
53
    54
    for (int i = 0; i < t; i++) {
55
        char servers[100001];  // Assuming max length constraint
56
        scanf(""%s"", servers);
57
        printf(""%d\n"", minDecommissionCost(servers));
58
    }
59
    60
    return 0;
61
}",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055627
1390055617,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
    left = 0
3
    zeros = 0
4
    max_ones = 0
5
    n = len(s)
6
    7
    for right in range(n):
8
        if s[right] == '0':
9
            zeros += 1
10
        while zeros > k:
11
            if s[left] == '0':
12
                zeros -= 1
13
            left += 1
14
        current_ones = (right - left + 1) - zeros
15
        max_ones = max(max_ones, current_ones)
16
    17
    return max_ones
18
19
def min_flips_to_make_ones_consecutive(s):
20
    n = len(s)
21
    total_ones = s.count('1')
22
    23
    if total_ones == 0 or '1' * total_ones in s:
24
        return 0
25
    26
    total_zeros = n - total_ones
27
    max_consecutive_ones = max(map(len, s.split('0')))
28
    29
    low, high = 0, max(total_ones, total_zeros)
30
    answer = high
31
32
    while low <= high:
33
        mid = (low + high) // 2
34
        required_ones = max(0, total_ones - mid)
35
36
        if required_ones == 0:
37
            answer = mid
38
            high = mid - 1
39
            continue
40
        41
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
42
        if max_ones >= required_ones:
43
            answer = mid
44
            high = mid - 1
45
        else:
46
            low = mid + 1
47
    48
    return answer
49
50
# Input handling
51
T = int(input().strip())
52
for _ in range(T):
53
    s = input().strip()
54
    print(min_flips_to_make_ones_consecutive(s))",27,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055617
1390055614,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    dp[0][0] = 0
7
8
    for i in range(1, n + 1):
9
        for j in range(k + 1):
10
            # Option 1: Don't skip the current firewall
11
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j)
12
13
            # Option 2: Skip the current firewall (if possible)
14
            if j > 0:
15
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
16
17
    min_effort = float('inf')
18
    for j in range(k + 1):
19
        min_effort = min(min_effort, dp[n][j])
20
21
    print(min_effort)
22
23
24
t = int(input())
25
for _ in range(t):
26
    solve()",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055614
1390055612,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
    T = s.count('1')
3
    if T == 0:
4
        return 0
5
    n = len(s)
6
    7
    # Compute x_max_case1: max number of 1's in window of length T
8
    x_max_case1 = 0
9
    if T <= n:
10
        current = sum(1 for c in s[:T] if c == '1')
11
        x_max_case1 = current
12
        for i in range(1, n - T + 1):
13
            if s[i-1] == '1':
14
                current -= 1
15
            if s[i + T - 1] == '1':
16
                current += 1
17
            if current > x_max_case1:
18
                x_max_case1 = current
19
    20
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
21
    x_max_case2 = 0
22
    current_run = 0
23
    for c in s:
24
        if c == '1':
25
            current_run += 1
26
        else:
27
            if current_run > 0:
28
                candidate = min(current_run, T-1)
29
                if candidate > x_max_case2:
30
                    x_max_case2 = candidate
31
                current_run = 0
32
    # Check the last run
33
    if current_run > 0:
34
        candidate = min(current_run, T-1)
35
        if candidate > x_max_case2:
36
            x_max_case2 = candidate
37
    38
    case1_cost = T - x_max_case1
39
    case2_cost = T - x_max_case2
40
    return min(case1_cost, case2_cost)
41
42
def main():
43
    import sys
44
    input = sys.stdin.read().split()
45
    T_cases = int(input[0])
46
    for i in range(1, T_cases + 1):
47
        s = input[i]
48
        print(compute_min_cost(s))
49
50
if __name__ == ""__main__"":
51
    main()",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055612
1390055615,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055615
1390055605,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
9
int main() {
10
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
11
    int cases;
12
    cin >> cases;
13
    14
    while (cases--) {
15
        int n, k;
16
        cin >> n >> k;
17
        vector<int> array(n);
18
        19
        for (int i = 0; i < n; i++) {
20
            cin >> array[i];
21
        }
22
23
        for (int i = 0; i <= n - k; i++) {
24
            int neg = 0;
25
            for (int j = i; j < i + k; j++) {
26
                if (array[j] < 0) {
27
                    neg = array[j];
28
                    break;
29
                }
30
            }
31
            cout << neg << "" "";
32
        }
33
        cout << endl;
34
    }
35
36
    return 0;
37
}",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055605
1390055607,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommissioning {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt(); // Number of test cases
7
        scanner.nextLine(); // Consume the newline character
8
9
        for (int t = 0; t < T; t++) {
10
            String servers = scanner.nextLine(); // Binary string representing the server rack
11
            int n = servers.length();
12
            int minCost = Integer.MAX_VALUE;
13
14
            // Precompute prefix sums for 0's and 1's
15
            int[] prefixZeros = new int[n + 1];
16
            int[] prefixOnes = new int[n + 1];
17
            for (int i = 0; i < n; i++) {
18
                prefixZeros[i + 1] = prefixZeros[i] + (servers.charAt(i) == '0' ? 1 : 0);
19
                prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
20
            }
21
22
            // Iterate over all possible decommissioning plans
23
            for (int left = 0; left <= n; left++) {
24
                for (int right = 0; right <= n - left; right++) {
25
                    // Calculate remaining 0's in the middle substring
26
                    int remainingZeros = prefixZeros[n - right] - prefixZeros[left];
27
                    // Calculate decommissioned 1's (from left and right)
28
                    int decommissionedOnes = prefixOnes[left] + (prefixOnes[n] - prefixOnes[n - right]);
29
                    // Compute the cost
30
                    int cost = Math.max(remainingZeros, decommissionedOnes);
31
                    // Update the minimum cost
32
                    if (cost < minCost) {
33
                        minCost = cost;
34
                    }
35
                }
36
            }
37
38
            System.out.println(minCost);
39
        }
40
        scanner.close();
41
    }
42
}",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055607
1390055609,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
}
103",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055609
1390055603,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    if k == n:
4
        return 0  # If we can skip all firewalls, effort is 0.
5
    6
    min_extra_cost = min(firewalls)  # Find the least firewall strength to skip
7
    return total_effort - min_extra_cost  # Minimum effort after skipping one firewall.
8
9
# Reading input
10
T = int(input().strip())
11
for _ in range(T):
12
    n, k = map(int, input().split())
13
    firewalls = list(map(int, input().split()))
14
    print(min_effort(n, k, firewalls))
15",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055603
1390055604,unknown,unknown,unknown,"1
def minimize_decommission_cost(test_cases):
2
    results = []
3
4
    for binary_string in test_cases:
5
        n = len(binary_string)
6
        total_idle = binary_string.count('0') 
7
        total_active = binary_string.count('1')  
8
9
        min_cost = float('inf')  
10
11
        12
        for start in range(n + 1):  
13
            for end in range(n - start + 1):  
14
                15
                remaining = binary_string[start:n - end]
16
17
                18
                remaining_idle = remaining.count('0')
19
                decommissioned_active = total_active - remaining.count('1')
20
21
                22
                cost = max(remaining_idle, decommissioned_active)
23
                min_cost = min(min_cost, cost)
24
25
        results.append(min_cost)
26
27
    return results
28
29
30
31
T = int(input().strip())
32
test_cases = [input().strip() for _ in range(T)]
33
34
35
results = minimize_decommission_cost(test_cases)
36
for result in results:
37
    print(result)
38",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055604
1390055598,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
#include <string.h>
4
5
#define MAX(a, b) ((a) > (b) ? (a) : (b))
6
#define MIN(a, b) ((a) < (b) ? (a) : (b))
7
8
int minDecommissionCost(const char* servers) {
9
    int n = strlen(servers);
10
    int minCost = __INT_MAX__;
11
    12
    // Precompute prefix sums for active and idle servers
13
    int* activePrefix = (int*)malloc((n + 1) * sizeof(int));
14
    int* idlePrefix = (int*)malloc((n + 1) * sizeof(int));
15
    16
    activePrefix[0] = 0;
17
    idlePrefix[0] = 0;
18
    19
    for (int i = 0; i < n; i++) {
20
        activePrefix[i + 1] = activePrefix[i] + (servers[i] == '1' ? 1 : 0);
21
        idlePrefix[i + 1] = idlePrefix[i] + (servers[i] == '0' ? 1 : 0);
22
    }
23
    24
    int totalActive = activePrefix[n];
25
    int totalIdle = idlePrefix[n];
26
    27
    // Try all combinations of prefix and suffix removals
28
    for (int left = 0; left <= n; left++) {  // Left cut position (inclusive)
29
        for (int right = left; right <= n; right++) {  // Right cut position (exclusive)
30
            // Skip empty remaining segment
31
            if (left == right) {
32
                continue;
33
            }
34
            35
            // Calculate metrics
36
            int activeRemoved = activePrefix[left] + (totalActive - activePrefix[right]);
37
            int idleRemaining = idlePrefix[right] - idlePrefix[left];
38
            39
            int cost = MAX(activeRemoved, idleRemaining);
40
            minCost = MIN(minCost, cost);
41
        }
42
    }
43
    44
    free(activePrefix);
45
    free(idlePrefix);
46
    47
    return minCost;
48
}
49
50
int main() {
51
    int t;
52
    scanf(""%d"", &t);  // Number of test cases
53
    54
    for (int i = 0; i < t; i++) {
55
        char servers[100001];  // Assuming max length constraint
56
        scanf(""%s"", servers);
57
        printf(""%d\n"", minDecommissionCost(servers));
58
    }
59
    60
    return 0;
61
}",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055598
1390055596,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()",28,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055596
1390055578,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
if __name__ == ""__main__"":
60
    T = int(input())
61
    test_cases = [input().strip() for _ in range(T)]
62
    results = min_decommissioning_cost(test_cases)
63
    for result in results:
64
        print(result)
65",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055578
1390055582,unknown,unknown,unknown,"1
def feasible(X, ones_indices, total1):
2
    if X >= total1:
3
        return True
4
    5
    j = 0
6
    for i in range(total1):
7
        if j < i:
8
            j = i
9
10
        while j < total1 and (ones_indices[j] - ones_indices[i] - (j - i)) <= X:
11
            j += 1
12
13
        m = j - i
14
        if m >= total1 - X:
15
            return True
16
17
    return False
18
19
def min_moves_to_make_ones_contiguous(s):
20
    ones_indices = [i for i, ch in enumerate(s) if ch == '1']
21
    total1 = len(ones_indices)
22
23
    if total1 == 0:
24
        return 0
25
26
    low, high, ans = 0, total1, total1
27
    while low <= high:
28
        mid = low + (high - low) // 2
29
        if feasible(mid, ones_indices, total1):
30
            ans = mid
31
            high = mid - 1
32
        else:
33
            low = mid + 1
34
35
    return ans
36
37
if __name__ == ""__main__"":
38
    T = int(input())
39
    for _ in range(T):
40
        s = input().strip()
41
        print(min_moves_to_make_ones_contiguous(s))
42",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055582
1390055589,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if _name_ == ""_main_"":
45
    main()",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055589
1390055571,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx+1])
10
        idx +=2
11
        a = list(map(int, input[idx:idx+n]))
12
        idx +=n
13
        sum_a = sum(a)
14
        v = []
15
        for i in range(n):
16
            val = a[i] - (n - i -1)
17
            v.append(val)
18
        v.sort(reverse=True)
19
        prefix = [0] * (n+1)
20
        for i in range(n):
21
            prefix[i+1] = prefix[i] + v[i]
22
        max_sum = 0
23
        max_t = min(k, n)
24
        for t in range(0, max_t+1):
25
            current = prefix[t] + t*(t-1)//2
26
            if current > max_sum:
27
                max_sum = current
28
        print(sum_a - max_sum)
29
30
if __name__ == ""_main_"":
31
    main()",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055571
1390055573,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
}",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055573
1390055574,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])  # Number of test cases
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
13
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if _name_ == ""_main_"":
45
    main()",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055574
1390055565,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases): 
2
    results = []
3
    4
    for s in test_cases:
5
        n = len(s)
6
        7
        prefix_ones = [0] * (n + 1)
8
        prefix_zeros = [0] * (n + 1)
9
        10
        for i in range(1, n + 1):
11
            prefix_ones[i] = prefix_ones[i - 1] + (1 if s[i - 1] == '1' else 0)
12
            prefix_zeros[i] = prefix_zeros[i - 1] + (1 if s[i - 1] == '0' else 0)
13
        14
        total_ones = prefix_ones[n]
15
        total_zeros = prefix_zeros[n]
16
        17
        min_cost = float('inf')
18
        19
        for i in range(n):
20
            for j in range(i + 1, n + 1):
21
                ones_in_subarray = prefix_ones[j] - prefix_ones[i]
22
                zeros_in_subarray = prefix_zeros[j] - prefix_zeros[i]
23
                24
                removed_ones = total_ones - ones_in_subarray
25
                cost = max(zeros_in_subarray, removed_ones)
26
                27
                min_cost = min(min_cost, cost)
28
        29
        results.append(min_cost)
30
    31
    return results
32
33
T = int(input())
34
test_cases = [input().strip() for _ in range(T)]
35
36
results = min_decommissioning_cost(test_cases)
37
38
for result in results:
39
    print(result)
40",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055565
1390055569,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055569
1390055570,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            long INF = Long.MAX_VALUE / 2;
23
            long[] dp = new long[k+1];
24
            Arrays.fill(dp, INF);
25
            dp[0] = 0;
26
            27
            28
            for (int i = 0; i < n; i++) {
29
                int lim = Math.min(i+1, k);
30
                long[] newdp = new long[k+1];
31
                Arrays.fill(newdp, INF);
32
                33
               34
                for (int j = lim; j >= 0; j--) {
35
                   36
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
37
                    38
                   39
                    if(j < k) {
40
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
41
                    }
42
                }
43
                dp = newdp;
44
            }
45
            46
           47
            long ans = INF;
48
            for (int j = 0; j <= k; j++) {
49
                ans = Math.min(ans, dp[j]);
50
            }
51
            System.out.println(ans);
52
        }
53
        sc.close();
54
    }
55
}",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055570
1390055563,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",29,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055563
1390055556,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        impact = [(strengths[i] + i, i) for i in range(n)]
21
        22
        impact.sort(reverse=True)
23
        24
        to_skip = set(idx for _, idx in impact[:k])
25
        26
        effort = 0
27
        skipped = 0
28
        29
        for i in range(n):
30
            if i in to_skip:
31
                skipped += 1
32
            else:
33
                effort += strengths[i] + skipped
34
        35
        results.append(str(effort))
36
    37
    sys.stdout.write(""\n"".join(results) + ""\n"")
38
39
if __name__ == ""__main__"":
40
    main()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055556
1390055559,unknown,unknown,unknown,"1
def min_cost(server_rack):
2
    n = len(server_rack)
3
    total_zeros = server_rack.count('0')  # Total number of 0's in the string
4
    total_ones = n - total_zeros          # Total number of 1's in the string
5
    min_cost = float('inf')
6
    7
    left = 0
8
    zeros_inside = 0  # Number of 0's in the current window
9
    for right in range(n):
10
        if server_rack[right] == '0':
11
            zeros_inside += 1
12
        13
        # Calculate the number of 1's outside the window
14
        ones_outside = total_ones - (right - left + 1 - zeros_inside)
15
        16
        # Calculate the cost
17
        cost = max(zeros_inside, ones_outside)
18
        19
        # Update the minimum cost
20
        if cost < min_cost:
21
            min_cost = cost
22
        23
        # Shrink the window from the left to try to find a better cost
24
        while left <= right and cost >= min_cost:
25
            if server_rack[left] == '0':
26
                zeros_inside -= 1
27
            left += 1
28
            29
            # Recalculate cost after shrinking the window
30
            ones_outside = total_ones - (right - left + 1 - zeros_inside)
31
            cost = max(zeros_inside, ones_outside)
32
            33
            # Update the minimum cost
34
            if cost < min_cost:
35
                min_cost = cost
36
    37
    return min_cost
38
39
# Read the number of test cases
40
T = int(input())
41
for _ in range(T):
42
    server_rack = input().strip()
43
    print(min_cost(server_rack))",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055559
1390055560,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
    left = 0
3
    zeros = 0
4
    max_ones = 0
5
    n = len(s)
6
    7
    for right in range(n):
8
        if s[right] == '0':
9
            zeros += 1
10
        while zeros > k:
11
            if s[left] == '0':
12
                zeros -= 1
13
            left += 1
14
        current_ones = (right - left + 1) - zeros
15
        max_ones = max(max_ones, current_ones)
16
    17
    return max_ones
18
19
def min_flips_to_make_ones_consecutive(s):
20
    n = len(s)
21
    total_ones = s.count('1')
22
    23
    if total_ones == 0 or '1' * total_ones in s:
24
        return 0
25
    26
    total_zeros = n - total_ones
27
    max_consecutive_ones = max(map(len, s.split('0')))
28
    29
    low, high = 0, max(total_ones, total_zeros)
30
    answer = high
31
32
    while low <= high:
33
        mid = (low + high) // 2
34
        required_ones = max(0, total_ones - mid)
35
36
        if required_ones == 0:
37
            answer = mid
38
            high = mid - 1
39
            continue
40
        41
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
42
        if max_ones >= required_ones:
43
            answer = mid
44
            high = mid - 1
45
        else:
46
            low = mid + 1
47
    48
    return answer
49
50
# Input handling
51
T = int(input().strip())
52
for _ in range(T):
53
    s = input().strip()
54
    print(min_flips_to_make_ones_consecutive(s))
55",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055560
1390055549,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()
32
    ",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055549
1390055550,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
3
    T = s.count('1')
4
5
    if T == 0:
6
7
        return 0
8
9
    n = len(s)
10
11
    12
13
    # Compute x_max_case1: max number of 1's in window of length T
14
15
    x_max_case1 = 0
16
17
    if T <= n:
18
19
        current = sum(1 for c in s[:T] if c == '1')
20
21
        x_max_case1 = current
22
23
        for i in range(1, n - T + 1):
24
25
            if s[i-1] == '1':
26
27
                current -= 1
28
29
            if s[i + T - 1] == '1':
30
31
                current += 1
32
33
            if current > x_max_case1:
34
35
                x_max_case1 = current
36
37
    38
39
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
40
41
    x_max_case2 = 0
42
43
    current_run = 0
44
45
    for c in s:
46
47
        if c == '1':
48
49
            current_run += 1
50
51
        else:
52
53
            if current_run > 0:
54
55
                candidate = min(current_run, T-1)
56
57
                if candidate > x_max_case2:
58
59
                    x_max_case2 = candidate
60
61
                current_run = 0
62
63
    # Check the last run
64
65
    if current_run > 0:
66
67
        candidate = min(current_run, T-1)
68
69
        if candidate > x_max_case2:
70
71
            x_max_case2 = candidate
72
73
    74
75
    case1_cost = T - x_max_case1
76
77
    case2_cost = T - x_max_case2
78
79
    return min(case1_cost, case2_cost)
80
81
def main():
82
83
    import sys
84
85
    input = sys.stdin.read().split()
86
87
    T_cases = int(input[0])
88
89
    for i in range(1, T_cases + 1):
90
91
        s = input[i]
92
93
        print(compute_min_cost(s))
94
95
if _name_ == ""_main_"":
96
97
    main()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055550
1390055552,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055552
1390055545,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    strengths = list(map(int, input().split()))
5
    6
    benefits = []
7
    for i in range(n):
8
        benefit = strengths[i] - (n - i - 1)
9
        benefits.append((benefit, i))
10
    11
12
    benefits.sort(reverse=True)
13
    to_skip = set(pos for _, pos in benefits[:k])
14
    15
    total_effort = 0
16
    skipped_till_now = 0
17
    18
    for i in range(n):
19
        if i in to_skip:
20
            skipped_till_now += 1
21
        else:
22
            total_effort += strengths[i] + skipped_till_now
23
    24
    print(total_effort)
25
26",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055545
1390055548,unknown,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        n, k = map(int, input().split())
5
        a = list(map(int, input().split()))
6
        sumA = sum(a)
7
        b = [a[i] + (i + 1) for i in range(n)]
8
        b.sort(reverse=True)
9
        prefix = [0] * (n + 1)
10
        for i in range(n):
11
            prefix[i + 1] = prefix[i] + b[i]
12
        min_cost = float('inf')
13
        for x in range(0, min(k, n) + 1):
14
            cost = sumA + x * n - (x * (x - 1)) // 2 - prefix[x]
15
            min_cost = min(min_cost, cost)
16
        print(min_cost)
17
18
solve()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055548
1390055544,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    # Read number of test cases
5
    T = int(input())
6
    for _ in range(T):
7
        # Read the binary string
8
        S = input().strip()
9
        n = len(S)
10
        11
        # Compute prefix sums for '0's and '1's
12
        prefix_zeros = [0] * (n + 1)
13
        prefix_ones = [0] * (n + 1)
14
        for i in range(1, n + 1):
15
            prefix_zeros[i] = prefix_zeros[i - 1] + (S[i - 1] == '0')
16
            prefix_ones[i] = prefix_ones[i - 1] + (S[i - 1] == '1')
17
        18
        # Initialize minimum cost
19
        min_cost = float('inf')
20
        21
        # Iterate over all possible end indices j
22
        for j in range(n + 1):
23
            # Number of '1's in the suffix from j to n
24
            C = prefix_ones[n] - prefix_ones[j]
25
            26
            # Binary search to find the smallest m where:
27
            # Number of '0's in [m, j-1] <= Number of '1's in [0, m-1] + [j, n-1]
28
            left, right = 0, j
29
            while left < right:
30
                mid = left + (right - left) // 2
31
                if prefix_zeros[j] - prefix_zeros[mid] <= prefix_ones[mid] + C:
32
                    right = mid
33
                else:
34
                    left = mid + 1
35
            m = left
36
            37
            # Compute cost based on the optimal m
38
            if m == 0:
39
                # If m is 0, no prefix is removed, cost is just '1's in suffix
40
                cost = C
41
            else:
42
                # Cost is min of '0's in [m-1, j-1] and '1's in [0, m-1] + [j, n-1]
43
                cost = min(prefix_zeros[j] - prefix_zeros[m - 1], prefix_ones[m] + C)
44
            min_cost = min(min_cost, cost)
45
        46
        # Output the minimum cost for this test case
47
        print(min_cost)
48
49
if __name__ == ""__main__"":
50
    main()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055544
1390055537,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if _name_ == ""_main_"":
45
    main()",30,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055537
1390055533,unknown,unknown,unknown,"1
def min_server_pruning_cost(binary_string):
2
    # Find the first and last occurrence of '1'
3
    first_one = binary_string.find('1')
4
    last_one = binary_string.rfind('1')
5
6
    if first_one == -1:  # If there are no '1s', we can remove everything
7
        return 0
8
9
    # Trim the string to only the relevant section
10
    trimmed_string = binary_string[first_one:last_one + 1]
11
12
    # Count idle servers (0s) remaining and active servers (1s) removed
13
    remaining_idle_servers = trimmed_string.count('0')
14
    removed_active_servers = first_one + (len(binary_string) - 1 - last_one)
15
16
    # Return the minimum possible cost
17
    return max(remaining_idle_servers, removed_active_servers)
18
19
def solve():
20
    t = int(input().strip())  # Number of test cases
21
    results = []
22
    23
    for _ in range(t):
24
        binary_string = input().strip()
25
        results.append(str(min_server_pruning_cost(binary_string)))
26
27
    # Print all results for test cases
28
    print(""\n"".join(results))
29
30
# Execute the solution
31
if _name_ == ""_main_"":
32
    solve()",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055533
1390055534,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if __name__ == ""__main__"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055534
1390055535,unknown,unknown,unknown,"1
def minimum_decommission_cost(servers):
2
    n = len(servers)
3
    4
    # Convert the string to a list of integers (0 or 1)
5
    server_list = [int(c) for c in servers]
6
7
    # Compute prefix sum of active servers (1s)
8
    prefix_sum = [0] * (n + 1)
9
    for i in range(n):
10
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
11
12
    total_ones = prefix_sum[n]  # Total active servers
13
    min_cost = total_ones  # Worst case: decommission all active servers
14
15
    j = 0  # Right boundary of the window
16
    for i in range(n + 1):
17
        # Move j to maintain segment_zeros >= total_ones_removed
18
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
19
            j += 1
20
        21
        # Calculate cost at current window
22
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
23
        left_ones = prefix_sum[i]
24
        right_ones = total_ones - prefix_sum[j - 1]
25
        cost = max(segment_zeros, left_ones + right_ones)
26
        27
        min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
def process_input():
32
    import sys
33
    input = sys.stdin.read
34
    data = input().split()
35
    36
    t = int(data[0])
37
    results = []
38
    39
    for i in range(1, t + 1):
40
        results.append(str(minimum_decommission_cost(data[i])))
41
    42
    print(""\n"".join(results))
43
44
if __name__ == ""__main__"":
45
    process_input()",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055535
1390055529,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
 3
    if k >= n:
4
        return 0
5
    6
    min_effort = float('inf')
7
    8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    dp[0][0] = 0  
10
    for i in range(1, n + 1):
11
        current_firewall = firewalls[i - 1]
12
        13
        for j in range(k + 1):
14
   15
            if j <= i - 1:
16
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_firewall + j)
17
           18
            if j > 0:
19
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
20
    21
    return min(dp[n][j] for j in range(k + 1))
22
23
def solve_test_cases():
24
    T = int(input().strip())
25
    results = []
26
    27
    for _ in range(T):
28
        n, k = map(int, input().strip().split())
29
        firewalls = list(map(int, input().strip().split()))
30
        results.append(min_effort_to_breach(n, k, firewalls))
31
    32
    return results
33
34
if __name__ == ""__main__"":
35
    results = solve_test_cases()
36
    for result in results:
37
        print(result)",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055529
1390055530,unknown,unknown,unknown,"1
import sys
2
3
def findMinCost():
4
    input_data = sys.stdin.read().splitlines()
5
    t = int(input_data[0].strip())
6
    line = 1
7
    ans = []
8
    9
    for _ in range(t):
10
        servers = input_data[line].strip()
11
        line += 1
12
        n = len(servers)
13
        14
        active_positions = [i for i, ch in enumerate(servers) if ch == '1']
15
        active_count = len(active_positions)
16
        17
        if active_count == 0:
18
            ans.append(""0"")
19
            continue
20
        21
        offset_positions = [active_positions[i] - i for i in range(active_count)]
22
        23
        def check(limit):
24
            if active_count - limit <= 0:
25
                return True
26
            j = 0
27
            for i in range(active_count):
28
                if j < i:
29
                    j = i
30
                while j < active_count and offset_positions[j] - offset_positions[i] <= limit:
31
                    j += 1
32
                if j - i >= active_count - limit:
33
                    return True
34
            return False
35
        36
        lo, hi, min_cost = 0, n, n
37
        while lo <= hi:
38
            mid = (lo + hi) // 2
39
            if check(mid):
40
                min_cost = mid
41
                hi = mid - 1
42
            else:
43
                lo = mid + 1
44
        45
        ans.append(str(min_cost))
46
    47
    sys.stdout.write(""\n"".join(ans))
48
    49
if __name__ == ""__main__"":
50
    findMinCost()",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055530
1390055531,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include<bits/stdc++.h>
7
using namespace std;
8
9
int solve(vector<int>& arr, int k){
10
    int n = arr.size();
11
    int ans = 0;
12
    13
    set<int> st;
14
    vector<int> right(n,0);
15
    for(int i=0; i<n; i++) right[i]=n-i-1;
16
    priority_queue<pair<int,int>, vector<pair<int,int>>> pq;
17
    for(int i=0; i<n; i++) pq.push({arr[i],i});
18
    19
    while(!pq.empty()){
20
        auto [val,idx] = pq.top(); pq.pop();
21
        22
        if(right[idx] < val && k){
23
            val=n-idx-1;
24
            st.insert(idx);
25
            k--;
26
            for(int i=0; i<idx; i++){
27
                right[i]--;
28
            }
29
            // cout<<""inserted ""<<idx<<"" k:""<<k<<"" "";
30
        }    
31
    }
32
    33
    // for(int i=0; i<n; i++) cout<<right[i]<<"" "";
34
    35
    int val=0, count=0; //count of k that is used.. val is no of -1 to be added
36
    37
    for(int i=0; i<n; i++){
38
        if(st.find(i)!=st.end()){
39
            if(count) val-=count;
40
            val += n-i-1;
41
            count++;
42
            continue;
43
        }
44
        ans += arr[i];
45
    }
46
    47
    ans += val;
48
    49
    return ans;
50
}
51
52
53
int main() {
54
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
55
    int t;
56
    cin>>t;
57
    while(t--){
58
        int n,k;
59
        cin>>n>>k;
60
        vector<int> arr(n);
61
        for(int i=0; i<n ;i++) cin>>arr[i];
62
        63
        int ans = solve(arr,k);
64
        cout<<ans<<endl;
65
    }
66
    return 0;
67
}
68",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055531
1390055526,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    for j in range(k + 1):
4
        dp[0][j] = 0
5
    6
    for i in range(1, n + 1):
7
        for j in range(k + 1):
8
            if j > 0:
9
                dp[i][j] = dp[i-1][j-1]
10
            current_strength = strengths[i-1] + j 
11
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
12
    return min(dp[n])
13
14
def solve():
15
    t = int(input())
16
    results = []
17
    18
    for _ in range(t):
19
        n, k = map(int, input().split())
20
        strengths = list(map(int, input().split()))
21
        results.append(min_effort_to_breach(n, k, strengths))
22
    23
    for result in results:
24
        print(result)
25
26
solve()",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055526
1390055527,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
9
        for (int testCase = 0; testCase < t; testCase++) {
10
            int n = scanner.nextInt();
11
            int k = scanner.nextInt();
12
13
            int[] strengths = new int[n];
14
            for (int i = 0; i < n; i++) {
15
                strengths[i] = scanner.nextInt();
16
            }
17
18
            System.out.println(minimumEffort(strengths, k));
19
        }
20
21
        scanner.close();
22
    }
23
24
    public static long minimumEffort(int[] strengths, int k) {
25
        int n = strengths.length;
26
27
        if (k >= n) {
28
            return 0;
29
        }
30
31
        long[][] dp = new long[n + 1][k + 1];
32
33
        for (int i = 0; i <= n; i++) {
34
            for (int j = 0; j <= k; j++) {
35
                dp[i][j] = Long.MAX_VALUE / 2;
36
            }
37
        }
38
        dp[0][0] = 0;
39
40
        for (int i = 1; i <= n; i++) {
41
            int currentStrength = strengths[i - 1];
42
43
            for (int j = 0; j <= k; j++) {
44
                if (dp[i - 1][j] != Long.MAX_VALUE / 2) {
45
                    dp[i][j] = dp[i - 1][j] + currentStrength + j;
46
                }
47
            }
48
49
            for (int j = 1; j <= k; j++) {
50
                if (dp[i - 1][j - 1] != Long.MAX_VALUE / 2) {
51
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
52
                }
53
            }
54
        }
55
56
        long minEffort = Long.MAX_VALUE;
57
        for (int j = 0; j <= k; j++) {
58
            minEffort = Math.min(minEffort, dp[n][j]);
59
        }
60
61
        return minEffort;
62
    }
63
}
64",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055527
1390055523,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}
69",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055523
1390055517,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
    left = 0
3
    zeros = 0
4
    max_ones = 0
5
    n = len(s)
6
    7
    for right in range(n):
8
        if s[right] == '0':
9
            zeros += 1
10
        while zeros > k:
11
            if s[left] == '0':
12
                zeros -= 1
13
            left += 1
14
        current_ones = (right - left + 1) - zeros
15
        max_ones = max(max_ones, current_ones)
16
    17
    return max_ones
18
19
def min_flips_to_make_ones_consecutive(s):
20
    n = len(s)
21
    total_ones = s.count('1')
22
    23
    if total_ones == 0 or '1' * total_ones in s:
24
        return 0
25
    26
    total_zeros = n - total_ones
27
    max_consecutive_ones = max(map(len, s.split('0')))
28
    29
    low, high = 0, max(total_ones, total_zeros)
30
    answer = high
31
32
    while low <= high:
33
        mid = (low + high) // 2
34
        required_ones = max(0, total_ones - mid)
35
36
        if required_ones == 0:
37
            answer = mid
38
            high = mid - 1
39
            continue
40
        41
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
42
        if max_ones >= required_ones:
43
            answer = mid
44
            high = mid - 1
45
        else:
46
            low = mid + 1
47
    48
    return answer
49
50
# Input handling
51
T = int(input().strip())
52
for _ in range(T):
53
    s = input().strip()
54
    print(min_flips_to_make_ones_consecutive(s))
55",31,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055517
1390055501,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int maxOnesWithAtMostKZeros(const string& s, int k) {
5
    int left = 0;
6
    int zeros = 0;
7
    int maxOnes = 0;
8
    int n = s.length();
9
    10
    for (int right = 0; right < n; right++) {
11
        if (s[right] == '0') {
12
            zeros++;
13
        }
14
        while (zeros > k) {
15
            if (s[left] == '0') {
16
                zeros--;
17
            }
18
            left++;
19
        }
20
        int currentOnes = (right - left + 1) - zeros;
21
        maxOnes = max(maxOnes, currentOnes);
22
    }
23
    24
    return maxOnes;
25
}
26
27
int main() {
28
    int T;
29
    cin >> T;
30
    cin.ignore();
31
    32
    while (T--) {
33
        string s;
34
        getline(cin, s);
35
        int n = s.length();
36
        int totalOnes = 0;
37
        int maxConsecutiveOnes = 0;
38
        int currentConsecutiveOnes = 0;
39
        40
        for (char c : s) {
41
            if (c == '1') {
42
                currentConsecutiveOnes++;
43
                maxConsecutiveOnes = max(maxConsecutiveOnes, currentConsecutiveOnes);
44
                totalOnes++;
45
            } else {
46
                currentConsecutiveOnes = 0;
47
            }
48
        }
49
        50
        if (totalOnes == 0) {
51
            cout << 0 << endl;
52
            continue;
53
        }
54
        if (maxConsecutiveOnes == totalOnes) {
55
            cout << 0 << endl;
56
            continue;
57
        }
58
        59
        int totalZeros = n - totalOnes;
60
        int low = 0;
61
        int high = max(totalOnes, totalZeros);
62
        int answer = high;
63
        64
        while (low <= high) {
65
            int mid = (low + high) / 2;
66
            int requiredOnes = max(0, totalOnes - mid);
67
            68
            if (requiredOnes == 0) {
69
                answer = mid;
70
                high = mid - 1;
71
                continue;
72
            }
73
            74
            int maxOnes = maxOnesWithAtMostKZeros(s, mid);
75
            if (maxOnes >= requiredOnes) {
76
                answer = mid;
77
                high = mid - 1;
78
            } else {
79
                low = mid + 1;
80
            }
81
        }
82
        83
        cout << answer << endl;
84
    }
85
    86
    return 0;
87
}
88",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055501
1390055508,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    dp[0][0] = 0
7
8
    for i in range(1, n + 1):
9
        for j in range(k + 1):
10
            # Option 1: Don't skip the current firewall
11
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j)
12
13
            # Option 2: Skip the current firewall (if possible)
14
            if j > 0:
15
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
16
17
    min_effort = float('inf')
18
    for j in range(k + 1):
19
        min_effort = min(min_effort, dp[n][j])
20
21
    print(min_effort)
22
23
24
t = int(input())
25
for _ in range(t):
26
    solve()",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055508
1390055512,unknown,unknown,unknown,"1
import java.util.*;
2
import java.io.*;
3
4
public class Main {
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        8
        int T = scanner.nextInt();
9
        for (int t = 0; t < T; t++) {
10
            int n = scanner.nextInt();
11
            int k = scanner.nextInt();
12
            13
            long[] a = new long[n];
14
            for (int i = 0; i < n; i++) {
15
                a[i] = scanner.nextLong();
16
            }
17
            18
            final long INF = 1_000_000_000_000_000_000L;
19
            20
            long[] prev = new long[k + 1];
21
            Arrays.fill(prev, INF);
22
            prev[0] = 0;
23
            24
            for (int i = 0; i < n; i++) {
25
                long[] curr = new long[k + 1];
26
                Arrays.fill(curr, INF);
27
                28
                for (int s = 0; s <= k; s++) {
29
                    curr[s] = prev[s] + a[i] + s;
30
                    31
                    if (s > 0) {
32
                        curr[s] = Math.min(curr[s], prev[s - 1]);
33
                    }
34
                }
35
                36
                prev = curr;
37
            }
38
            39
            long ans = INF;
40
            for (int s = 0; s <= k; s++) {
41
                ans = Math.min(ans, prev[s]);
42
            }
43
            44
            System.out.println(ans);
45
        }
46
        47
        scanner.close();
48
    }
49
}",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055512
1390055495,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} 
103",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055495
1390055499,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055499
1390055500,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommission {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt();  // Number of test cases
7
        scanner.nextLine();         // Consume the leftover newline
8
9
        while (T-- > 0) {
10
            String servers = scanner.nextLine();
11
            int n = servers.length();
12
13
            // Build prefix sums for '1's and '0's
14
            // prefixOnes[i] = number of '1's in servers[0..i-1]
15
            // prefixZeroes[i] = number of '0's in servers[0..i-1]
16
            int[] prefixOnes = new int[n + 1];
17
            int[] prefixZeroes = new int[n + 1];
18
19
            for (int i = 0; i < n; i++) {
20
                prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
21
                prefixZeroes[i + 1] = prefixZeroes[i] + (servers.charAt(i) == '0' ? 1 : 0);
22
            }
23
24
            // Total number of '1's in the entire string
25
            int totalOnes = prefixOnes[n];
26
            27
            int minCost = Integer.MAX_VALUE;
28
29
            // Try every subarray [L, R) as the portion we keep
30
            // We remove [0..L) from the front and [R..n) from the end
31
            for (int L = 0; L <= n; L++) {
32
                for (int R = L; R <= n; R++) {
33
                    // Number of 0s in [L, R) = prefixZeroes[R] - prefixZeroes[L]
34
                    int zeroesInSubarray = prefixZeroes[R] - prefixZeroes[L];
35
                    36
                    // Number of 1s in [L, R) = prefixOnes[R] - prefixOnes[L]
37
                    int onesInSubarray = prefixOnes[R] - prefixOnes[L];
38
                    39
                    // # of 1s removed = totalOnes - onesInSubarray
40
                    // # of 0s remaining = zeroesInSubarray
41
                    int cost = Math.max(zeroesInSubarray, totalOnes - onesInSubarray);
42
43
                    if (cost < minCost) {
44
                        minCost = cost;
45
                    }
46
                }
47
            }
48
49
            System.out.println(minCost);
50
        }
51
        scanner.close();
52
    }
53
}",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055500
1390055486,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerOptimization {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
8
        while (T-- > 0) {
9
            String s = sc.next();
10
            int n = s.length();
11
12
            if (n == 0 || !s.contains(""1"")) {
13
                System.out.println(0);
14
                continue;
15
            }
16
17
            int minCost = Integer.MAX_VALUE;
18
19
            for (int start = 0; start < n; start++) {
20
                for (int end = start; end < n; end++) {
21
                    int zerosRemaining = 0;
22
                    int onesRemoved = 0;
23
24
                    for (int i = start; i <= end; i++) {
25
                        if (s.charAt(i) == '0') {
26
                            zerosRemaining++;
27
                        }
28
                    }
29
30
                    for (int i = 0; i < start; i++) {
31
                        if (s.charAt(i) == '1') {
32
                            onesRemoved++;
33
                        }
34
                    }
35
36
                    for (int i = end + 1; i < n; i++) {
37
                        if (s.charAt(i) == '1') {
38
                            onesRemoved++;
39
                        }
40
                    }
41
42
                    int cost = Math.max(zerosRemaining, onesRemoved);
43
                    minCost = Math.min(minCost, cost);
44
                }
45
            }
46
47
            System.out.println(minCost);
48
        }
49
50
        sc.close();
51
    }
52
}
53",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055486
1390055489,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
    T = s.count('1')
3
    if T == 0:
4
        return 0
5
    n = len(s)
6
    7
    # Compute x_max_case1: max number of 1's in window of length T
8
    x_max_case1 = 0
9
    if T <= n:
10
        current = sum(1 for c in s[:T] if c == '1')
11
        x_max_case1 = current
12
        for i in range(1, n - T + 1):
13
            if s[i-1] == '1':
14
                current -= 1
15
            if s[i + T - 1] == '1':
16
                current += 1
17
            if current > x_max_case1:
18
                x_max_case1 = current
19
    20
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
21
    x_max_case2 = 0
22
    current_run = 0
23
    for c in s:
24
        if c == '1':
25
            current_run += 1
26
        else:
27
            if current_run > 0:
28
                candidate = min(current_run, T-1)
29
                if candidate > x_max_case2:
30
                    x_max_case2 = candidate
31
                current_run = 0
32
    # Check the last run
33
    if current_run > 0:
34
        candidate = min(current_run, T-1)
35
        if candidate > x_max_case2:
36
            x_max_case2 = candidate
37
    38
    case1_cost = T - x_max_case1
39
    case2_cost = T - x_max_case2
40
    return min(case1_cost, case2_cost)
41
42
def main():
43
    import sys
44
    input = sys.stdin.read().split()
45
    T_cases = int(input[0])
46
    for i in range(1, T_cases + 1):
47
        s = input[i]
48
        print(compute_min_cost(s))
49
50
if __name__ == ""__main__"":
51
    main()",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055489
1390055490,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    ptr = 0
6
    T = int(input[ptr])
7
    ptr += 1
8
    for _ in range(T):
9
        n, k = map(int, input[ptr:ptr+2])
10
        ptr += 2
11
        a = list(map(int, input[ptr:ptr+n]))
12
        ptr += n
13
        sum_a = sum(a)
14
        values = [a[i] + (i + 1) for i in range(n)]
15
        values.sort(reverse=True)
16
        prefix = [0] * (n + 1)
17
        for i in range(n):
18
            prefix[i+1] = prefix[i] + values[i]
19
        max_gain = 0
20
        max_m = min(k, n)
21
        for m in range(0, max_m + 1):
22
            current = prefix[m] - m * n + (m * (m - 1)) // 2
23
            if current > max_gain:
24
                max_gain = current
25
        print(sum_a - max_gain)
26
27
if __name__ == ""__main__"":
28
    main()",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055490
1390055484,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if _name_ == ""_main_"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",32,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055484
1390055475,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void findEarliestFaults(int[] arr, int k) {
7
        List<Integer> result = new ArrayList<>();
8
        Deque<Integer> deque = new LinkedList<>(); // Store indices of negative numbers
9
10
        for (int i = 0; i < arr.length; i++) {
11
            // Remove elements that are out of this window
12
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
13
                deque.poll();
14
            }
15
16
            // Add current element if it's negative
17
            if (arr[i] < 0) {
18
                deque.offer(i);
19
            }
20
21
            // If we have processed at least k elements, record the earliest fault
22
            if (i >= k - 1) {
23
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
24
            }
25
        }
26
27
        // Print the result
28
        for (int num : result) {
29
            System.out.print(num + "" "");
30
        }
31
        System.out.println();
32
    }
33
34
    public static void main(String[] args) {
35
        Scanner scanner = new Scanner(System.in);
36
        int t = scanner.nextInt(); // Number of test cases
37
38
        while (t-- > 0) {
39
            int n = scanner.nextInt(); // Size of array
40
            int k = scanner.nextInt(); // Batch size
41
            int[] arr = new int[n];
42
43
            for (int i = 0; i < n; i++) {
44
                arr[i] = scanner.nextInt();
45
            }
46
47
            findEarliestFaults(arr, k);
48
        }
49
50
        scanner.close();
51
    }
52
}",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055475
1390055480,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
using ll = long long;
5
6
int main() {
7
    // i/o
8
    ios::sync_with_stdio(false);
9
    cin.tie(0);
10
11
    int T;
12
    cin >> T;
13
    for (int t = 0; t < T; t++) {
14
        int n, k;
15
        cin >> n >> k;
16
        vector<ll> a(n);
17
        for (int i = 0; i < n; i++) {
18
            cin >> a[i];
19
        }
20
21
        // INF for impossible states 
22
        const ll INF = 1e18;
23
24
        vector<ll> prev(k + 1, INF);
25
        prev[0] = 0; 
26
27
    28
        for (int i = 0; i < n; i++) {
29
            vector<ll> curr(k + 1, INF);
30
            for (int s = 0; s <= k; s++) {
31
                // Don't skip i
32
                curr[s] = prev[s] + a[i] + s;
33
                // Skip i hehe
34
                if (s > 0) {
35
                    curr[s] = min(curr[s], prev[s - 1]);
36
                }
37
            }
38
            prev = curr; 
39
        }
40
41
42
        ll ans = *min_element(prev.begin(), prev.end());
43
        cout << ans << '\n';
44
    }
45
    return 0;
46
}",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055480
1390055481,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
11
        12
        Scanner sc = new Scanner(System.in);
13
        int reading = sc.nextInt();
14
        StringBuilder result = new StringBuilder();
15
        16
        while(reading --> 0){
17
            int n = sc.nextInt();
18
            int k = sc.nextInt();
19
            int arr[] = new int[n];
20
            21
            for(int i = 0; i < n; i++){
22
                arr[i] = sc.nextInt();
23
            }
24
            25
            for(int i = 0; i <= n - k; i++){
26
                int faulty = 0;
27
                for(int j = i; j < i+k; j++){
28
                    if(arr[j] < 0) {
29
                        faulty = arr[j];
30
                        break;
31
                    }
32
                }
33
            result.append(faulty).append("" "");
34
            }
35
            result.append(""\n"");
36
        }
37
        System.out.print(result.toString().trim());
38
        sc.close();
39
        40
    }
41
}",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055481
1390055465,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
9
        # Precompute prefix counts for 0s and 1s
10
        prefix_0, prefix_1 = [0] * (n + 1), [0] * (n + 1)
11
        for i in range(1, n + 1):
12
            prefix_0[i] = prefix_0[i - 1] + (servers[i - 1] == '0')
13
            prefix_1[i] = prefix_1[i - 1] + (servers[i - 1] == '1')
14
15
        # Precompute suffix counts for 0s and 1s
16
        suffix_0, suffix_1 = [0] * (n + 1), [0] * (n + 1)
17
        for j in range(1, n + 1):
18
            suffix_0[j] = suffix_0[j - 1] + (servers[n - j] == '0')
19
            suffix_1[j] = suffix_1[j - 1] + (servers[n - j] == '1')
20
21
        min_cost = float('inf')
22
23
        # Iterate over all possible prefixes (i)
24
        for i in range(n + 1):
25
            j_max = n - i
26
            left, right = 0, j_max
27
            best_j, best_cost = 0, float('inf')
28
29
            # Binary search for the best j
30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
36
                if current_cost < best_cost:
37
                    best_cost = current_cost
38
                    best_j = mid
39
                elif current_cost == best_cost and mid < best_j:
40
                    best_j = mid
41
42
                if decommissioned_1 < remaining_0:
43
                    left = mid + 1
44
                else:
45
                    right = mid - 1
46
47
            # Check neighboring j values
48
            for dj in [-1, 0, 1]:
49
                j = best_j + dj
50
                if 0 <= j <= j_max:
51
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
52
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
53
                    current_cost = max(remaining_0, decommissioned_1)
54
                    best_cost = min(best_cost, current_cost)
55
56
            min_cost = min(min_cost, best_cost)
57
58
        results.append(min_cost)
59
    60
    return results
61
62
63
if __name__ == ""__main__"":
64
    T = int(input())
65
    test_cases = [input().strip() for _ in range(T)]
66
    67
    results = min_decommissioning_cost(test_cases)
68
    69
    for result in results:
70
        print(result)
71",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055465
1390055467,unknown,unknown,unknown,"1
def solve():
2
    server_rack = input().strip()
3
    n = len(server_rack)
4
5
    # Count total number of '1's
6
    total_ones = server_rack.count('1')
7
8
    min_cost = float('inf')
9
    left_ones = 0  # Number of '1's removed from the left
10
    remaining_zeros = server_rack.count('0')  # Number of '0's remaining in the rack
11
12
    # Iterate through all possible removal points
13
    for i in range(n + 1):  
14
        if i > 0:
15
            # Update the number of removed ones from left
16
            left_ones += (server_rack[i - 1] == '1')
17
18
        # Compute cost at this point
19
        cost = max(remaining_zeros, left_ones)
20
        min_cost = min(min_cost, cost)
21
22
        # If we move forward, decrease remaining zeros count (since they are skipped)
23
        if i < n and server_rack[i] == '0':
24
            remaining_zeros -= 1
25
26
    print(min_cost)
27
28
# Read number of test cases
29
T = int(input().strip())
30
for _ in range(T):
31
    solve()
32
33",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055467
1390055464,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055464
1390055457,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    for n, k, firewalls in test_cases:
4
        firewalls.sort() 
5
        6
        prefix_sum = [0] * (n + 1)
7
        for i in range(1, n + 1):
8
            prefix_sum[i] = prefix_sum[i - 1] + firewalls[i - 1]  
9
10
        min_effort = float('inf')
11
12
        for x in range(k + 1):
13
            remaining_firewalls = n - x
14
            15
            if remaining_firewalls == 0:
16
                min_effort = 0 
17
                break
18
            cost = prefix_sum[remaining_firewalls]+x
19
            min_effort = min(min_effort, cost)
20
21
        results.append(min_effort)
22
23
    return results
24
25
T = int(input())
26
test_cases = []
27
for _ in range(T):
28
    n, k = map(int, input().split())
29
    firewalls = list(map(int, input().split()))
30
    test_cases.append((n, k, firewalls))
31
32
for result in min_effort_to_breach(T, test_cases):
33
    print(result)
34",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055457
1390055455,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
if __name__ == ""__main__"":
60
    T = int(input())
61
    test_cases = [input().strip() for _ in range(T)]
62
    results = min_decommissioning_cost(test_cases)
63
    for result in results:
64
        print(result)",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055455
1390055459,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055459
1390055453,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",33,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055453
1390055446,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055446
1390055449,unknown,unknown,unknown,"1
def min_cost(server_rack):
2
    n = len(server_rack)
3
    total_zeros = server_rack.count('0')
4
    total_ones = n - total_zeros
5
    min_cost = float('inf')
6
    7
    left = 0
8
    current_zeros = 0
9
    for right in range(n):
10
        if server_rack[right] == '0':
11
            current_zeros += 1
12
        13
        zeros_remaining = current_zeros
14
        ones_removed = total_ones - (right - left + 1 - current_zeros)
15
        16
        cost = max(zeros_remaining, ones_removed)
17
        if cost < min_cost:
18
            min_cost = cost
19
        20
        while left <= right and cost > min_cost:
21
            if server_rack[left] == '0':
22
                current_zeros -= 1
23
            left += 1
24
            zeros_remaining = current_zeros
25
            ones_removed = total_ones - (right - left + 1 - current_zeros)
26
            cost = max(zeros_remaining, ones_removed)
27
            if cost < min_cost:
28
                min_cost = cost
29
    30
    return min_cost
31
32
T = int(input())
33
for _ in range(T):
34
    server_rack = input().strip()
35
    print(min_cost(server_rack))",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055449
1390055450,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
    T = s.count('1')
3
    if T == 0:
4
        return 0
5
    n = len(s)
6
    7
    # Compute x_max_case1: max number of 1's in window of length T
8
    x_max_case1 = 0
9
    if T <= n:
10
        current = sum(1 for c in s[:T] if c == '1')
11
        x_max_case1 = current
12
        for i in range(1, n - T + 1):
13
            if s[i-1] == '1':
14
                current -= 1
15
            if s[i + T - 1] == '1':
16
                current += 1
17
            if current > x_max_case1:
18
                x_max_case1 = current
19
    20
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
21
    x_max_case2 = 0
22
    current_run = 0
23
    for c in s:
24
        if c == '1':
25
            current_run += 1
26
        else:
27
            if current_run > 0:
28
                candidate = min(current_run, T-1)
29
                if candidate > x_max_case2:
30
                    x_max_case2 = candidate
31
                current_run = 0
32
    # Check the last run
33
    if current_run > 0:
34
        candidate = min(current_run, T-1)
35
        if candidate > x_max_case2:
36
            x_max_case2 = candidate
37
    38
    case1_cost = T - x_max_case1
39
    case2_cost = T - x_max_case2
40
    return min(case1_cost, case2_cost)
41
42
def main():
43
    import sys
44
    input = sys.stdin.read().split()
45
    T_cases = int(input[0])
46
    for i in range(1, T_cases + 1):
47
        s = input[i]
48
        print(compute_min_cost(s))
49
50
if _name_ == ""_main_"":
51
    main()",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055450
1390055442,unknown,unknown,unknown,"1
2
3
4
5
6
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
  9
import java.util.Scanner;
10
11
public class Main {
12
13
    public static void main(String[] args) {
14
15
        Scanner sc = new Scanner(System.in);
16
17
        int T = sc.nextInt();
18
19
        sc.nextLine(); // Consume the newline after T
20
21
        while (T-- > 0) {
22
23
            String s = sc.nextLine().trim();
24
25
            int n = s.length();
26
27
            int totalOnes = 0;
28
29
            int maxConsecutiveOnes = 0;
30
31
            int currentConsecutiveOnes = 0;
32
33
            34
35
            // Calculate totalOnes and maxConsecutiveOnes
36
37
            for (char c : s.toCharArray()) {
38
39
                if (c == '1') {
40
41
                    currentConsecutiveOnes++;
42
43
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
44
45
                    totalOnes++;
46
47
                } else {
48
49
                    currentConsecutiveOnes = 0;
50
51
                }
52
53
            }
54
55
            56
57
            // Handle cases where the cost is trivially 0
58
59
            if (totalOnes == 0) {
60
61
                System.out.println(0);
62
63
                continue;
64
65
            }
66
67
            if (maxConsecutiveOnes == totalOnes) {
68
69
                System.out.println(0);
70
71
                continue;
72
73
            }
74
75
            76
77
            int totalZeros = n - totalOnes;
78
79
            int low = 0;
80
81
            int high = Math.max(totalOnes, totalZeros);
82
83
            int answer = high;
84
85
            86
87
            // Binary search for the minimal possible cost
88
89
            while (low <= high) {
90
91
                int mid = (low + high) / 2;
92
93
                int requiredOnes = Math.max(0, totalOnes - mid);
94
95
                96
97
                if (requiredOnes == 0) {
98
99
                    answer = mid;
100
101
                    high = mid - 1;
102
103
                    continue;
104
105
                }
106
107
                108
109
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
110
111
                if (maxOnes >= requiredOnes) {
112
113
                    answer = mid;
114
115
                    high = mid - 1;
116
117
                } else {
118
119
                    low = mid + 1;
120
121
                }
122
123
            }
124
125
            126
127
            System.out.println(answer);
128
129
        }
130
131
        sc.close();
132
133
    }
134
135
    136
137
    // Helper function to calculate maximum ones in any window with at most k zeros
138
139
    private static int maxOnesWithAtMostKZeros(String s, int k) {
140
141
        int left = 0;
142
143
        int zeros = 0;
144
145
        int maxOnes = 0;
146
147
        int n = s.length();
148
149
        150
151
        for (int right = 0; right < n; right++) {
152
153
            if (s.charAt(right) == '0') {
154
155
                zeros++;
156
157
            }
158
159
            // Shrink the window if zeros exceed k
160
161
            while (zeros > k) {
162
163
                if (s.charAt(left) == '0') {
164
165
                    zeros--;
166
167
                }
168
169
                left++;
170
171
            }
172
173
            // Calculate current number of ones in the window
174
175
            int currentOnes = (right - left + 1) - zeros;
176
177
            maxOnes = Math.max(maxOnes, currentOnes);
178
179
        }
180
181
        182
183
        return maxOnes;
184
185
    }
186
187
}",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055442
1390055443,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
if __name__ == ""__main__"":
60
    T = int(input())
61
    test_cases = [input().strip() for _ in range(T)]
62
    results = min_decommissioning_cost(test_cases)
63
    for result in results:
64
        print(result)",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055443
1390055444,unknown,unknown,unknown,"1
import java.util.*;
2
public class Main {
3
    public static void main(String[] args) {
4
        Scanner sc = new Scanner(System.in);
5
        int t = sc.nextInt();
6
        while (t-- > 0) {
7
            int n = sc.nextInt(), k = sc.nextInt();
8
            int[] a = new int[n];
9
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
10
            System.out.println(minEffort(n, k, a));
11
        }
12
        sc.close();
13
    }
14
    15
    static long minEffort(int n, int k, int[] a) {
16
        long[] curr = new long[k + 1];
17
        long[] next = new long[k + 1];
18
19
        Arrays.fill(curr, Long.MAX_VALUE);
20
        Arrays.fill(next, Long.MAX_VALUE);
21
22
        Arrays.fill(next, 0);
23
        24
        for (int i = n - 1; i >= 0; i--) {
25
            for (int skip = 0; skip <= k; skip++) {
26
                long takeEffort = a[i] + skip;
27
28
                if (i < n - 1) {
29
                    takeEffort += next[skip];
30
                }
31
32
                long skipEffort = Long.MAX_VALUE;
33
                if (skip < k) {
34
                    skipEffort = next[skip + 1];
35
                }
36
37
                curr[skip] = Math.min(takeEffort, skipEffort);
38
            }
39
40
            long[] temp = next;
41
            next = curr;
42
            curr = temp;
43
        }
44
        45
        return next[0];
46
    }
47
}",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055444
1390055439,unknown,unknown,unknown,"1
def min_decommissioning_cost(rack):
2
    n = len(rack)
3
    prefix_zeros = [0] * (n + 1)
4
    prefix_ones = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if rack[i] == '0' else 0)
7
        prefix_ones[i+1] = prefix_ones[i] + (1 if rack[i] == '1' else 0)
8
    total_zeros = prefix_zeros[n]
9
    total_ones = prefix_ones[n]
10
    min_cost = float('inf')
11
    for i in range(n + 1):
12
        for j in range(n + 1 - i):
13
            if i + j == n:
14
                continue
15
            zeros_removed_start = prefix_zeros[i]
16
            ones_removed_start = prefix_ones[i]
17
            zeros_removed_end = total_zeros - prefix_zeros[n-j]
18
            ones_removed_end = total_ones - prefix_ones[n-j]
19
            remaining_zeros = total_zeros - zeros_removed_start - zeros_removed_end
20
            removed_ones = ones_removed_start + ones_removed_end
21
            cost = max(remaining_zeros, removed_ones)
22
            min_cost = min(min_cost, cost)
23
    return min_cost
24
def solve_test_cases():
25
    t = int(input())  
26
    results = []
27
    for _ in range(t):
28
        rack = input().strip()
29
        result = min_decommissioning_cost(rack)
30
        results.append(result)
31
    return results
32
if __name__ == ""__main__"":
33
    results = solve_test_cases()
34
    for result in results:
35
        print(result)",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055439
1390055441,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommission {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt(); // Number of test cases
7
        scanner.nextLine(); // Consume the newline after the integer input
8
9
        while (T-- > 0) {
10
            String servers = scanner.nextLine();
11
            int n = servers.length();
12
13
            // Total count of 1s and 0s in the entire string
14
            int totalOnes = 0;
15
            int[] onesPrefixSum = new int[n+1]; // Prefix sum array for ones
16
17
            for (int i = 0; i < n; i++) {
18
                totalOnes += servers.charAt(i) == '1' ? 1 : 0;
19
                onesPrefixSum[i+1] = onesPrefixSum[i] + (servers.charAt(i) == '1' ? 1 : 0);
20
            }
21
22
            int minCost = Integer.MAX_VALUE;
23
24
            // Calculate costs for all subarrays between i and j
25
            for (int i = 0; i <= n; i++) {
26
                for (int j = i; j <= n; j++) {
27
                    int onesRemoved = onesPrefixSum[i] + (totalOnes - onesPrefixSum[j]);
28
                    int zeroesRemaining = j - i - (onesPrefixSum[j] - onesPrefixSum[i]);
29
                    int currentCost = Math.max(zeroesRemaining, onesRemoved);
30
                    minCost = Math.min(minCost, currentCost);
31
                }
32
            }
33
34
            System.out.println(minCost);
35
        }
36
37
        scanner.close();
38
    }
39
}",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055441
1390055440,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055440
1390055438,unknown,unknown,unknown,"1
def min_decommission_cost(binary_string):
2
    left = 0
3
    right = len(binary_string) - 1
4
    5
    while left <= right and binary_string[left] == '0':
6
        left += 1
7
    8
    while right >= left and binary_string[right] == '0':
9
        right -= 1
10
    11
    if left > right:
12
        return 0
13
    14
    remaining_zeros = binary_string[left:right+1].count('0')
15
    removed_ones = binary_string[:left].count('1') + binary_string[right+1:].count('1')
16
    17
    return max(remaining_zeros, removed_ones)
18
19
T = int(input())  
20
for _ in range(T):
21
    binary_string = input().strip()
22
    print(min_decommission_cost(binary_string))
23",34,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055438
1390055426,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
import sys
3
4
data = sys.stdin.read().split()
5
6
if not data:
7
8
    exit()
9
10
t = int(data[0])
11
12
ptr = 1
13
14
res = []
15
16
for _ in range(t):
17
18
    s = data[ptr]
19
20
    ptr += 1
21
22
    n = len(s)
23
24
    pre = [0]*(n+1)
25
26
    for i in range(n):
27
28
        pre[i+1] = pre[i] + (1 if s[i]=='1' else 0)
29
30
    O = pre[n]
31
32
    best = 10**9
33
34
    for L in range(n+1):
35
36
        if L <= n - O:
37
38
            cost = O - (pre[L+O] - pre[L])
39
40
        else:
41
42
            cost = pre[L] + ((n - L - O) if n - L - O > 0 else 0)
43
44
        if cost < best:
45
46
            best = cost
47
48
    res.append(str(best))
49
50
sys.stdout.write(""\n"".join(res))",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055426
1390055430,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055430
1390055437,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        sc.nextLine(); // Consume the newline after T
8
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
27
            // If there are no '1's, the cost is 0
28
            if (totalOnes == 0 || maxConsecutiveOnes == totalOnes) {
29
                System.out.println(0);
30
                continue;
31
            }
32
33
            int totalZeros = n - totalOnes;
34
            int low = 0;
35
            int high = Math.max(totalOnes, totalZeros);
36
            int answer = high;
37
38
            // Binary search for the minimal possible cost
39
            while (low <= high) {
40
                int mid = (low + high) / 2;
41
                int requiredOnes = Math.max(0, totalOnes - mid);
42
43
                if (requiredOnes == 0) {
44
                    answer = mid;
45
                    high = mid - 1;
46
                    continue;
47
                }
48
49
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
50
                if (maxOnes >= requiredOnes) {
51
                    answer = mid;
52
                    high = mid - 1;
53
                } else {
54
                    low = mid + 1;
55
                }
56
            }
57
58
            System.out.println(answer);
59
        }
60
        sc.close();
61
    }
62
63
    // Helper function to calculate maximum ones in any window with at most k zeros
64
    private static int maxOnesWithAtMostKZeros(String s, int k) {
65
        int left = 0;
66
        int zeros = 0;
67
        int maxOnes = 0;
68
        int n = s.length();
69
70
        for (int right = 0; right < n; right++) {
71
            if (s.charAt(right) == '0') {
72
                zeros++;
73
            }
74
            // Shrink the window if zeros exceed k
75
            while (zeros > k) {
76
                if (s.charAt(left) == '0') {
77
                    zeros--;
78
                }
79
                left++;
80
            }
81
            // Calculate current number of ones in the window
82
            int currentOnes = (right - left + 1) - zeros;
83
            maxOnes = Math.max(maxOnes, currentOnes);
84
        }
85
86
        return maxOnes;
87
    }
88
}
89",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055437
1390055423,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
if _name_ == ""_main_"":
60
    T = int(input())
61
    test_cases = [input().strip() for _ in range(T)]
62
    results = min_decommissioning_cost(test_cases)
63
    for result in results:
64
        print(result)",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055423
1390055425,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
    T = s.count('1')
3
    if T == 0:
4
        return 0
5
    n = len(s)
6
    7
    # Compute x_max_case1: max number of 1's in window of length T
8
    x_max_case1 = 0
9
    if T <= n:
10
        current = sum(1 for c in s[:T] if c == '1')
11
        x_max_case1 = current
12
        for i in range(1, n - T + 1):
13
            if s[i-1] == '1':
14
                current -= 1
15
            if s[i + T - 1] == '1':
16
                current += 1
17
            if current > x_max_case1:
18
                x_max_case1 = current
19
    20
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
21
    x_max_case2 = 0
22
    current_run = 0
23
    for c in s:
24
        if c == '1':
25
            current_run += 1
26
        else:
27
            if current_run > 0:
28
                candidate = min(current_run, T-1)
29
                if candidate > x_max_case2:
30
                    x_max_case2 = candidate
31
                current_run = 0
32
    # Check the last run
33
    if current_run > 0:
34
        candidate = min(current_run, T-1)
35
        if candidate > x_max_case2:
36
            x_max_case2 = candidate
37
    38
    case1_cost = T - x_max_case1
39
    case2_cost = T - x_max_case2
40
    return min(case1_cost, case2_cost)
41
42
def main():
43
    import sys
44
    input = sys.stdin.read().split()
45
    T_cases = int(input[0])
46
    for i in range(1, T_cases + 1):
47
        s = input[i]
48
        print(compute_min_cost(s))
49
50
if __name__ == ""__main__"":
51
    main()",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055425
1390055421,unknown,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        n, k = map(int, input().split())
5
        a = list(map(int, input().split()))
6
        sumA = sum(a)
7
        b = [a[i] + (i + 1) for i in range(n)]
8
        b.sort(reverse=True)
9
        prefix = [0] * (n + 1)
10
        for i in range(n):
11
            prefix[i + 1] = prefix[i] + b[i]
12
        min_cost = float('inf')
13
        for x in range(0, min(k, n) + 1):
14
            cost = sumA + x * n - (x * (x - 1)) // 2 - prefix[x]
15
            min_cost = min(min_cost, cost)
16
        print(min_cost)
17
18
solve()
19",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055421
1390055415,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    if n==k:
3
        return 0
4
    total_effort = sum(firewalls)
5
    min_effort = total_effort  # Start with no skips
6
    7
    for i in range(n):
8
        if k > 0:  # If we can skip at least one firewall
9
            new_effort = total_effort - firewalls[i]  # Remove the skipped firewall's effort
10
            new_effort += sum(1 for j in range(i + 1, n))  # Increase remaining firewalls' strength
11
            min_effort = min(min_effort, new_effort)  # Keep track of the minimum effort
12
13
    return min_effort
14
15
t = int(input())
16
for _ in range(t):
17
    n, k = map(int, input().split())
18
    firewalls = list(map(int, input().split()))
19
    print(min_effort(n, k, firewalls))
20",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055415
1390055416,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055416
1390055419,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <climits>
4
#include <algorithm>
5
6
using namespace std;
7
8
int min_effort(int n, int k, const vector<int>& firewalls) {
9
    if (n == 0) return 0;
10
    11
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX));
12
    dp[0][0] = 0;
13
    14
    for (int i = 1; i <= n; ++i) {
15
        for (int j = 0; j <= k; ++j) {
16
            // Case 1: Do not skip the i-th firewall
17
            if (dp[i-1][j] != INT_MAX) {
18
                dp[i][j] = dp[i-1][j] + firewalls[i-1] + j;
19
            }
20
            // Case 2: Skip the i-th firewall if possible
21
            if (j > 0 && dp[i-1][j-1] != INT_MAX) {
22
                dp[i][j] = min(dp[i][j], dp[i-1][j-1]);
23
            }
24
        }
25
    }
26
    27
    return *min_element(dp[n].begin(), dp[n].end());
28
}
29
30
int main() {
31
    ios_base::sync_with_stdio(false);
32
    cin.tie(nullptr);
33
    34
    int T;
35
    cin >> T;
36
    37
    while (T--) {
38
        int n, k;
39
        cin >> n >> k;
40
        41
        vector<int> firewalls(n);
42
        for (int i = 0; i < n; ++i) {
43
            cin >> firewalls[i];
44
        }
45
        46
        if (firewalls.size() != n) {
47
            cout << ""Invalid input\n"";
48
            return 1;
49
        }
50
        51
        cout << min_effort(n, k, firewalls) << '\n';
52
    }
53
    54
    return 0;
55
}
56",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055419
1390055413,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine();
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
16
            for (char c : s.toCharArray()) {
17
                if (c == '1') {
18
                    currentConsecutiveOnes++;
19
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
20
                    totalOnes++;
21
                } else {
22
                    currentConsecutiveOnes = 0;
23
                }
24
            }
25
26
            if (totalOnes == 0) {
27
                System.out.println(0);
28
                continue;
29
            }
30
            if (maxConsecutiveOnes == totalOnes) {
31
                System.out.println(0);
32
                continue;
33
            }
34
            35
            int totalZeros = n - totalOnes;
36
            int low = 0;
37
            int high = Math.max(totalOnes, totalZeros);
38
            int answer = high;
39
40
            while (low <= high) {
41
                int mid = (low + high) / 2;
42
                int requiredOnes = Math.max(0, totalOnes - mid);
43
                44
                if (requiredOnes == 0) {
45
                    answer = mid;
46
                    high = mid - 1;
47
                    continue;
48
                }
49
                50
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
51
                if (maxOnes >= requiredOnes) {
52
                    answer = mid;
53
                    high = mid - 1;
54
                } else {
55
                    low = mid + 1;
56
                }
57
            }
58
            59
            System.out.println(answer);
60
        }
61
        sc.close();
62
    }
63
64
    private static int maxOnesWithAtMostKZeros(String s, int k) {
65
        int left = 0;
66
        int zeros = 0;
67
        int maxOnes = 0;
68
        int n = s.length();
69
        70
        for (int right = 0; right < n; right++) {
71
            if (s.charAt(right) == '0') {
72
                zeros++;
73
            }
74
            while (zeros > k) {
75
                if (s.charAt(left) == '0') {
76
                    zeros--;
77
                }
78
                left++;
79
            }
80
            int currentOnes = (right - left + 1) - zeros;
81
            maxOnes = Math.max(maxOnes, currentOnes);
82
        }
83
        84
        return maxOnes;
85
    }
86
}",35,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055413
1390055405,unknown,unknown,unknown,"1
import sys
2
data = sys.stdin.read().split()
3
if not data:
4
    exit()
5
t = int(data[0])
6
ptr = 1
7
res = []
8
for _ in range(t):
9
    s = data[ptr]
10
    ptr += 1
11
    n = len(s)
12
    pre = [0]*(n+1)
13
    for i in range(n):
14
        pre[i+1] = pre[i] + (1 if s[i]=='1' else 0)
15
    O = pre[n]
16
    best = 10**9
17
    for L in range(n+1):
18
        if L <= n - O:
19
            cost = O - (pre[L+O] - pre[L])
20
        else:
21
            cost = pre[L] + ((n - L - O) if n - L - O > 0 else 0)
22
        if cost < best:
23
            best = cost
24
    res.append(str(best))
25
sys.stdout.write(""\n"".join(res))",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055405
1390055407,unknown,unknown,unknown,"1
def min_cost(server_rack):
2
    n = len(server_rack)
3
    total_zeros = server_rack.count('0')
4
    total_ones = n - total_zeros
5
    min_cost = float('inf')
6
    7
    left = 0
8
    current_zeros = 0
9
    for right in range(n):
10
        if server_rack[right] == '0':
11
            current_zeros += 1
12
        13
        zeros_remaining = current_zeros
14
        ones_removed = total_ones - (right - left + 1 - current_zeros)
15
        16
        cost = max(zeros_remaining, ones_removed)
17
        if cost < min_cost:
18
            min_cost = cost
19
        20
        while left <= right and cost > min_cost:
21
            if server_rack[left] == '0':
22
                current_zeros -= 1
23
            left += 1
24
            zeros_remaining = current_zeros
25
            ones_removed = total_ones - (right - left + 1 - current_zeros)
26
            cost = max(zeros_remaining, ones_removed)
27
            if cost < min_cost:
28
                min_cost = cost
29
    30
    return min_cost
31
32
T = int(input())
33
for _ in range(T):
34
    server_rack = input().strip()
35
    print(min_cost(server_rack))",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055407
1390055412,unknown,unknown,unknown,1,36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055412
1390055398,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <string.h>
3
#include <math.h>
4
#include <stdlib.h>
5
void early_fulat(int* arr, int n, int k) {
6
    int front = 0, rear = 0, dq[n], result[n - k + 1], resIndex = 0;
7
      int extra_var = 0; 
8
      9
      for (int i = 0; i < n; i++) {
10
          extra_var += arr[i] * 0;
11
          if (front < rear && dq[front] == i - k) {
12
              front++;
13
          }
14
          if (arr[i] < 0) {
15
              dq[rear++] = i;
16
          }
17
          if (i >= k - 1) {
18
              result[resIndex++] = (front < rear) ? arr[dq[front]] : 0;
19
          }
20
      }
21
      for (int i = 0; i < resIndex; i++) {
22
          printf(""%d "", result[i]);
23
      }
24
      printf(""\n"");
25
}
26
27
int main() {
28
    int t;
29
    scanf(""%d"", &t);
30
    while (t--) {
31
        int n, k;
32
        scanf(""%d %d"", &n, &k);
33
        int* arr = (int*)malloc(n * sizeof(int));
34
        for (int i = 0; i < n; i++) {
35
            scanf(""%d"", &arr[i]);
36
        }
37
        early_fulat(arr, n, k);
38
        free(arr);
39
    }
40
    return 0;
41
}
42",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055398
1390055404,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055404
1390055397,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055397
1390055390,unknown,unknown,unknown,"1
def min_effort_to_breach(arr, k):
2
    n = len(arr)
3
    4
    # If we can skip all firewalls, effort is 0
5
    if k >= n:
6
        return 0
7
    8
    # Initialize DP table
9
    # dp[i][j] = min effort to breach first i firewalls using exactly j skips
10
    dp = {}
11
    12
    # Base case: no firewalls, no effort
13
    dp[(0, 0)] = 0  # (firewalls processed, skips used) -> min effort
14
    15
    for i in range(n):
16
        new_dp = {}
17
        18
        for (processed, skips), effort in dp.items():
19
            # Option 1: Skip current firewall
20
            if skips < k:
21
                new_state = (processed + 1, skips + 1)
22
                new_effort = effort
23
                if new_state not in new_dp or new_effort < new_dp[new_state]:
24
                    new_dp[new_state] = new_effort
25
            26
            # Option 2: Breach current firewall
27
            new_state = (processed + 1, skips)
28
            new_effort = effort + arr[i] + skips
29
            if new_state not in new_dp or new_effort < new_dp[new_state]:
30
                new_dp[new_state] = new_effort
31
        32
        dp = new_dp
33
    34
    # Find minimum effort among all states that processed all firewalls
35
    min_effort = float('inf')
36
    for (processed, skips), effort in dp.items():
37
        if processed == n:
38
            min_effort = min(min_effort, effort)
39
    40
    return min_effort
41
42
def solve_test_cases():
43
    t = int(input())  # Number of test cases
44
    results = []
45
    46
    for _ in range(t):
47
        n, k = map(int, input().split())
48
        arr = list(map(int, input().split()))
49
        50
        result = min_effort_to_breach(arr, k)
51
        results.append(result)
52
    53
    # Print results
54
    for result in results:
55
        print(result)
56
57
# Execute program
58
if __name__ == ""__main__"":
59
    solve_test_cases()",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055390
1390055392,unknown,unknown,unknown,"1
def min_effort_to_breach_firewalls(t, test_cases):
2
    results = []
3
4
    for test in test_cases:
5
        n, k = test[0]
6
        arr = test[1]
7
8
        # Sort firewall strengths in descending order
9
        arr_sorted = sorted(arr, reverse=True)
10
11
        # Choose top k strong firewalls to skip
12
        skips = set()
13
        for i in range(k):
14
            skips.add(arr_sorted[i])
15
16
        total_effort = 0
17
        skipped = 0
18
19
        for strength in arr:
20
            if strength in skips and skipped < k:
21
                skipped += 1
22
                skips.remove(strength)  # Remove to handle duplicates properly
23
            else:
24
                total_effort += strength + skipped  # Each skip adds +1 to every subsequent effort
25
26
        results.append(total_effort)
27
28
    return results
29
30
31
# -------- DRIVER CODE --------
32
T = int(input())
33
test_cases = []
34
35
for _ in range(T):
36
    n, k = map(int, input().split())
37
    arr = list(map(int, input().split()))
38
    test_cases.append(((n, k), arr))
39
40
answers = min_effort_to_breach_firewalls(T, test_cases)
41
42
for ans in answers:
43
    print(ans)
44",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055392
1390055394,unknown,unknown,unknown,"1
def minimize_decommission_cost(test_cases):
2
    results = []
3
4
    for binary_string in test_cases:
5
        n = len(binary_string)
6
        total_idle = binary_string.count('0')  
7
        total_active = binary_string.count('1')  
8
        min_cost = float('inf')  
9
10
        11
        for start in range(n + 1):  
12
            for end in range(n - start + 1):  
13
               14
                remaining = binary_string[start:n - end]
15
16
       17
                remaining_idle = remaining.count('0')
18
                decommissioned_active = total_active - remaining.count('1')
19
20
               21
                cost = max(remaining_idle, decommissioned_active)
22
                min_cost = min(min_cost, cost)
23
24
        results.append(min_cost)
25
26
    return results
27
28
29
30
T = int(input().strip())
31
test_cases = [input().strip() for _ in range(T)]
32
33
34
results = minimize_decommission_cost(test_cases)
35
for result in results:
36
    print(result)
37",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055394
1390055389,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    # Read number of test cases
5
    T = int(input())
6
    for _ in range(T):
7
        # Read the binary string
8
        S = input().strip()
9
        n = len(S)
10
        11
        # Compute prefix sums for '0's and '1's
12
        prefix_zeros = [0] * (n + 1)
13
        prefix_ones = [0] * (n + 1)
14
        for i in range(1, n + 1):
15
            prefix_zeros[i] = prefix_zeros[i - 1] + (S[i - 1] == '0')
16
            prefix_ones[i] = prefix_ones[i - 1] + (S[i - 1] == '1')
17
        18
        # Initialize minimum cost
19
        min_cost = float('inf')
20
        21
        # Iterate over all possible end indices j
22
        for j in range(n + 1):
23
            # Number of '1's in the suffix from j to n
24
            C = prefix_ones[n] - prefix_ones[j]
25
            26
            # Binary search to find the smallest m where:
27
            # Number of '0's in [m, j-1] <= Number of '1's in [0, m-1] + [j, n-1]
28
            left, right = 0, j
29
            while left < right:
30
                mid = left + (right - left) // 2
31
                if prefix_zeros[j] - prefix_zeros[mid] <= prefix_ones[mid] + C:
32
                    right = mid
33
                else:
34
                    left = mid + 1
35
            m = left
36
            37
            # Compute cost based on the optimal m
38
            if m == 0:
39
                # If m is 0, no prefix is removed, cost is just '1's in suffix
40
                cost = C
41
            else:
42
                # Cost is min of '0's in [m-1, j-1] and '1's in [0, m-1] + [j, n-1]
43
                cost = min(prefix_zeros[j] - prefix_zeros[m - 1], prefix_ones[m] + C)
44
            min_cost = min(min_cost, cost)
45
        46
        # Output the minimum cost for this test case
47
        print(min_cost)
48
49
if __name__ == ""__main__"":
50
    main()",36,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055389
1390055378,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    a = list(map(int, input().split()))
5
    values = [a[i] - (n - i - 1) for i in range(n)]
6
    values.sort(reverse=True)
7
    prefix_sum = [0] * (n + 1)
8
    for i in range(n):
9
        prefix_sum[i + 1] = prefix_sum[i] + values[i]
10
    max_m = min(k, n)
11
    max_total = max(prefix_sum[m] + m * (m - 1) // 2 for m in range(max_m + 1))
12
    print(sum(a) - max_total)",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055378
1390055383,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055383
1390055386,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
    T = s.count('1')
3
    if T == 0:
4
        return 0
5
    n = len(s)
6
    7
    # Compute x_max_case1: max number of 1's in window of length T
8
    x_max_case1 = 0
9
    if T <= n:
10
        current = sum(1 for c in s[:T] if c == '1')
11
        x_max_case1 = current
12
        for i in range(1, n - T + 1):
13
            if s[i-1] == '1':
14
                current -= 1
15
            if s[i + T - 1] == '1':
16
                current += 1
17
            if current > x_max_case1:
18
                x_max_case1 = current
19
    20
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
21
    x_max_case2 = 0
22
    current_run = 0
23
    for c in s:
24
        if c == '1':
25
            current_run += 1
26
        else:
27
            if current_run > 0:
28
                candidate = min(current_run, T-1)
29
                if candidate > x_max_case2:
30
                    x_max_case2 = candidate
31
                current_run = 0
32
    # Check the last run
33
    if current_run > 0:
34
        candidate = min(current_run, T-1)
35
        if candidate > x_max_case2:
36
            x_max_case2 = candidate
37
    38
    case1_cost = T - x_max_case1
39
    case2_cost = T - x_max_case2
40
    return min(case1_cost, case2_cost)
41
42
def main():
43
    import sys
44
    input = sys.stdin.read().split()
45
    T_cases = int(input[0])
46
    for i in range(1, T_cases + 1):
47
        s = input[i]
48
        print(compute_min_cost(s))
49
50
if __name__ == ""__main__"":
51
    main()",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055386
1390055373,unknown,unknown,unknown,"1
import sys
2
def solve():
3
    x = sys.stdin.buffer.read().split()
4
    if not x: return
5
    t = int(x[0])
6
    i = 1
7
    o = []
8
    for _ in range(t):
9
        s = x[i].decode()
10
        i += 1
11
        n = len(s)
12
        A = [0]*(n+1)
13
        B = [0]*(n+1)
14
        for j in range(n):
15
            B[j+1] = B[j] + (s[j]=='1')
16
            A[j+1] = A[j] + (s[j]=='0')
17
        T = A[n]
18
        C = [0]*(n+1)
19
        E = [0]*(n+1)
20
        for j in range(n):
21
            E[j+1] = E[j] + (s[n-1-j]=='1')
22
            C[j+1] = C[j] + (s[n-1-j]=='0')
23
        r = 10**9
24
        for x_ in range(n+1):
25
            m = n - x_
26
            y = T - A[x_] - B[x_]
27
            if y < 0: y = 0
28
            if y > m: y = m
29
            for z in (y, y-1, y+1):
30
                if z < 0 or z > m: continue
31
                v1 = B[x_] + E[z]
32
                v2 = T - (A[x_] + C[z])
33
                v = v1 if v1 >= v2 else v2
34
                if v < r: r = v
35
        o.append(str(r))
36
    sys.stdout.write(""\n"".join(o))
37
if __name__==""__main__"":
38
    solve()
39",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055373
1390055374,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if __name__ == ""__main__"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055374
1390055377,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
#include <ext/pb_ds/assoc_container.hpp>
3
#include <ext/pb_ds/tree_policy.hpp>
4
#include <ext/pb_ds/detail/standard_policies.hpp>
5
#include <cmath>
6
#define int long long int
7
#define pb push_back
8
/*---------------------------------------------------------------------------------------------------------------------------------*/
9
/*ASCII small case-> a-97 to z-122
10
upper case-> A-65 to Z-90*/
11
#define nl ""\n""
12
#define mp map<int, int>
13
#define all(v) v.begin(), v.end()
14
#define F first
15
#define S second
16
#define ump unordered_map<long long, int, custom_hash>
17
#define mstpi multiset<pair<int, int> >
18
#define mst multiset<int>
19
#define vec vector<int>
20
#define pi pair<int, int>
21
#define ld long double
22
#define vep vector<pair<int, int>>
23
#define ul unsigned long long
24
#define loop1 for (int i = 0; i < n; i++)
25
#define REP(i, a, b) for (int i = a; i <= b; i++)
26
#define NO cout << ""NO"" << endl
27
#define YES cout << ""YES"" << endl
28
using namespace std;
29
using namespace __gnu_pbds;
30
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
31
/*---------------------------------------------------------------------------------------------------------------------------------*/
32
const double PI = 3.1415926535;
33
const int inf = 1e18;
34
const int mod = 1000000007;
35
/*---------------------------------------------------------------------------------------------------------------------------------*/
36
int modmul(int a, int b, int m)
37
{
38
    a %= m;
39
    b %= m;
40
    return (a * b) % m;
41
}
42
int modexp(int n, int x)
43
{
44
    int ans = 1;
45
    while (n > 0)
46
    {
47
        if (n & 1)
48
        {
49
            ans = (ans * x) % mod;
50
        }
51
        n >>= 1;
52
        x = (x * x) % mod;
53
    }
54
    return ans;
55
}
56
/*---------------------------------------------------------------------------------------------------------------------------------*/
57
string add(string a, string b)
58
{
59
    string ans = """";
60
    int carry = 0;
61
    while (!a.empty() || !b.empty() || carry > 0)
62
    {
63
        int digitA = a.empty() ? 0 : a.back() - '0';
64
        int digitB = b.empty() ? 0 : b.back() - '0';
65
        int sum = digitA + digitB + carry;
66
        ans = to_string(sum % 10) + ans;
67
        carry = sum / 10;
68
        if (!a.empty())
69
            a.pop_back();
70
        if (!b.empty())
71
            b.pop_back();
72
    }
73
    return ans;
74
}
75
string ministrnum(string a, string b)
76
{
77
    if (a.length() > b.length())
78
        return b;
79
    else if (b.length() > a.length())
80
        return a;
81
    else
82
    {
83
        int n = a.length();
84
        for (int i = 0; i < n; i++)
85
        {
86
            if (a[i] > b[i])
87
                return b;
88
            else if (a[i] < b[i])
89
                return a;
90
        }
91
    }
92
    return a;
93
}
94
vector<int> sieve(int n) {
95
    vector<bool> isPrime(n + 1, true);
96
    vector<int> primes;
97
    if(n >= 0) isPrime[0] = false;
98
    if(n >= 1) isPrime[1] = false;
99
    for (int i = 2; i <= n; i++) {
100
        if (isPrime[i]) {
101
            primes.push_back(i);
102
            for (int j = 2 * i; j <= n; j += i)
103
                isPrime[j] = false;
104
        }
105
    }
106
    return primes;
107
}
108
109
class SegmentTree {
110
public:
111
    int n;
112
    std::vector<int> tree;
113
    std::vector<int> lazy;
114
    115
    SegmentTree(const std::vector<int>& arr) {
116
        n = arr.size();
117
        tree.resize(4 * n, 0);
118
        lazy.resize(4 * n, 0);
119
        build(arr, 0, n - 1, 0);
120
    }
121
    122
    void build(const std::vector<int>& arr, int start, int end, int index) {
123
        if (start == end) {
124
            tree[index] = arr[start];
125
            return;
126
        }
127
        int mid = (start + end) / 2;
128
        build(arr, start, mid, 2 * index + 1);
129
        build(arr, mid + 1, end, 2 * index + 2);
130
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
131
    }
132
    133
    int queryRange(int start, int end, int l, int r, int index = 0) {
134
        if (lazy[index] != 0) {
135
            tree[index] += (end - start + 1) * lazy[index];
136
            if(start != end) {
137
                lazy[2 * index + 1] += lazy[index];
138
                lazy[2 * index + 2] += lazy[index];
139
            }
140
            lazy[index] = 0;
141
        }
142
        if (start > r || end < l)
143
            return 0;
144
        if (start >= l && end <= r)
145
            return tree[index];
146
        int mid = (start + end) / 2;
147
        return queryRange(start, mid, l, r, 2 * index + 1) +
148
               queryRange(mid + 1, end, l, r, 2 * index + 2);
149
    }
150
    151
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
152
        if(lazy[index] != 0) {
153
            tree[index] += (end - start + 1) * lazy[index];
154
            if(start != end) {
155
                lazy[2 * index + 1] += lazy[index];
156
                lazy[2 * index + 2] += lazy[index];
157
            }
158
            lazy[index] = 0;
159
        }
160
        if(start > r || end < l)
161
            return;
162
        if(start >= l && end <= r) {
163
            tree[index] += (end - start + 1) * diff;
164
            if(start != end) {
165
                lazy[2 * index + 1] += diff;
166
                lazy[2 * index + 2] += diff;
167
            }
168
            return;
169
        }
170
        int mid = (start + end) / 2;
171
        updateRange(start, mid, l, r, diff, 2 * index + 1);
172
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
173
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
174
    }
175
};
176
class DSU {
177
public:
178
    std::vector<int> parent, rank;
179
    180
    DSU(int n) {
181
        parent.resize(n);
182
        rank.resize(n, 0);
183
        for (int i = 0; i < n; i++)
184
            parent[i] = i;
185
    }
186
    187
    int find(int x) {
188
        if (parent[x] != x)
189
            parent[x] = find(parent[x]);
190
        return parent[x];
191
    }
192
    193
    bool unionSets(int x, int y) {
194
        int rootX = find(x);
195
        int rootY = find(y);
196
        if (rootX == rootY)
197
            return false;
198
        if (rank[rootX] < rank[rootY])
199
            parent[rootX] = rootY;
200
        else if (rank[rootX] > rank[rootY])
201
            parent[rootY] = rootX;
202
        else {
203
            parent[rootY] = rootX;
204
            rank[rootX]++;
205
        }
206
        return true;
207
    }
208
};
209
210
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
211
struct Node {
212
    int val;
213
    int weight, size;
214
    Node *left, *right;
215
    bool rev = false;
216
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
217
};
218
ostream &operator<<(ostream &os, Node *n) {
219
    if(!n) return os;
220
    os << n -> left;
221
    os << n -> val;
222
    os << n -> right;
223
    return os;
224
}
225
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
226
void push(Node* Treap) {
227
    if(!Treap) return;
228
    if(Treap -> rev) {
229
        Treap -> rev = false;
230
        swap(Treap->left, Treap->right);
231
        if(Treap -> left) Treap->left->rev ^= true;
232
        if(Treap -> right) Treap->right->rev ^= true;
233
    }
234
}
235
void pull(Node *Treap) {
236
    if(!Treap) return;
237
    push(Treap -> left), push(Treap -> right);
238
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
239
    return;
240
}
241
void split(Node *Treap, Node *&left, Node *&right, int val) {
242
    if(!Treap) {
243
        left = right = NULL;
244
        return;
245
    }
246
    push(Treap);
247
    if(size(Treap -> left) < val) {
248
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
249
        left = Treap;
250
    }
251
    else {
252
        split(Treap -> left, left, Treap -> left, val);
253
        right = Treap;
254
    }
255
    pull(Treap);
256
}
257
void merge(Node *&Treap, Node *left, Node *right) {
258
    push(left), push(right);
259
    if(left == NULL) {
260
        Treap = right;
261
        return;
262
    }
263
    if(right == NULL) {
264
        Treap = left;
265
        return;
266
    }
267
    if(left -> weight < right -> weight) {
268
        merge(right -> left, left, right -> left);
269
        Treap = right;
270
    }
271
    else {
272
        merge(left->right, left->right, right);
273
        Treap = left;
274
    }
275
    pull(Treap);
276
}
277
void inOrder(Node *curr, vector<int> &res) {
278
    if(curr == NULL) return;
279
    push(curr);
280
    inOrder(curr->left, res);
281
    res.pb(curr->val);
282
    inOrder(curr->right, res);
283
    pull(curr);
284
}
285
struct Treap {
286
    Node *root = nullptr;
287
    void insert(int i, int val) {
288
        Node *l, *r;
289
        split(root, l, r, i);
290
        Node *v = new Node(val);
291
        merge(l, l, v);
292
        merge(root, l, r);
293
    }
294
    295
    void del(int i) {
296
        Node *l, *r;
297
        split(root, l, r, i);
298
        split(r, root, r, 1);
299
        merge(root, l, r);
300
    }
301
    302
    void update(int l, int r, function<void(Node *)> f) {
303
        Node *a, *b, *c;
304
        split(root, a, b, l-1);
305
        split(b, b, c, r-l+1);
306
        if(b) {f(b);}
307
        merge(root, a, b);
308
        merge(root, root, c);
309
    }
310
    311
    vector<int> allPr() {
312
        vector<int> res;
313
        inOrder(root, res);
314
        return res;
315
    }
316
    317
    void cycShft(int l, int r) {
318
        Node *a, *b, *c, *d;
319
        split(root, a, b, l-1);
320
        split(b, b, c, r-l+1);
321
        split(b, b, d, r-l);
322
        merge(root, a, d);
323
        merge(root, root, b);
324
        merge(root, root, c);
325
    }
326
};
327
vector<int> computePrefix(const string &pattern) {
328
    int n = pattern.size();
329
    vector<int> prefix(n, 0);
330
    for (int i = 1, j = 0; i < n; i++) {
331
        while (j > 0 && pattern[i] != pattern[j])
332
            j = prefix[j - 1];
333
        if (pattern[i] == pattern[j])
334
            j++;
335
        prefix[i] = j;
336
    }
337
    return prefix;
338
}
339
340
vector<int> KMPSearch(const string &text, const string &pattern) {
341
    vector<int> prefix = computePrefix(pattern);
342
    vector<int> occurrences;
343
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
344
        while (j > 0 && text[i] != pattern[j])
345
            j = prefix[j - 1];
346
        if (text[i] == pattern[j])
347
            j++;
348
        if (j == (int)pattern.size()) {
349
            occurrences.push_back(i - j + 1);
350
            j = prefix[j - 1];
351
        }
352
    }
353
    return occurrences;
354
}
355
void solve()
356
{
357
    int n, ans = 1e9;
358
    string s;
359
    cin>>s;
360
    n = s.size();
361
    362
    int tot1 = count(all(s), '1');
363
    ans = tot1;
364
    365
    366
    auto check = [&](int m) {
367
        int cnt0 = 0, cnt1 = 0;
368
        for(int i = 0, j = 0; i<n; i++) {
369
            cnt0 += s[i] == '0';
370
            cnt1 += s[i] == '1';
371
            372
            if(tot1 - cnt1 == m) {
373
                while(j < n && s[j] == '0') {
374
                    cnt0--;
375
                    j++;
376
                }
377
                if(cnt0 <= m) return true;
378
                cnt1--;
379
                j++;
380
            }
381
        }
382
        return false;
383
    };
384
    385
    int l = 0, r = ans;
386
    while(l <= r) {
387
        int m = r - (r - l)/2;
388
        if(check(m)) r = m - 1;
389
        else l = m + 1;
390
    }
391
    cout<<l<<endl;
392
}
393
int32_t main()
394
{
395
    ios_base ::sync_with_stdio(0);
396
    cin.tie(0);
397
    cout.tie(0);
398
    int t = 1;
399
    cin >> t;
400
    while (t--)
401
        solve();
402
}",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055377
1390055369,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055369
1390055370,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055370
1390055371,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    total_effort = sum(strengths)  # Base effort without skipping
3
    min_effort = total_effort  # Initialize minimum effort
4
    5
    for skips in range(k + 1):  # Try skipping 0 to k firewalls
6
        effort = sum(strengths[skips:]) + sum(range(skips))  # Apply security increase for remaining firewalls
7
        min_effort = min(min_effort, effort)  # Track minimum possible effort
8
    9
    return min_effort
10
11
# Read input
12
t = int(input())
13
for _ in range(t):
14
    n, k = map(int, input().split())
15
    strengths = list(map(int, input().split()))
16
    print(min_effort_to_breach(n, k, strengths))",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055371
1390055367,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    min_effort = total_effort  # Start with no skips
4
    5
    for i in range(n):
6
        if k > 0:  # If we can skip at least one firewall
7
            new_effort = total_effort - firewalls[i]  # Remove the skipped firewall's effort
8
            new_effort += sum(1 for j in range(i + 1, n))  # Increase remaining firewalls' strength
9
            min_effort = min(min_effort, new_effort)  # Keep track of the minimum effort
10
11
    return min_effort
12
13
t = int(input())
14
for _ in range(t):
15
    n, k = map(int, input().split())
16
    firewalls = list(map(int, input().split()))
17
    print(min_effort(n, k, firewalls))
18",37,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055367
1390055362,unknown,unknown,unknown,"1
def min_effort_to_breach(arr, k):
2
    n = len(arr)
3
    4
    # If we can skip all firewalls, effort is 0
5
    if k >= n:
6
        return 0
7
    8
    # Initialize DP table
9
    # dp[i][j] = min effort to breach first i firewalls using exactly j skips
10
    dp = {}
11
    12
    # Base case: no firewalls, no effort
13
    dp[(0, 0)] = 0  # (firewalls processed, skips used) -> min effort
14
    15
    for i in range(n):
16
        new_dp = {}
17
        18
        for (processed, skips), effort in dp.items():
19
            # Option 1: Skip current firewall
20
            if skips < k:
21
                new_state = (processed + 1, skips + 1)
22
                new_effort = effort
23
                if new_state not in new_dp or new_effort < new_dp[new_state]:
24
                    new_dp[new_state] = new_effort
25
            26
            # Option 2: Breach current firewall
27
            new_state = (processed + 1, skips)
28
            new_effort = effort + arr[i] + skips
29
            if new_state not in new_dp or new_effort < new_dp[new_state]:
30
                new_dp[new_state] = new_effort
31
        32
        dp = new_dp
33
    34
    # Find minimum effort among all states that processed all firewalls
35
    min_effort = float('inf')
36
    for (processed, skips), effort in dp.items():
37
        if processed == n:
38
            min_effort = min(min_effort, effort)
39
    40
    return min_effort
41
42
def solve_test_cases():
43
    t = int(input())  # Number of test cases
44
    results = []
45
    46
    for _ in range(t):
47
        n, k = map(int, input().split())
48
        arr = list(map(int, input().split()))
49
        50
        result = min_effort_to_breach(arr, k)
51
        results.append(result)
52
    53
    # Print results
54
    for result in results:
55
        print(result)
56
57
# Execute program
58
if __name__ == ""__main__"":
59
    solve_test_cases()",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055362
1390055363,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if __name__ == ""__main__"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055363
1390055361,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055361
1390055356,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt();
7
        8
        while (t-- > 0) {
9
            solve(sc);
10
        }
11
        12
        sc.close();
13
    }
14
15
    static void solve(Scanner sc) {
16
        int n = sc.nextInt();
17
        int k = sc.nextInt();
18
        int[] a = new int[n];
19
20
        for (int i = 0; i < n; i++) {
21
            a[i] = sc.nextInt();
22
        }
23
24
        int minEffort = Integer.MAX_VALUE;
25
26
        // Iterate over all subsets using bitmasking
27
        for (int i = 0; i < (1 << n); i++) {
28
            List<Integer> skipped = new ArrayList<>();
29
            List<Integer> efforts = new ArrayList<>();
30
31
            for (int j = 0; j < n; j++) {
32
                if ((i >> j & 1) == 1) {
33
                    skipped.add(j);
34
                } else {
35
                    efforts.add(j);
36
                }
37
            }
38
39
            if (skipped.size() <= k) {
40
                int effort = 0;
41
                int skippedCount = 0;
42
43
                for (int j = 0; j < n; j++) {
44
                    if (skipped.contains(j)) {
45
                        skippedCount++;
46
                    } else {
47
                        effort += a[j] + skippedCount;
48
                    }
49
                }
50
51
                minEffort = Math.min(minEffort, effort);
52
            }
53
        }
54
55
        System.out.println(minEffort);
56
    }
57
}
58",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055356
1390055355,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055355
1390055358,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx+1])
10
        idx +=2
11
        a = list(map(int, input[idx:idx+n]))
12
        idx +=n
13
        sum_a = sum(a)
14
        v = []
15
        for i in range(n):
16
            val = a[i] - (n - i -1)
17
            v.append(val)
18
        v.sort(reverse=True)
19
        prefix = [0] * (n+1)
20
        for i in range(n):
21
            prefix[i+1] = prefix[i] + v[i]
22
        max_sum = 0
23
        max_t = min(k, n)
24
        for t in range(0, max_t+1):
25
            current = prefix[t] + t*(t-1)//2
26
            if current > max_sum:
27
                max_sum = current
28
        print(sum_a - max_sum)
29
30
if __name__ == ""__main__"":
31
    main()",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055358
1390055352,unknown,unknown,unknown,"1
def min_decommission_cost(s: str) -> int:
2
    n = len(s)
3
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
4
    T = len(ones_pos)
5
    6
    if T == 0:
7
        return 0
8
    9
    zeros_total = s.count('0')
10
    ans = min(zeros_total, T) 
11
    12
    for X in range(1, T + 1):
13
        for i in range(0, T - X + 1):
14
            left = ones_pos[i]
15
            right = ones_pos[i + X - 1]
16
            length = right - left + 1
17
            zeros_in_block = length - X
18
            candidate = max(zeros_in_block, T - X)
19
            ans = min(ans, candidate)
20
    21
    return ans
22
23
if __name__ == '__main__':
24
    T = int(input().strip())
25
    for _ in range(T):
26
        s = input().strip()
27
        print(min_decommission_cost(s))",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055352
1390055353,unknown,unknown,unknown,"1
import sys
2
3
def findMinimumCost():
4
    data = sys.stdin.read().splitlines()
5
    tests = int(data[0])
6
    line = 1
7
    ans = []
8
    9
    for _ in range(tests):
10
        servers = data[line].strip()
11
        line += 1
12
        ones = [i for i, c in enumerate(servers) if c == '1']
13
        one_count = len(ones)
14
        15
        if one_count == 0:
16
            ans.append(""0"")
17
            continue
18
            19
        diffs = [ones[i] - i for i in range(one_count)]
20
        21
        def check(limit):
22
            if one_count - limit <= 0:
23
                return True
24
            j = 0
25
            for i in range(one_count):
26
                j = max(j, i)
27
                while j < one_count and diffs[j] - diffs[i] <= limit:
28
                    j += 1
29
                if j - i >= one_count - limit:
30
                    return True
31
            return False
32
            33
        left, right, answer = 0, len(servers), len(servers)
34
        while left <= right:
35
            mid = (left + right) // 2
36
            if check(mid):
37
                answer = mid
38
                right = mid - 1
39
            else:
40
                left = mid + 1
41
                42
        ans.append(str(answer))
43
        44
    sys.stdout.write(""\n"".join(ans))
45
    46
if __name__ == ""__main__"":
47
    findMinimumCost()",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055353
1390055354,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055354
1390055350,unknown,unknown,unknown,"1
def min_effort(n, k, a):
2
    if k >= n:
3
        return 0
4
    total = sum(a)
5
    window_sum = sum(a[:k])
6
    min_effort = total - window_sum + (n - k) * 0
7
    for i in range(k, n):
8
        window_sum = window_sum + a[i] - a[i - k]
9
        effort = total - window_sum + (n - k) * (i - k + 1)
10
        min_effort = min(min_effort, effort)
11
    return min_effort
12
13
T = int(input())
14
for _ in range(T):
15
    n, k = map(int, input().split())
16
    a = list(map(int, input().split()))
17
    print(min_effort(n, k, a))",38,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055350
1390055342,unknown,unknown,unknown,1,39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055342
1390055344,unknown,unknown,unknown,"1
2
3
from collections import deque
4
5
def earliest_faults(arr, k):
6
    result = []
7
    dq = deque()
8
    9
    for i in range(len(arr)):
10
        # Remove elements that are out of the current window
11
        if dq and dq[0] < i - k + 1:
12
            dq.popleft()
13
        14
        # Add current element if it's negative
15
        if arr[i] < 0:
16
            dq.append(i)
17
        18
        # Capture the first faulty component in the batch
19
        if i >= k - 1:
20
            result.append(arr[dq[0]] if dq else 0)
21
    22
    return result
23
24
def process_test_cases():
25
    t = int(input())
26
    results = []
27
    for _ in range(t):
28
        n, k = map(int, input().split())
29
        arr = list(map(int, input().split()))
30
        results.append("" "".join(map(str, earliest_faults(arr, k))))
31
    32
    print(""\n"".join(results))
33
34
# Run the function
35
process_test_cases()
36",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055344
1390055345,unknown,unknown,unknown,"1
from collections import deque
2
3
def faulty_readings(arr, k):
4
    result = []
5
    dq = deque()  
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    result.append(arr[dq[0]] if dq else 0)
12
    13
    for i in range(k, len(arr)):
14
        if dq and dq[0] < i - k + 1:
15
            dq.popleft()
16
        17
        if arr[i] < 0:
18
            dq.append(i)
19
        20
        result.append(arr[dq[0]] if dq else 0)
21
    22
    return result
23
24
t = int(input())  
25
for _ in range(t):
26
    n, k = map(int, input().split())  
27
    arr = list(map(int, input().split()))  
28
    29
    print(*faulty_readings(arr, k))  
30",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055345
1390055332,unknown,unknown,unknown,"1
def min_cost(s):
2
    total_ones = s.count('1')
3
    n = len(s)
4
    5
    scenario_empty = total_ones  # cost when removing all
6
    7
    # Scenario 1: window lengths 1 to min(total_ones, n)
8
    scenario1_cost = float('inf')
9
    if total_ones == 0:
10
        scenario1_cost = 0  # all are 0s, best is to remove all
11
    else:
12
        max_ones = 0
13
        L = min(total_ones, n)
14
        for l in range(1, L + 1):
15
            if l > n:
16
                continue
17
            current_ones = sum(1 for c in s[:l] if c == '1')
18
            current_max = current_ones
19
            for i in range(1, n - l + 1):
20
                current_ones -= (s[i-1] == '1')
21
                current_ones += (s[i + l - 1] == '1')
22
                if current_ones > current_max:
23
                    current_max = current_ones
24
            if current_max > max_ones:
25
                max_ones = current_max
26
        scenario1_cost = total_ones - max_ones
27
    28
    # Scenario 2: window lengths > total_ones
29
    scenario2_cost = float('inf')
30
    if n > total_ones:
31
        min_zeros = float('inf')
32
        for l in range(total_ones + 1, n + 1):
33
            current_zeros = sum(1 for c in s[:l] if c == '0')
34
            current_min = current_zeros
35
            for i in range(1, n - l + 1):
36
                current_zeros -= (s[i-1] == '0')
37
                current_zeros += (s[i + l -1] == '0')
38
                if current_zeros < current_min:
39
                    current_min = current_zeros
40
            if current_min < min_zeros:
41
                min_zeros = current_min
42
        scenario2_cost = min_zeros
43
    44
    candidates = [scenario1_cost, scenario_empty]
45
    if n > total_ones:
46
        candidates.append(scenario2_cost)
47
    return min(candidates)
48
49
T = int(input())
50
for _ in range(T):
51
    s = input().strip()
52
    print(min_cost(s))",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055332
1390055340,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        prefix_0 = [0] * (n + 1)
10
        prefix_1 = [0] * (n + 1)
11
        suffix_0 = [0] * (n + 1)
12
        suffix_1 = [0] * (n + 1)
13
        14
        for i in range(1, n + 1):
15
            prefix_0[i] = prefix_0[i - 1] + (1 if servers[i - 1] == '0' else 0)
16
            prefix_1[i] = prefix_1[i - 1] + (1 if servers[i - 1] == '1' else 0)
17
        18
        for j in range(1, n + 1):
19
            suffix_0[j] = suffix_0[j - 1] + (1 if servers[n - j] == '0' else 0)
20
            suffix_1[j] = suffix_1[j - 1] + (1 if servers[n - j] == '1' else 0)
21
        22
        min_cost = float('inf')
23
        24
        for i in range(n + 1):
25
            left = 0
26
            right = n - i
27
            best_cost = float('inf')
28
            best_j = 0
29
            30
            while left <= right:
31
                mid = (left + right) // 2
32
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
33
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
34
                current_cost = max(remaining_0, decommissioned_1)
35
                36
                if current_cost < best_cost or (current_cost == best_cost and mid < best_j):
37
                    best_cost = current_cost
38
                    best_j = mid
39
                40
                if decommissioned_1 < remaining_0:
41
                    left = mid + 1
42
                else:
43
                    right = mid - 1
44
            45
            for dj in [-1, 0, 1]:
46
                j = best_j + dj
47
                if 0 <= j <= n - i:
48
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
49
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
50
                    current_cost = max(remaining_0, decommissioned_1)
51
                    best_cost = min(best_cost, current_cost)
52
            53
            min_cost = min(min_cost, best_cost)
54
        55
        results.append(min_cost)
56
    57
    return results
58
59
# Input Handling
60
if __name__ == ""__main__"":
61
    T = int(input())
62
    test_cases = [input().strip() for _ in range(T)]
63
    results = min_decommissioning_cost(test_cases)
64
    for result in results:
65
        print(result)",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055340
1390055336,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }
19
20
      21
        auto check = [&](int k) {
22
            int l = 0;
23
         24
            for (int r = 0; r < n; r++) {
25
              26
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
27
                    l++;
28
                }
29
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
30
                    return true;
31
                }
32
            }
33
      34
            if (prefix_1[n] <= k) {
35
                return true;
36
            }
37
            return false;
38
        };
39
40
        int low = 0, high = n;
41
        while (low < high) {
42
            int mid = (low + high) / 2;
43
            if (check(mid)) {
44
                high = mid;
45
            } else {
46
                low = mid + 1;
47
            }
48
        }
49
        cout << low << endl;
50
    }
51
    return 0;
52
}",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055336
1390055325,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {  // Use Solution if required by the online judge
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
17
            List<Long> values = new ArrayList<>();
18
            for (int i = 0; i < n; i++) {
19
                long val = a[i] - (n - i - 1L);
20
                values.add(val);
21
            }
22
23
            // Sort in descending order using Collections.sort
24
            Collections.sort(values, new Comparator<Long>() {
25
                public int compare(Long x, Long y) {
26
                    return Long.compare(y, x); // Descending order
27
                }
28
            });
29
30
            long[] prefixSum = new long[n + 1];
31
            prefixSum[0] = 0;
32
            for (int i = 1; i <= n; i++) {
33
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
34
            }
35
36
            int max_m = Math.min(k, n);
37
            long maxTotal = Long.MIN_VALUE;
38
            for (int m = 0; m <= max_m; m++) {
39
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
40
                if (current > maxTotal) {
41
                    maxTotal = current;
42
                }
43
            }
44
45
            long minEffort = sum_a - maxTotal;
46
            System.out.println(minEffort);
47
        }
48
        sc.close();
49
    }
50
}
51",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055325
1390055323,unknown,unknown,unknown,"1
def solve():
2
    server_rack = input().strip()
3
    n = len(server_rack)
4
5
    # Count total '1's in the string
6
    total_ones = server_rack.count('1')
7
8
    min_cost = float('inf')
9
    left_ones = 0
10
    remaining_zeros = server_rack.count('0')
11
12
    # Traverse the string considering removing from left side
13
    for i in range(n + 1):
14
        if i > 0:
15
            # Update the number of removed ones
16
            left_ones += (server_rack[i - 1] == '1')
17
18
        # Compute cost at this point
19
        cost = max(remaining_zeros, left_ones)
20
        min_cost = min(min_cost, cost)
21
22
        # Reduce remaining zeros if the next character is '0'
23
        if i < n and server_rack[i] == '0':
24
            remaining_zeros -= 1
25
26
    print(min_cost)
27
28
# Read number of test cases
29
T = int(input().strip())
30
for _ in range(T):
31
    solve()
32
33
34",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055323
1390055329,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055329
1390055322,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}",39,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055322
1390055318,unknown,unknown,unknown,"1
def minimum_decommission_cost(servers):
2
    n = len(servers)
3
    4
    # Convert the string to a list of integers (0 or 1)
5
    server_list = [int(c) for c in servers]
6
7
    # Compute prefix sum of active servers (1s)
8
    prefix_sum = [0] * (n + 1)
9
    for i in range(n):
10
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
11
12
    total_ones = prefix_sum[n]  # Total active servers
13
    min_cost = total_ones  # Worst case: decommission all active servers
14
15
    j = 0  # Right boundary of the window
16
    for i in range(n + 1):
17
        # Move j to maintain segment_zeros >= total_ones_removed
18
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
19
            j += 1
20
        21
        # Calculate cost at current window
22
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
23
        left_ones = prefix_sum[i]
24
        right_ones = total_ones - prefix_sum[j - 1]
25
        cost = max(segment_zeros, left_ones + right_ones)
26
        27
        min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
def process_input():
32
    import sys
33
    input = sys.stdin.read
34
    data = input().split()
35
    36
    t = int(data[0])
37
    results = []
38
    39
    for i in range(1, t + 1):
40
        results.append(str(minimum_decommission_cost(data[i])))
41
    42
    print(""\n"".join(results))
43
44
if __name__ == ""__main__"":
45
    process_input()
46",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055318
1390055319,unknown,unknown,unknown,"1
def min_effort_to_breach_firewalls(t, test_cases):
2
    results = []
3
4
    for test in test_cases:
5
        n, k = test[0]
6
        arr = test[1]
7
8
        # Sort firewall strengths in descending order
9
        arr_sorted = sorted(arr, reverse=True)
10
11
        # Choose top k strong firewalls to skip
12
        skips = set()
13
        for i in range(k):
14
            skips.add(arr_sorted[i])
15
16
        total_effort = 0
17
        skipped = 0
18
19
        for strength in arr:
20
            if strength in skips and skipped < k:
21
                skipped += 1
22
                skips.remove(strength)  # Remove to handle duplicates properly
23
            else:
24
                total_effort += strength + skipped  # Each skip adds +1 to every subsequent effort
25
26
        results.append(total_effort)
27
28
    return results
29
30
31
# -------- DRIVER CODE --------
32
T = int(input())
33
test_cases = []
34
35
for _ in range(T):
36
    n, k = map(int, input().split())
37
    arr = list(map(int, input().split()))
38
    test_cases.append(((n, k), arr))
39
40
answers = min_effort_to_breach_firewalls(T, test_cases)
41
42
for ans in answers:
43
    print(ans)
44",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055319
1390055316,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055316
1390055309,unknown,unknown,unknown,"1
def min_effort(tst_case):
2
    rst = []
3
    for n, k, st in tst_case:
4
        st.sort()
5
        if k >= n:
6
            rst.append(0)
7
        else:
8
            te = sum(st[k:])
9
            rst.append(te)
10
    return rst
11
12
if __name__==""__main__"":
13
    T = int(input())
14
    tst_case = []
15
    for _ in range(T):
16
        n, k = map(int, input().split())
17
        st =  list(map(int,input().split()))
18
        tst_case.append((n,k,st))
19
    20
    rst = min_effort(tst_case)
21
    22
    for res in rst:
23
        print(res)",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055309
1390055313,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(t, test_cases):
4
    results = []
5
    6
    for case in test_cases:
7
        n, k, arr = case
8
        dq = deque()
9
        output = []
10
        11
        for i in range(n):
12
            # Remove elements that are out of this window
13
            if dq and dq[0] < i - k + 1:
14
                dq.popleft()
15
            16
            # Add current element if it is faulty (negative)
17
            if arr[i] < 0:
18
                dq.append(i)
19
            20
            # Process first valid window
21
            if i >= k - 1:
22
                output.append(arr[dq[0]] if dq else 0)
23
        24
        results.append(output)
25
    26
    return results
27
28
# Reading input
29
t = int(input())
30
test_cases = []
31
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    test_cases.append((n, k, arr))
36
37
# Processing and printing output
38
results = earliest_faulty_readings(t, test_cases)
39
for res in results:
40
    print("" "".join(map(str, res)))",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055313
1390055314,unknown,unknown,unknown,"1
// #include <cmath>
2
// #include <cstdio>
3
// #include <vector>
4
// #include <iostream>
5
// #include <algorithm>
6
// using namespace std;
7
8
9
// int main() {
10
//     /* Enter your code here. Read input from STDIN. Print output to STDOUT */
11
//     int t=0;
12
//     cin>>t;
13
//     while(t){
14
//     int n=0,k=0,sum=0;
15
//     cin>>n;
16
//     cin>>k;
17
//     vector<int>arr;
18
//     for(int i=0;i<n;i++){
19
//         int temp=0;
20
//         cin>>temp;
21
//         arr.emplace_back(temp);
22
//     }
23
    24
//     while(k){
25
//         int maximum=max_element(arr.begin(),arr.end());
26
//         // cout<<maximum<<"" "";
27
//         for (auto it = maximum; it != arr.end(); ++it) {
28
//         (*it)++;  //+1
29
//     }
30
//         arr.erase(remove(arr.begin(), arr.end(), maximum), arr.end());
31
//         k--;
32
//     }
33
//     for(auto it:arr){
34
//         sum+=it;
35
//     }
36
//         cout<<sum<<endl;
37
//         t--;
38
//     }
39
    40
    41
    42
    43
    44
    45
//     return 0;
46
// }
47
48
49
#include <iostream>
50
#include <vector>
51
#include <algorithm>
52
using namespace std;
53
54
int main() {
55
    int t;
56
    cin >> t;
57
58
    while (t--) {
59
        int n, k;
60
        cin >> n >> k;
61
        vector<int> arr(n);
62
        63
        for (int i = 0; i < n; i++) {
64
            cin >> arr[i];
65
        }   
66
        67
        68
        for (int i = 0; i < k; i++) {
69
            auto max_it = max_element(arr.begin(), arr.end());
70
            71
            if (max_it == arr.end()) break;
72
            73
            int max_index = distance(arr.begin(), max_it);
74
            for (int j = max_index + 1; j < n; j++) {
75
                arr[j]++;
76
            }
77
            arr.erase(max_it);
78
            n--;
79
        }
80
        81
        82
        83
        int sum = 0;
84
        for (int x : arr) {
85
            sum += x;
86
        }
87
88
        cout << sum << endl;
89
    }
90
    91
    92
    93
    94
    95
    96
    97
98
    return 0;
99
}
100",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055314
1390055305,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055305
1390055306,unknown,unknown,unknown,"1
t = int(input())  
2
3
while t > 0:
4
    l, s = map(int, input().split()) 
5
    user_input = list(map(int, input().split()))  
6
    7
    total_effort = sum(user_input)  
8
    min_effort = total_effort  
9
10
    for i in range(l):  
11
        new_effort = (total_effort - user_input[i]) + s * (l - 1)
12
        min_effort = min(min_effort, new_effort)  
13
    14
    print(min_effort)  
15
    t -= 1  
16
 17
        ",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055306
1390055307,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for s in test_cases:
5
        n = len(s)
6
        7
        prefix_ones = [0] * (n + 1)
8
        prefix_zeros = [0] * (n + 1)
9
        10
        for i in range(1, n + 1):
11
            prefix_ones[i] = prefix_ones[i - 1] + (1 if s[i - 1] == '1' else 0)
12
            prefix_zeros[i] = prefix_zeros[i - 1] + (1 if s[i - 1] == '0' else 0)
13
        14
        total_ones = prefix_ones[n]
15
        total_zeros = prefix_zeros[n]
16
        17
        min_cost = float('inf')
18
        19
        for i in range(n + 1):
20
            for j in range(i, n + 1):
21
                ones_in_subarray = prefix_ones[j] - prefix_ones[i]
22
                zeros_in_subarray = prefix_zeros[j] - prefix_zeros[i]
23
                24
                removed_ones = total_ones - ones_in_subarray
25
                cost = max(zeros_in_subarray, removed_ones)
26
                27
                min_cost = min(min_cost, cost)
28
        29
        results.append(min_cost)
30
    31
    return results
32
33
T = int(input())
34
test_cases = [input().strip() for _ in range(T)]
35
36
results = min_decommissioning_cost(test_cases)
37
38
for result in results:
39
    print(result)
40",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055307
1390055304,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    4
    for n, k, arr in test_cases:
5
        output = []
6
        for i in range(n - k + 1):
7
            batch = arr[i:i + k]
8
            found = next((x for x in batch if x < 0), 0)
9
            output.append(str(found))
10
        11
        results.append("" "".join(output))
12
    13
    return results
14
15
16
t = int(input().strip())
17
test_cases = []
18
for _ in range(t):
19
    n, k = map(int, input().split())
20
    arr = list(map(int, input().split()))
21
    test_cases.append((n, k, arr))
22
23
24
for result in earliest_faulty_readings(test_cases):
25
    print(result)
26",40,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055304
1390055300,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    if n == 0:
3
        return 0  # No firewalls to pass
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    dp[0][0] = 0
6
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Do not skip
10
            dp[i][j] = dp[i-1][j] + firewalls[i-1] + j
11
            # Case 2: Skip if possible
12
            if j > 0:
13
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
14
    15
    return min(dp[n])
16
17
T = int(input())
18
for _ in range(T):
19
    n, k = map(int, input().split())
20
    firewalls = list(map(int, input().split()))
21
    if len(firewalls) != n:
22
        print(""Invalid input"")  # Handle input error
23
        exit()
24
    print(min_effort(n, k, firewalls))",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055300
1390055303,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
3
    # DP array, initialized with large values
4
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
7
    dp[0][0] = 0  # Base case: No firewalls, no effort
8
9
    # DP Computation
10
11
    for i in range(1, n + 1):
12
13
        for j in range(k + 1):
14
15
            # Case 1: Don't skip this firewall
16
17
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
18
19
            # Case 2: Skip this firewall (if skips available)
20
21
            if j > 0:
22
23
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
24
25
    # Answer is the minimum effort across all skip possibilities
26
27
    return min(dp[n])
28
29
# Read input
30
31
T = int(input())  # Number of test cases
32
33
for _ in range(T):
34
35
    n, k = map(int, input().split())  # Read n and k
36
37
    firewalls = list(map(int, input().split()))  # Firewall strengths
38
39
    # Compute and print the minimum effort
40
41
    print(min_effort(n, k, firewalls))",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055303
1390055299,unknown,unknown,unknown,"1
def compute_min_cost(s):
2
    T = s.count('1')
3
    if T == 0:
4
        return 0
5
    n = len(s)
6
    7
    # Compute x_max_case1: max number of 1's in window of length T
8
    x_max_case1 = 0
9
    if T <= n:
10
        current = sum(1 for c in s[:T] if c == '1')
11
        x_max_case1 = current
12
        for i in range(1, n - T + 1):
13
            if s[i-1] == '1':
14
                current -= 1
15
            if s[i + T - 1] == '1':
16
                current += 1
17
            if current > x_max_case1:
18
                x_max_case1 = current
19
    20
    # Compute x_max_case2: max of min(run_length, T-1) for all runs of 1's
21
    x_max_case2 = 0
22
    current_run = 0
23
    for c in s:
24
        if c == '1':
25
            current_run += 1
26
        else:
27
            if current_run > 0:
28
                candidate = min(current_run, T-1)
29
                if candidate > x_max_case2:
30
                    x_max_case2 = candidate
31
                current_run = 0
32
    # Check the last run
33
    if current_run > 0:
34
        candidate = min(current_run, T-1)
35
        if candidate > x_max_case2:
36
            x_max_case2 = candidate
37
    38
    case1_cost = T - x_max_case1
39
    case2_cost = T - x_max_case2
40
    return min(case1_cost, case2_cost)
41
42
def main():
43
    import sys
44
    input = sys.stdin.read().split()
45
    T_cases = int(input[0])
46
    for i in range(1, T_cases + 1):
47
        s = input[i]
48
        print(compute_min_cost(s))
49
50
if __name__ == ""__main__"":
51
    main()",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055299
1390055294,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055294
1390055297,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055297
1390055298,unknown,unknown,unknown,"1
def min_cost(server_rack):
2
    n = len(server_rack)
3
    total_zeros = server_rack.count('0')
4
    total_ones = n - total_zeros
5
    min_cost = float('inf')
6
    7
    left = 0
8
    current_zeros = 0
9
    for right in range(n):
10
        if server_rack[right] == '0':
11
            current_zeros += 1
12
        13
        zeros_remaining = current_zeros
14
        ones_removed = total_ones - (right - left + 1 - current_zeros)
15
        16
        cost = max(zeros_remaining, ones_removed)
17
        if cost < min_cost:
18
            min_cost = cost
19
        20
        while left <= right and cost > min_cost:
21
            if server_rack[left] == '0':
22
                current_zeros -= 1
23
            left += 1
24
    25
    return min_cost
26
27
T = int(input())
28
for _ in range(T):
29
    server_rack = input().strip()
30
    print(min_cost(server_rack))",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055298
1390055290,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    ios::sync_with_stdio(false);
10
    cin.tie(nullptr);
11
    12
    int T;
13
    cin >> T;
14
    while(T--) {
15
        string s;
16
        cin >> s;
17
        int n = s.size();
18
        19
        // Build prefix sums for zeros and ones.
20
        // prefix0[i] = number of '0's in s[0, i)
21
        // prefix1[i] = number of '1's in s[0, i)
22
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
23
        for (int i = 0; i < n; i++) {
24
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
25
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
26
        }
27
        int totalOnes = prefix1[n];
28
        29
        // We'll binary search for the minimal cost C in the range [0, n].
30
        int low = 0, high = n, ans = n;
31
        while(low <= high) {
32
            int mid = (low + high) / 2;
33
            bool feasible = false;
34
            35
            // For each possible prefix removal (i.e. for each starting index l of the kept substring)
36
            for (int l = 0; l <= n; l++) {
37
                // In the kept substring s[l, r), the zeros count is: prefix0[r] - prefix0[l].
38
                // We require that prefix0[r] - prefix0[l] <= mid.
39
                // That is, prefix0[r] <= prefix0[l] + mid.
40
                // Because prefix0 is non-decreasing, we can use upper_bound:
41
                int allowed = prefix0[l] + mid;
42
                // Find the first index r (in [l, n+1)) where prefix0[r] > allowed.
43
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
44
                // Then the maximum r with zeros constraint is r_max = r - 1.
45
                if(r - 1 < l) continue; // should not happen because at least r = l exists.
46
                int r_max = r - 1;
47
                // Ones kept in s[l, r_max) is:
48
                int onesKept = prefix1[r_max] - prefix1[l];
49
                // We need onesKept >= totalOnes - mid.
50
                if(onesKept >= totalOnes - mid) {
51
                    feasible = true;
52
                    break;
53
                }
54
            }
55
            56
            if(feasible) {
57
                ans = mid;
58
                high = mid - 1;
59
            } else {
60
                low = mid + 1;
61
            }
62
        }
63
        64
        cout << ans << ""\n"";
65
    }
66
    return 0;
67
}",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055290
1390055293,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    dp[0][0] = 0
7
8
    for i in range(1, n + 1):
9
        for j in range(k + 1):
10
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i - 1] + j)
11
12
            if j > 0:
13
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
14
15
    min_effort = float('inf')
16
    for j in range(k + 1):
17
        min_effort = min(min_effort, dp[n][j])
18
19
    print(min_effort)
20
21
22
t = int(input())
23
for _ in range(t):
24
    solve()",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055293
1390055292,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    if n==k:
3
        return 0
4
    total_effort = sum(firewalls)
5
    min_effort = total_effort  # Start with no skips
6
    7
    for i in range(n):
8
        if k > 0:  # If we can skip at least one firewall
9
            new_effort = total_effort - firewalls[i]  # Remove the skipped firewall's effort
10
            new_effort += sum(1 for j in range(i + 1, n))  # Increase remaining firewalls' strength
11
            min_effort = min(min_effort, new_effort)  # Keep track of the minimum effort
12
13
    return min_effort
14
15
t = int(input())
16
for _ in range(t):
17
    n, k = map(int, input().split())
18
    firewalls = list(map(int, input().split()))
19
    print(min_effort(n, k, firewalls))
20",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055292
1390055288,unknown,unknown,unknown,"1
#include <cmath>
2
3
#include <cstdio>
4
5
#include <vector>
6
7
#include <iostream>
8
9
#include <algorithm>
10
11
using namespace std;
12
13
int main() {
14
15
    ios::sync_with_stdio(false);
16
17
    cin.tie(nullptr);
18
19
    20
21
    int T;
22
23
    cin >> T;
24
25
    while(T--) {
26
27
        string s;
28
29
        cin >> s;
30
31
        int n = s.size();
32
33
        34
35
36
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
37
38
        for (int i = 0; i < n; i++) {
39
40
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
41
42
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
43
44
        }
45
46
        int totalOnes = prefix1[n];
47
48
        49
50
51
        int low = 0, high = n, ans = n;
52
53
        while(low <= high) {
54
55
            int mid = (low + high) / 2;
56
57
            bool feasible = false;
58
59
            60
61
           62
            for (int l = 0; l <= n; l++) {
63
64
               65
                int allowed = prefix0[l] + mid;
66
67
               68
69
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
70
71
72
                if(r - 1 < l) continue;  
73
                74
                75
                int r_max = r - 1;
76
77
            78
79
                int onesKept = prefix1[r_max] - prefix1[l];
80
81
               82
83
                if(onesKept >= totalOnes - mid) {
84
85
                    feasible = true;
86
87
                    break;
88
89
                }
90
91
            }
92
93
            94
95
            if(feasible) {
96
97
                ans = mid;
98
99
                high = mid - 1;
100
101
            } else {
102
103
                low = mid + 1;
104
105
            }
106
107
        }
108
109
        110
111
        cout << ans << ""\n"";
112
113
    }
114
115
    return 0;
116
117
}
118",41,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055288
1390055278,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055278
1390055280,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055280
1390055286,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
        # get indices for active servers ('1')
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        # Precompute A: A[i] = positions[i] - i
18
        A = [positions[i] - i for i in range(m)]
19
        20
        # check(X) returns True if there exists a window in A
21
        # such that:
22
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
23
        # and A[j] - A[i] <= X.
24
        def check(X):
25
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                # slide j as far as possible while A[j]-A[i] <= X
33
                while j < m and A[j] - A[i] <= X:
34
                    j += 1
35
                # j now is one past the last index satisfying condition, so the window has length (j - i)
36
                if j - i >= m - X:
37
                    return True
38
            return False
39
40
        # Binary search for the minimum X
41
        lo, hi, ans = 0, n, n
42
        while lo <= hi:
43
            mid = (lo + hi) // 2
44
            if check(mid):
45
                ans = mid
46
                hi = mid - 1
47
            else:
48
                lo = mid + 1
49
        out_lines.append(str(ans))
50
    51
    sys.stdout.write(""\n"".join(out_lines))
52
    53
if __name__ == ""__main__"":
54
    solve()",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055286
1390055262,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055262
1390055265,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
    left = 0
3
    zeros = 0
4
    max_ones = 0
5
    n = len(s)
6
    7
    for right in range(n):
8
        if s[right] == '0':
9
            zeros += 1
10
        11
        while zeros > k:
12
            if s[left] == '0':
13
                zeros -= 1
14
            left += 1
15
        16
        current_ones = (right - left + 1) - zeros
17
        max_ones = max(max_ones, current_ones)
18
    19
    return max_ones
20
21
def min_server_pruning_cost(s):
22
    n = len(s)
23
    total_ones = s.count('1')
24
    25
    if total_ones == 0:
26
        return 0
27
    28
    total_zeros = n - total_ones
29
    low, high = 0, max(total_ones, total_zeros)
30
    answer = high
31
32
    while low <= high:
33
        mid = (low + high) // 2
34
        required_ones = max(0, total_ones - mid)
35
        if required_ones == 0:
36
            answer = mid
37
            high = mid - 1
38
            continue
39
40
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
41
        if max_ones >= required_ones:
42
            answer = mid
43
            high = mid - 1
44
        else:
45
            low = mid + 1
46
47
    return answer
48
49
T = int(input().strip())
50
for _ in range(T):
51
    s = input().strip()
52
    print(min_server_pruning_cost(s))",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055265
1390055269,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055269
1390055258,unknown,unknown,unknown,"1
def minimum_decommission_cost(servers):
2
    n = len(servers)
3
    4
    # Convert the string to a list of integers (0 or 1)
5
    server_list = [int(c) for c in servers]
6
7
    # Compute prefix sum of active servers (1s)
8
    prefix_sum = [0] * (n + 1)
9
    for i in range(n):
10
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
11
12
    total_ones = prefix_sum[n]  # Total active servers
13
    min_cost = total_ones  # Worst case: decommission all active servers
14
15
    j = 0  # Right boundary of the window
16
    for i in range(n + 1):
17
        # Move j to maintain segment_zeros >= total_ones_removed
18
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
19
            j += 1
20
        21
        # Calculate cost at the current window
22
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
23
        left_ones = prefix_sum[i]
24
        right_ones = total_ones - prefix_sum[j - 1]
25
        cost = max(segment_zeros, left_ones + right_ones)
26
        27
        min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
def process_input():
32
    import sys
33
    input = sys.stdin.read
34
    data = input().split()
35
    36
    t = int(data[0])
37
    results = []
38
    39
    for i in range(1, t + 1):
40
        results.append(str(minimum_decommission_cost(data[i])))
41
    42
    print(""\n"".join(results))
43
44
# Correcting the name definition
45
if __name__ == ""__main__"":
46
    process_input()
47",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055258
1390055259,unknown,unknown,unknown,"1
import sys
2
3
def min_effort_to_breach(n, k, strengths):
4
    impacts = []
5
6
    for i in range(n):
7
        impact = strengths[i] - (n - i - 1)
8
        impacts.append((impact, i))
9
10
    impacts.sort(reverse=True)
11
12
    to_skip = set(impacts[i][1] for i in range(k))
13
14
    total_effort = 0
15
    penalty = 0
16
17
    for i in range(n):
18
        if i in to_skip:
19
            penalty += 1
20
        else:
21
            total_effort += strengths[i] + penalty
22
23
    return total_effort
24
25
def solve_test_cases():
26
    t = int(sys.stdin.readline().strip())  # Efficient input handling
27
    results = []
28
29
    for _ in range(t):
30
        n, k = map(int, sys.stdin.readline().strip().split())
31
        strengths = list(map(int, sys.stdin.readline().strip().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
34
    return results
35
36
def main():
37
    results = solve_test_cases()
38
    for result in results:
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()
43",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055259
1390055260,unknown,unknown,unknown,"1
def min_decommission_cost(server_rack):
2
    n = len(server_rack)
3
4
    # Find the first and last occurrence of '1'
5
    first_one = server_rack.find('1')
6
    last_one = server_rack.rfind('1')
7
8
    # If there are no active servers, the cost is 0
9
    if first_one == -1:
10
        return 0
11
12
    # Core segment that must remain
13
    core_segment = server_rack[first_one:last_one + 1]
14
    15
    # Count idle servers in core segment
16
    remaining_idle = core_segment.count('0')
17
18
    # Try different trims from both ends
19
    min_cost = remaining_idle  # Start with keeping all '1's
20
21
    for trim_start in range(first_one + 1):  # Remove '1's from start
22
        for trim_end in range(n - last_one):  # Remove '1's from end
23
            decommissioned_active = trim_start + trim_end
24
            cost = max(remaining_idle, decommissioned_active)
25
            min_cost = min(min_cost, cost)
26
27
    return min_cost
28
29
# Read input
30
t = int(input().strip())  # Number of test cases
31
for _ in range(t):
32
    server_rack = input().strip()  # Read binary string
33
    print(min_decommission_cost(server_rack))
34",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055260
1390055256,unknown,unknown,unknown,"1
def find_earliest_fault(test_cases):
2
    result = []
3
    for n, k, arr in test_cases:
4
        batch_result = []
5
        for i in range(n - k + 1):
6
            batch = arr[i:i+k]
7
            fault = next((x for x in batch if x < 0), 0)
8
            batch_result.append(fault)
9
        result.append(batch_result)
10
    return result
11
12
t = int(input())  
13
test_cases = []
14
for _ in range(t):
15
    n, k = map(int, input().split()) 
16
    arr = list(map(int, input().split())) 
17
    test_cases.append((n, k, arr))
18
19
results = find_earliest_fault(test_cases)
20
for res in results:
21
    print("" "".join(map(str, res)))
22",42,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055256
1390055253,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
#include <ext/pb_ds/assoc_container.hpp>
3
#include <ext/pb_ds/tree_policy.hpp>
4
#include <ext/pb_ds/detail/standard_policies.hpp>
5
#include <cmath>
6
#define int long long int
7
#define pb push_back
8
/*---------------------------------------------------------------------------------------------------------------------------------*/
9
/*ASCII small case-> a-97 to z-122
10
upper case-> A-65 to Z-90*/
11
#define nl ""\n""
12
#define mp map<int, int>
13
#define all(v) v.begin(), v.end()
14
#define F first
15
#define S second
16
#define ump unordered_map<long long, int, custom_hash>
17
#define mstpi multiset<pair<int, int> >
18
#define mst multiset<int>
19
#define vec vector<int>
20
#define pi pair<int, int>
21
#define ld long double
22
#define vep vector<pair<int, int>>
23
#define ul unsigned long long
24
#define loop1 for (int i = 0; i < n; i++)
25
#define REP(i, a, b) for (int i = a; i <= b; i++)
26
#define NO cout << ""NO"" << endl
27
#define YES cout << ""YES"" << endl
28
using namespace std;
29
using namespace __gnu_pbds;
30
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
31
/*---------------------------------------------------------------------------------------------------------------------------------*/
32
const double PI = 3.1415926535;
33
const int inf = 1e18;
34
const int mod = 1000000007;
35
/*---------------------------------------------------------------------------------------------------------------------------------*/
36
int modmul(int a, int b, int m)
37
{
38
    a %= m;
39
    b %= m;
40
    return (a * b) % m;
41
}
42
int modexp(int n, int x)
43
{
44
    int ans = 1;
45
    while (n > 0)
46
    {
47
        if (n & 1)
48
        {
49
            ans = (ans * x) % mod;
50
        }
51
        n >>= 1;
52
        x = (x * x) % mod;
53
    }
54
    return ans;
55
}
56
/*---------------------------------------------------------------------------------------------------------------------------------*/
57
string add(string a, string b)
58
{
59
    string ans = """";
60
    int carry = 0;
61
    while (!a.empty() || !b.empty() || carry > 0)
62
    {
63
        int digitA = a.empty() ? 0 : a.back() - '0';
64
        int digitB = b.empty() ? 0 : b.back() - '0';
65
        int sum = digitA + digitB + carry;
66
        ans = to_string(sum % 10) + ans;
67
        carry = sum / 10;
68
        if (!a.empty())
69
            a.pop_back();
70
        if (!b.empty())
71
            b.pop_back();
72
    }
73
    return ans;
74
}
75
string ministrnum(string a, string b)
76
{
77
    if (a.length() > b.length())
78
        return b;
79
    else if (b.length() > a.length())
80
        return a;
81
    else
82
    {
83
        int n = a.length();
84
        for (int i = 0; i < n; i++)
85
        {
86
            if (a[i] > b[i])
87
                return b;
88
            else if (a[i] < b[i])
89
                return a;
90
        }
91
    }
92
    return a;
93
}
94
vector<int> sieve(int n) {
95
    vector<bool> isPrime(n + 1, true);
96
    vector<int> primes;
97
    if(n >= 0) isPrime[0] = false;
98
    if(n >= 1) isPrime[1] = false;
99
    for (int i = 2; i <= n; i++) {
100
        if (isPrime[i]) {
101
            primes.push_back(i);
102
            for (int j = 2 * i; j <= n; j += i)
103
                isPrime[j] = false;
104
        }
105
    }
106
    return primes;
107
}
108
109
class SegmentTree {
110
public:
111
    int n;
112
    std::vector<int> tree;
113
    std::vector<int> lazy;
114
    115
    SegmentTree(const std::vector<int>& arr) {
116
        n = arr.size();
117
        tree.resize(4 * n, 0);
118
        lazy.resize(4 * n, 0);
119
        build(arr, 0, n - 1, 0);
120
    }
121
    122
    void build(const std::vector<int>& arr, int start, int end, int index) {
123
        if (start == end) {
124
            tree[index] = arr[start];
125
            return;
126
        }
127
        int mid = (start + end) / 2;
128
        build(arr, start, mid, 2 * index + 1);
129
        build(arr, mid + 1, end, 2 * index + 2);
130
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
131
    }
132
    133
    int queryRange(int start, int end, int l, int r, int index = 0) {
134
        if (lazy[index] != 0) {
135
            tree[index] += (end - start + 1) * lazy[index];
136
            if(start != end) {
137
                lazy[2 * index + 1] += lazy[index];
138
                lazy[2 * index + 2] += lazy[index];
139
            }
140
            lazy[index] = 0;
141
        }
142
        if (start > r || end < l)
143
            return 0;
144
        if (start >= l && end <= r)
145
            return tree[index];
146
        int mid = (start + end) / 2;
147
        return queryRange(start, mid, l, r, 2 * index + 1) +
148
               queryRange(mid + 1, end, l, r, 2 * index + 2);
149
    }
150
    151
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
152
        if(lazy[index] != 0) {
153
            tree[index] += (end - start + 1) * lazy[index];
154
            if(start != end) {
155
                lazy[2 * index + 1] += lazy[index];
156
                lazy[2 * index + 2] += lazy[index];
157
            }
158
            lazy[index] = 0;
159
        }
160
        if(start > r || end < l)
161
            return;
162
        if(start >= l && end <= r) {
163
            tree[index] += (end - start + 1) * diff;
164
            if(start != end) {
165
                lazy[2 * index + 1] += diff;
166
                lazy[2 * index + 2] += diff;
167
            }
168
            return;
169
        }
170
        int mid = (start + end) / 2;
171
        updateRange(start, mid, l, r, diff, 2 * index + 1);
172
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
173
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
174
    }
175
};
176
class DSU {
177
public:
178
    std::vector<int> parent, rank;
179
    180
    DSU(int n) {
181
        parent.resize(n);
182
        rank.resize(n, 0);
183
        for (int i = 0; i < n; i++)
184
            parent[i] = i;
185
    }
186
    187
    int find(int x) {
188
        if (parent[x] != x)
189
            parent[x] = find(parent[x]);
190
        return parent[x];
191
    }
192
    193
    bool unionSets(int x, int y) {
194
        int rootX = find(x);
195
        int rootY = find(y);
196
        if (rootX == rootY)
197
            return false;
198
        if (rank[rootX] < rank[rootY])
199
            parent[rootX] = rootY;
200
        else if (rank[rootX] > rank[rootY])
201
            parent[rootY] = rootX;
202
        else {
203
            parent[rootY] = rootX;
204
            rank[rootX]++;
205
        }
206
        return true;
207
    }
208
};
209
210
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
211
struct Node {
212
    int val;
213
    int weight, size;
214
    Node *left, *right;
215
    bool rev = false;
216
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
217
};
218
ostream &operator<<(ostream &os, Node *n) {
219
    if(!n) return os;
220
    os << n -> left;
221
    os << n -> val;
222
    os << n -> right;
223
    return os;
224
}
225
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
226
void push(Node* Treap) {
227
    if(!Treap) return;
228
    if(Treap -> rev) {
229
        Treap -> rev = false;
230
        swap(Treap->left, Treap->right);
231
        if(Treap -> left) Treap->left->rev ^= true;
232
        if(Treap -> right) Treap->right->rev ^= true;
233
    }
234
}
235
void pull(Node *Treap) {
236
    if(!Treap) return;
237
    push(Treap -> left), push(Treap -> right);
238
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
239
    return;
240
}
241
void split(Node *Treap, Node *&left, Node *&right, int val) {
242
    if(!Treap) {
243
        left = right = NULL;
244
        return;
245
    }
246
    push(Treap);
247
    if(size(Treap -> left) < val) {
248
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
249
        left = Treap;
250
    }
251
    else {
252
        split(Treap -> left, left, Treap -> left, val);
253
        right = Treap;
254
    }
255
    pull(Treap);
256
}
257
void merge(Node *&Treap, Node *left, Node *right) {
258
    push(left), push(right);
259
    if(left == NULL) {
260
        Treap = right;
261
        return;
262
    }
263
    if(right == NULL) {
264
        Treap = left;
265
        return;
266
    }
267
    if(left -> weight < right -> weight) {
268
        merge(right -> left, left, right -> left);
269
        Treap = right;
270
    }
271
    else {
272
        merge(left->right, left->right, right);
273
        Treap = left;
274
    }
275
    pull(Treap);
276
}
277
void inOrder(Node *curr, vector<int> &res) {
278
    if(curr == NULL) return;
279
    push(curr);
280
    inOrder(curr->left, res);
281
    res.pb(curr->val);
282
    inOrder(curr->right, res);
283
    pull(curr);
284
}
285
struct Treap {
286
    Node *root = nullptr;
287
    void insert(int i, int val) {
288
        Node *l, *r;
289
        split(root, l, r, i);
290
        Node *v = new Node(val);
291
        merge(l, l, v);
292
        merge(root, l, r);
293
    }
294
    295
    void del(int i) {
296
        Node *l, *r;
297
        split(root, l, r, i);
298
        split(r, root, r, 1);
299
        merge(root, l, r);
300
    }
301
    302
    void update(int l, int r, function<void(Node *)> f) {
303
        Node *a, *b, *c;
304
        split(root, a, b, l-1);
305
        split(b, b, c, r-l+1);
306
        if(b) {f(b);}
307
        merge(root, a, b);
308
        merge(root, root, c);
309
    }
310
    311
    vector<int> allPr() {
312
        vector<int> res;
313
        inOrder(root, res);
314
        return res;
315
    }
316
    317
    void cycShft(int l, int r) {
318
        Node *a, *b, *c, *d;
319
        split(root, a, b, l-1);
320
        split(b, b, c, r-l+1);
321
        split(b, b, d, r-l);
322
        merge(root, a, d);
323
        merge(root, root, b);
324
        merge(root, root, c);
325
    }
326
};
327
vector<int> computePrefix(const string &pattern) {
328
    int n = pattern.size();
329
    vector<int> prefix(n, 0);
330
    for (int i = 1, j = 0; i < n; i++) {
331
        while (j > 0 && pattern[i] != pattern[j])
332
            j = prefix[j - 1];
333
        if (pattern[i] == pattern[j])
334
            j++;
335
        prefix[i] = j;
336
    }
337
    return prefix;
338
}
339
340
vector<int> KMPSearch(const string &text, const string &pattern) {
341
    vector<int> prefix = computePrefix(pattern);
342
    vector<int> occurrences;
343
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
344
        while (j > 0 && text[i] != pattern[j])
345
            j = prefix[j - 1];
346
        if (text[i] == pattern[j])
347
            j++;
348
        if (j == (int)pattern.size()) {
349
            occurrences.push_back(i - j + 1);
350
            j = prefix[j - 1];
351
        }
352
    }
353
    return occurrences;
354
}
355
void solve()
356
{
357
    int n, ans = 1e9;
358
    string s;
359
    cin>>s;
360
    n = s.size();
361
    362
    int tot1 = count(all(s), '1');
363
    ans = tot1;
364
    365
    // vector<int> pref(n, 0);
366
    // for(int i = 0; i<n; i++) {
367
        // pref[i] = s[i] == '1';
368
        // if(i) pref[i] += pref[i - 1];
369
    // }
370
//     
371
//     
372
    // for(int i = 0; i<n; i++) {
373
        // for(int j = i; j<n; j++) {
374
            // int cnt1 = (i?pref[i-1]:0) + pref[n-1] - (j!=n-1?pref[j+1]:pref[n-1]), cnt0 = (j - i + 1) - (pref[j] - (i?pref[i-1]:0));
375
            // ans = min(ans, max(cnt1, cnt0)); 
376
        // }
377
    // }
378
    // cout<<ans<<'\n';
379
    380
    auto check = [&](int m) {
381
        int cnt0 = 0, cnt1 = 0;
382
        for(int i = 0, j = 0; i<n; i++) {
383
            cnt0 += s[i] == '0';
384
            cnt1 += s[i] == '1';
385
            386
            if(tot1 - cnt1 == m) {
387
                while(j < n && s[j] == '0') {
388
                    cnt0--;
389
                    j++;
390
                }
391
                if(cnt0 <= m) return true;
392
                while(j < n && s[j] != '0') {
393
                    cnt0--;
394
                    j++;
395
                }
396
                cnt1--;
397
                j++;
398
            }
399
        }
400
        return false;
401
    };
402
    403
    int l = 0, r = ans;
404
    while(l <= r) {
405
        int m = r - (r - l)/2;
406
        if(check(m)) r = m - 1;
407
        else l = m + 1;
408
    }
409
    cout<<l<<endl;
410
}
411
int32_t main()
412
{
413
    ios_base ::sync_with_stdio(0);
414
    cin.tie(0);
415
    cout.tie(0);
416
    int t = 1;
417
    cin >> t;
418
    while (t--)
419
        solve();
420
}",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055253
1390055250,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
int main() {
6
    int t; // number of test cases
7
    cin >> t;
8
9
    while (t--) {
10
        int n, k; // size of array and batch size
11
        cin >> n >> k;
12
13
        vector<int> arr(n);
14
        for (int i = 0; i < n; i++) {
15
            cin >> arr[i];
16
        }
17
18
        // Iterate through each window (consecutive batch of size k)
19
        for (int i = 0; i <= n - k; i++) {
20
            int earliest_fault = 0; // Assume no faults
21
            // Check the batch from arr[i] to arr[i+k-1]
22
            for (int j = i; j < i + k; j++) {
23
                if (arr[j] < 0) {
24
                    earliest_fault = arr[j]; // Found a negative value, set it as earliest fault
25
                    break;
26
                }
27
            }
28
            cout << earliest_fault << "" "";
29
        }
30
        cout << endl;
31
    }
32
33
    return 0;
34
}
35",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055250
1390055243,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
5
    result = []  
6
7
    dq = deque()  
8
9
    10
11
    for i in range(k):
12
13
        if arr[i] < 0:
14
15
            dq.append(i)  
16
17
    18
19
    20
21
    for i in range(len(arr) - k + 1):
22
23
    24
25
        if dq:
26
27
            result.append(arr[dq[0]])  
28
29
        else:
30
31
            result.append(0)  
32
33
        34
35
    36
37
        if dq and dq[0] == i:
38
39
            dq.popleft()
40
41
        42
43
        44
45
        if i + k < len(arr) and arr[i + k] < 0:
46
47
            dq.append(i + k)
48
49
    50
51
    return result
52
53
54
55
t = int(input())  
56
57
for _ in range(t):
58
59
    n, k = map(int, input().split())  
60
61
    arr = list(map(int, input().split()))  
62
63
    64
65
66
67
    print(*earliest_faulty_readings(arr, k))",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055243
1390055246,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
5
    n = len(arr)
6
7
    result = []
8
9
    dq = deque()  # To store indices of negative numbers
10
11
    12
13
    # Process the first window
14
15
    for i in range(k):
16
17
        if arr[i] < 0:
18
19
            dq.append(i)
20
21
    22
23
    # Store the result for the first window
24
25
    result.append(arr[dq[0]] if dq else 0)
26
27
    28
29
    # Process the remaining windows
30
31
    for i in range(k, n):
32
33
        # Remove elements that are out of the current window
34
35
        if dq and dq[0] < i - k + 1:
36
37
            dq.popleft()
38
39
        40
41
        # Add the current element if it is negative
42
43
        if arr[i] < 0:
44
45
            dq.append(i)
46
47
        48
49
        # Store the result for the current window
50
51
        result.append(arr[dq[0]] if dq else 0)
52
53
    54
55
    return result
56
57
# Reading input
58
59
t = int(input())  # Number of test cases
60
61
for _ in range(t):
62
63
    n, k = map(int, input().split())  # Size of array and batch size
64
65
    arr = list(map(int, input().split()))  # Array elements
66
67
    68
69
    # Get the results and print as space-separated values
70
71
    print(*earliest_faulty_readings(arr, k))",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055246
1390055248,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055248
1390055234,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_faulty_batches(sensor_data, batch_size):
4
5
    output_list = []
6
7
    index_queue = deque()
8
9
    for idx in range(batch_size):
10
11
        if sensor_data[idx] < 0:
12
13
            index_queue.append(idx)
14
15
    output_list.append(sensor_data[index_queue[0]] if index_queue else 0)
16
17
    for idx in range(batch_size, len(sensor_data)):
18
19
        if index_queue and index_queue[0] < idx - batch_size + 1:
20
21
            index_queue.popleft()
22
23
        if sensor_data[idx] < 0:
24
25
            index_queue.append(idx)
26
27
        output_list.append(sensor_data[index_queue[0]] if index_queue else 0)
28
29
    return output_list
30
31
test_cases = int(input())
32
33
for _ in range(test_cases):
34
35
    array_size, batch_size = map(int, input().split())
36
37
    sensor_readings = list(map(int, input().split()))
38
39
    print(*find_faulty_batches(sensor_readings, batch_size))",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055234
1390055242,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(t, test_cases):
4
    results = []
5
    6
    for case in test_cases:
7
        n, k, arr = case
8
        dq = deque()
9
        output = []
10
        11
        for i in range(n):
12
            # Remove elements that are out of this window
13
            if dq and dq[0] < i - k + 1:
14
                dq.popleft()
15
            16
            # Add current element if it is faulty (negative)
17
            if arr[i] < 0:
18
                dq.append(i)
19
            20
            # Process first valid window
21
            if i >= k - 1:
22
                output.append(arr[dq[0]] if dq else 0)
23
        24
        results.append(output)
25
    26
    return results
27
28
# Reading input
29
t = int(input())
30
test_cases = []
31
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    test_cases.append((n, k, arr))
36
37
# Processing and printing output
38
results = earliest_faulty_readings(t, test_cases)
39
for res in results:
40
    print("" "".join(map(str, res)))",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055242
1390055235,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
    public static List<Integer> earliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>();
7
8
        for (int i = 0; i < arr.length; i++) {
9
            // Remove out-of-window elements
10
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
11
                deque.poll();
12
            }
13
14
            // Add new faulty readings
15
            if (arr[i] < 0) {
16
                deque.offer(i);
17
            }
18
19
            // Collect results for valid windows
20
            if (i >= k - 1) {
21
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
22
            }
23
        }
24
        return result;
25
    }
26
27
    public static void main(String[] args) {
28
        Scanner scanner = new Scanner(System.in);
29
        int t = scanner.nextInt(); // Number of test cases
30
31
        while (t-- > 0) {
32
            int n = scanner.nextInt(); // Array size
33
            int k = scanner.nextInt(); // Batch size
34
            int[] arr = new int[n];
35
36
            for (int i = 0; i < n; i++) {
37
                arr[i] = scanner.nextInt();
38
            }
39
40
            // Compute and print results
41
            List<Integer> faults = earliestFaults(arr, k);
42
            for (int val : faults) {
43
                System.out.print(val + "" "");
44
            }
45
            System.out.println();
46
        }
47
        scanner.close();
48
    }
49
}",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055235
1390055229,unknown,unknown,unknown,"1
def min_cost(rack):
2
    n = len(rack)
3
    min_cost = float('inf')
4
    5
    for start in range(n + 1):
6
        for end in range(n - start + 1):
7
            remaining = rack[start:n-end]
8
            idle_remaining = remaining.count('0')
9
            removed_start = rack[:start]
10
            removed_end = rack[n-end:] if end > 0 else ''
11
            active_removed = removed_start.count('1') + removed_end.count('1')
12
            cost = max(idle_remaining, active_removed)
13
            min_cost = min(min_cost, cost)
14
    15
    return min_cost
16
17
T = int(input())
18
for _ in range(T):
19
    rack = input().strip()
20
    print(min_cost(rack))
21",43,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055229
1390055226,unknown,unknown,unknown,"1
def min_effort(n, k, a):
2
    dp = [float('inf')] * (k + 1)
3
    dp[0] = 0
4
    for i in range(n):
5
        prev = dp[:]
6
        for j in range(k + 1):
7
            if j <= i + 1:
8
                dp[j] = prev[j] + a[i] + j
9
            if j > 0:
10
                dp[j] = min(dp[j], prev[j - 1])
11
    return min(dp)
12
13
T = int(input())
14
for _ in range(T):
15
    n, k = map(int, input().split())
16
    a = list(map(int, input().split()))
17
    print(min_effort(n, k, a))",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055226
1390055228,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
 3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0 
5
6
    for i in range(1, n + 1):
7
        for j in range(k + 1):
8
           9
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
10
11
            if j > 0:
12
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
13
14
    return min(dp[n])
15
16
17
T = int(input()) 
18
for _ in range(T):
19
    n, k = map(int, input().split()) 
20
    firewalls = list(map(int, input().split()))  
21
22
    # Compute and print the minimum effort
23
    print(min_effort(n, k, firewalls))",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055228
1390055227,unknown,unknown,unknown,"1
def min_effort_to_breach(arr, k):
2
    n = len(arr)
3
    4
   5
    if k >= n:
6
        return 0
7
    8
  9
    min_effort = float('inf')
10
    11
  12
    effective_costs = []
13
    for i in range(n):
14
       15
        skip_penalty = n - i - 1
16
        17
        18
     19
        effective_cost = arr[i] - skip_penalty
20
        21
        effective_costs.append((effective_cost, i))
22
    23
    24
    effective_costs.sort(reverse=True)
25
    26
   27
    skipped = [False] * n
28
    skips_used = 0
29
    30
    for cost, idx in effective_costs:
31
        if skips_used < k and cost > 0:
32
            skipped[idx] = True
33
            skips_used += 1
34
    35
 36
    total_effort = 0
37
    penalty = 0
38
    39
    for i in range(n):
40
        if skipped[i]:
41
            penalty += 1
42
        else:
43
            total_effort += arr[i] + penalty
44
    45
    return total_effort
46
47
def solve_test_cases():
48
    t = int(input())  -
49
    results = []
50
    51
    for _ in range(t):
52
        n, k = map(int, input().split())
53
        arr = list(map(int, input().split()))
54
        55
        result = min_effort_to_breach(arr, k)
56
        results.append(result)
57
    58
    59
    for result in results:
60
        print(result)
61
62
63
if __name__ == ""__main__"":
64
    solve_test_cases()",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055227
1390055219,unknown,unknown,unknown,"1
2
def min_cost_server_pruning(server_rack):
3
4
    n = len(server_rack)
5
    active_prefix_sum = [0] * (n + 1)
6
    idle_suffix_sum = [0] * (n + 1)
7
8
    for i in range(n):
9
10
        active_prefix_sum[i+1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
11
12
    for i in range(n-1, -1, -1):
13
14
        idle_suffix_sum[i] = idle_suffix_sum[i+1] + (1 if server_rack[i] == '0' else 0)
15
16
    min_cost = float('inf')
17
18
19
    for left in range(n + 1):
20
21
        for right in range(left, n + 1):
22
            active_removed = active_prefix_sum[left] + (active_prefix_sum[n] - active_prefix_sum[right])
23
24
            idle_remaining = idle_suffix_sum[left] - idle_suffix_sum[right]
25
            cost = max(idle_remaining, active_removed)
26
27
            min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
t = int(input())
32
33
for _ in range(t):
34
35
    server_rack = input().strip()
36
37
    print(min_cost_server_pruning(server_rack))",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055219
1390055216,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
7
        Scanner sc = new Scanner(System.in);
8
9
        int T = sc.nextInt();
10
11
        sc.nextLine();
12
13
        while (T-- > 0) {
14
15
            String s = sc.nextLine().trim();
16
17
            int n = s.length();
18
19
            int totalOnes = 0;
20
21
            int maxConsecutiveOnes = 0;
22
23
            int currentConsecutiveOnes = 0;
24
25
            26
27
            for (char c : s.toCharArray()) {
28
29
                if (c == '1') {
30
31
                    currentConsecutiveOnes++;
32
33
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
34
35
                    totalOnes++;
36
37
                } else {
38
39
                    currentConsecutiveOnes = 0;
40
41
                }
42
43
            }
44
45
            46
47
            if (totalOnes == 0) {
48
49
                System.out.println(0);
50
51
                continue;
52
53
            }
54
55
            if (maxConsecutiveOnes == totalOnes) {
56
57
                System.out.println(0);
58
59
                continue;
60
61
            }
62
63
            64
65
            int totalZeros = n - totalOnes;
66
67
            int low = 0;
68
69
            int high = Math.max(totalOnes, totalZeros);
70
71
            int answer = high;
72
73
            74
75
            while (low <= high) {
76
77
                int mid = (low + high) / 2;
78
79
                int requiredOnes = Math.max(0, totalOnes - mid);
80
81
                82
83
                if (requiredOnes == 0) {
84
85
                    answer = mid;
86
87
                    high = mid - 1;
88
89
                    continue;
90
91
                }
92
93
                94
95
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
96
97
                if (maxOnes >= requiredOnes) {
98
99
                    answer = mid;
100
101
                    high = mid - 1;
102
103
                } else {
104
105
                    low = mid + 1;
106
107
                }
108
109
            }
110
111
            112
113
            System.out.println(answer);
114
115
        }
116
117
        sc.close();
118
119
    }
120
121
    122
123
    private static int maxOnesWithAtMostKZeros(String s, int k) {
124
125
        int left = 0;
126
127
        int zeros = 0;
128
129
        int maxOnes = 0;
130
131
        int n = s.length();
132
133
        134
135
        for (int right = 0; right < n; right++) {
136
137
            if (s.charAt(right) == '0') {
138
139
                zeros++;
140
141
            }
142
143
            while (zeros > k) {
144
145
                if (s.charAt(left) == '0') {
146
147
                    zeros--;
148
149
                }
150
151
                left++;
152
153
            }
154
155
            int currentOnes = (right - left + 1) - zeros;
156
157
            maxOnes = Math.max(maxOnes, currentOnes);
158
159
        }
160
161
        162
163
        return maxOnes;
164
165
    }
166
167
}",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055216
1390055223,unknown,unknown,unknown,"1
def min_decommission_cost(s: str) -> int:
2
    n = len(s)
3
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
4
    T = len(ones_pos)
5
    6
    if T == 0:
7
        return 0
8
    9
    zeros_total = s.count('0')
10
    ans = min(zeros_total, T) 
11
    12
    for X in range(1, T + 1):
13
        for i in range(0, T - X + 1):
14
            left = ones_pos[i]
15
            right = ones_pos[i + X - 1]
16
            length = right - left + 1
17
            zeros_in_block = length - X
18
            candidate = max(zeros_in_block, T - X)
19
            ans = min(ans, candidate)
20
    21
    return ans
22
23
if __name__ == '__main__':
24
    T = int(input().strip())
25
    for _ in range(T):
26
        s = input().strip()
27
        print(min_decommission_cost(s))",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055223
1390055212,unknown,unknown,unknown,"1
def min_cost_server_pruning(server_rack):
2
    n = len(server_rack)  
3
4
5
    active_prefix_sum = [0] * (n + 1)
6
    idle_suffix_sum = [0] * (n + 1)
7
8
    for i in range(n):
9
        active_prefix_sum[i+1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
10
    for i in range(n-1, -1, -1):
11
        idle_suffix_sum[i] = idle_suffix_sum[i+1] + (1 if server_rack[i] == '0' else 0)
12
13
    min_cost = float('inf')
14
15
    for left in range(n + 1):
16
        for right in range(left, n + 1):
17
            active_removed = active_prefix_sum[left] + (active_prefix_sum[n] - active_prefix_sum[right])
18
            idle_remaining = idle_suffix_sum[left] - idle_suffix_sum[right]
19
            cost = max(idle_remaining, active_removed)
20
            min_cost = min(min_cost, cost)
21
22
    return min_cost
23
24
t = int(input())
25
for _ in range(t):
26
    server_rack = input().strip()
27
    print(min_cost_server_pruning(server_rack))",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055212
1390055213,unknown,unknown,unknown,"1
function processData(input) {
2
    let data = input.trim().split(/\s+/);
3
    let index = 0;
4
    let T = parseInt(data[index++]);
5
    let output = [];
6
7
    for (let test = 0; test < T; test++) {
8
        let n = parseInt(data[index++]);
9
        let k = parseInt(data[index++]);
10
        let a = data.slice(index, index + n).map(Number);
11
        index += n;
12
13
        let sumA = a.reduce((acc, num) => acc + num, 0);
14
        let v = [];
15
16
        for (let i = 0; i < n; i++) {
17
            v.push(a[i] - (n - i - 1));
18
        }
19
20
        v.sort((a, b) => b - a);
21
22
        let prefix = Array(n + 1).fill(0);
23
        for (let i = 0; i < n; i++) {
24
            prefix[i + 1] = prefix[i] + v[i];
25
        }
26
27
        let maxSum = 0;
28
        let maxT = Math.min(k, n);
29
30
        for (let t = 0; t <= maxT; t++) {
31
            let current = prefix[t] + (t * (t - 1)) / 2;
32
            maxSum = Math.max(maxSum, current);
33
        }
34
35
        output.push(sumA - maxSum);
36
    }
37
38
    console.log(output.join(""\n""));
39
}
40
41
process.stdin.resume();
42
process.stdin.setEncoding(""utf-8"");
43
let input = """";
44
45
process.stdin.on(""data"", function (chunk) {
46
    input += chunk;
47
});
48
49
process.stdin.on(""end"", function () {
50
    processData(input);
51
});
52
53",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055213
1390055215,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int t = scanner.nextInt();
7
        scanner.nextLine(); // Consume newline
8
        9
        for (int i = 0; i < t; i++) {
10
            String servers = scanner.nextLine();
11
            int minCost = minimizeServerCost(servers);
12
            System.out.println(minCost);
13
        }
14
        scanner.close();
15
    }
16
    17
    public static int minimizeServerCost(String servers) {
18
        int n = servers.length();
19
        20
        // Precompute prefix sums for O(1) range queries
21
        int[] prefixZeros = new int[n + 1];
22
        int[] prefixOnes = new int[n + 1];
23
        24
        for (int i = 0; i < n; i++) {
25
            prefixZeros[i + 1] = prefixZeros[i] + (servers.charAt(i) == '0' ? 1 : 0);
26
            prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
27
        }
28
        29
        int minCost = Integer.MAX_VALUE;
30
        int totalOnes = prefixOnes[n];
31
        32
        // Special case optimization - removing no servers
33
        minCost = Math.min(minCost, prefixZeros[n]);
34
        35
        // Optimization: instead of nested loops, use a different approach
36
        // For each possible prefix end position
37
        for (int prefixEnd = 0; prefixEnd <= n; prefixEnd++) {
38
            int onesRemovedFromPrefix = prefixOnes[prefixEnd];
39
            40
            // For minimal cost, we want to minimize max(zerosRemaining, onesRemoved)
41
            // Since onesRemovedFromPrefix is fixed, we can binary search for the optimal suffix
42
            int left = prefixEnd;
43
            int right = n;
44
            45
            while (left <= right) {
46
                int mid = left + (right - left) / 2;
47
                48
                int zerosRemaining = prefixZeros[mid] - prefixZeros[prefixEnd];
49
                int onesRemovedFromSuffix = totalOnes - prefixOnes[mid];
50
                int onesRemoved = onesRemovedFromPrefix + onesRemovedFromSuffix;
51
                52
                if (zerosRemaining <= onesRemoved) {
53
                    // Try to decrease onesRemoved by moving right
54
                    left = mid + 1;
55
                } else {
56
                    // Try to increase zerosRemaining by moving left
57
                    right = mid - 1;
58
                }
59
                60
                int cost = Math.max(zerosRemaining, onesRemoved);
61
                if (prefixEnd > 0 || mid < n) { // Skip if removing nothing
62
                    minCost = Math.min(minCost, cost);
63
                }
64
            }
65
        }
66
        67
        // Handle cases where we couldn't find an optimal solution
68
        // One more pass with the regular approach
69
        for (int prefixEnd = 0; prefixEnd <= n; prefixEnd++) {
70
            for (int suffixStart = n; suffixStart >= prefixEnd; suffixStart--) {
71
                // Skip if removing nothing
72
                if (prefixEnd == 0 && suffixStart == n) continue;
73
                74
                int onesRemoved = prefixOnes[prefixEnd] + (prefixOnes[n] - prefixOnes[suffixStart]);
75
                int zerosRemaining = prefixZeros[suffixStart] - prefixZeros[prefixEnd];
76
                77
                int cost = Math.max(zerosRemaining, onesRemoved);
78
                minCost = Math.min(minCost, cost);
79
                80
                // Early termination if we have a boundary case
81
                if (prefixEnd == 0 || suffixStart == n) {
82
                    break; // We only need to check one boundary case
83
                }
84
            }
85
        }
86
        87
        return minCost;
88
    }
89
}",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055215
1390055210,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])  # Number of test cases
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
13
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if _name_ == ""_main_"":
45
    main()
46",44,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055210
1390055207,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055207
1390055208,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055208
1390055209,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055209
1390055202,unknown,unknown,unknown,"1
def optimize_server_decommissioning(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    optimal_i = 0
5
    optimal_j = 0
6
   7
    for i in range(n + 1):
8
        for j in range(n + 1 - i):
9
            10
            remaining = server_rack[i:n-j]
11
            12
            if not remaining:  
13
                active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
14
                cost = active_removed
15
            else:
16
               17
                idle_remaining = remaining.count('0')
18
                19
                20
                active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
21
                22
                23
                cost = max(idle_remaining, active_removed)
24
            25
           26
            if cost < min_cost:
27
                min_cost = cost
28
                optimal_i = i
29
                optimal_j = j
30
    31
    return min_cost
32
33
def main():
34
    t = int(input().strip())
35
    results = []
36
    37
    for _ in range(t):
38
        server_rack = input().strip()
39
        min_cost = optimize_server_decommissioning(server_rack)
40
        results.append(min_cost)
41
    42
    for result in results:
43
        print(result)
44
45
if __name__ == ""__main__"":
46
    main()",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055202
1390055204,unknown,unknown,unknown,"1
def earliest_faults(arr, k):
2
    result = []
3
    first_fault = 0  # Default if no faults in batch
4
5
    for i in range(len(arr) - k + 1):  # Iterate through batches
6
        batch = arr[i:i + k]
7
        first_fault = 0  # Reset for each batch
8
        9
        for num in batch:  # Find first faulty reading
10
            if num < 0:
11
                first_fault = num
12
                break
13
        14
        result.append(first_fault)
15
16
    return result
17
18
19
# Reading input
20
t = int(input())  # Number of test cases
21
for _ in range(t):
22
    n, k = map(int, input().split())  # Size of array and batch size
23
    arr = list(map(int, input().split()))  # Sensor readings
24
    25
    # Get the result and print it
26
    print(*earliest_faults(arr, k))
27",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055204
1390055205,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055205
1390055199,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055199
1390055200,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        benefits = []
12
        for i in range(n):
13
            benefit = a[i] - (n - i - 1)
14
            benefits.append((benefit, i))
15
        16
        17
        benefits.sort(reverse=True)
18
19
        skipped = [False] * n
20
21
        for i in range(k):
22
            _, idx = benefits[i]
23
            skipped[idx] = True
24
25
        26
        total_effort = 0
27
        penalty = 0  
28
        for i in range(n):
29
            if skipped[i]:
30
                penalty += 1
31
            else:
32
                total_effort += a[i] + penalty
33
34
        print(total_effort)
35
36
threading.Thread(target=main).start()
37",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055200
1390055201,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    4
    for j in range(k + 1):
5
        dp[0][j] = 0
6
    7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            if j > 0:
10
                dp[i][j] = dp[i-1][j-1]
11
            12
            current_strength = strengths[i-1] + j
13
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
14
    15
    return min(dp[n])
16
17
def solve():
18
    t = int(input())
19
    results = []
20
    21
    for _ in range(t):
22
        n, k = map(int, input().split())
23
        strengths = list(map(int, input().split()))
24
        results.append(min_effort_to_breach(n, k, strengths))
25
    26
    for result in results:
27
        print(result)
28
29
solve()
30",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055201
1390055198,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} ",45,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055198
1390055193,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055193
1390055195,unknown,unknown,unknown,"1
import sys
2
3
def minimize_server_shutdown_cost():
4
    num_cases = int(sys.stdin.readline().strip())
5
    6
    for _ in range(num_cases):
7
        server_status = sys.stdin.readline().strip()
8
        9
        active_servers = [index for index, state in enumerate(server_status) if state == '1']
10
        total_active = len(active_servers)
11
        12
        # If no active servers or already consecutive, no operations needed
13
        if total_active == 0 or active_servers[-1] - active_servers[0] == total_active - 1:
14
            print(0)
15
            continue
16
        17
        low, high = 0, total_active
18
        19
        while high - low > 1:
20
            mid_point = (low + high) // 2
21
            servers_to_keep = total_active - mid_point
22
            23
            is_possible = False
24
            for i in range(mid_point + 1):
25
                first, last = active_servers[i], active_servers[i + servers_to_keep - 1]
26
                if (last - first + 1) - servers_to_keep <= mid_point:
27
                    is_possible = True
28
                    break
29
            30
            if is_possible:
31
                high = mid_point
32
            else:
33
                low = mid_point
34
        35
        print(high)
36
37
if __name__ == ""__main__"":
38
    minimize_server_shutdown_cost()",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055195
1390055197,unknown,unknown,unknown,"1
import sys, bisect
2
def solve():
3
    d = sys.stdin.buffer.read().split()
4
    if not d: return
5
    t = int(d[0])
6
    i_d = 1
7
    res = []
8
    for _ in range(t):
9
        s = d[i_d].decode()
10
        i_d += 1
11
        n = len(s)
12
        p1 = [0]*(n+1)
13
        p0 = [0]*(n+1)
14
        for i in range(n):
15
            p1[i+1] = p1[i] + (s[i]=='1')
16
            p0[i+1] = p0[i] + (s[i]=='0')
17
        z = p0[n]
18
        s1 = [0]*(n+1)
19
        s0 = [0]*(n+1)
20
        for j in range(n):
21
            s1[j+1] = s1[j] + (s[n-1-j]=='1')
22
            s0[j+1] = s0[j] + (s[n-1-j]=='0')
23
        best = 10**9
24
        for i in range(n+1):
25
            lo = 0
26
            hi = n - i
27
            cand = 10**9
28
            while lo <= hi:
29
                m = (lo+hi)//2
30
                a = p1[i] + s1[m]
31
                b = (z - p0[i]) - s0[m]
32
                c = a if a>=b else b
33
                if a < b:
34
                    lo = m+1
35
                else:
36
                    hi = m-1
37
                if c < cand: cand = c
38
            if cand < best: best = cand
39
        res.append(str(best))
40
    sys.stdout.write(""\n"".join(res))
41
if __name__==""__main__"":
42
    solve()
43",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055197
1390055189,unknown,unknown,unknown,"1
def faulty_sensor_readings(arr, k):
2
3
    n = len(arr)
4
    results = []
5
6
    for i in range(n - k + 1):
7
        batch = arr[i:i + k]
8
        found_fault = False
9
        for j in range(len(batch)):
10
            if batch[j] < 0:
11
                results.append(batch[j])
12
                found_fault = True
13
                break  
14
        if not found_fault:
15
            results.append(0)
16
17
    return results
18
19
20
21
t = int(input())
22
for _ in range(t):
23
    n, k = map(int, input().split())
24
    arr = list(map(int, input().split()))
25
    result = faulty_sensor_readings(arr, k)
26
    print(*result)
27",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055189
1390055192,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
vector<int> helper(vector<int>&arr,int k){
8
    vector<int> result;
9
    for(int i = 0; i <= arr.size() - k; i++){
10
        int f = 0;
11
        for(int j = i; j < i + k; j++){
12
            if(arr[j] < 0){
13
                f = arr[j];
14
                break;
15
            }
16
        }
17
        result.push_back(f);
18
    }
19
    return result;
20
}
21
22
23
int main() {
24
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
25
    int a;
26
    cin>>a;
27
    while(a--){
28
        int n,k;
29
        cin>>n>>k;
30
        vector<int> arr(n);
31
        for(int i = 0; i < n; i++){
32
            cin>>arr[i];
33
        }
34
        vector<int>result = helper(arr,k);
35
        for(int i = 0; i < result.size(); i++){
36
            cout<<result[i]<<(i == result.size() - 1 ? """":"" "");
37
        }
38
        cout<<endl;
39
    }
40
    return 0;
41
}",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055192
1390055190,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array initialized with infinity
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: no firewalls, no effort
5
6
    for i in range(1, n + 1):
7
        for j in range(k + 1):
8
            # Case 1: Do not skip the i-th firewall
9
            dp[i][j] = dp[i-1][j] + firewalls[i-1] + j
10
11
            # Case 2: Skip the i-th firewall if possible
12
            if j > 0:
13
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
14
15
    # The answer is the minimum value in the last row
16
    return min(dp[n])
17
18
# Read input
19
T = int(input())
20
for _ in range(T):
21
    n, k = map(int, input().split())
22
    firewalls = list(map(int, input().split()))
23
    print(min_effort(n, k, firewalls))",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055190
1390055182,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_earliest_faulty_readings(t, test_cases):
4
    results = []
5
    6
    for case in test_cases:
7
        n, k = case[0], case[1]
8
        arr = case[2]
9
        10
        # This will store the result for this test case
11
        result = []
12
        13
        # Deque to store indices of faulty readings (negative values)
14
        dq = deque()
15
        16
        # Process the first batch
17
        for i in range(k):
18
            if arr[i] < 0:
19
                dq.append(i)
20
        21
        # For the first window, check the earliest faulty reading
22
        if dq:
23
            result.append(arr[dq[0]])
24
        else:
25
            result.append(0)
26
        27
        # Slide the window across the rest of the array
28
        for i in range(k, n):
29
            # Remove elements out of the current window
30
            while dq and dq[0] <= i - k:
31
                dq.popleft()
32
            33
            # Add the new element if it's a fault (negative)
34
            if arr[i] < 0:
35
                dq.append(i)
36
            37
            # Get the earliest faulty reading for this window
38
            if dq:
39
                result.append(arr[dq[0]])
40
            else:
41
                result.append(0)
42
        43
        results.append(result)
44
    45
    return results
46
47
48
# Input Reading
49
t = int(input())  # Number of test cases
50
test_cases = []
51
52
for _ in range(t):
53
    n, k = map(int, input().split())
54
    arr = list(map(int, input().split()))
55
    test_cases.append((n, k, arr))
56
57
# Processing
58
results = find_earliest_faulty_readings(t, test_cases)
59
60
# Output
61
for result in results:
62
    print("" "".join(map(str, result)))
63",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055182
1390055187,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_earliest_faults(arr, k):
4
    result = []
5
    dq = deque()
6
7
    for i in range(len(arr)):
8
        # Remove indices that are out of the current window
9
        if dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
12
        # Add index of negative number to the deque
13
        if arr[i] < 0:
14
            dq.append(i)
15
16
        # Start collecting results when we have a full window
17
        if i >= k - 1:
18
            result.append(arr[dq[0]] if dq else 0)
19
20
    return result
21
22
23
# ------------------------
24
# MAIN DRIVER CODE
25
# ------------------------
26
27
t = int(input())  # Number of test cases
28
29
for _ in range(t):
30
    n, k = map(int, input().split())  # Size of array and window size
31
    arr = list(map(int, input().split()))  # Input array
32
33
    result = find_earliest_faults(arr, k)
34
    print(*result)
35",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055187
1390055188,unknown,unknown,unknown,"1
def min_cost(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    5
    # Precompute the prefix sums for 0's and 1's
6
    prefix_zeros = [0] * (n + 1)
7
    prefix_ones = [0] * (n + 1)
8
    9
    for i in range(n):
10
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_rack[i] == '0' else 0)
11
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_rack[i] == '1' else 0)
12
    13
    # Iterate over all possible windows
14
    for left in range(n + 1):
15
        for right in range(left, n + 1):
16
            # Calculate the number of 0's remaining in the window
17
            zeros_remaining = prefix_zeros[right] - prefix_zeros[left]
18
            # Calculate the number of 1's removed outside the window
19
            ones_removed = prefix_ones[left] + (prefix_ones[n] - prefix_ones[right])
20
            # Calculate the cost
21
            cost = max(zeros_remaining, ones_removed)
22
            # Update the minimum cost
23
            if cost < min_cost:
24
                min_cost = cost
25
    26
    return min_cost
27
28
# Read the number of test cases
29
T = int(input())
30
for _ in range(T):
31
    server_rack = input().strip()
32
    print(min_cost(server_rack))",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055188
1390055181,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",46,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055181
1390055175,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        total_ones = s.count('1')
6
        total_zeros = s.count('0')
7
        min_cost = float('inf')
8
        for i in range(n + 1):
9
            for j in range(i, n + 1):
10
                window_zeros = s[i:j].count('0')
11
                window_ones = s[i:j].count('1')               
12
                removed_ones = total_ones - window_ones
13
                remaining_zeros = window_zeros
14
                cost = max(remaining_zeros, removed_ones)
15
                min_cost = min(min_cost, cost)
16
        results.append(min_cost)
17
    return results
18
T = int(input()) 
19
test_cases = [input().strip() for _ in range(T)]
20
results = min_decommissioning_cost(test_cases)
21
for result in results:
22
    print(result)
23",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055175
1390055176,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(t, test_cases):
4
    results = []
5
    6
    for case in test_cases:
7
        n, k, arr = case
8
        dq = deque()
9
        output = []
10
        11
        for i in range(n):
12
            # Remove elements that are out of this window
13
            if dq and dq[0] < i - k + 1:
14
                dq.popleft()
15
            16
            # Add current element if it is faulty (negative)
17
            if arr[i] < 0:
18
                dq.append(i)
19
            20
            # Process first valid window
21
            if i >= k - 1:
22
                output.append(arr[dq[0]] if dq else 0)
23
        24
        results.append(output)
25
    26
    return results
27
28
# Reading input
29
t = int(input())
30
test_cases = []
31
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    test_cases.append((n, k, arr))
36
37
# Processing and printing output
38
results = earliest_faulty_readings(t, test_cases)
39
for res in results:
40
    print("" "".join(map(str, res)))",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055176
1390055177,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        reductions = []
6
        for i in range(n):
7
            reductions.append(a[i] - (n - i - 1))
8
        positive_reductions = [r for r in reductions if r > 0]
9
        positive_reductions.sort(reverse=True)
10
        skip_count = min(k, len(positive_reductions))
11
        total_reduction = sum(positive_reductions[:skip_count])
12
       13
        firewall_indices = [(a[i], i) for i in range(n)]
14
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
15
        skip_indices = set()
16
        for i in range(min(k, n)):
17
            skip_indices.add(firewall_indices[i][1])
18
        total_effort = 0
19
        increase = 0
20
        for i in range(n):
21
            if i in skip_indices:
22
                increase += 1
23
            else:
24
                total_effort += a[i] + increase
25
        26
        results.append(total_effort)
27
    return results
28
29
T = int(input())
30
test_cases = []
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    a = list(map(int, input().split()))
34
    test_cases.append((n, k, a))
35
36
results = min_effort(test_cases)
37
38
for res in results:
39
    print(res)",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055177
1390055168,unknown,unknown,unknown,"1
def find_faulty_readings(arr, k):
2
    result = []
3
    for i in range(len(arr) - k + 1):
4
        batch = arr[i:i + k]
5
        faulty_reading = 0
6
        for num in batch:
7
            if num < 0:
8
                faulty_reading = num
9
                break
10
        result.append(faulty_reading)
11
    return result
12
13
if __name__ == ""__main__"":
14
    t = int(input())
15
    for _ in range(t):
16
        n, k = map(int, input().split())
17
        arr = list(map(int, input().split()))
18
        output = find_faulty_readings(arr, k)
19
        print(*output)",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055168
1390055169,unknown,unknown,unknown,"1
import sys
2
from itertools import accumulate
3
4
def min_effort(arr, k):
5
    n = len(arr)
6
    T = sum(arr)
7
    A = [arr[i] + (i+1) for i in range(n)]
8
    A.sort(reverse=True)
9
    P = [0] + list(accumulate(A))
10
    m_max = min(k, n)
11
    best = float('inf')
12
    for m in range(m_max + 1):
13
        cost = T + m * n - (m * m - m) // 2 - P[m]
14
        if cost < best:
15
            best = cost
16
    return best
17
18
def solve():
19
    data = sys.stdin.read().strip().split()
20
    if not data:
21
        return
22
    t = int(data[0])
23
    index = 1
24
    res = []
25
    for _ in range(t):
26
        n = int(data[index]); index += 1
27
        k = int(data[index]); index += 1
28
        arr = list(map(int, data[index:index+n])); index += n
29
        res.append(str(min_effort(arr, k)))
30
    sys.stdout.write(""\n"".join(res))
31
32
if __name__ == ""__main__"":
33
    solve()",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055169
1390055174,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055174
1390055158,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    ans = float('inf')
6
    7
    for i in range(n + 1):
8
        decommissioned_ones_left = s[:i].count('1')
9
        10
        for j in range(n - i + 1):
11
            decommissioned_ones_right = s[n - j:].count('1')
12
            remaining_zeros = s[i:n - j].count('0')
13
            14
            ans = min(ans, max(decommissioned_ones_left + decommissioned_ones_right, remaining_zeros))
15
            16
    print(ans)
17
18
t = int(input())
19
for _ in range(t):
20
    solve()",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055158
1390055160,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for servers in test_cases:
4
        n = len(servers)
5
        total_ones = servers.count('1')
6
        min_cost = float('inf')
7
        for p in range(n + 1):
8
            for s in range(n - p + 1):
9
                remaining = servers[p:n-s]
10
                remaining_zeros = remaining.count('0')
11
                remaining_ones = remaining.count('1')
12
                removed_ones = total_ones - remaining_ones
13
                cost = max(remaining_zeros, removed_ones)
14
                min_cost = min(min_cost, cost)
15
        results.append(min_cost)
16
    return results
17
T = int(input().strip())
18
test_cases = [input().strip() for _ in range(T)]
19
results = min_cost(test_cases)
20
print(""\n"".join(map(str, results)))",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055160
1390055163,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
    left = 0
3
    zeros = 0
4
    max_ones = 0
5
    n = len(s)
6
    7
    for right in range(n):
8
        if s[right] == '0':
9
            zeros += 1
10
        11
        while zeros > k:
12
            if s[left] == '0':
13
                zeros -= 1
14
            left += 1
15
        16
        current_ones = (right - left + 1) - zeros
17
        max_ones = max(max_ones, current_ones)
18
    19
    return max_ones
20
21
def min_cost_to_prune(s):
22
    n = len(s)
23
    total_ones = s.count('1')
24
    max_consecutive_ones = max(map(len, s.split('0')))
25
    26
    if total_ones == 0:
27
        return 0
28
    if max_consecutive_ones == total_ones:
29
        return 0
30
    31
    total_zeros = n - total_ones
32
    low, high = 0, max(total_ones, total_zeros)
33
    answer = high
34
    35
    while low <= high:
36
        mid = (low + high) // 2
37
        required_ones = max(0, total_ones - mid)
38
        39
        if required_ones == 0:
40
            answer = mid
41
            high = mid - 1
42
            continue
43
        44
        max_ones = max_ones_with_at_most_k_zeros(s, mid)
45
        if max_ones >= required_ones:
46
            answer = mid
47
            high = mid - 1
48
        else:
49
            low = mid + 1
50
    51
    return answer
52
53
54
def main():
55
    t = int(input().strip())
56
    for _ in range(t):
57
        s = input().strip()
58
        print(min_cost_to_prune(s))
59
60
if __name__ == ""__main__"":
61
    main()",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055163
1390055156,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()",47,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055156
1390055149,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine();
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            for (char c : s.toCharArray()) {
17
                if (c == '1') {
18
                    currentConsecutiveOnes++;
19
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
20
                    totalOnes++;
21
                } else {
22
                    currentConsecutiveOnes = 0;
23
                }
24
            }
25
            26
            if (totalOnes == 0) {
27
                System.out.println(0);
28
                continue;
29
            }
30
            if (maxConsecutiveOnes == totalOnes) {
31
                System.out.println(0);
32
                continue;
33
            }
34
            35
            int totalZeros = n - totalOnes;
36
            int low = 0;
37
            int high = Math.max(totalOnes, totalZeros);
38
            int answer = high;
39
            40
            while (low <= high) {
41
                int mid = (low + high) / 2;
42
                int requiredOnes = Math.max(0, totalOnes - mid);
43
                44
                if (requiredOnes == 0) {
45
                    answer = mid;
46
                    high = mid - 1;
47
                    continue;
48
                }
49
                50
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
51
                if (maxOnes >= requiredOnes) {
52
                    answer = mid;
53
                    high = mid - 1;
54
                } else {
55
                    low = mid + 1;
56
                }
57
            }
58
            59
            System.out.println(answer);
60
        }
61
        sc.close();
62
    }
63
    64
    private static int maxOnesWithAtMostKZeros(String s, int k) {
65
        int left = 0;
66
        int zeros = 0;
67
        int maxOnes = 0;
68
        int n = s.length();
69
        70
        for (int right = 0; right < n; right++) {
71
            if (s.charAt(right) == '0') {
72
                zeros++;
73
            }
74
            while (zeros > k) {
75
                if (s.charAt(left) == '0') {
76
                    zeros--;
77
                }
78
                left++;
79
            }
80
            int currentOnes = (right - left + 1) - zeros;
81
            maxOnes = Math.max(maxOnes, currentOnes);
82
        }
83
        84
        return maxOnes;
85
    }
86
}",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055149
1390055152,unknown,unknown,unknown,"1
import sys
2
data = sys.stdin.read().split()
3
if not data:
4
    exit()
5
t = int(data[0])
6
ptr = 1
7
res = []
8
for _ in range(t):
9
    s = data[ptr]
10
    ptr += 1
11
    n = len(s)
12
    pre = [0]*(n+1)
13
    for i in range(n):
14
        pre[i+1] = pre[i] + (1 if s[i]=='1' else 0)
15
    O = pre[n]
16
    best = 10**9
17
    for L in range(n+1):
18
        if L <= n - O:
19
            cost = O - (pre[L+O] - pre[L])
20
        else:
21
            cost = pre[L] + ((n - L - O) if n - L - O > 0 else 0)
22
        if cost < best:
23
            best = cost
24
    res.append(str(best))
25
sys.stdout.write(""\n"".join(res))",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055152
1390055155,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055155
1390055141,unknown,unknown,unknown,"1
def minimize_effort():
2
    n, k = map(int, input().split())
3
    strengths = list(map(int, input().split()))
4
    5
    # Calculate the initial total effort
6
    total_effort = sum(strengths)
7
    8
    # Compute the penalty for skipping each firewall
9
    skip_penalty = [strengths[i] - (n - i - 1) for i in range(n)]
10
    11
    # Sort in descending order to prioritize the most beneficial skips
12
    skip_penalty.sort(reverse=True)
13
    14
    # Reduce effort by skipping up to k firewalls
15
    total_effort -= sum(skip_penalty[:k])
16
    17
    # Account for the incremental difficulty of later firewalls
18
    total_effort -= k * (k - 1) // 2
19
    20
    # Print the minimized effort
21
    print(total_effort)
22
if __name__ == ""__main__"":
23
    test_cases = int(input())
24
    for _ in range(test_cases):
25
        minimize_effort()
26",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055141
1390055146,unknown,unknown,unknown,"1
def minimize_cost(s):
2
    total_ones = s.count('1')
3
    total_zeros = len(s) - total_ones
4
    low = 0
5
    high = max(total_ones, total_zeros)
6
    answer = high  # Initialize with the maximum possible value
7
8
    while low <= high:
9
        mid = (low + high) // 2
10
        K = total_ones - mid
11
12
        # Check if current mid is feasible
13
        if K <= 0:
14
            feasible = (total_zeros <= mid)
15
        else:
16
            current_0 = 0
17
            current_1 = 0
18
            left = 0
19
            feasible = False
20
            for right in range(len(s)):
21
                if s[right] == '0':
22
                    current_0 += 1
23
                else:
24
                    current_1 += 1
25
                # Move left pointer to ensure current_0 <= mid
26
                while current_0 > mid:
27
                    if s[left] == '0':
28
                        current_0 -= 1
29
                    else:
30
                        current_1 -= 1
31
                    left += 1
32
                # Check if current window meets the 1's requirement
33
                if current_1 >= K:
34
                    feasible = True
35
                    break
36
        if feasible:
37
            answer = mid
38
            high = mid - 1
39
        else:
40
            low = mid + 1
41
    return answer
42
43
T = int(input())
44
for _ in range(T):
45
    s = input().strip()
46
    print(minimize_cost(s))",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055146
1390055144,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <algorithm>
4
#include <climits>
5
#include <vector>
6
7
using namespace std;
8
9
int solve(const string& servers) {
10
    int n = servers.length();
11
    12
    // Edge case - if all servers are the same type
13
    bool allActive = true;
14
    bool allIdle = true;
15
    for (char c : servers) {
16
        if (c == '0') allActive = false;
17
        if (c == '1') allIdle = false;
18
    }
19
    20
    if (allActive) return 0; // Remove all from one end - no active servers removed
21
    if (allIdle) return 0;   // Remove all from one end - no idle servers remaining
22
    23
    // Count total servers of each type
24
    int totalActive = 0;
25
    for (char c : servers) {
26
        if (c == '1') totalActive++;
27
    }
28
    int totalIdle = n - totalActive;
29
    30
    // Get running counts of each type from left
31
    vector<int> leftActive(n + 1, 0);
32
    vector<int> leftIdle(n + 1, 0);
33
    for (int i = 0; i < n; i++) {
34
        leftActive[i + 1] = leftActive[i] + (servers[i] == '1');
35
        leftIdle[i + 1] = leftIdle[i] + (servers[i] == '0');
36
    }
37
    38
    int minCost = min(totalActive, totalIdle); // Initialize with removing nothing from left and everything from right
39
    40
    // For each possible cut point (where to split the server rack)
41
    for (int cut = 1; cut <= n; cut++) {
42
        // Try removing left part and keeping right part
43
        int activeRemovedLeft = leftActive[cut];
44
        int idleRemainingRight = totalIdle - leftIdle[cut];
45
        minCost = min(minCost, max(activeRemovedLeft, idleRemainingRight));
46
        47
        // Try removing right part and keeping left part
48
        int activeRemovedRight = totalActive - leftActive[cut];
49
        int idleRemainingLeft = leftIdle[cut];
50
        minCost = min(minCost, max(activeRemovedRight, idleRemainingLeft));
51
        52
        // Try removing both left and right parts up to this point
53
        for (int leftCut = 0; leftCut < cut; leftCut++) {
54
            int activeRemoved = leftActive[leftCut] + (totalActive - leftActive[cut]);
55
            int idleRemaining = leftIdle[cut] - leftIdle[leftCut];
56
            minCost = min(minCost, max(activeRemoved, idleRemaining));
57
        }
58
    }
59
    60
    return minCost;
61
}
62
63
int main() {
64
    ios_base::sync_with_stdio(false);
65
    cin.tie(nullptr);
66
    67
    int t;
68
    cin >> t;
69
    70
    while (t--) {
71
        string servers;
72
        cin >> servers;
73
        cout << solve(servers) << ""\n"";
74
    }
75
    76
    return 0;
77
}",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055144
1390055134,unknown,unknown,unknown,"1
def calculate_minimum_cost(num_items, num_skipped, values):
2
    if num_skipped >= num_items:
3
        return 0
4
    impact_list = []
5
    for i in range(num_items):
6
        impact_value = values[i] - (num_items - i - 1)
7
        impact_list.append((impact_value, i))
8
    impact_list.sort(reverse=True)
9
    skipped_indices = set(impact_list[i][1] for i in range(num_skipped))
10
    total_cost = 0
11
    extra_penalty = 0
12
    for i in range(num_items):
13
        if i in skipped_indices:
14
            extra_penalty += 1
15
        else:
16
            total_cost += values[i] + extra_penalty
17
    return total_cost
18
19
def process_test_cases():
20
    test_cases = int(input())
21
    results = []
22
    for _ in range(test_cases):
23
        num_items, num_skipped = map(int, input().split())
24
        values = list(map(int, input().split()))
25
        results.append(calculate_minimum_cost(num_items, num_skipped, values))
26
    return results
27
28
def main():
29
    results = process_test_cases()
30
    for result in results:
31
        print(result)
32
33
if __name__ == ""__main__"":
34
    main()
35",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055134
1390055139,unknown,unknown,unknown,"1
import sys
2
input = sys.stdin.read
3
4
def minimum_effort(arr, k):
5
    n = len(arr)
6
    7
    if k == n:
8
        return 0
9
    10
    total_effort = sum(arr)
11
    min_effort = total_effort
12
    13
    # Initial window sum (first k elements)
14
    window_sum = sum(arr[:k])
15
    16
    # Try removing every window of size k
17
    for i in range(n - k + 1):
18
        # Effort after skipping this window
19
        skipped_effort = total_effort - window_sum + k
20
        min_effort = min(min_effort, skipped_effort)
21
        22
        # Slide the window to the right
23
        if i + k < n:
24
            window_sum = window_sum - arr[i] + arr[i + k]
25
    26
    return min_effort
27
28
# Efficient Input Handling
29
data = input().strip().split(""\n"")
30
t = int(data[0])
31
index = 1
32
33
results = []
34
for _ in range(t):
35
    n, k = map(int, data[index].split())
36
    arr = list(map(int, data[index + 1].split()))
37
    results.append(str(minimum_effort(arr, k)))
38
    index += 2
39
40
# Fast Output
41
sys.stdout.write(""\n"".join(results) + ""\n"")
42",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055139
1390055132,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
using ll = long long;
5
6
int main() {
7
    // Optimize input/output
8
    ios::sync_with_stdio(false);
9
    cin.tie(0);
10
11
    int T;
12
    cin >> T;
13
    for (int t = 0; t < T; t++) {
14
        int n, k;
15
        cin >> n >> k;
16
        vector<ll> a(n);
17
        for (int i = 0; i < n; i++) {
18
            cin >> a[i];
19
        }
20
21
        // INF for impossible states , really tough one to solved actually 
22
        const ll INF = 1e18;
23
24
        vector<ll> prev(k + 1, INF);
25
        prev[0] = 0; 
26
27
    28
        for (int i = 0; i < n; i++) {
29
            vector<ll> curr(k + 1, INF);
30
            for (int s = 0; s <= k; s++) {
31
                // Don't skip i
32
                curr[s] = prev[s] + a[i] + s;
33
                // Skip i (if possible)
34
                if (s > 0) {
35
                    curr[s] = min(curr[s], prev[s - 1]);
36
                }
37
            }
38
            prev = curr; 
39
        }
40
41
42
        ll ans = *min_element(prev.begin(), prev.end());
43
        cout << ans << '\n';
44
    }
45
    return 0;
46
}",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055132
1390055130,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
        # get indices for active servers ('1')
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        # Precompute A: A[i] = positions[i] - i
18
        A = [positions[i] - i for i in range(m)]
19
        20
        # check(X) returns True if there exists a window in A
21
        # such that:
22
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
23
        # and A[j] - A[i] <= X.
24
        def check(X):
25
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                # slide j as far as possible while A[j]-A[i] <= X
33
                while j < m and A[j] - A[i] <= X:
34
                    j += 1
35
                # j now is one past the last index satisfying condition, so the window has length (j - i)
36
                if j - i >= m - X:
37
                    return True
38
            return False
39
40
        # Binary search for the minimum X
41
        lo, hi, ans = 0, n, n
42
        while lo <= hi:
43
            mid = (lo + hi) // 2
44
            if check(mid):
45
                ans = mid
46
                hi = mid - 1
47
            else:
48
                lo = mid + 1
49
        out_lines.append(str(ans))
50
    51
    sys.stdout.write(""\n"".join(out_lines))
52
    53
if __name__ == '__main__':
54
    solve()",48,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055130
1390055123,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int t = scanner.nextInt();
7
        scanner.nextLine(); // Consume newline
8
        9
        for (int i = 0; i < t; i++) {
10
            String servers = scanner.nextLine();
11
            int minCost = minimizeServerCost(servers);
12
            System.out.println(minCost);
13
        }
14
        scanner.close();
15
    }
16
    17
    public static int minimizeServerCost(String servers) {
18
        int n = servers.length();
19
        20
        // Precompute prefix sums for O(1) range queries
21
        int[] prefixZeros = new int[n + 1];
22
        int[] prefixOnes = new int[n + 1];
23
        24
        for (int i = 0; i < n; i++) {
25
            prefixZeros[i + 1] = prefixZeros[i] + (servers.charAt(i) == '0' ? 1 : 0);
26
            prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
27
        }
28
        29
        int minCost = Integer.MAX_VALUE;
30
        31
        // Try all prefix and suffix combinations in O(n^2) time
32
        for (int prefixEnd = 0; prefixEnd <= n; prefixEnd++) {
33
            for (int suffixStart = prefixEnd; suffixStart <= n; suffixStart++) {
34
                // Skip if removing everything
35
                if (prefixEnd == 0 && suffixStart == n) continue;
36
                37
                // Calculate cost components
38
                int onesRemoved = prefixOnes[prefixEnd] + (prefixOnes[n] - prefixOnes[suffixStart]);
39
                int zerosRemaining = prefixZeros[suffixStart] - prefixZeros[prefixEnd];
40
                41
                int cost = Math.max(zerosRemaining, onesRemoved);
42
                minCost = Math.min(minCost, cost);
43
            }
44
        }
45
        46
        return minCost;
47
    }
48
}",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055123
1390055118,unknown,unknown,unknown,"1
print(1)
2
print(3)
3
print(0)",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055118
1390055128,unknown,unknown,unknown,"1
def min_effort(n, k, a):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    dp[0][0] = 0
4
    for i in range(1, n + 1):
5
        for j in range(k + 1):
6
            if j <= i:
7
                dp[i][j] = dp[i-1][j] + a[i-1] + j
8
            if j > 0:
9
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
10
    return min(dp[n])
11
12
T = int(input())
13
for _ in range(T):
14
    n, k = map(int, input().split())
15
    a = list(map(int, input().split()))
16
    print(min_effort(n, k, a))",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055128
1390055113,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for s in test_cases:
5
        # Remove leading and trailing zeros
6
        trimmed = s.strip('0')
7
8
        if not trimmed:  # If the entire string was zeros
9
            results.append(0)
10
            continue
11
12
        total_ones = trimmed.count('1')
13
        min_cost = float('inf')
14
15
        left_zeros = 0
16
        left_ones_removed = 0
17
        n = len(trimmed)
18
19
        # Iterate through possible partitions
20
        for i in range(n + 1):
21
            # Remaining zeros after removing left part
22
            right_zeros = trimmed[i:].count('0')
23
24
            # Cost calculation
25
            cost = max(right_zeros, left_ones_removed)
26
            min_cost = min(min_cost, cost)
27
28
            # Update count of removed ones
29
            if i < n:
30
                if trimmed[i] == '1':
31
                    left_ones_removed += 1
32
                else:
33
                    left_zeros += 1
34
35
        results.append(min_cost)
36
37
    return results
38
39
40
# Reading input
41
t = int(input().strip())
42
test_cases = [input().strip() for _ in range(t)]
43
result = min_decommissioning_cost(test_cases)
44
45
# Output results
46
for res in result:
47
    print(res)
48",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055113
1390055115,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055115
1390055116,unknown,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        s = input()
5
        n = len(s)
6
        7
        min_cost = float('inf')
8
        9
        for i in range(n + 1):
10
            for j in range(n - i + 1):
11
                remaining = s[i:n-j]
12
                13
                idle_count = remaining.count('0')
14
                removed_count = s[:i].count('1') + s[n-j:].count('1')
15
                16
                cost = max(idle_count, removed_count)
17
                min_cost = min(min_cost, cost)
18
        19
        print(min_cost)
20
21
solve()
22",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055116
1390055104,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055104
1390055109,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055109
1390055111,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    a = list(map(int, input().split()))
5
    dp = [float('inf')] * (k + 1)
6
    dp[0] = 0
7
    for x in a:
8
        new_dp = [float('inf')] * (k + 1)
9
        for s in range(k + 1):
10
            new_dp[s] = min(new_dp[s], dp[s] + x + s)
11
            if s < k:
12
                new_dp[s + 1] = min(new_dp[s + 1], dp[s])
13
        dp = new_dp
14
    print(min(dp))
15",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055111
1390055103,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_earliest_faults(arr, k):
4
    result = []
5
    dq = deque()
6
7
    for i in range(len(arr)):
8
        # Remove indices that are out of the current window
9
        if dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
12
        # Add index of negative number to the deque
13
        if arr[i] < 0:
14
            dq.append(i)
15
16
        # Start collecting results when we have a full window
17
        if i >= k - 1:
18
            result.append(arr[dq[0]] if dq else 0)
19
20
    return result
21
22
23
# ------------------------
24
# MAIN DRIVER CODE
25
# ------------------------
26
27
t = int(input())  # Number of test cases
28
29
for _ in range(t):
30
    n, k = map(int, input().split())  # Size of array and window size
31
    arr = list(map(int, input().split()))  # Input array
32
33
    result = find_earliest_faults(arr, k)
34
    print(*result)
35",49,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055103
1390055094,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055094
1390055097,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055097
1390055101,unknown,unknown,unknown,"1
def earliest_fault_in_batches(arr, k):
2
    results = []
3
    n = len(arr)
4
    5
    # Process each batch of size k
6
    for i in range(n - k + 1):
7
        batch = arr[i:i+k]
8
        9
        # Find earliest fault (negative value) in current batch
10
        fault_found = False
11
        for val in batch:
12
            if val < 0:
13
                results.append(val)
14
                fault_found = True
15
                break
16
        17
        # If no fault found in batch, append 0
18
        if not fault_found:
19
            results.append(0)
20
    21
    return results
22
23
# Process multiple test cases
24
def solve_test_cases():
25
    t = int(input())  # Number of test cases
26
    results = []
27
    28
    for _ in range(t):
29
        n, k = map(int, input().split())
30
        arr = list(map(int, input().split()))
31
        32
        batch_results = earliest_fault_in_batches(arr, k)
33
        results.append(batch_results)
34
    35
    # Print results
36
    for batch_result in results:
37
        print(*batch_result)
38
39
# Execute program
40
if __name__ == ""__main__"":
41
    solve_test_cases()",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055101
1390055090,unknown,unknown,unknown,"1
function processData(input) {
2
    let lines = input.trim().split(""\n"");
3
    let t = parseInt(lines[0]); 
4
    let index = 1;
5
    let output = [];
6
7
    for (let test = 0; test < t; test++) {
8
        let [n, k] = lines[index].split("" "").map(Number);
9
        let arr = lines[index + 1].split("" "").map(Number);
10
        index += 2; // Move to next test case
11
        12
        let res = [];
13
    14
        for(let i = 0; i <= n - k; i++){
15
            let batch = arr.slice(i,i+k)
16
            let faulty = false;
17
18
            for(let val of batch){
19
                if(val < 0){
20
                    res.push(val)
21
                    faulty = true
22
                    break;
23
                }
24
            }
25
26
            if(!faulty) res.push(0)
27
28
        }
29
30
        output.push(res.join("" ""))        
31
    }
32
    33
    console.log(output.join(""\n""));
34
} 
35
36
process.stdin.resume();
37
process.stdin.setEncoding(""ascii"");
38
_input = """";
39
process.stdin.on(""data"", function (input) {
40
    _input += input;
41
});
42
43
process.stdin.on(""end"", function () {
44
   processData(_input);
45
});",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055090
1390055092,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, n, k):
4
    result = []
5
    dq = deque()  # Store indices of negative numbers
6
7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Process remaining windows
13
    for i in range(n - k + 1):
14
        # If deque is not empty, the front of the queue is the earliest negative
15
        if dq:
16
            result.append(arr[dq[0]])
17
        else:
18
            result.append(0)
19
20
        # Remove elements that are out of this window
21
        if dq and dq[0] == i:
22
            dq.popleft()
23
24
        # Add the next element of the window
25
        if i + k < n and arr[i + k] < 0:
26
            dq.append(i + k)
27
28
    print(*result)  # Print space-separated output
29
30
# Read input
31
t = int(input())  # Number of test cases
32
for _ in range(t):
33
    n, k = map(int, input().split())  # Size of array and batch size
34
    arr = list(map(int, input().split()))  # Array elements
35
    earliest_faulty_readings(arr, n, k)",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055092
1390055093,unknown,unknown,unknown,"1
def min_cost(rack):
2
    n = len(rack)
3
    return min(max(rack[start:n-end].count('0'), rack[:start].count('1') + rack[n-end:].count('1')) 
4
              for start in range(n + 1) for end in range(n - start + 1))
5
6
T = int(input())
7
for _ in range(T):
8
    print(min_cost(input().strip()))",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055093
1390055085,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055085
1390055087,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
3
using namespace std;
4
5
using ll = long long;
6
7
int main() {
8
9
    // Optimize input/output
10
11
    ios::sync_with_stdio(false);
12
13
    cin.tie(0);
14
15
    int T;
16
17
    cin >> T;
18
19
    for (int t = 0; t < T; t++) {
20
21
        int n, k;
22
23
        cin >> n >> k;
24
25
        vector<ll> a(n);
26
27
        for (int i = 0; i < n; i++) {
28
29
            cin >> a[i];
30
31
        }
32
33
        // INF for impossible states , really tough one to solved actually 
34
35
        const ll INF = 1e18;
36
37
        vector<ll> prev(k + 1, INF);
38
39
        prev[0] = 0; 
40
41
    42
43
        for (int i = 0; i < n; i++) {
44
45
            vector<ll> curr(k + 1, INF);
46
47
            for (int s = 0; s <= k; s++) {
48
49
                // Don't skip i
50
51
                curr[s] = prev[s] + a[i] + s;
52
53
                // Skip i (if possible)
54
55
                if (s > 0) {
56
57
                    curr[s] = min(curr[s], prev[s - 1]);
58
59
                }
60
61
            }
62
63
            prev = curr; 
64
65
        }
66
67
        ll ans = *min_element(prev.begin(), prev.end());
68
69
        cout << ans << '\n';
70
71
    }
72
73
    return 0;
74
75
}",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055087
1390055089,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055089
1390055083,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    min_total_effort = float('inf')
3
    4
    dp = [[float('inf') for _ in range(k+1)] for _ in range(n+1)]
5
    dp[0][0] = 0 
6
    7
    for i in range(1, n+1):
8
        current_strength = strengths[i-1]
9
        10
        for j in range(k+1):
11
            if dp[i-1][j] != float('inf'):
12
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
13
        14
        for j in range(1, k+1):
15
            if dp[i-1][j-1] != float('inf'):
16
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
17
    18
    return min(dp[n])
19
20
def solve_test_cases():
21
    t = int(input())  
22
    23
    results = []
24
    for _ in range(t):
25
        n, k = map(int, input().split())
26
        strengths = list(map(int, input().split()))
27
        28
        min_effort = min_effort_to_breach(n, k, strengths)
29
        results.append(min_effort)
30
    31
    return results
32
33
if __name__ == ""__main__"":
34
    results = solve_test_cases()
35
    for result in results:
36
        print(result)",50,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055083
1390055075,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
3
    impacts = []
4
    5
    for i in range(n):
6
7
        impact = strengths[i] - (n - i - 1)
8
        impacts.append((impact, i))
9
    10
    impacts.sort(reverse=True)
11
    12
    to_skip = set(impacts[i][1] for i in range(k))
13
14
    total_effort = 0
15
    penalty = 0
16
    17
    for i in range(n):
18
        if i in to_skip:
19
            penalty += 1
20
        else:
21
            total_effort += strengths[i] + penalty
22
    23
    return total_effort
24
25
def solve_test_cases():
26
27
    t = int(input())  
28
    results = []
29
    30
    for _ in range(t):
31
        n, k = map(int, input().split())
32
        strengths = list(map(int, input().split()))
33
        results.append(min_effort_to_breach(n, k, strengths))
34
    35
    return results
36
37
def main():
38
    results = solve_test_cases()
39
    40
    for result in results:
41
        print(result)
42
43
if name == ""main"":
44
    main()",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055075
1390055079,unknown,unknown,unknown,1,51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055079
1390055078,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    int T;
10
    cin >> T;
11
    while (T--) {
12
        string s;
13
        cin >> s;
14
        int n = s.size();
15
16
        // Prefix sums
17
        vector<int> prefix_1(n + 1, 0);
18
        vector<int> prefix_0(n + 1, 0);
19
        for (int i = 0; i < n; i++) {
20
            prefix_1[i + 1] = prefix_1[i] + (s[i] == '1' ? 1 : 0);
21
            prefix_0[i + 1] = prefix_0[i] + (s[i] == '0' ? 1 : 0);
22
        }
23
24
        int total_1 = prefix_1[n];
25
        int min_cost = n;
26
27
        // Try all possible kept substrings [l, r)
28
        for (int l = 0; l <= n; l++) {
29
            // Instead of full nested loop, calculate cost directly
30
            // for r = n (maximum right end possible for fixed l)
31
            for (int r = l; r <= n; r++) {
32
                int kept_1 = prefix_1[r] - prefix_1[l];
33
                int kept_0 = prefix_0[r] - prefix_0[l];
34
                int removed_1 = total_1 - kept_1;
35
                int cost = max(removed_1, kept_0);
36
                if (cost < min_cost) min_cost = cost;
37
            }
38
        }
39
40
        cout << min_cost << endl;
41
    }
42
    return 0;
43
}",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055078
1390055068,unknown,unknown,unknown,"1
2
def min_cost_server_pruning(server_rack):
3
    n = len(server_rack)
4
5
    active_prefix_sum = [0] * (n + 1)
6
7
    idle_suffix_sum = [0] * (n + 1)
8
    for i in range(n):
9
10
        active_prefix_sum[i+1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
11
    for i in range(n-1, -1, -1):
12
13
        idle_suffix_sum[i] = idle_suffix_sum[i+1] + (1 if server_rack[i] == '0' else 0)
14
15
    min_cost = float('inf')
16
    for left in range(n + 1):
17
18
        for right in range(left, n + 1):
19
20
            # Active servers decommissioned (from start and end)
21
22
            active_removed = active_prefix_sum[left] + (active_prefix_sum[n] - active_prefix_sum[right])
23
24
            25
26
            # Idle servers remaining in the middle
27
28
            idle_remaining = idle_suffix_sum[left] - idle_suffix_sum[right]
29
            cost = max(idle_remaining, active_removed)
30
            min_cost = min(min_cost, cost)
31
    return min_cost
32
33
t = int(input())
34
35
for _ in range(t):
36
37
    server_rack = input().strip()
38
39
    print(min_cost_server_pruning(server_rack))",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055068
1390055069,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055069
1390055074,unknown,unknown,unknown,"1
def solve(n, k, a):
2
    if k >= n:
3
        return 0
4
5
    mem = {}
6
7
    def dfs(i, kl, p):
8
        if i == n:
9
            return 0
10
11
        st = (i, kl, p)
12
        if st in mem:
13
14
            return mem[st]
15
16
        ans = a[i] + p + dfs(i + 1, kl, p)
17
18
        if kl > 0:
19
            ans = min(ans, dfs(i + 1, kl - 1, p + 1))
20
21
        mem[st] = ans
22
        return ans
23
24
25
    return dfs(0, k, 0)
26
27
def main():
28
    t = int(input())
29
    res = []
30
31
    for _ in range(t):
32
        n, k = map(int, input().split())
33
        a = list(map(int, input().split()))
34
        res.append(solve(n, k, a))
35
36
37
    for x in res:
38
        print(x)
39
40
if __name__ == ""__main__"":
41
42
    main()",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055074
1390055061,unknown,unknown,unknown,"1
import sys
2
data = sys.stdin.read().split()
3
if not data:
4
    exit()
5
t = int(data[0])
6
ptr = 1
7
res = []
8
for _ in range(t):
9
    s = data[ptr]
10
    ptr += 1
11
    n = len(s)
12
    pre = [0]*(n+1)
13
    for i in range(n):
14
        pre[i+1] = pre[i] + (1 if s[i]=='1' else 0)
15
    O = pre[n]
16
    best = 10**9
17
    for L in range(n+1):
18
        if L <= n - O:
19
            cost = O - (pre[L+O] - pre[L])
20
        else:
21
            cost = pre[L] + ((n - L - O) if n - L - O > 0 else 0)
22
        if cost < best:
23
            best = cost
24
    res.append(str(best))
25
sys.stdout.write(""\n"".join(res))
26",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055061
1390055063,unknown,unknown,unknown,"1
2
#include <bits/stdc++.h>
3
using namespace std;
4
5
typedef long long ll;
6
7
void solve() {
8
    int n, k;
9
    cin >> n >> k;
10
    vector<ll> arr(n);
11
    ll total = 0;
12
    13
    14
    for (int i = 0; i < n; i++) {
15
        cin >> arr[i];
16
        total += arr[i];
17
    }
18
    19
    vector<ll> benefits(n);
20
    for (int j = 0; j < n; j++){
21
        benefits[j] = arr[j] - (n - 1 - j);
22
    }
23
    24
    sort(benefits.begin(), benefits.end(), greater<ll>());
25
26
    ll best = total;
27
    ll sumb = 0;
28
    int m = min(k, n);
29
    for (int i = 0; i < m; i++){
30
        if (benefits[i] < 0) {
31
        }
32
        sumb += benefits[i];
33
        int skips = i + 1;
34
        ll candidate = total - sumb - (skips * (skips - 1LL)) / 2LL;
35
        best = min(best, candidate);
36
    }
37
    cout << best << ""\n"";
38
}
39
40
int main() {
41
    int t; cin >> t;
42
    while (t--) {
43
        solve();
44
    }
45
    return 0;
46
}",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055063
1390055064,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        18
        // Precompute prefix counts for 0s and 1s
19
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
20
        for (int i = 1; i <= n; ++i) {
21
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
22
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
23
        }
24
        25
        // Precompute suffix counts for 0s and 1s
26
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
27
        for (int j = 1; j <= n; ++j) {
28
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
29
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
30
        }
31
        32
        int min_cost = INT_MAX;
33
        34
        // Iterate over all possible prefixes (i)
35
        for (int i = 0; i <= n; ++i) {
36
            int j_max = n - i;
37
            int left = 0, right = j_max;
38
            int best_j = 0;
39
            int best_cost = INT_MAX;
40
            41
            // Binary search for the best j
42
            while (left <= right) {
43
                int mid = (left + right) / 2;
44
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
45
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
46
                int current_cost = max(remaining_0, decommissioned_1);
47
                48
                if (current_cost < best_cost) {
49
                    best_cost = current_cost;
50
                    best_j = mid;
51
                } else if (current_cost == best_cost && mid < best_j) {
52
                    best_j = mid;
53
                }
54
                55
                if (decommissioned_1 < remaining_0) {
56
                    left = mid + 1;
57
                } else {
58
                    right = mid - 1;
59
                }
60
            }
61
            62
            // Check neighboring j values
63
            for (int dj : {-1, 0, 1}) {
64
                int j = best_j + dj;
65
                if (j >= 0 && j <= j_max) {
66
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
67
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
68
                    int current_cost = max(remaining_0, decommissioned_1);
69
                    if (current_cost < best_cost) {
70
                        best_cost = current_cost;
71
                    }
72
                }
73
            }
74
            75
            if (best_cost < min_cost) {
76
                min_cost = best_cost;
77
            }
78
        }
79
        80
        results.push_back(min_cost);
81
    }
82
    83
    return results;
84
}
85
86
int main() {
87
    int T;
88
    cin >> T;
89
    vector<string> test_cases(T);
90
    for (int i = 0; i < T; ++i) {
91
        cin >> test_cases[i];
92
    }
93
    94
    vector<int> results = min_decommissioning_cost(test_cases);
95
    96
    for (int result : results) {
97
        cout << result << endl;
98
    }
99
    100
    return 0;
101
}
102",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055064
1390055060,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
}",51,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055060
1390055050,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
3
    if k >= n:
4
5
        return 0
6
7
    8
9
    # Calculate the gain from skipping each firewall
10
11
    gains = []
12
13
    for i in range(n):
14
15
        gain = strengths[i] - (n - i - 1)
16
17
        gains.append((gain, i))
18
19
    20
21
    # Sort by gain in descending order
22
23
    gains.sort(reverse=True)
24
25
    26
27
    # Select the top k firewalls to skip
28
29
    to_skip = set()
30
31
    for i in range(min(k, n)):
32
33
        if gains[i][0] > 0:  # Only skip if it gives positive gain
34
35
            to_skip.add(gains[i][1])
36
37
    38
39
    # Calculate the total effort
40
41
    effort = 0
42
43
    skipped = 0
44
45
    46
47
    for i in range(n):
48
49
        if i in to_skip:
50
51
            skipped += 1
52
53
        else:
54
55
            effort += strengths[i] + skipped
56
57
    58
59
    return effort
60
61
t = int(input())
62
63
for _ in range(t):
64
65
    n, k = map(int, input().split())
66
67
    strengths = list(map(int, input().split()))
68
69
    print(min_effort_to_breach(n, k, strengths))",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055050
1390055053,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
   3
    min_total_effort = float('inf')
4
    5
    6
    for i in range(n + 1):  
7
        if i + k >= n:  
8
           9
            effort = sum(strengths[:i])
10
            min_total_effort = min(min_total_effort, effort)
11
        else:
12
            13
            effort_before = sum(strengths[:i])
14
            15
           16
            remaining = strengths[i+k:]
17
           18
            effort_after = sum(x + k for x in remaining)
19
            20
            total_effort = effort_before + effort_after
21
            min_total_effort = min(min_total_effort, total_effort)
22
    23
    return min_total_effort
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
if __name__ == ""__main__"":
38
    solve()",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055053
1390055059,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
7
using namespace std;
8
9
int main() {
10
    ios::sync_with_stdio(false);
11
    cin.tie(nullptr);
12
    13
    int T;
14
    cin >> T;
15
    while (T--) {
16
        string s;
17
        cin >> s;
18
        int n = s.size();
19
        20
        21
        vector<int> prefix0(n + 1, 0), prefix1(n + 1, 0);
22
        for (int i = 0; i < n; i++) {
23
            prefix0[i + 1] = prefix0[i] + (s[i] == '0');
24
            prefix1[i + 1] = prefix1[i] + (s[i] == '1');
25
        }
26
        int totalOnes = prefix1[n];
27
28
        29
        int low = 0, high = n, ans = n;
30
        while (low <= high) {
31
            int mid = (low + high) / 2;
32
            bool feasible = false;
33
34
            for (int l = 0; l <= n; l++) {
35
                int allowed = prefix0[l] + mid;
36
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
37
                if (r - 1 < l) continue; 
38
                int r_max = r - 1;
39
                int onesKept = prefix1[r_max] - prefix1[l];
40
                if (onesKept >= totalOnes - mid) {
41
                    feasible = true;
42
                    break;
43
                }
44
            }
45
46
            if (feasible) {
47
                ans = mid;
48
                high = mid - 1;
49
            } else {
50
                low = mid + 1;
51
            }
52
        }
53
54
        cout << ans << ""\n"";
55
    }
56
57
    return 0;
58
}
59",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055059
1390055046,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
7
        Scanner sc = new Scanner(System.in);
8
9
        int T = sc.nextInt();
10
11
        while (T-- > 0) {
12
13
            int n = sc.nextInt();
14
15
            int k = sc.nextInt();
16
17
            int[] a = new int[n];
18
19
            long sum_a = 0;
20
21
            for (int i = 0; i < n; i++) {
22
23
                a[i] = sc.nextInt();
24
25
                sum_a += a[i];
26
27
            }
28
29
            List<Long> values = new ArrayList<>();
30
31
            for (int i = 0; i < n; i++) {
32
33
                long val = a[i] - (n - i - 1L);
34
35
                values.add(val);
36
37
            }
38
39
            values.sort((x, y) -> Long.compare(y, x));
40
41
            long[] prefixSum = new long[n + 1];
42
43
            prefixSum[0] = 0;
44
45
            for (int i = 1; i <= n; i++) {
46
47
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
48
49
            }
50
51
            int max_m = Math.min(k, n);
52
53
            long maxTotal = Long.MIN_VALUE;
54
55
            for (int m = 0; m <= max_m; m++) {
56
57
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
58
59
                if (current > maxTotal) {
60
61
                    maxTotal = current;
62
63
                }
64
65
            }
66
67
            long minEffort = sum_a - maxTotal;
68
69
            System.out.println(minEffort);
70
71
        }
72
73
        sc.close();
74
75
    }
76
77
}",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055046
1390055047,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])  # Number of test cases
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
13
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if _name_ == ""_main_"":
45
    main()
46",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055047
1390055049,unknown,unknown,unknown,"1
def min_decommission_cost(s: str) -> int:
2
    n = len(s)
3
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
4
    T = len(ones_pos)
5
    6
    if T == 0:
7
        return 0
8
    9
    zeros_total = s.count('0')
10
    ans = min(zeros_total, T) 
11
    12
    for X in range(1, T + 1):
13
        for i in range(0, T - X + 1):
14
            left = ones_pos[i]
15
            right = ones_pos[i + X - 1]
16
            length = right - left + 1
17
            zeros_in_block = length - X
18
            candidate = max(zeros_in_block, T - X)
19
            ans = min(ans, candidate)
20
    21
    return ans
22
23
if __name__ == '__main__':
24
    T = int(input().strip())
25
    for _ in range(T):
26
        s = input().strip()
27
        print(min_decommission_cost(s))",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055049
1390055040,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner s = new Scanner(System.in);
6
        int t = s.nextInt();  // Number of test cases
7
        8
        while (t-- > 0) {
9
            int n = s.nextInt();
10
            int k = s.nextInt();
11
            int[] arr = new int[n];
12
13
            for (int i = 0; i < n; i++) {
14
                arr[i] = s.nextInt();
15
            }
16
17
            // Using a queue to track the index of negative numbers
18
            Queue<Integer> queue = new LinkedList<>();
19
            int i = 0;
20
21
            // Process first window
22
            for (i = 0; i < k; i++) {
23
                if (arr[i] < 0) {
24
                    queue.add(i);
25
                }
26
            }
27
28
            // Process remaining windows
29
            for (; i < n; i++) {
30
                // Print first negative number of previous window
31
                if (!queue.isEmpty()) {
32
                    System.out.print(arr[queue.peek()] + "" "");
33
                } else {
34
                    System.out.print(""0 "");
35
                }
36
37
                // Remove elements that are out of this window
38
                while (!queue.isEmpty() && queue.peek() <= i - k) {
39
                    queue.poll();
40
                }
41
42
                // Add current element if it's negative
43
                if (arr[i] < 0) {
44
                    queue.add(i);
45
                }
46
            }
47
48
            // Print for last window
49
            if (!queue.isEmpty()) {
50
                System.out.print(arr[queue.peek()] + "" "");
51
            } else {
52
                System.out.print(""0 "");
53
            }
54
55
            System.out.println();
56
        }
57
        s.close();
58
    }
59
}",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055040
1390055042,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} ",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055042
1390055044,unknown,unknown,unknown,"1
def min_effort_to_breach(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
8
    dp[0][0] = 0
9
    10
    for i in range(1, n + 1):
11
        fw = firewalls[i - 1]
12
        13
        for j in range(k + 1):
14
            if j <= i - 1:
15
                dp[i][j] = min(dp[i][j], dp[i-1][j] + fw + j)
16
            17
            if j > 0:
18
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
19
    20
    return min(dp[n])
21
22
import sys
23
input = sys.stdin.readline
24
25
t = int(input())
26
for _ in range(t):
27
    n, k = map(int, input().split())
28
    firewalls = list(map(int, input().split()))
29
    print(min_effort_to_breach(firewalls, k))",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055044
1390055039,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    min_effort = float('inf')
6
7
    for i in range(1 << n):  # Iterate through all possible combinations of skipping firewalls
8
        skipped_count = 0
9
        current_effort = 0
10
        skipped_indices = []
11
12
        for j in range(n):
13
            if (i >> j) & 1:  # Check if the j-th firewall is skipped
14
                skipped_count += 1
15
                skipped_indices.append(j)
16
17
        if skipped_count > k:
18
            continue
19
20
        temp_a = a[:]
21
        for skipped_index in skipped_indices:
22
          for l in range(skipped_index +1, n):
23
            temp_a[l] += 1
24
            25
        for j in range(n):
26
            if (i >> j) & 1: #skip the firewall
27
                continue
28
            else:
29
                current_effort += temp_a[j]
30
                31
32
        min_effort = min(min_effort, current_effort)
33
34
    print(min_effort)
35
36
37
t = int(input())
38
for _ in range(t):
39
    solve()",52,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055039
1390055032,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
3
    n = len(firewalls)
4
5
    6
7
    if k >= n:
8
9
        return 0
10
11
    12
13
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
14
15
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
16
17
    18
19
    # Base case: when we've processed all firewalls
20
21
    for j in range(k + 1):
22
23
        dp[n][j] = 0
24
25
    26
27
    # Fill DP table from right to left
28
29
    for i in range(n - 1, -1, -1):
30
31
        for j in range(k + 1):
32
33
            # Option 1: Skip this firewall (if skips remain)
34
35
            if j < k:
36
37
                dp[i][j] = dp[i + 1][j + 1]
38
39
            40
41
            # Option 2: Don't skip this firewall
42
43
            effort = firewalls[i] + j  # Current firewall + skips used before
44
45
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
46
47
    48
49
    return dp[0][0]
50
51
# Handle automatic input
52
53
t = int(input())
54
55
for _ in range(t):
56
57
    n, k = map(int, input().split())
58
59
    firewalls = list(map(int, input().split()))
60
61
    result = min_effort(firewalls, k)
62
63
    print(result)",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055032
1390055038,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
    8
    # Process first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Process the remaining windows
14
    for i in range(n - k + 1):
15
        # Append earliest fault in the current window
16
        if dq:
17
            result.append(arr[dq[0]])
18
        else:
19
            result.append(0)
20
        21
        # Remove elements that are out of the window
22
        if dq and dq[0] == i:
23
            dq.popleft()
24
        25
        # Add next element (if negative)
26
        if i + k < n and arr[i + k] < 0:
27
            dq.append(i + k)
28
    29
    return result
30
31
# Read input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())
35
    arr = list(map(int, input().split()))
36
    print(*earliest_faults(arr, k))",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055038
1390055034,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
import sys
3
4
def main():
5
    T = int(sys.stdin.readline().strip())
6
    for _ in range(T):
7
        n, k = map(int, sys.stdin.readline().split())
8
        a = list(map(int, sys.stdin.readline().split()))
9
        10
        sum_a = sum(a)
11
        values = [a[i] - (n - i - 1) for i in range(n)]
12
        values.sort(reverse=True)
13
        prefix_sum = [0] * (n + 1)
14
        for i in range(1, n + 1):
15
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
16
        max_m = min(k, n)
17
        max_total = float('-inf')
18
        for m in range(max_m + 1):
19
            current = prefix_sum[m] + (m * (m - 1)) // 2
20
            max_total = max(max_total, current)
21
        min_effort = sum_a - max_total
22
        print(min_effort)
23
24
if __name__ == ""__main__"":
25
    main()",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055034
1390055027,unknown,unknown,unknown,"1
print(21)
2
print(0)",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055027
1390055028,unknown,unknown,unknown,"1
def solve():
2
    T = int(input())
3
    for _ in range(T):
4
        n, k = map(int, input().split())
5
        a = list(map(int, input().split()))
6
        7
        min_effort = float('inf')
8
        9
        for i in range(1 << n):
10
            skipped = []
11
            remaining = []
12
            count = 0
13
            14
            for j in range(n):
15
                if (i >> j) & 1:
16
                    skipped.append(j)
17
                    count += 1
18
                else:
19
                    remaining.append(j)
20
            21
            if count <= k:
22
                effort = 0
23
                skipped_count = 0
24
                25
                for j in range(n):
26
                    if j in skipped:
27
                        skipped_count += 1
28
                    else:
29
                        effort += a[j] + skipped_count
30
                31
                min_effort = min(min_effort, effort)
32
        33
        print(min_effort)
34
        35
solve()
36",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055028
1390055026,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
10
        while (T-- > 0) {
11
            String s = sc.nextLine().trim();
12
            int n = s.length();
13
            int totalOnes = 0;
14
            int maxConsecutiveOnes = 0;
15
            int currentConsecutiveOnes = 0;
16
17
            // Calculate totalOnes and maxConsecutiveOnes
18
            for (char c : s.toCharArray()) {
19
                if (c == '1') {
20
                    currentConsecutiveOnes++;
21
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
22
                    totalOnes++;
23
                } else {
24
                    currentConsecutiveOnes = 0;
25
                }
26
            }
27
28
            // Handle cases where the cost is trivially 0
29
            if (totalOnes == 0 || maxConsecutiveOnes == totalOnes) {
30
                System.out.println(0);
31
                continue;
32
            }
33
34
            int totalZeros = n - totalOnes;
35
            int low = 0;
36
            int high = Math.max(totalOnes, totalZeros);
37
            int answer = high;
38
39
            // Binary search for the minimal possible cost
40
            while (low <= high) {
41
                int mid = (low + high) / 2;
42
                int requiredOnes = Math.max(0, totalOnes - mid);
43
44
                if (requiredOnes == 0) {
45
                    answer = mid;
46
                    high = mid - 1;
47
                    continue;
48
                }
49
50
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
51
                if (maxOnes >= requiredOnes) {
52
                    answer = mid;
53
                    high = mid - 1;
54
                } else {
55
                    low = mid + 1;
56
                }
57
            }
58
59
            System.out.println(answer);
60
        }
61
        sc.close();
62
    }
63
64
    // Helper function to calculate maximum ones in any window with at most k zeros
65
    private static int maxOnesWithAtMostKZeros(String s, int k) {
66
        int left = 0;
67
        int zeros = 0;
68
        int maxOnes = 0;
69
        int n = s.length();
70
71
        for (int right = 0; right < n; right++) {
72
            if (s.charAt(right) == '0') {
73
                zeros++;
74
            }
75
            // Shrink the window if zeros exceed k
76
            while (zeros > k) {
77
                if (s.charAt(left) == '0') {
78
                    zeros--;
79
                }
80
                left++;
81
            }
82
            // Calculate current number of ones in the window
83
            int currentOnes = (right - left + 1) - zeros;
84
            maxOnes = Math.max(maxOnes, currentOnes);
85
        }
86
87
        return maxOnes;
88
    }
89
}
90",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055026
1390055023,unknown,unknown,unknown,"1
def find_faulty_readings(test_cases):
2
    for case in test_cases:
3
        n, k = case[0], case[1]
4
        readings = case[2]
5
        result = []
6
        7
        for i in range(n - k + 1):
8
            batch = readings[i:i+k]
9
            fault = next((x for x in batch if x < 0), 0)  # Find the first negative number or 0 if no faults
10
            result.append(fault)
11
        12
        # Print the result for each test case in the format requested
13
        print("" "".join(map(str, result)))
14
15
def main():
16
    t = int(raw_input())  # Number of test cases
17
    test_cases = []
18
    19
    for _ in range(t):
20
        n, k = map(int, raw_input().split())  # Size of array and batch size
21
        arr = map(int, raw_input().split())   # Array of sensor readings
22
        test_cases.append((n, k, arr))
23
    24
    find_faulty_readings(test_cases)
25
26
if __name__ == ""__main__"":
27
    main()
28",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390055023
1390055021,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
    left = 0
3
    zeros = 0
4
    max_ones = 0
5
    n = len(s)
6
7
    for right in range(n):
8
        if s[right] == '0':
9
            zeros += 1
10
11
        while zeros > k:
12
            if s[left] == '0':
13
                zeros -= 1
14
            left += 1
15
16
        current_ones = (right - left + 1) - zeros
17
        max_ones = max(max_ones, current_ones)
18
19
    return max_ones
20
21
22
def minimize_cost(t, test_cases):
23
    results = []
24
25
    for s in test_cases:
26
        n = len(s)
27
        total_ones = s.count('1')
28
29
        if total_ones == 0 or total_ones == n:
30
            results.append(0)
31
            continue
32
33
        total_zeros = n - total_ones
34
        low, high = 0, max(total_ones, total_zeros)
35
        answer = high
36
37
        while low <= high:
38
            mid = (low + high) // 2
39
            required_ones = max(0, total_ones - mid)
40
41
            if required_ones == 0:
42
                answer = mid
43
                high = mid - 1
44
                continue
45
46
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
47
48
            if max_ones >= required_ones:
49
                answer = mid
50
                high = mid - 1
51
            else:
52
                low = mid + 1
53
54
        results.append(answer)
55
56
    return results
57
58
59
if __name__ == ""__main__"":
60
    t = int(input())
61
    test_cases = [input().strip() for _ in range(t)]
62
63
    results = minimize_cost(t, test_cases)
64
65
    for res in results:
66
        print(res)",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055021
1390055025,unknown,unknown,unknown,"1
def min_cost_to_decommission(rack):
2
    length = len(rack)
3
    min_cost = float('inf')
4
    5
    for prefix in range(length + 1):
6
        for suffix in range(length + 1 - prefix):
7
            remaining = rack[prefix:length - suffix]
8
            9
            if not remaining:
10
                continue
11
            12
            idle_count = remaining.count('0')
13
            active_removed = rack[:prefix].count('1') + rack[length - suffix:].count('1')
14
            15
            cost = max(idle_count, active_removed)
16
            min_cost = min(min_cost, cost)
17
    18
    return min_cost
19
20
def process_cases():
21
    test_cases = int(input().strip())
22
    results = []
23
    24
    for _ in range(test_cases):
25
        rack = input().strip()
26
        results.append(str(min_cost_to_decommission(rack)))
27
    28
    print(""\n"".join(results))
29
30
process_cases()",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055025
1390055019,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T;
7
    8
    while (T-- > 0) {
9
        int n, k;
10
        cin >> n >> k;
11
        12
        vector<int> a(n);
13
        long long sum_a = 0;
14
        15
        for (int i = 0; i < n; i++) {
16
            cin >> a[i];
17
            sum_a += a[i];
18
        }
19
        20
        vector<long long> values;
21
        for (int i = 0; i < n; i++) {
22
            long long val = a[i] - (n - i - 1LL);
23
            values.push_back(val);
24
        }
25
        26
        sort(values.begin(), values.end(), greater<long long>());
27
        28
        vector<long long> prefixSum(n + 1, 0);
29
        for (int i = 1; i <= n; i++) {
30
            prefixSum[i] = prefixSum[i - 1] + values[i - 1];
31
        }
32
        33
        int max_m = min(k, n);
34
        long long maxTotal = LLONG_MIN;
35
        36
        for (int m = 0; m <= max_m; m++) {
37
            long long current = prefixSum[m] + (m *1LL* (m - 1)) / 2;
38
            if (current > maxTotal) {
39
                maxTotal = current;
40
            }
41
        }
42
        43
        long long minEffort = sum_a - maxTotal;
44
        cout << minEffort << endl;
45
    }
46
    47
    return 0;
48
}",53,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055019
1390055012,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055012
1390055013,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055013
1390055017,unknown,unknown,unknown,"1
import sys
2
input = sys.stdin.read
3
4
def minimum_effort(arr, k):
5
    n = len(arr)
6
    7
    if k == n:
8
        return 0
9
    10
    total_effort = sum(arr)
11
    min_effort = total_effort
12
    13
    # Sliding window to calculate the sum of any skipped window of size k
14
    window_sum = sum(arr[:k])
15
    for i in range(n - k + 1):
16
        skipped_effort = total_effort - window_sum + k
17
        min_effort = min(min_effort, skipped_effort)
18
        19
        # Slide the window to the right
20
        if i + k < n:
21
            window_sum = window_sum - arr[i] + arr[i + k]
22
    23
    return min_effort
24
25
# Efficient Input Handling with ASCII Conversion
26
data = input().encode('ascii', 'ignore').decode('ascii').strip().split(""\n"")
27
t = int(data[0])
28
index = 1
29
30
results = []
31
for _ in range(t):
32
    n, k = map(int, data[index].split())
33
    arr = list(map(int, data[index + 1].split()))
34
    results.append(str(minimum_effort(arr, k)))
35
    index += 2
36
37
# Fast Output
38
sys.stdout.write(""\n"".join(results) + ""\n"")
39",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055017
1390055009,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    arr = list(map(int, input().split()))
5
    if k == n:
6
        print(0)
7
        continue
8
9
    effort_sum = sum(arr)
10
    11
    for i in range(1, n+1):
12
        temp = arr[i-1]
13
        arr[i-1] = 0   
14
        effort_sum = min(effort_sum, sum(arr[:]) + (1 * (n-i)))
15
        arr[i-1] = temp 
16
       17
    print(effort_sum)",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055009
1390055010,unknown,unknown,unknown,"1
def minimize_cost(s):
2
    total_ones = s.count('1')
3
    total_zeros = len(s) - total_ones
4
    low = 0
5
    high = max(total_ones, total_zeros)
6
    answer = high  # Initialize with the maximum possible value
7
8
    while low <= high:
9
        mid = (low + high) // 2
10
        K = total_ones - mid
11
12
        # Check if current mid is feasible
13
        if K <= 0:
14
            feasible = (total_zeros <= mid)
15
        else:
16
            current_0 = 0
17
            current_1 = 0
18
            left = 0
19
            feasible = False
20
            for right in range(len(s)):
21
                if s[right] == '0':
22
                    current_0 += 1
23
                else:
24
                    current_1 += 1
25
                # Move left pointer to ensure current_0 <= mid
26
                while current_0 > mid:
27
                    if s[left] == '0':
28
                        current_0 -= 1
29
                    else:
30
                        current_1 -= 1
31
                    left += 1
32
                # Check if current window meets the 1's requirement
33
                if current_1 >= K:
34
                    feasible = True
35
                    break
36
        if feasible:
37
            answer = mid
38
            high = mid - 1
39
        else:
40
            low = mid + 1
41
    return answer
42
43
T = int(input())
44
for _ in range(T):
45
    s = input().strip()
46
    print(minimize_cost(s))",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055010
1390055011,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for s in test_cases:
5
        # Remove leading and trailing zeros, they don't contribute to cost
6
        trimmed = s.strip('0')
7
8
        if not trimmed:  # If string becomes empty after trimming
9
            results.append(0)
10
            continue
11
12
        total_ones = trimmed.count('1')
13
        min_cost = float('inf')
14
15
        # Try removing from both ends
16
        left_zeros = 0
17
        left_ones_removed = 0
18
        n = len(trimmed)
19
20
        for i in range(n + 1):
21
            # Calculate remaining zeros
22
            right_zeros = trimmed[i:].count('0')
23
            cost = max(right_zeros, left_ones_removed)
24
            min_cost = min(min_cost, cost)
25
26
            # If not at the end, update counts
27
            if i < n:
28
                if trimmed[i] == '1':
29
                    left_ones_removed += 1
30
                else:
31
                    left_zeros += 1
32
33
        results.append(min_cost)
34
35
    return results
36
37
38
# Reading input
39
t = int(input().strip())
40
test_cases = [input().strip() for _ in range(t)]
41
result = min_decommissioning_cost(test_cases)
42
43
# Output results
44
for res in result:
45
    print(res)
46",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055011
1390055004,unknown,unknown,unknown,"1
import sys
2
3
from itertools import accumulate
4
5
def min_effort(arr, k):
6
    7
8
    n = len(arr)
9
10
    T = sum(arr)
11
    12
13
    A = [arr[i] + (i+1) for i in range(n)]
14
    15
    16
17
    A.sort(reverse=True)
18
19
    P = [0] + list(accumulate(A))
20
21
    m_max = min(k, n)
22
23
    best = float('inf')
24
    25
    26
27
    for m in range(m_max + 1):
28
        29
30
        cost = T + m * n - (m * m - m) // 2 - P[m]
31
        32
        33
34
        if cost < best:
35
36
            best = cost
37
            38
            39
40
    return best
41
42
43
44
def solve():
45
46
    data = sys.stdin.read().strip().split()
47
48
    if not data:
49
50
        return
51
    52
    53
54
    t = int(data[0])
55
56
    index = 1
57
    58
59
    res = []
60
    61
    62
63
    for _ in range(t):
64
65
        n = int(data[index]); index += 1
66
67
        k = int(data[index]); index += 1
68
69
        arr = list(map(int, data[index:index+n])); index += n
70
71
        res.append(str(min_effort(arr, k)))
72
        73
74
    sys.stdout.write(""\n"".join(res))
75
    76
    77
78
if __name__ == ""__main__"":
79
    80
81
    solve()",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055004
1390055007,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    min_cost = float('inf')
5
    6
    for i in range(n + 1):  
7
        for j in range(n + 1 - i):  
8
            if i + j > n:
9
                continue
10
                11
            remaining = server_rack[i:n-j]
12
            13
            if not remaining:
14
                continue  
15
                16
            idle_remaining = remaining.count('0')
17
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
18
            19
            cost = max(idle_remaining, active_removed)
20
            21
            min_cost = min(min_cost, cost)
22
    23
    return min_cost
24
25
t = int(input())
26
results = []
27
28
for _ in range(t):
29
    server_rack = input().strip()
30
    results.append(min_decommissioning_cost(server_rack))
31
32
for result in results:
33
    print(result)",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055007
1390055008,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_zeros = servers.count('0')
7
        total_ones = n - total_zeros
8
        9
        prefix_zeros = [0] * (n + 1)
10
        prefix_ones = [0] * (n + 1)
11
        for i in range(1, n + 1):
12
            prefix_zeros[i] = prefix_zeros[i - 1] + (servers[i - 1] == '0')
13
            prefix_ones[i] = prefix_ones[i - 1] + (servers[i - 1] == '1')
14
        15
        suffix_zeros = [0] * (n + 1)
16
        suffix_ones = [0] * (n + 1)
17
        for j in range(1, n + 1):
18
            suffix_zeros[j] = suffix_zeros[j - 1] + (servers[n - j] == '0')
19
            suffix_ones[j] = suffix_ones[j - 1] + (servers[n - j] == '1')
20
        21
        min_cost = float('inf')
22
        23
        for i in range(n + 1):
24
            j_max = n - i
25
            left, right = 0, j_max
26
            best_j = 0
27
            best_cost = float('inf')
28
            29
            while left <= right:
30
                mid = (left + right) // 2
31
                remaining_zeros = total_zeros - (prefix_zeros[i] + suffix_zeros[mid])
32
                decommissioned_ones = prefix_ones[i] + suffix_ones[mid]
33
                current_cost = max(remaining_zeros, decommissioned_ones)
34
                35
                if current_cost < best_cost:
36
                    best_cost = current_cost
37
                    best_j = mid
38
                elif current_cost == best_cost and mid < best_j:
39
                    best_j = mid
40
                41
                if decommissioned_ones < remaining_zeros:
42
                    left = mid + 1
43
                else:
44
                    right = mid - 1
45
            46
            for dj in [-1, 0, 1]:
47
                j = best_j + dj
48
                if 0 <= j <= j_max:
49
                    remaining_zeros = total_zeros - (prefix_zeros[i] + suffix_zeros[j])
50
                    decommissioned_ones = prefix_ones[i] + suffix_ones[j]
51
                    current_cost = max(remaining_zeros, decommissioned_ones)
52
                    if current_cost < best_cost:
53
                        best_cost = current_cost
54
            55
            if best_cost < min_cost:
56
                min_cost = best_cost
57
        58
        results.append(min_cost)
59
    60
    return results
61
62
if __name__ == ""__main__"":
63
    test_cases_count = int(input())
64
    test_cases = [input().strip() for _ in range(test_cases_count)]
65
    66
    results = min_decommissioning_cost(test_cases)
67
    68
    for result in results:
69
        print(result)
70",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055008
1390055003,unknown,unknown,unknown,"1
def minimize_effort(n, k, a):
2
    a.sort(reverse=True)  # Sort firewalls in descending order (strongest first)
3
4
    # Total effort without skipping any firewall
5
    total_effort = sum(a)
6
7
    # If we can skip all firewalls, effort becomes 0
8
    if k == n:
9
        return 0
10
11
    # Pick the strongest `k` firewalls to skip
12
    skip_total = sum(a[:k])  # Sum of the `k` highest firewalls we skip
13
14
    # Calculate penalty for remaining firewalls
15
    penalty = sum(range(k))  # Sum of first `k` natural numbers (0, 1, 2, ..., k-1)
16
17
    # Minimum effort calculation
18
    return (total_effort - skip_total + penalty)
19
20
# Driver Code
21
T = int(input().strip())  # Number of test cases
22
for _ in range(T):
23
    n, k = map(int, input().split())  # Read n (firewalls) and k (skips)
24
    a = list(map(int, input().split()))  # Read firewall strengths
25
    26
    result = minimize_effort(n, k, a)
27
    print(result)
28",54,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390055003
1390054999,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} ",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054999
1390055000,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    6
    7
    static boolean feasible(int X, int[] onesIndices, int total1) {
8
       9
        if (X >= total1) return true;
10
        int j = 0;
11
        for (int i = 0; i < total1; i++) {
12
            13
            if (j < i) j = i;
14
            15
            while (j < total1 && (onesIndices[j] - onesIndices[i] - (j - i)) <= X) {
16
                j++;
17
            }
18
            int m = j - i; 
19
            if (m >= total1 - X) return true;
20
        }
21
        return false;
22
    }
23
    24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int T = sc.nextInt();
27
        28
        while(T-- > 0) {
29
            String s = sc.next();
30
            int n = s.length();
31
            32
           33
            ArrayList<Integer> onesList = new ArrayList<>();
34
            for (int i = 0; i < n; i++) {
35
                if (s.charAt(i) == '1') {
36
                    onesList.add(i);
37
                }
38
            }
39
            int total1 = onesList.size();
40
            41
           42
            if (total1 == 0) {
43
                System.out.println(0);
44
                continue;
45
            }
46
            47
           48
            int[] onesIndices = new int[total1];
49
            for (int i = 0; i < total1; i++) {
50
                onesIndices[i] = onesList.get(i);
51
            }
52
            53
           54
            int low = 0, high = total1, ans = high;
55
            while (low <= high) {
56
                int mid = low + (high - low) / 2;
57
                if (feasible(mid, onesIndices, total1)) {
58
                    ans = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            System.out.println(ans);
65
        }
66
        sc.close();
67
    }
68
}
69",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055000
1390055002,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }
19
20
      21
        auto check = [&](int k) {
22
            int l = 0;
23
         24
            for (int r = 0; r < n; r++) {
25
              26
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
27
                    l++;
28
                }
29
                // wtf ,  check number of 1's decommissioned
30
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
31
                    return true;
32
                }
33
            }
34
      35
            if (prefix_1[n] <= k) {
36
                return true;
37
            }
38
            return false;
39
        };
40
41
        // Binary search for minimum cost
42
        int low = 0, high = n;
43
        while (low < high) {
44
            int mid = (low + high) / 2;
45
            if (check(mid)) {
46
                high = mid;
47
            } else {
48
                low = mid + 1;
49
            }
50
        }
51
        cout << low << endl;
52
    }
53
    return 0;
54
}",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390055002
1390054990,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054990
1390054992,unknown,unknown,unknown,"1
def min_cost_server_pruning(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    5
    for i in range(n + 1):
6
        for j in range(n + 1 - i):
7
            remaining = server_rack[i:n-j]
8
            idle_remaining = remaining.count('0')
9
            10
            removed_start = server_rack[:i].count('1')
11
            removed_end = server_rack[n-j:].count('1')
12
            active_decommissioned = removed_start + removed_end
13
            14
            cost = max(idle_remaining, active_decommissioned)
15
            min_cost = min(min_cost, cost)
16
    17
    return min_cost
18
19
t = int(input())
20
for _ in range(t):
21
    server_rack = input().strip()
22
    print(min_cost_server_pruning(server_rack))",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054992
1390054997,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        total_ones = s.count('1')
6
        total_zeros = s.count('0')
7
        min_cost = float('inf')
8
        for i in range(n + 1):  
9
            for j in range(i, n + 1):  
10
                remaining_zeros = s[i:j].count('0')
11
                remaining_ones = s[i:j].count('1')
12
                removed_ones = total_ones - remaining_ones
13
                cost = max(remaining_zeros, removed_ones)
14
                min_cost = min(min_cost, cost)
15
        results.append(min_cost)
16
    return results
17
T = int(input())  
18
test_cases = [input().strip() for _ in range(T)]
19
results = min_decommissioning_cost(test_cases)
20
for result in results:
21
    print(result)
22",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054997
1390054987,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <algorithm>
4
#include <vector>
5
6
using namespace std;
7
8
int solve() {
9
    string s;
10
    cin >> s;
11
    int n = s.length();
12
    int min_cost = n;
13
14
    int total_ones = 0;
15
    for (char c : s) {
16
        if (c == '1') {
17
            total_ones++;
18
        }
19
    }
20
21
    for (int i = 0; i <= n; ++i) {
22
        int removed_ones_prefix = 0;
23
        for (int k = 0; k < i; ++k) {
24
            if (s[k] == '1') {
25
                removed_ones_prefix++;
26
            }
27
        }
28
29
        for (int j = i; j <= n; ++j) {
30
            int remaining_zeros = 0;
31
            for (int k = i; k < j; ++k) {
32
                if (s[k] == '0') {
33
                    remaining_zeros++;
34
                }
35
            }
36
37
            int removed_ones_suffix = 0;
38
            for (int k = j; k < n; ++k) {
39
                if (s[k] == '1') {
40
                    removed_ones_suffix++;
41
                }
42
            }
43
44
            int removed_ones = removed_ones_prefix + removed_ones_suffix;
45
            min_cost = min(min_cost, max(remaining_zeros, removed_ones));
46
        }
47
    }
48
    return min_cost;
49
}
50
51
int main() {
52
    int t;
53
    cin >> t;
54
    while (t--) {
55
        cout << solve() << endl;
56
    }
57
    return 0;
58
}",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054987
1390054989,unknown,unknown,unknown,"1
2
def min_cost_server_pruning(server_rack):
3
    n = len(server_rack)
4
    min_cost = float('inf')
5
    6
    for i in range(n + 1):
7
        for j in range(n + 1 - i):
8
            remaining = server_rack[i:n-j]
9
            idle_remaining = remaining.count('0')
10
            11
            removed_start = server_rack[:i].count('1')
12
            removed_end = server_rack[n-j:].count('1')
13
            active_decommissioned = removed_start + removed_end
14
            15
            cost = max(idle_remaining, active_decommissioned)
16
            min_cost = min(min_cost, cost)
17
    18
    return min_cost
19
20
t = int(input())
21
for _ in range(t):
22
    server_rack = input().strip()
23
    print(min_cost_server_pruning(server_rack))",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054989
1390054986,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <vector>
4
#include <algorithm>
5
#include <climits>
6
7
using namespace std;
8
9
int findMinimumCost(const string& servers) {
10
    int n = servers.size();
11
    12
    // Count total idle and active servers
13
    int totalIdle = 0;
14
    for (char c : servers) {
15
        if (c == '0') totalIdle++;
16
    }
17
    int totalActive = n - totalIdle;
18
    19
    // Precompute prefix counts
20
    vector<int> prefixActive(n + 1, 0);
21
    vector<int> prefixIdle(n + 1, 0);
22
    23
    for (int i = 0; i < n; i++) {
24
        prefixActive[i + 1] = prefixActive[i] + (servers[i] == '1');
25
        prefixIdle[i + 1] = prefixIdle[i] + (servers[i] == '0');
26
    }
27
    28
    int minCost = INT_MAX;
29
    30
    // Optimize by using a linear approach instead of nested loops
31
    // For each possible starting point (front removal ending point)
32
    for (int start = 0; start <= n; start++) {
33
        // Calculate the remaining idle servers if we remove from 0 to start-1
34
        int frontActiveRemoved = prefixActive[start];
35
        36
        // Binary search or linear scan to find optimal end removal
37
        // For this problem size, linear scan should be efficient enough
38
        for (int end = start; end <= n; end++) {
39
            // Skip if we're not removing anything
40
            if (start == 0 && end == n) continue;
41
            42
            int remainingIdle = prefixIdle[end] - prefixIdle[start];
43
            int endActiveRemoved = totalActive - frontActiveRemoved - (prefixActive[end] - prefixActive[start]);
44
            int totalActiveRemoved = frontActiveRemoved + endActiveRemoved;
45
            46
            int cost = max(remainingIdle, totalActiveRemoved);
47
            minCost = min(minCost, cost);
48
        }
49
    }
50
    51
    return minCost;
52
}
53
54
int main() {
55
    ios_base::sync_with_stdio(false);
56
    cin.tie(nullptr);
57
    58
    int t;
59
    cin >> t;
60
    61
    while (t--) {
62
        string servers;
63
        cin >> servers;
64
        cout << findMinimumCost(servers) << ""\n"";
65
    }
66
    67
    return 0;
68
}",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054986
1390054983,unknown,unknown,unknown,"1
def min_cost_server_pruning(server_rack):
2
    n = len(server_rack)
3
    4
    # Precompute prefix and suffix counts of '1'
5
    prefix_ones = [0] * (n + 1)
6
    suffix_ones = [0] * (n + 1)
7
8
    for i in range(n):
9
        prefix_ones[i + 1] = prefix_ones[i] + (server_rack[i] == '1')
10
    11
    for i in range(n - 1, -1, -1):
12
        suffix_ones[i] = suffix_ones[i + 1] + (server_rack[i] == '1')
13
14
    total_ones = prefix_ones[n]  # Total active servers ('1' count)
15
    min_cost = float('inf')
16
17
    for i in range(n + 1):
18
        for j in range(i, n + 1):
19
            idle_remaining = server_rack[i:j].count('0')
20
            active_decommissioned = total_ones - (prefix_ones[j] - prefix_ones[i])
21
            cost = max(idle_remaining, active_decommissioned)
22
            min_cost = min(min_cost, cost)
23
24
    return min_cost
25
26
# Input handling
27
t = int(input().strip())
28
for _ in range(t):
29
    server_rack = input().strip()
30
    print(min_cost_server_pruning(server_rack))
31",55,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054983
1390054977,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for s in test_cases:
5
        # Remove leading and trailing zeros, they don't contribute to cost
6
        trimmed = s.strip('0')
7
8
        if not trimmed:  # If string becomes empty after trimming
9
            results.append(0)
10
            continue
11
12
        total_ones = trimmed.count('1')
13
        min_cost = float('inf')
14
15
        # Try removing from both ends
16
        left_zeros = 0
17
        left_ones_removed = 0
18
        n = len(trimmed)
19
20
        for i in range(n + 1):
21
            # Calculate remaining zeros
22
            right_zeros = trimmed[i:].count('0')
23
            cost = max(right_zeros, left_ones_removed)
24
            min_cost = min(min_cost, cost)
25
26
            # If not at the end, update counts
27
            if i < n:
28
                if trimmed[i] == '1':
29
                    left_ones_removed += 1
30
                else:
31
                    left_zeros += 1
32
33
        results.append(min_cost)
34
35
    return results
36
37
38
# Reading input
39
t = int(input().strip())
40
test_cases = [input().strip() for _ in range(t)]
41
result = min_decommissioning_cost(test_cases)
42
43
# Output results
44
for res in result:
45
    print(res)
46",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054977
1390054979,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
         Scanner sc = new Scanner(System.in);
11
        int t = sc.nextInt(); // Number of test cases
12
13
        while (t-- > 0) {
14
            int n = sc.nextInt(); // Size of the array
15
            int k = sc.nextInt(); // Batch size
16
            int[] arr = new int[n];
17
18
            for (int i = 0; i < n; i++) {
19
                arr[i] = sc.nextInt();
20
            }
21
22
            List<Integer> result = findEarliestFaults(arr, n, k);
23
            for (int num : result) {
24
                System.out.print(num + "" "");
25
            }
26
            System.out.println();
27
        }
28
        sc.close();
29
    }
30
    31
    public static List<Integer> findEarliestFaults(int[] arr, int n, int k) {
32
        List<Integer> result = new ArrayList<>();
33
34
        for (int i = 0; i <= n - k; i++) {
35
            boolean found = false;
36
            for (int j = i; j < i + k; j++) {
37
                if (arr[j] < 0) {
38
                    result.add(arr[j]);  // First negative number in batch
39
                    found = true;
40
                    break;
41
                }
42
            }
43
            if (!found) {
44
                result.add(0); // If no negative number found
45
            }
46
        }
47
48
        return result;
49
    }
50
}",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054979
1390054982,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054982
1390054972,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
public class Solution {
4
    public static void main(String[] args) {
5
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
        scanner.nextLine(); // Consume newline
9
        10
        for (int i = 0; i < t; i++) {
11
            String servers = scanner.nextLine();
12
            int minCost = minimizeServerCost(servers);
13
            System.out.println(minCost);
14
        }
15
        scanner.close();
16
    }
17
    18
    public static int minimizeServerCost(String servers) {
19
        int n = servers.length();
20
        int minCost = Integer.MAX_VALUE;
21
        22
        for (int prefixLength = 0; prefixLength <= n; prefixLength++) {
23
            for (int suffixLength = 0; suffixLength <= n - prefixLength; suffixLength++) {
24
                if (prefixLength + suffixLength == n) continue;
25
                String remaining = servers.substring(prefixLength, n - suffixLength);
26
27
                int activeServersRemoved = 0;
28
                for (int i = 0; i < prefixLength; i++) {
29
                    if (servers.charAt(i) == '1') activeServersRemoved++;
30
                }
31
                for (int i = n - suffixLength; i < n; i++) {
32
                    if (servers.charAt(i) == '1') activeServersRemoved++;
33
                }
34
35
                int idleServersRemaining = 0;
36
                for (int i = 0; i < remaining.length(); i++) {
37
                    if (remaining.charAt(i) == '0') idleServersRemaining++;
38
                }
39
                int cost = Math.max(idleServersRemaining, activeServersRemoved);
40
                minCost = Math.min(minCost, cost);
41
            }
42
        }
43
        44
        return minCost;
45
    }
46
}",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054972
1390054974,unknown,unknown,unknown,"1
def min_effort(strengths, n, k):
2
    if k >= n:
3
        return 0
4
        5
    dp = {}
6
    7
    def solve(idx, skips_left, extra):
8
        if idx == n:
9
            return 0
10
            11
        if (idx, skips_left, extra) in dp:
12
            return dp[(idx, skips_left, extra)]
13
            14
        op1 = float('inf')
15
        if skips_left > 0:
16
            op1 = solve(idx + 1, skips_left - 1, extra + 1)
17
            18
        op2 = strengths[idx] + extra + solve(idx + 1, skips_left, extra)
19
        20
        dp[(idx, skips_left, extra)] = min(op1, op2)
21
        return dp[(idx, skips_left, extra)]
22
    23
    return solve(0, k, 0)
24
25
def main():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort(strengths, n, k))
33
    34
    for result in results:
35
        print(result)
36
37
if __name__ == ""__main__"":
38
    main()",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054974
1390054976,unknown,unknown,unknown,"1
def min_cost_server_optimization(server_rack):
2
    n = len(server_rack)
3
    4
    prefix_active = [0] * (n + 1)
5
    prefix_idle = [0] * (n + 1)
6
    7
    for i in range(n):
8
        prefix_active[i + 1] = prefix_active[i] + (server_rack[i] == '1')
9
        prefix_idle[i + 1] = prefix_idle[i] + (server_rack[i] == '0')
10
    11
    total_active = prefix_active[n]
12
    total_idle = prefix_idle[n]
13
    min_cost = float('inf')
14
    15
    16
    for i in range(n + 1): 
17
        active_removed_prefix = prefix_active[i]
18
        19
       20
        for j in range(n + 1 - i): 
21
            if i + j == n:  
22
                continue
23
                24
            active_removed_suffix = total_active - prefix_active[n - j]
25
            active_removed = active_removed_prefix + active_removed_suffix
26
            27
            idle_remaining = total_idle - (prefix_idle[i] + (total_idle - prefix_idle[n - j]))
28
            29
            cost = max(idle_remaining, active_removed)
30
            min_cost = min(min_cost, cost)
31
    32
    return min_cost
33
34
35
import sys
36
input = sys.stdin.readline
37
38
def main():
39
    t = int(input().strip())
40
    41
    for _ in range(t):
42
        server_rack = input().strip()
43
        result = min_cost_server_optimization(server_rack)
44
        print(result)
45
46
if __name__ == ""__main__"":
47
    main()",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054976
1390054965,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }
19
20
      21
        auto check = [&](int k) {
22
            int l = 0;
23
         24
            for (int r = 0; r < n; r++) {
25
              26
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
27
                    l++;
28
                }
29
                // wtf ,  check number of 1's decommissioned
30
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
31
                    return true;
32
                }
33
            }
34
      35
            if (prefix_1[n] <= k) {
36
                return true;
37
            }
38
            return false;
39
        };
40
41
        // Binary search for minimum cost
42
        int low = 0, high = n;
43
        while (low < high) {
44
            int mid = (low + high) / 2;
45
            if (check(mid)) {
46
                high = mid;
47
            } else {
48
                low = mid + 1;
49
            }
50
        }
51
        cout << low << endl;
52
    }
53
    return 0;
54
}",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054965
1390054968,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = []
9
        efforts = []
10
        11
        for j in range(n):
12
            if (i >> j) & 1:
13
                skipped.append(j)
14
            else:
15
                efforts.append(j)
16
        17
        if len(skipped) <= k:
18
            effort = 0
19
            skipped_count = 0
20
            for j in range(n):
21
                if j in skipped:
22
                    skipped_count += 1
23
                else:
24
                    effort += a[j] + skipped_count
25
            min_effort = min(min_effort, effort)
26
    27
    print(min_effort)
28
    29
t = int(input())
30
for _ in range(t):
31
    solve()",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054968
1390054971,unknown,unknown,unknown,"1
def min_cost(server_str):
2
    n = len(server_str)
3
    prefix_1 = [0] * (n + 1)  
4
    prefix_0 = [0] * (n + 1)  
5
6
    for i in range(n):
7
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
8
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
9
10
    total_1 = prefix_1[n]
11
    total_0 = prefix_0[n]
12
13
    min_cost = float('inf')
14
15
    16
    for l in range(n + 1):
17
       18
        for r in range(n - l + 1):
19
            left = l
20
            right = n - r
21
            remaining_0 = prefix_0[right] - prefix_0[left]
22
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
23
            cost = max(remaining_0, removed_1)
24
            min_cost = min(min_cost, cost)
25
26
    return min_cost
27
28
29
T = int(input())
30
for _ in range(T):
31
    server_str = input().strip()
32
    print(min_cost(server_str))",56,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054971
1390054961,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void earliest_faulty_readings(int arr[], int n, int k) {
5
    int i;
6
    int front = 0, rear = 0;  // Deque implemented using an array
7
    int deque[n]; // Stores indices of negative numbers
8
9
    // Process the first window
10
    for (i = 0; i < k; i++) {
11
        if (arr[i] < 0)
12
            deque[rear++] = i;
13
    }
14
15
    // Process rest of the windows
16
    for (i = k; i <= n; i++) {
17
        // Print the first negative number in the current window
18
        if (front < rear)
19
            printf(""%d "", arr[deque[front]]);
20
        else
21
            printf(""0 "");
22
23
        // Remove elements not in this window
24
        while (front < rear && deque[front] < i - k + 1)
25
            front++;
26
27
        // Add the new element if negative
28
        if (i < n && arr[i] < 0)
29
            deque[rear++] = i;
30
    }
31
32
    printf(""\n"");
33
}
34
35
int main() {
36
    int t;
37
    scanf(""%d"", &t);
38
39
    while (t--) {
40
        int n, k;
41
        scanf(""%d %d"", &n, &k);
42
        int arr[n];
43
44
        for (int i = 0; i < n; i++)
45
            scanf(""%d"", &arr[i]);
46
47
        earliest_faulty_readings(arr, n, k);
48
    }
49
50
    return 0;
51
}",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054961
1390054962,unknown,unknown,unknown,"1
def main():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().split(""\n"")
5
    6
    t = int(data[0])
7
    index = 1
8
9
    results = []
10
    for _ in range(t):
11
        n, k = map(int, data[index].split())
12
        strengths = list(map(int, data[index + 1].split()))
13
        index += 2
14
        15
        if k >= n:
16
            results.append(""0"")
17
            continue
18
        19
        # Calculate the impact of each firewall: strength + index
20
        impact = [(strengths[i] + i, i) for i in range(n)]
21
        22
        # Sort firewalls by impact (higher impact should be skipped)
23
        impact.sort(reverse=True)
24
        25
        # Select the top k firewalls to skip
26
        to_skip = set(idx for _, idx in impact[:k])
27
        28
        # Compute the minimal effort
29
        effort = 0
30
        skipped = 0
31
        32
        for i in range(n):
33
            if i in to_skip:
34
                skipped += 1
35
            else:
36
                effort += strengths[i] + skipped
37
        38
        results.append(str(effort))
39
    40
    # Print all results at once (faster output handling)
41
    sys.stdout.write(""\n"".join(results) + ""\n"")
42
43
if __name__ == ""__main__"":
44
    main()
45",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054962
1390054963,unknown,unknown,unknown,"1
def min_decommission_cost(s: str) -> int:
2
    n = len(s)
3
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
4
    T = len(ones_pos)
5
    6
    if T == 0:
7
        return 0
8
    9
    zeros_total = s.count('0')
10
    ans = min(zeros_total, T) 
11
    12
    for X in range(1, T + 1):
13
        for i in range(0, T - X + 1):
14
            left = ones_pos[i]
15
            right = ones_pos[i + X - 1]
16
            length = right - left + 1
17
            zeros_in_block = length - X
18
            candidate = max(zeros_in_block, T - X)
19
            ans = min(ans, candidate)
20
    21
    return ans
22
23
if __name__ == '__main__':
24
    T = int(input().strip())
25
    for _ in range(T):
26
        s = input().strip()
27
        print(min_decommission_cost(s))",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054963
1390054954,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
    left = 0
3
    zeros = 0
4
    max_ones = 0
5
    n = len(s)
6
7
    for right in range(n):
8
        if s[right] == '0':
9
            zeros += 1
10
11
        while zeros > k:
12
            if s[left] == '0':
13
                zeros -= 1
14
            left += 1
15
16
        current_ones = (right - left + 1) - zeros
17
        max_ones = max(max_ones, current_ones)
18
19
    return max_ones
20
21
22
def minimize_cost(t, test_cases):
23
    results = []
24
25
    for s in test_cases:
26
        n = len(s)
27
        total_ones = s.count('1')
28
29
        if total_ones == 0 or total_ones == n:
30
            results.append(0)
31
            continue
32
33
        total_zeros = n - total_ones
34
        low, high = 0, max(total_ones, total_zeros)
35
        answer = high
36
37
        while low <= high:
38
            mid = (low + high) // 2
39
            required_ones = max(0, total_ones - mid)
40
41
            if required_ones == 0:
42
                answer = mid
43
                high = mid - 1
44
                continue
45
46
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
47
48
            if max_ones >= required_ones:
49
                answer = mid
50
                high = mid - 1
51
            else:
52
                low = mid + 1
53
54
        results.append(answer)
55
56
    return results
57
58
59
if __name__ == ""__main__"":
60
    t = int(input())
61
    test_cases = [input().strip() for _ in range(t)]
62
63
    results = minimize_cost(t, test_cases)
64
65
    for res in results:
66
        print(res)",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054954
1390054957,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, arr = case
5
        result = []
6
        for i in range(n - k + 1):
7
            batch = arr[i:i+k]
8
            earliest_fault = 0
9
            for num in batch:
10
                if num < 0:
11
                    earliest_fault = num
12
                    break
13
            result.append(earliest_fault)
14
        results.append(result)
15
    return results
16
17
# Read input
18
t = int(input())
19
test_cases = []
20
for _ in range(t):
21
    n, k = map(int, input().split())
22
    arr = list(map(int, input().split()))
23
    test_cases.append((n, k, arr))
24
25
# Compute results
26
results = earliest_faulty_readings(test_cases)
27
28
# Output results
29
for result in results:
30
    print(' '.join(map(str, result)) + ' ')",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054957
1390054960,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054960
1390054952,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054952
1390054953,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    strengths.sort(reverse=True)
3
    return sum(strengths[k:])
4
5
t = int(input())
6
for _ in range(t):
7
    n, k = map(int, input().split())
8
    strengths = list(map(int, input().split()))
9
    print(min_effort_to_breach(n, k, strengths))",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054953
1390054949,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054949
1390054948,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    prefix_ones = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_ones[i + 1] = prefix_ones[i] + (servers[i] == '1')
7
    8
    total_ones = prefix_ones[n]
9
    min_cost = total_ones  
10
11
    for end in range(n + 1):
12
        active_removed = total_ones - prefix_ones[end]
13
        idle_remaining = end - prefix_ones[end]
14
        min_cost = min(min_cost, max(active_removed, idle_remaining))
15
16
    return min_cost
17
18
t = int(input())
19
for _ in range(t):
20
    servers = input().strip()
21
    print(min_decommissioning_cost(servers))
22",57,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054948
1390054943,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
    5
    # Calculate the effort for all possible combinations of skipping firewalls
6
    efforts = []
7
    for mask in range(1 << n):
8
        if bin(mask).count('1') <= k:
9
            skipped = [i for i in range(n) if mask & (1 << i)]
10
            extra = 0
11
            total = 0
12
            13
            for i in range(n):
14
                if i in skipped:
15
                    extra += 1
16
                else:
17
                    total += strengths[i] + extra
18
                    19
            efforts.append(total)
20
    21
    return min(efforts)
22
23
t = int(input())
24
for _ in range(t):
25
    n, k = map(int, input().split())
26
    strengths = list(map(int, input().split()))
27
    print(min_effort_to_breach(n, k, strengths))",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054943
1390054946,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(len(arr)):
8
        # Remove elements that are out of the current batch window
9
        while dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
        12
        # Add the current element if it's faulty (negative)
13
        if arr[i] < 0:
14
            dq.append(i)
15
        16
        # Determine the earliest faulty reading for the current batch
17
        if i >= k - 1:
18
            result.append(arr[dq[0]] if dq else 0)
19
    20
    return result
21
22
def process_test_cases(test_cases):
23
    results = []
24
    for size, k, arr in test_cases:
25
        results.append(earliest_faulty_readings(arr, k))
26
    return results
27
28
# Read input
29
if __name__ == ""__main__"":
30
    t = int(input().strip())
31
    test_cases = []
32
    33
    for _ in range(t):
34
        size, k = map(int, input().split())
35
        arr = list(map(int, input().split()))
36
        test_cases.append((size, k, arr))
37
    38
    # Process and print results
39
    results = process_test_cases(test_cases)
40
    for res in results:
41
        print("" "".join(map(str, res)))",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054946
1390054942,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054942
1390054939,unknown,unknown,unknown,1,58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054939
1390054937,unknown,unknown,unknown,"1
import sys  
2
from itertools import accumulate  
3
4
def min_effort(arr, k):  
5
    n = len(arr)  
6
    T = sum(arr)  
7
    A = [arr[i] + (i + 1) for i in range(n)]  
8
    A.sort(reverse=True)  
9
    P = [0] + list(accumulate(A))  
10
    m_max = min(k, n)  
11
    best = float('inf')  
12
    13
    for m in range(m_max + 1):  
14
        cost = T + m * n - (m * m - m) // 2 - P[m]  
15
        if cost < best:  
16
            best = cost  
17
            18
    return best  
19
20
def solve():  
21
    data = sys.stdin.read().strip().split()  
22
    if not data:  
23
        return  
24
    t = int(data[0])  
25
    index = 1  
26
    res = []  
27
    28
    for _ in range(t):  
29
        n = int(data[index])  
30
        index += 1  
31
        k = int(data[index])  
32
        index += 1  
33
        arr = list(map(int, data[index:index + n]))  
34
        index += n  
35
        res.append(str(min_effort(arr, k)))  
36
        37
    sys.stdout.write(""\n"".join(res) + ""\n"")  
38
39
if __name__ == ""__main__"":  
40
    solve()  ",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054937
1390054940,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void findEarliestFaultyReadings(int *arr, int n, int k) {
5
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
6
    int front = 0, rear = 0;
7
    int queue[n];
8
    9
    // Process the first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) {
12
            queue[rear++] = i;
13
        }
14
    }
15
    16
    // Store result for the first batch
17
    result[0] = (front < rear) ? arr[queue[front]] : 0;
18
    19
    // Process the remaining windows
20
    for (int i = k; i < n; i++) {
21
        // Remove elements not within the window
22
        while (front < rear && queue[front] <= i - k) {
23
            front++;
24
        }
25
        26
        // Add new element if it's faulty
27
        if (arr[i] < 0) {
28
            queue[rear++] = i;
29
        }
30
        31
        // Store result for current batch
32
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
33
    }
34
    35
    // Print the result
36
    for (int i = 0; i < n - k + 1; i++) {
37
        printf(""%d "", result[i]);
38
    }
39
    printf(""\n"");
40
    41
    free(result);
42
}
43
44
int main() {
45
    int t;
46
    scanf(""%d"", &t);
47
    48
    while (t--) {
49
        int n, k;
50
        scanf(""%d %d"", &n, &k);
51
        int arr[n];
52
        53
        for (int i = 0; i < n; i++) {
54
            scanf(""%d"", &arr[i]);
55
        }
56
        57
        findEarliestFaultyReadings(arr, n, k);
58
    }
59
    60
    return 0;
61
}",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054940
1390054929,unknown,unknown,unknown,"1
def min_decommission_cost(s: str) -> int:
2
    n = len(s)
3
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
4
    T = len(ones_pos)
5
    6
    if T == 0:
7
        return 0
8
    9
    zeros_total = s.count('0')
10
    ans = min(zeros_total, T) 
11
    12
    for X in range(1, T + 1):
13
        for i in range(0, T - X + 1):
14
            left = ones_pos[i]
15
            right = ones_pos[i + X - 1]
16
            length = right - left + 1
17
            zeros_in_block = length - X
18
            candidate = max(zeros_in_block, T - X)
19
            ans = min(ans, candidate)
20
    21
    return ans
22
23
if __name__ == '__main__':
24
    T = int(input().strip())
25
    for _ in range(T):
26
        s = input().strip()
27
        print(min_decommission_cost(s))",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054929
1390054932,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    T = int(sys.stdin.readline().strip())
5
    for _ in range(T):
6
        n, k = map(int, sys.stdin.readline().split())
7
        a = list(map(int, sys.stdin.readline().split()))
8
        9
        sum_a = sum(a)
10
        values = [a[i] - (n - i - 1) for i in range(n)]
11
        values.sort(reverse=True)
12
        prefix_sum = [0] * (n + 1)
13
        for i in range(1, n + 1):
14
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
15
        maximum_m = min(k, n)
16
        maximum_total = float('-inf')
17
        for m in range(maximum_m + 1):
18
            current = prefix_sum[m] + (m * (m - 1)) // 2
19
            maximum_total = max(maximum_total, current)
20
        minimum_effort = sum_a - maximum_total
21
        print(minimum_effort)
22
23
if __name__ == ""__main__"":
24
    main()",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054932
1390054936,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054936
1390054927,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    ans = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            remaining = s[i:n-j]
10
            11
            idle_count = 0
12
            for char in remaining:
13
                if char == '0':
14
                    idle_count += 1
15
            16
            active_removed = 0
17
            for k in range(i):
18
                if s[k] == '1':
19
                    active_removed += 1
20
            for k in range(n - j, n):
21
                if s[k] == '1':
22
                    active_removed += 1
23
            24
            ans = min(ans, max(idle_count, active_removed))
25
    26
    print(ans)
27
28
t = int(input())
29
for _ in range(t):
30
    solve()
31",58,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054927
1390054922,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        total_ones = s.count('1')
6
        total_zeros = s.count('0')
7
        min_cost = float('inf')
8
        for i in range(n + 1):  
9
            for j in range(i, n + 1):  
10
                remaining_zeros = s[i:j].count('0')
11
                remaining_ones = s[i:j].count('1')
12
                removed_ones = total_ones - remaining_ones
13
                cost = max(remaining_zeros, removed_ones)
14
                min_cost = min(min_cost, cost)
15
        results.append(min_cost)
16
    return results
17
T = int(input())  
18
test_cases = [input().strip() for _ in range(T)]
19
results = min_decommissioning_cost(test_cases)
20
for result in results:
21
    print(result)
22",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054922
1390054923,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        benefits = []
12
        for i in range(n):
13
            benefit = a[i] - (n - i - 1)
14
            benefits.append((benefit, i))
15
        16
        benefits.sort(reverse=True)
17
18
        skipped = [False] * n
19
20
        for i in range(k):
21
            _, idx = benefits[i]
22
            skipped[idx] = True
23
24
        25
        total_effort = 0
26
        penalty = 0  
27
        for i in range(n):
28
            if skipped[i]:
29
                penalty += 1
30
            else:
31
                total_effort += a[i] + penalty
32
33
        print(total_effort)
34
35
threading.Thread(target=main).start()",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054923
1390054924,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <bits/stdc++.h>
7
using namespace std;
8
9
int solve(vector<int>&arr, int i, int skip, int inc,vector<vector<int>>&dp) {
10
    int n = arr.size();
11
    if(i==n){
12
        return 0;
13
    }
14
    if(dp[i][skip]!=-1)return dp[i][skip];
15
    //skip
16
    int ans = INT_MAX;
17
    if(skip>0) {
18
        ans = min(ans,solve(arr,i+1,skip-1,inc+1,dp));
19
    }
20
    //no skip
21
    ans = min(ans,arr[i]+inc + solve(arr,i+1,skip,inc,dp));
22
    return dp[i][skip]= ans;
23
}
24
25
26
int main() {
27
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
28
    int t;
29
    cin>>t;
30
    while(t--) {
31
        int n,skip;
32
        cin>>n>>skip;
33
        vector<int>arr;
34
        vector<vector<int>>dp(n,vector<int>(skip+1,-1));
35
        while(n--) {
36
            int a;
37
            cin>>a;
38
            arr.push_back(a);
39
        }
40
        cout<<solve(arr,0,skip,0,dp)<<endl;
41
    }
42
    return 0;
43
}",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054924
1390054917,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.Scanner;
3
4
public class Main {
5
6
    public static void main(String[] args) {
7
        Scanner sc = new Scanner(System.in);
8
        int T = sc.nextInt();
9
        sc.nextLine(); // Consume the newline after T
10
        while (T-- > 0) {
11
            String s = sc.nextLine().trim();
12
            int n = s.length();
13
            int totalOnes = 0;
14
            int maxConsecutiveOnes = 0;
15
            int currentConsecutiveOnes = 0;
16
            17
            // Calculate totalOnes and maxConsecutiveOnes
18
            for (char c : s.toCharArray()) {
19
                if (c == '1') {
20
                    currentConsecutiveOnes++;
21
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
22
                    totalOnes++;
23
                } else {
24
                    currentConsecutiveOnes = 0;
25
                }
26
            }
27
            28
            // Handle cases where the cost is trivially 0
29
            if (totalOnes == 0) {
30
                System.out.println(0);
31
                continue;
32
            }
33
            if (maxConsecutiveOnes == totalOnes) {
34
                System.out.println(0);
35
                continue;
36
            }
37
            38
            int totalZeros = n - totalOnes;
39
            int low = 0;
40
            int high = Math.max(totalOnes, totalZeros);
41
            int answer = high;
42
            43
            // Binary search for the minimal possible cost
44
            while (low <= high) {
45
                int mid = (low + high) / 2;
46
                int requiredOnes = Math.max(0, totalOnes - mid);
47
                48
                if (requiredOnes == 0) {
49
                    answer = mid;
50
                    high = mid - 1;
51
                    continue;
52
                }
53
                54
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
55
                if (maxOnes >= requiredOnes) {
56
                    answer = mid;
57
                    high = mid - 1;
58
                } else {
59
                    low = mid + 1;
60
                }
61
            }
62
            63
            System.out.println(answer);
64
        }
65
        sc.close();
66
    }
67
    68
    // Helper function to calculate maximum ones in any window with at most k zeros
69
    private static int maxOnesWithAtMostKZeros(String s, int k) {
70
        int left = 0;
71
        int zeros = 0;
72
        int maxOnes = 0;
73
        int n = s.length();
74
        75
        for (int right = 0; right < n; right++) {
76
            if (s.charAt(right) == '0') {
77
                zeros++;
78
            }
79
            // Shrink the window if zeros exceed k
80
            while (zeros > k) {
81
                if (s.charAt(left) == '0') {
82
                    zeros--;
83
                }
84
                left++;
85
            }
86
            // Calculate current number of ones in the window
87
            int currentOnes = (right - left + 1) - zeros;
88
            maxOnes = Math.max(maxOnes, currentOnes);
89
        }
90
        91
        return maxOnes;
92
    }
93
}",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054917
1390054918,unknown,unknown,unknown,"1
def min_cost_to_decommission(rack):
2
    length = len(rack)
3
    min_cost = float('inf')
4
    5
    for prefix in range(length + 1):
6
        for suffix in range(length + 1 - prefix):
7
            remaining = rack[prefix:length - suffix]
8
            9
            if not remaining:
10
                continue
11
            12
            idle_count = remaining.count('0')
13
            active_removed = rack[:prefix].count('1') + rack[length - suffix:].count('1')
14
            15
            cost = max(idle_count, active_removed)
16
            min_cost = min(min_cost, cost)
17
    18
    return min_cost if min_cost != float('inf') else 0
19
20
def process_cases():
21
    test_cases = int(input().strip())
22
    results = []
23
    24
    for _ in range(test_cases):
25
        rack = input().strip()
26
        results.append(min_cost_to_decommission(rack))
27
    28
    print(""\n"".join(map(str, results)))
29
30
process_cases()",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054918
1390054921,unknown,unknown,unknown,"1
def min_decommission_cost(s: str) -> int:
2
    n = len(s)
3
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
4
    T = len(ones_pos)
5
    6
    if T == 0:
7
        return 0
8
    9
    zeros_total = s.count('0')
10
    ans = min(zeros_total, T) 
11
    12
    for X in range(1, T + 1):
13
        for i in range(0, T - X + 1):
14
            left = ones_pos[i]
15
            right = ones_pos[i + X - 1]
16
            length = right - left + 1
17
            zeros_in_block = length - X
18
            candidate = max(zeros_in_block, T - X)
19
            ans = min(ans, candidate)
20
    21
    return ans
22
23
if __name__ == '__main__':
24
    T = int(input().strip())
25
    for _ in range(T):
26
        s = input().strip()
27
        print(min_decommission_cost(s))
28",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054921
1390054911,unknown,unknown,unknown,"1
import java.util.*;
2
public class Main {
3
    public static void main(String[] args) {
4
        Scanner sc = new Scanner(System.in);
5
        int t = sc.nextInt();
6
        while (t-- > 0) {
7
            int n = sc.nextInt(), k = sc.nextInt();
8
            int[] a = new int[n];
9
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
10
            System.out.println(minEffort(n, k, a));
11
        }
12
        sc.close();
13
    }
14
    15
    static int minEffort(int n, int k, int[] a) {
16
        int[] curr = new int[k + 1];
17
        int[] next = new int[k + 1];
18
19
        for (int i = n - 1; i >= 0; i--) {
20
            for (int skip = 0; skip <= k; skip++) {
21
                int take = a[i] + skip;
22
                if (take < 0) take = Integer.MAX_VALUE; 
23
                else if (i < n - 1) {
24
                    if (take <= Integer.MAX_VALUE - next[skip])
25
                        take += next[skip];
26
                    else
27
                        take = Integer.MAX_VALUE;
28
                }
29
30
                int leave = Integer.MAX_VALUE;
31
                if (skip < k) leave = next[skip + 1];
32
                33
                curr[skip] = Math.min(take, leave);
34
            }
35
36
            int[] temp = next;
37
            next = curr;
38
            curr = temp;
39
        }
40
        41
        return next[0];
42
    }
43
}",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054911
1390054913,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <vector>
4
#include <algorithm>
5
#include <climits>
6
7
using namespace std;
8
9
int findMinimumCost(const string& servers) {
10
    int n = servers.size();
11
    12
    // Precompute prefix and suffix counts of active servers (1's)
13
    vector<int> prefixActive(n + 1, 0);
14
    vector<int> suffixActive(n + 1, 0);
15
    16
    for (int i = 0; i < n; i++) {
17
        prefixActive[i + 1] = prefixActive[i] + (servers[i] == '1');
18
    }
19
    20
    for (int i = n - 1; i >= 0; i--) {
21
        suffixActive[i] = suffixActive[i + 1] + (servers[i] == '1');
22
    }
23
    24
    int minCost = INT_MAX;
25
    int totalActive = prefixActive[n];
26
    27
    // Try all valid combinations of front and end removals
28
    for (int frontRemove = 0; frontRemove <= n; frontRemove++) {
29
        for (int endRemove = 0; endRemove <= n - frontRemove; endRemove++) {
30
            // Skip if we're not removing anything
31
            if (frontRemove == 0 && endRemove == 0) continue;
32
            33
            // Calculate remaining length
34
            int remainingLength = n - frontRemove - endRemove;
35
            36
            // Calculate active servers removed
37
            int activeRemoved = prefixActive[frontRemove] + suffixActive[n - endRemove];
38
            39
            // Calculate idle servers remaining
40
            int totalRemaining = remainingLength;
41
            int activeRemaining = totalActive - activeRemoved;
42
            int idleRemaining = totalRemaining - activeRemaining;
43
            44
            // Calculate cost
45
            int cost = max(idleRemaining, activeRemoved);
46
            47
            // Update minimum cost
48
            minCost = min(minCost, cost);
49
        }
50
    }
51
    52
    return minCost;
53
}
54
55
int main() {
56
    ios_base::sync_with_stdio(false);
57
    cin.tie(NULL);
58
    59
    int t;
60
    cin >> t;
61
    62
    for (int i = 0; i < t; i++) {
63
        string servers;
64
        cin >> servers;
65
        cout << findMinimumCost(servers) << endl;
66
    }
67
    68
    return 0;
69
}",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054913
1390054914,unknown,unknown,unknown,"1
import sys, bisect
2
def solve():
3
    d = sys.stdin.read().split()
4
    if not d:
5
        return
6
    t = int(d[0])
7
    idx = 1
8
    r = []
9
    for _ in range(t):
10
        s = d[idx]
11
        idx += 1
12
        n = len(s)
13
        p1 = [0] * (n + 1)
14
        p0 = [0] * (n + 1)
15
        for i in range(n):
16
            p1[i + 1] = p1[i] + (s[i] == '1')
17
            p0[i + 1] = p0[i] + (s[i] == '0')
18
        zt = p0[n]
19
        ot = p1[n]
20
        s1 = [0] * (n + 1)
21
        s0 = [0] * (n + 1)
22
        for j in range(n):
23
            s1[j + 1] = s1[j] + (s[n - 1 - j] == '1')
24
            s0[j + 1] = s0[j] + (s[n - 1 - j] == '0')
25
        def chk(x):
26
            for i in range(n + 1):
27
                if p1[i] > x:
28
                    break
29
                as1 = x - p1[i]
30
                jmx = bisect.bisect_right(s1, as1) - 1
31
                nd = zt - x - p0[i]
32
                jmn = 0 if nd <= 0 else bisect.bisect_left(s0, nd)
33
                if jmn <= jmx and jmn <= n - i:
34
                    return True
35
            return False
36
        l, h = 0, max(zt, ot)
37
        ans = h
38
        while l <= h:
39
            m = (l + h) // 2
40
            if chk(m):
41
                ans = m
42
                h = m - 1
43
            else:
44
                l = m + 1
45
        r.append(str(ans))
46
    sys.stdout.write(""\n"".join(r))
47
if __name__ == '__main__':
48
    solve()
49",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054914
1390054910,unknown,unknown,unknown,"1
def find_earliest_faults(n, k, arr):
2
    if n < k or n < 1 or k < 1:
3
        return []
4
    result = []
5
    for i in range(0, n - k + 1):
6
        batch = arr[i:i+k]
7
        earliest_fault = 0
8
        for num in batch:
9
            if num < 0:
10
                earliest_fault = num
11
                break
12
        result.append(earliest_fault)
13
    return result
14
15
t = int(input())
16
for _ in range(t):
17
    n, k = map(int, input().split())
18
    arr = list(map(int, input().split()))
19
    result = find_earliest_faults(n, k, arr)
20
    print(*result)",59,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054910
1390054903,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054903
1390054904,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }
19
20
      21
        auto check = [&](int k) {
22
            int l = 0;
23
         24
            for (int r = 0; r < n; r++) {
25
              26
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
27
                    l++;
28
                }
29
                // wtf ,  check number of 1's decommissioned
30
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
31
                    return true;
32
                }
33
            }
34
      35
            if (prefix_1[n] <= k) {
36
                return true;
37
            }
38
            return false;
39
        };
40
41
        // Binary search for minimum cost
42
        int low = 0, high = n;
43
        while (low < high) {
44
            int mid = (low + high) / 2;
45
            if (check(mid)) {
46
                high = mid;
47
            } else {
48
                low = mid + 1;
49
            }
50
        }
51
        cout << low << endl;
52
    }
53
    return 0;
54
}",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054904
1390054907,unknown,unknown,unknown,"1
def minimum_cost(T, test_cases):
2
    results = []
3
    for binary_string in test_cases:
4
        n = len(binary_string)
5
        left_zeros = [0] * (n + 1)
6
        right_ones = [0] * (n + 1)
7
8
        # Count zeros from the left
9
        for i in range(1, n + 1):
10
            left_zeros[i] = left_zeros[i - 1] + (1 if binary_string[i - 1] == '0' else 0)
11
12
        # Count ones from the right
13
        for i in range(n - 1, -1, -1):
14
            right_ones[i] = right_ones[i + 1] + (1 if binary_string[i] == '1' else 0)
15
16
        # Calculate the minimum cost
17
        min_cost = float('inf')
18
        for i in range(n + 1):
19
            # Cost is max of idle servers left and active servers removed
20
            cost = max(left_zeros[i], right_ones[i])
21
            min_cost = min(min_cost, cost)
22
23
        results.append(min_cost)
24
    return results
25
26
# Input
27
T = 3
28
test_cases = [
29
    ""101110110"",      # Binary string for Test Case 1
30
    ""1001001001001"",  # Binary string for Test Case 2
31
    ""0000111111""      # Binary string for Test Case 3
32
]
33
34
# Running the function
35
results = minimum_cost(T, test_cases)
36
37
# Output the results
38
for res in results:
39
    print(res)
40",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054907
1390054900,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        8
        while (T-- > 0) {
9
            int n = sc.nextInt();
10
            int k = sc.nextInt();
11
            int[] a = new int[n];
12
            long sum_a = 0;
13
14
            for (int i = 0; i < n; i++) {
15
                a[i] = sc.nextInt();
16
                sum_a += a[i];
17
            }
18
19
            List<Long> values = new ArrayList<>();
20
            for (int i = 0; i < n; i++) {
21
                long val = a[i] - (n - i - 1L);
22
                values.add(val);
23
            }
24
25
            values.sort((x, y) -> Long.compare(y, x));
26
27
            long[] prefixSum = new long[n + 1];
28
            prefixSum[0] = 0;
29
            for (int i = 1; i <= n; i++) {
30
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
31
            }
32
33
            int max_m = Math.min(k, n);
34
            long maxTotal = Long.MIN_VALUE;
35
            36
            for (int m = 0; m <= max_m; m++) {
37
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
38
                maxTotal = Math.max(maxTotal, current);
39
            }
40
41
            long minEffort = sum_a - maxTotal;
42
            System.out.println(minEffort);
43
        }
44
45
        sc.close();
46
    }
47
}
48",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054900
1390054901,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054901
1390054898,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054898
1390054894,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054894
1390054895,unknown,unknown,unknown,"1
def optimize_server_rack(rack):
2
    n = len(rack)
3
    4
    # Build prefix sums for O(1) access
5
    active_prefix = [0] * (n + 1)
6
    idle_prefix = [0] * (n + 1)
7
    8
    for i in range(n):
9
        active_prefix[i + 1] = active_prefix[i] + (rack[i] == '1')
10
        idle_prefix[i + 1] = idle_prefix[i] + (rack[i] == '0')
11
    12
    min_cost = float('inf')
13
    14
    # Insight: For a fixed left cut, the cost function with respect to right cut
15
    # is monotonically decreasing then increasing (or just monotonic)
16
    # So for each left cut, we can find optimal right cut in O(log n) or linear time
17
    18
    for left in range(n + 1):
19
        # Binary search would take O(log n) time here, but since we already process n left cuts,
20
        # the total complexity remains O(n^2) in worst case
21
        # Let's use faster heuristic approach for large inputs
22
        23
        # Try all possible right cuts for this left cut
24
        for right in range(n + 1 - left):
25
            # Calculate cost
26
            active_removed = active_prefix[left] + (active_prefix[n] - active_prefix[n - right])
27
            idle_remaining = idle_prefix[n - right] - idle_prefix[left]
28
            29
            cost = max(active_removed, idle_remaining)
30
            min_cost = min(min_cost, cost)
31
    32
    return min_cost
33
34
def main():
35
    t = int(input())
36
    37
    for _ in range(t):
38
        rack = input()
39
        print(optimize_server_rack(rack))
40
41
if __name__ == ""__main__"":
42
    main()",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054895
1390054897,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
}",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054897
1390054893,unknown,unknown,unknown,"1
def solve():
2
    server_rack = input()
3
    n = len(server_rack)
4
5
    min_cost = float('inf')
6
7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            remaining_rack = server_rack[i:n-j]
10
11
            remaining_zeros = remaining_rack.count('0')
12
            removed_ones = server_rack[:i].count('1') + server_rack[n-j:].count('1')
13
14
            cost = max(remaining_zeros, removed_ones)
15
            min_cost = min(min_cost, cost)
16
17
    print(min_cost)
18
19
T = int(input())
20
for _ in range(T):
21
    solve()",60,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054893
1390054890,unknown,unknown,unknown,"1
import sys, bisect
2
data = sys.stdin.read().split()
3
if not data:
4
    exit()
5
t = int(data[0])
6
ptr = 1
7
out = []
8
for _ in range(t):
9
    s = data[ptr]
10
    ptr += 1
11
    n = len(s)
12
    pos = []
13
    for i,ch in enumerate(s):
14
        if ch=='1':
15
            pos.append(i)
16
    tot = len(pos)
17
    if tot==0:
18
        out.append(""1"")
19
        continue
20
    A = [pos[i]-i for i in range(tot)]
21
    lo, hi = 0, tot
22
    def feas(C):
23
        req = tot - C
24
        for i in range(tot):
25
            lim = C + (pos[i]-i)
26
            j = bisect.bisect_right(A, lim) - 1
27
            if j < i: continue
28
            if j - i + 1 >= req:
29
                return True
30
        return False
31
    while lo < hi:
32
        mid = (lo+hi)//2
33
        if feas(mid):
34
            hi = mid
35
        else:
36
            lo = mid+1
37
    out.append(str(lo))
38
sys.stdout.write(""\n"".join(out))
39",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054890
1390054891,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054891
1390054892,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054892
1390054886,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int maxOnesWithAtMostKZeros(const string &s, int k) {
9
    int left = 0, zeros = 0, maxOnes = 0, n = s.length();
10
11
    for (int right = 0; right < n; right++) {
12
        if (s[right] == '0') zeros++;
13
        while (zeros > k) {
14
            if (s[left] == '0') zeros--;
15
            left++;
16
        }
17
        maxOnes = max(maxOnes, (right - left + 1) - zeros);
18
    }
19
20
    return maxOnes;
21
}
22
23
void solve() {
24
    string s;
25
    cin >> s;
26
    int n = s.length(), totalOnes = 0, maxConsecutiveOnes = 0, currentConsecutiveOnes = 0;
27
28
    for (char c : s) {
29
        if (c == '1') {
30
            currentConsecutiveOnes++;
31
            maxConsecutiveOnes = max(maxConsecutiveOnes, currentConsecutiveOnes);
32
            totalOnes++;
33
        } else {
34
            currentConsecutiveOnes = 0;
35
        }
36
    }
37
38
    if (totalOnes == 0 || maxConsecutiveOnes == totalOnes) {
39
        cout << 0 << endl;
40
        return;
41
    }
42
43
    int totalZeros = n - totalOnes, low = 0, high = max(totalOnes, totalZeros), answer = high;
44
45
    while (low <= high) {
46
        int mid = (low + high) / 2, requiredOnes = max(0, totalOnes - mid);
47
48
        if (requiredOnes == 0) {
49
            answer = mid;
50
            high = mid - 1;
51
            continue;
52
        }
53
54
        if (maxOnesWithAtMostKZeros(s, mid) >= requiredOnes) {
55
            answer = mid;
56
            high = mid - 1;
57
        } else {
58
            low = mid + 1;
59
        }
60
    }
61
62
    cout << answer << endl;
63
}
64
65
int main() {
66
    int t;
67
    cin >> t;
68
    while (t--) solve();
69
    return 0;
70
}
71",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054886
1390054887,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054887
1390054888,unknown,unknown,unknown,"1
def calculate_min_effort(num_firewalls, max_skips, firewall_strengths):
2
    if max_skips >= num_firewalls:
3
        return 0
4
5
    skip_impacts = []
6
    for i in range(num_firewalls):
7
        skip_impact = firewall_strengths[i] - (num_firewalls - i - 1)
8
        skip_impacts.append((skip_impact, i))
9
10
    skip_impacts.sort(reverse=True)
11
    firewalls_to_skip = set(skip_impacts[i][1] for i in range(max_skips))
12
13
    total_effort = 0
14
    penalty = 0
15
16
    for i in range(num_firewalls):
17
        if i in firewalls_to_skip:
18
            penalty += 1
19
        else:
20
            total_effort += firewall_strengths[i] + penalty
21
22
    return total_effort
23
24
def process_test_cases():
25
    num_test_cases = int(input())
26
    results = []
27
28
    for _ in range(num_test_cases):
29
        num_firewalls, max_skips = map(int, input().split())
30
        firewall_strengths = list(map(int, input().split()))
31
        results.append(calculate_min_effort(num_firewalls, max_skips, firewall_strengths))
32
33
    return results
34
35
def main():
36
    results = process_test_cases()
37
    for result in results:
38
        print(result)
39
40
if __name__ == ""__main__"":
41
    main()",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054888
1390054878,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
3
    n = len(servers)
4
5
    6
7
    # Create prefix sums for 1's to optimize counting
8
9
    prefix_ones = [0] * (n + 1)
10
11
    for i in range(n):
12
13
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
14
15
    16
17
    # Create prefix sums for 0's
18
19
    prefix_zeros = [0] * (n + 1)
20
21
    for i in range(n):
22
23
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
24
25
    26
27
    min_cost = float('inf')
28
29
    30
31
    # Try all possible substrings (start, end)
32
33
    for start in range(n + 1):
34
35
        for end in range(start, n + 1):
36
37
            # Active servers removed = ones before start + ones after end
38
39
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
40
41
            # Idle servers remaining = zeros between start and end
42
43
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
44
45
            46
47
            cost = max(idle_remaining, active_removed)
48
49
            min_cost = min(min_cost, cost)
50
51
    52
53
    return min_cost
54
55
# Process test cases
56
57
t = int(input())
58
59
for _ in range(t):
60
61
    servers = input().strip()
62
63
    print(min_decommissioning_cost(servers))",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054878
1390054883,unknown,unknown,unknown,"1
def min_effort_to_breach(arr, k):
2
    n = len(arr)
3
    4
    5
    if k >= n:
6
        return 0
7
    8
    9
    min_effort = float('inf')
10
    11
12
    13
    14
    effective_costs = []
15
    for i in range(n):
16
       17
        skip_penalty = n - i - 1
18
        19
       20
        effective_cost = arr[i] - skip_penalty
21
        22
        effective_costs.append((effective_cost, i))
23
    24
25
    effective_costs.sort(reverse=True)
26
    27
   28
    skipped = [False] * n
29
    skips_used = 0
30
    31
    for cost, idx in effective_costs:
32
        if skips_used < k and cost > 0:
33
            skipped[idx] = True
34
            skips_used += 1
35
    36
    37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if skipped[i]:
42
            penalty += 1
43
        else:
44
            total_effort += arr[i] + penalty
45
    46
    return total_effort
47
48
def solve_test_cases():
49
    t = int(input())  
50
    results = []
51
    52
    for _ in range(t):
53
        n, k = map(int, input().split())
54
        arr = list(map(int, input().split()))
55
        56
        result = min_effort_to_breach(arr, k)
57
        results.append(result)
58
    59
   60
    for result in results:
61
        print(result)
62
63
64
if __name__ == ""__main__"":
65
    solve_test_cases()",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054883
1390054881,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); 
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
           17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
         42
            while (low <= high) {
43
                int mid = (low + high) / 2;
44
                int requiredOnes = Math.max(0, totalOnes - mid);
45
                46
                if (requiredOnes == 0) {
47
                    answer = mid;
48
                    high = mid - 1;
49
                    continue;
50
                }
51
                52
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
53
                if (maxOnes >= requiredOnes) {
54
                    answer = mid;
55
                    high = mid - 1;
56
                } else {
57
                    low = mid + 1;
58
                }
59
            }
60
            61
            System.out.println(answer);
62
        }
63
        sc.close();
64
    }
65
    66
    67
    private static int maxOnesWithAtMostKZeros(String s, int k) {
68
        int left = 0;
69
        int zeros = 0;
70
        int maxOnes = 0;
71
        int n = s.length();
72
        73
        for (int right = 0; right < n; right++) {
74
            if (s.charAt(right) == '0') {
75
                zeros++;
76
            }
77
            78
            while (zeros > k) {
79
                if (s.charAt(left) == '0') {
80
                    zeros--;
81
                }
82
                left++;
83
            }
84
            85
            int currentOnes = (right - left + 1) - zeros;
86
            maxOnes = Math.max(maxOnes, currentOnes);
87
        }
88
        89
        return maxOnes;
90
    }
91
}",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054881
1390054874,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
3
    """"""
4
5
    Calculate the minimum effort needed to breach the network.
6
7
    8
9
    Args:
10
11
        n (int): Number of firewalls
12
13
        k (int): Maximum number of firewalls that can be skipped
14
15
        strengths (list): List of firewall strengths
16
17
    18
19
    Returns:
20
21
        int: Minimum effort required
22
23
    """"""
24
25
    # Edge case: if we can skip all firewalls
26
27
    if k >= n:
28
29
        return 0
30
31
        32
33
    # We need to find the optimal firewalls to skip
34
35
    # This is a combinatorial problem
36
37
    38
39
    # First, let's calculate the impact of skipping each firewall
40
41
    # Impact = firewall's strength - penalty to subsequent firewalls
42
43
    impacts = []
44
45
    46
47
    for i in range(n):
48
49
        # If we skip this firewall, we save its strength
50
51
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
52
53
        impact = strengths[i] - (n - i - 1)
54
55
        impacts.append((impact, i))
56
57
    58
59
    # Sort by impact in descending order
60
61
    impacts.sort(reverse=True)
62
63
    64
65
    # Select the k firewalls with the highest impact to skip
66
67
    to_skip = set(impacts[i][1] for i in range(k))
68
69
    70
71
    # Calculate the total effort
72
73
    total_effort = 0
74
75
    penalty = 0
76
77
    78
79
    for i in range(n):
80
81
        if i in to_skip:
82
83
            # Skip this firewall
84
85
            penalty += 1
86
87
        else:
88
89
            # Breach this firewall (with penalty applied)
90
91
            total_effort += strengths[i] + penalty
92
93
    94
95
    return total_effort
96
97
def solve_test_cases():
98
99
    """"""
100
101
    Process all test cases and return the minimum effort for each.
102
103
    """"""
104
105
    t = int(input())  # Number of test cases
106
107
    results = []
108
109
    110
111
    for _ in range(t):
112
113
        n, k = map(int, input().split())
114
115
        strengths = list(map(int, input().split()))
116
117
        results.append(min_effort_to_breach(n, k, strengths))
118
119
    120
121
    return results
122
123
# Main function to run the solution
124
125
def main():
126
127
    results = solve_test_cases()
128
129
    130
131
    # Print the results
132
133
    for result in results:
134
135
        print(result)
136
137
if __name__ == ""__main__"":
138
139
    main()",61,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054874
1390054871,unknown,unknown,unknown,"1
def min_decommission_cost(s: str) -> int:
2
    n = len(s)
3
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
4
    T = len(ones_pos)
5
    6
    if T == 0:
7
        return 0
8
    9
    zeros_total = s.count('0')
10
    ans = min(zeros_total, T) 
11
    12
    for X in range(1, T + 1):
13
        for i in range(0, T - X + 1):
14
            left = ones_pos[i]
15
            right = ones_pos[i + X - 1]
16
            length = right - left + 1
17
            zeros_in_block = length - X
18
            candidate = max(zeros_in_block, T - X)
19
            ans = min(ans, candidate)
20
    21
    return ans
22
23
if __name__ == '__main__':
24
    T = int(input().strip())
25
    for _ in range(T):
26
        s = input().strip()
27
        print(min_decommission_cost(s))
28",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054871
1390054872,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054872
1390054873,unknown,unknown,unknown,"1
def min_cost_server_optimization(server_rack):
2
    n = len(server_rack)
3
    4
    total_active = server_rack.count('1')
5
    total_idle = server_rack.count('0')
6
    7
    min_cost = float('inf')
8
    9
    10
    for prefix_len in range(n + 1):
11
        prefix_active = server_rack[:prefix_len].count('1')
12
        prefix_idle = prefix_len - prefix_active
13
        14
       15
        for suffix_len in range(n + 1 - prefix_len):
16
            if prefix_len + suffix_len == n:
17
                continue  
18
                19
            suffix_active = server_rack[n-suffix_len:].count('1')
20
            suffix_idle = suffix_len - suffix_active
21
            22
            active_removed = prefix_active + suffix_active
23
            idle_removed = prefix_idle + suffix_idle
24
            25
            remaining_active = total_active - active_removed
26
            remaining_idle = total_idle - idle_removed
27
            28
            cost = max(remaining_idle, active_removed)
29
            min_cost = min(min_cost, cost)
30
    31
    return min_cost
32
33
def main():
34
    t = int(input().strip())
35
    36
    for _ in range(t):
37
        server_rack = input().strip()
38
        result = min_cost_server_optimization(server_rack)
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054873
1390054870,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        Scanner sc = new Scanner(System.in);
11
        int T = sc.nextInt();
12
        while (T-- > 0) {
13
            String servers = sc.next();
14
            int n = servers.length();
15
            int total0 = 0;
16
            for (int i = 0; i < n; i++) {
17
                if (servers.charAt(i) == '0') {
18
                    total0++;
19
                }
20
            }
21
            int total1 = n - total0;
22
            int[] prefix0 = new int[n + 1], prefix1 = new int[n + 1];
23
            for (int i = 1; i <= n; i++) {
24
                prefix0[i] = prefix0[i - 1] + (servers.charAt(i - 1) == '0' ? 1 : 0);
25
                prefix1[i] = prefix1[i - 1] + (servers.charAt(i - 1) == '1' ? 1 : 0);
26
            }
27
            int[] suffix0 = new int[n + 1], suffix1 = new int[n + 1];
28
            for (int j = 1; j <= n; j++) {
29
                suffix0[j] = suffix0[j - 1] + (servers.charAt(n - j) == '0' ? 1 : 0);
30
                suffix1[j] = suffix1[j - 1] + (servers.charAt(n - j) == '1' ? 1 : 0);
31
            }
32
            int minCost = Integer.MAX_VALUE;
33
            for (int i = 0; i <= n; i++) {
34
                int jMax = n - i;
35
                int left = 0, right = jMax;
36
                int bestJ = 0, bestCost = Integer.MAX_VALUE;
37
                while (left <= right) {
38
                    int mid = (left + right) / 2;
39
                    int remaining0 = total0 - (prefix0[i] + suffix0[mid]);
40
                    int decommissioned1 = prefix1[i] + suffix1[mid];
41
                    int currentCost = Math.max(remaining0, decommissioned1);
42
                    if (currentCost < bestCost) {
43
                        bestCost = currentCost;
44
                        bestJ = mid;
45
                    } else if (currentCost == bestCost && mid < bestJ) {
46
                        bestJ = mid;
47
                    }
48
                    if (decommissioned1 < remaining0) {
49
                        left = mid + 1;
50
                    } else {
51
                        right = mid - 1;
52
                    }
53
                }
54
                for (int dj = -1; dj <= 1; dj++) {
55
                    int j = bestJ + dj;
56
                    if (j >= 0 && j <= jMax) {
57
                        int remaining0 = total0 - (prefix0[i] + suffix0[j]);
58
                        int decommissioned1 = prefix1[i] + suffix1[j];
59
                        int currentCost = Math.max(remaining0, decommissioned1);
60
                        bestCost = Math.min(bestCost, currentCost);
61
                    }
62
                }
63
                minCost = Math.min(minCost, bestCost);
64
            }
65
            System.out.println(minCost);
66
        }
67
        sc.close();
68
    }
69
}
70",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054870
1390054860,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
    public static void main(String[] args) {
5
        import java.util.Scanner;
6
7
public class Main {
8
9
    public static void main(String[] args) {
10
        Scanner sc = new Scanner(System.in);
11
        int T = sc.nextInt();
12
        sc.nextLine(); // Consume the newline after T
13
        while (T-- > 0) {
14
            String s = sc.nextLine().trim();
15
            int n = s.length();
16
            int totalOnes = 0;
17
            int maxConsecutiveOnes = 0;
18
            int currentConsecutiveOnes = 0;
19
            20
            // Calculate totalOnes and maxConsecutiveOnes
21
            for (char c : s.toCharArray()) {
22
                if (c == '1') {
23
                    currentConsecutiveOnes++;
24
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
25
                    totalOnes++;
26
                } else {
27
                    currentConsecutiveOnes = 0;
28
                }
29
            }
30
            31
            // Handle cases where the cost is trivially 0
32
            if (totalOnes == 0) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            if (maxConsecutiveOnes == totalOnes) {
37
                System.out.println(0);
38
                continue;
39
            }
40
            41
            int totalZeros = n - totalOnes;
42
            int low = 0;
43
            int high = Math.max(totalOnes, totalZeros);
44
            int answer = high;
45
            46
            // Binary search for the minimal possible cost
47
            while (low <= high) {
48
                int mid = (low + high) / 2;
49
                int requiredOnes = Math.max(0, totalOnes - mid);
50
                51
                if (requiredOnes == 0) {
52
                    answer = mid;
53
                    high = mid - 1;
54
                    continue;
55
                }
56
                57
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
58
                if (maxOnes >= requiredOnes) {
59
                    answer = mid;
60
                    high = mid - 1;
61
                } else {
62
                    low = mid + 1;
63
                }
64
            }
65
            66
            System.out.println(answer);
67
        }
68
        sc.close();
69
    }
70
    71
    // Helper function to calculate maximum ones in any window with at most k zeros
72
    private static int maxOnesWithAtMostKZeros(String s, int k) {
73
        int left = 0;
74
        int zeros = 0;
75
        int maxOnes = 0;
76
        int n = s.length();
77
        78
        for (int right = 0; right < n; right++) {
79
            if (s.charAt(right) == '0') {
80
                zeros++;
81
            }
82
            // Shrink the window if zeros exceed k
83
            while (zeros > k) {
84
                if (s.charAt(left) == '0') {
85
                    zeros--;
86
                }
87
                left++;
88
            }
89
            // Calculate current number of ones in the window
90
            int currentOnes = (right - left + 1) - zeros;
91
            maxOnes = Math.max(maxOnes, currentOnes);
92
        }
93
        94
        return maxOnes;
95
    }
96
}",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054860
1390054856,unknown,unknown,unknown,"1
def bf(arr, k):
2
    if k >= len(arr):
3
        return 0  
4
    arr.sort(reverse=True)  
5
    rem = arr[k:]
6
    return sum(rem)+1
7
8
t = int(input())
9
for _ in range(t):
10
    n, k = map(int, input().split())
11
    arr = list(map(int, input().split()))
12
    print(bf(arr, k))",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054856
1390054857,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommissioning {
4
5
    public static int minDecommissioningCost(String serverRack) {
6
        int firstOne = serverRack.indexOf('1');
7
        int lastOne = serverRack.lastIndexOf('1');
8
9
        // If there are no active servers (all 0s), cost is 0
10
        if (firstOne == -1) {
11
            return 0;
12
        }
13
14
        // Extract the core segment containing all necessary servers
15
        String coreSegment = serverRack.substring(firstOne, lastOne + 1);
16
17
        // Count remaining idle servers (0s)
18
        int remainingIdle = (int) coreSegment.chars().filter(ch -> ch == '0').count();
19
20
        // Count removed active servers (1s) from the prefix and suffix
21
        int removedActive = (int) serverRack.substring(0, firstOne).chars().filter(ch -> ch == '1').count() +
22
                            (int) serverRack.substring(lastOne + 1).chars().filter(ch -> ch == '1').count();
23
24
        // Return the minimum cost
25
        return Math.max(remainingIdle, removedActive);
26
    }
27
28
    public static void main(String[] args) {
29
        Scanner scanner = new Scanner(System.in);
30
        int T = scanner.nextInt(); // Number of test cases
31
        scanner.nextLine(); // Consume the newline
32
33
        while (T-- > 0) {
34
            String serverRack = scanner.nextLine();
35
            System.out.println(minDecommissioningCost(serverRack));
36
        }
37
38
        scanner.close();
39
    }
40
}
41",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054857
1390054858,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
5
    impacts = []
6
    7
    for i in range(n):
8
        impact = strengths[i] - (n - i - 1)
9
        impacts.append((impact, i))
10
    11
    impacts.sort(reverse=True)
12
    13
    to_skip = set(impacts[i][1] for i in range(k))
14
    15
    total_effort = 0
16
    penalty = 0
17
    18
    for i in range(n):
19
        if i in to_skip:
20
            penalty += 1
21
        else:
22
            total_effort += strengths[i] + penalty
23
    24
    return total_effort
25
26
def solve_test_cases():
27
28
    t = int(input())  
29
    results = []
30
    31
    for _ in range(t):
32
        n, k = map(int, input().split())
33
        strengths = list(map(int, input().split()))
34
        results.append(min_effort_to_breach(n, k, strengths))
35
    36
    return results
37
38
def main():
39
    results = solve_test_cases()
40
    41
    for result in results:
42
        print(result)
43
44
if __name__ == ""__main__"":
45
    main()
46",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054858
1390054855,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",62,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054855
1390054849,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    memo = {}    
3
    def solve(idx, skipped):
4
        if idx == n:
5
            return 0
6
        if (idx, skipped) in memo:
7
            return memo[(idx, skipped)]
8
        skip_effort = float('inf')
9
        if skipped < k:
10
            skip_effort = solve(idx + 1, skipped + 1)
11
        dont_skip_effort = (strengths[idx] + skipped) + solve(idx + 1, skipped)
12
        result = min(skip_effort, dont_skip_effort)
13
        memo[(idx, skipped)] = result
14
        return result
15
    return solve(0, 0)
16
def solve_test_cases():
17
    t = int(input()) 
18
    results = []
19
    for _ in range(t):
20
        n, k = map(int, input().split())
21
        strengths = list(map(int, input().split()))
22
        min_effort = min_effort_to_breach(n, k, strengths)
23
        results.append(min_effort)
24
    return results
25
if __name__ == ""__main__"":
26
    results = solve_test_cases()
27
    for result in results:
28
        print(result)",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054849
1390054848,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} #include <iostream>
103
#include <vector>
104
#include <string>
105
#include <climits>
106
107
using namespace std;
108
109
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
110
    vector<int> results;
111
    112
    for (const string& servers : test_cases) {
113
        int n = servers.size();
114
        int total_0 = 0;
115
        for (char c : servers) {
116
            if (c == '0') total_0++;
117
        }
118
        int total_1 = n - total_0;
119
        120
        // Precompute prefix counts for 0s and 1s
121
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
122
        for (int i = 1; i <= n; ++i) {
123
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
124
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
125
        }
126
        127
        // Precompute suffix counts for 0s and 1s
128
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
129
        for (int j = 1; j <= n; ++j) {
130
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
131
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
132
        }
133
        134
        int min_cost = INT_MAX;
135
        136
        // Iterate over all possible prefixes (i)
137
        for (int i = 0; i <= n; ++i) {
138
            int j_max = n - i;
139
            int left = 0, right = j_max;
140
            int best_j = 0;
141
            int best_cost = INT_MAX;
142
            143
            // Binary search for the best j
144
            while (left <= right) {
145
                int mid = (left + right) / 2;
146
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
147
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
148
                int current_cost = max(remaining_0, decommissioned_1);
149
                150
                if (current_cost < best_cost) {
151
                    best_cost = current_cost;
152
                    best_j = mid;
153
                } else if (current_cost == best_cost && mid < best_j) {
154
                    best_j = mid;
155
                }
156
                157
                if (decommissioned_1 < remaining_0) {
158
                    left = mid + 1;
159
                } else {
160
                    right = mid - 1;
161
                }
162
            }
163
            164
            // Check neighboring j values
165
            for (int dj : {-1, 0, 1}) {
166
                int j = best_j + dj;
167
                if (j >= 0 && j <= j_max) {
168
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
169
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
170
                    int current_cost = max(remaining_0, decommissioned_1);
171
                    if (current_cost < best_cost) {
172
                        best_cost = current_cost;
173
                    }
174
                }
175
            }
176
            177
            if (best_cost < min_cost) {
178
                min_cost = best_cost;
179
            }
180
        }
181
        182
        results.push_back(min_cost);
183
    }
184
    185
    return results;
186
}
187
188
int main() {
189
    int T;
190
    cin >> T;
191
    vector<string> test_cases(T);
192
    for (int i = 0; i < T; ++i) {
193
        cin >> test_cases[i];
194
    }
195
    196
    vector<int> results = min_decommissioning_cost(test_cases);
197
    198
    for (int result : results) {
199
        cout << result << endl;
200
    }
201
    202
    return 0;
203
} 
204",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054848
1390054854,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner input = new Scanner(System.in);
6
        int t = input.nextInt();  // Number of test cases
7
        8
        while (t-- > 0) {
9
            int N = input.nextInt();  // Array size
10
            int K = input.nextInt();  // Batch size
11
            int[] arr = new int[N];
12
            13
            for (int i = 0; i < N; i++) {
14
                arr[i] = input.nextInt();
15
            }
16
            17
            List<Integer> result = findEarliestFaults(arr, K);
18
            19
            // Print the result for this test case
20
            for (int num : result) {
21
                System.out.print(num + "" "");
22
            }
23
            System.out.println();
24
        }
25
        26
        input.close();
27
    }
28
29
    public static List<Integer> findEarliestFaults(int[] arr, int K) {
30
        List<Integer> result = new ArrayList<>();
31
        Deque<Integer> deque = new LinkedList<>();  // Stores indices of negative numbers
32
        33
        int n = arr.length;
34
35
        // Process first window of size K
36
        for (int i = 0; i < K; i++) {
37
            if (arr[i] < 0) {
38
                deque.addLast(i);
39
            }
40
        }
41
        42
        // Process remaining elements
43
        for (int i = K; i <= n; i++) {
44
            // If deque is not empty, the first element is the earliest fault
45
            if (!deque.isEmpty()) {
46
                result.add(arr[deque.peekFirst()]);
47
            } else {
48
                result.add(0);
49
            }
50
51
            // Remove elements that are out of the current window
52
            if (!deque.isEmpty() && deque.peekFirst() <= i - K) {
53
                deque.pollFirst();
54
            }
55
56
            // Add next element (if negative)
57
            if (i < n && arr[i] < 0) {
58
                deque.addLast(i);
59
            }
60
        }
61
        62
        return result;
63
    }
64
}
65",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054854
1390054845,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
import sys
3
4
def main():
5
    input = sys.stdin.read
6
    data = input().split(""\n"")
7
    8
    t = int(data[0])  # Number of test cases
9
    index = 1
10
11
    results = []
12
    for _ in range(t):
13
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
14
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
15
        index += 2
16
        17
        if k >= n:
18
            results.append(""0"")
19
            continue
20
        21
        # Calculate the impact of each firewall: strength + index
22
        impact = [(strengths[i] + i, i) for i in range(n)]
23
        24
        # Sort firewalls by impact (higher impact should be skipped first)
25
        impact.sort(reverse=True)
26
        27
        # Select the top k firewalls to skip
28
        to_skip = set(idx for _, idx in impact[:k])
29
        30
        # Compute the minimal effort
31
        effort = 0
32
        skipped = 0
33
        34
        for i in range(n):
35
            if i in to_skip:
36
                skipped += 1
37
            else:
38
                effort += strengths[i] + skipped
39
        40
        results.append(str(effort))
41
    42
    # Print all results at once (faster output handling)
43
    sys.stdout.write(""\n"".join(results) + ""\n"")
44
45
if _name_ == ""_main_"":
46
    main()",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054845
1390054846,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054846
1390054847,unknown,unknown,unknown,"1
2
def min_cost_server_pruning(server_rack):
3
    n = len(server_rack)
4
    min_cost = float('inf')
5
    6
    for i in range(n + 1):
7
        for j in range(n + 1 - i):
8
            remaining = server_rack[i:n-j]
9
            idle_remaining = remaining.count('0')
10
            11
            removed_start = server_rack[:i].count('1')
12
            removed_end = server_rack[n-j:].count('1')
13
            active_decommissioned = removed_start + removed_end
14
            15
            cost = max(idle_remaining, active_decommissioned)
16
            min_cost = min(min_cost, cost)
17
    18
    return min_cost
19
20
t = int(input())
21
for _ in range(t):
22
    server_rack = input().strip()
23
    print(min_cost_server_pruning(server_rack))",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054847
1390054840,unknown,unknown,unknown,"1
2
def min_cost_decommissioning(rack):
3
    first_active = rack.find('1')
4
    last_active = rack.rfind('1')
5
    6
    if first_active == -1:
7
        return 0  # No active servers
8
    9
    idle_servers = rack[first_active:last_active + 1].count('0')
10
    active_servers_removed = first_active + (len(rack) - last_active - 1)
11
    12
    return max(idle_servers, active_servers_removed)
13
14
15
16
T = int(input().strip())
17
for _ in range(T):
18
    rack = input().strip()
19
    print(min_cost_decommissioning(rack))
20
21",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054840
1390054843,unknown,unknown,unknown,"1
def min_cost_to_decommission(rack):
2
    length = len(rack)
3
    min_cost = float('inf')
4
    5
    for prefix in range(length + 1):
6
        for suffix in range(length + 1 - prefix):
7
            remaining = rack[prefix:length - suffix]
8
            9
            if not remaining:
10
                continue
11
            12
            idle_count = remaining.count('0')
13
            active_removed = rack[:prefix].count('1') + rack[length - suffix:].count('1')
14
            15
            cost = max(idle_count, active_removed)
16
            min_cost = min(min_cost, cost)
17
    18
    return min_cost
19
20
def process_cases():
21
    test_cases = int(input().strip())
22
    results = []
23
    24
    for _ in range(test_cases):
25
        rack = input().strip()
26
        results.append(min_cost_to_decommission(rack))
27
    28
    print(""\n"".join(map(str, results)))
29
30
process_cases()",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054843
1390054839,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
5
public class Solution {
6
7
    public static void main(String[] args) {
8
        Scanner sc = new Scanner(System.in);
9
        int T = sc.nextInt();
10
        sc.nextLine(); 
11
        while (T-- > 0) {
12
            String s = sc.nextLine().trim();
13
            int n = s.length();
14
            int totalOnes = 0;
15
            int maxConsecutiveOnes = 0;
16
            int currentConsecutiveOnes = 0;
17
            18
            for (char c : s.toCharArray()) {
19
                if (c == '1') {
20
                    currentConsecutiveOnes++;
21
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
22
                    totalOnes++;
23
                } else {
24
                    currentConsecutiveOnes = 0;
25
                }
26
            }
27
            28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            while (low <= high) {
43
                int mid = (low + high) / 2;
44
                int requiredOnes = Math.max(0, totalOnes - mid);
45
                46
                if (requiredOnes == 0) {
47
                    answer = mid;
48
                    high = mid - 1;
49
                    continue;
50
                }
51
                52
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
53
                if (maxOnes >= requiredOnes) {
54
                    answer = mid;
55
                    high = mid - 1;
56
                } else {
57
                    low = mid + 1;
58
                }
59
            }
60
            61
            System.out.println(answer);
62
        }
63
        sc.close();
64
    }
65
    66
    private static int maxOnesWithAtMostKZeros(String s, int k) {
67
        int left = 0;
68
        int zeros = 0;
69
        int maxOnes = 0;
70
        int n = s.length();
71
        72
        for (int right = 0; right < n; right++) {
73
            if (s.charAt(right) == '0') {
74
                zeros++;
75
            }
76
            while (zeros > k) {
77
                if (s.charAt(left) == '0') {
78
                    zeros--;
79
                }
80
                left++;
81
            }
82
            int currentOnes = (right - left + 1) - zeros;
83
            maxOnes = Math.max(maxOnes, currentOnes);
84
        }
85
        86
        return maxOnes;
87
    }
88
89
}",63,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054839
1390054832,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <string.h>
3
#include <math.h>
4
#include <stdlib.h>
5
6
int main() {
7
8
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    
9
    return 0;
10
}",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054832
1390054833,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
3
    left = 0
4
5
    zeros = 0
6
7
    max_ones = 0
8
9
    n = len(s)
10
11
    for right in range(n):
12
13
        if s[right] == '0':
14
15
            zeros += 1
16
17
        while zeros > k:
18
19
            if s[left] == '0':
20
21
                zeros -= 1
22
23
            left += 1
24
25
        current_ones = (right - left + 1) - zeros
26
27
        max_ones = max(max_ones, current_ones)
28
29
    30
31
    return max_ones
32
33
def main():
34
35
    T = int(input())
36
37
    for _ in range(T):
38
39
        s = input().strip()
40
41
        n = len(s)
42
43
        total_ones = s.count('1')
44
45
        # Calculate max consecutive ones
46
47
        max_consecutive_ones = 0
48
49
        current = 0
50
51
        for c in s:
52
53
            if c == '1':
54
55
                current += 1
56
57
                max_consecutive_ones = max(max_consecutive_ones, current)
58
59
            else:
60
61
                current = 0
62
63
        if total_ones == 0 or total_ones == max_consecutive_ones:
64
65
            print(0)
66
67
            continue
68
69
        total_zeros = n - total_ones
70
71
        low, high = 0, max(total_ones, total_zeros)
72
73
        answer = high
74
75
        while low <= high:
76
77
            mid = (low + high) // 2
78
79
            required_ones = max(0, total_ones - mid)
80
81
            if required_ones == 0:
82
83
                answer = mid
84
85
                high = mid - 1
86
87
                continue
88
89
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
90
91
            if max_ones >= required_ones:
92
93
                answer = mid
94
95
                high = mid - 1
96
97
            else:
98
99
                low = mid + 1
100
101
        print(answer)
102
103
if __name__ == ""__main__"":
104
105
    main()def max_ones_with_at_most_k_zeros(s, k):
106
107
    left = 0
108
109
    zeros = 0
110
111
    max_ones = 0
112
113
    n = len(s)
114
115
    for right in range(n):
116
117
        if s[right] == '0':
118
119
            zeros += 1
120
121
        while zeros > k:
122
123
            if s[left] == '0':
124
125
                zeros -= 1
126
127
            left += 1
128
129
        current_ones = (right - left + 1) - zeros
130
131
        max_ones = max(max_ones, current_ones)
132
133
    134
135
    return max_ones
136
137
def main():
138
139
    T = int(input())
140
141
    for _ in range(T):
142
143
        s = input().strip()
144
145
        n = len(s)
146
147
        total_ones = s.count('1')
148
149
        # Calculate max consecutive ones
150
151
        max_consecutive_ones = 0
152
153
        current = 0
154
155
        for c in s:
156
157
            if c == '1':
158
159
                current += 1
160
161
                max_consecutive_ones = max(max_consecutive_ones, current)
162
163
            else:
164
165
                current = 0
166
167
        if total_ones == 0 or total_ones == max_consecutive_ones:
168
169
            print(0)
170
171
            continue
172
173
        total_zeros = n - total_ones
174
175
        low, high = 0, max(total_ones, total_zeros)
176
177
        answer = high
178
179
        while low <= high:
180
181
            mid = (low + high) // 2
182
183
            required_ones = max(0, total_ones - mid)
184
185
            if required_ones == 0:
186
187
                answer = mid
188
189
                high = mid - 1
190
191
                continue
192
193
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
194
195
            196
197
            198
199
200
         201
202",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054833
1390054838,unknown,unknown,unknown,"1
def find_earliest_faults(n, k, arr):
2
    result = []
3
    for i in range(0, len(arr) - k + 1):
4
        batch = arr[i:i+k]
5
        earliest_fault = 0
6
        for num in batch:
7
            if num < 0:
8
                earliest_fault = num
9
                break
10
        result.append(earliest_fault)
11
    return result
12
13
def process_test_cases():
14
    t = int(input())
15
    results = []
16
    17
    for _ in range(t):
18
        n, k = map(int, input().split())
19
        arr = list(map(int, input().split()))
20
        result = find_earliest_faults(n, k, arr)
21
        results.append(result)
22
    23
    for result in results:
24
        print(*result)
25
26
test_cases = [
27
    (5, 2, [-8, 2, 3, -6, 10]),
28
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
29
]
30
31
for n, k, arr in test_cases:
32
    result = find_earliest_faults(n, k, arr)
33
    print(*result)",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054838
1390054826,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int t;
6
    cin >> t;
7
    8
    while (t--) {
9
        int n, k;
10
        cin >> n >> k;
11
        12
        vector<int> strengths(n);
13
        for (int i = 0; i < n; i++) {
14
            cin >> strengths[i];
15
        }
16
        17
      18
        int min_effort = INT_MAX;
19
        20
        21
        for (int start_pos = 0; start_pos <= n; start_pos++) {
22
            23
            int effort = 0;
24
            vector<int> current_strengths = strengths; 
25
        26
            vector<bool> skip(n, false);
27
            for (int i = start_pos; i < min(start_pos + k, n); i++) {
28
                skip[i] = true;
29
            }
30
            31
           32
            int skipped_count = 0;
33
            for (int i = 0; i < n; i++) {
34
                if (skip[i]) {
35
                    skipped_count++;
36
                } else {
37
                    current_strengths[i] += skipped_count; 
38
                    effort += current_strengths[i];
39
                }
40
            }
41
            42
            min_effort = min(min_effort, effort);
43
        }
44
        45
        cout << min_effort << endl;
46
    }
47
    48
    return 0;
49
}",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054826
1390054828,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} 3rd",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054828
1390054829,unknown,unknown,unknown,"1
import sys
2
input = sys.stdin.read
3
4
def minimum_effort(arr, k):
5
    n = len(arr)
6
    7
    if k == n:
8
        return 0
9
    10
    total_effort = sum(arr)
11
    min_effort = total_effort
12
    13
    # Sliding window to calculate the sum of any skipped window of size k
14
    window_sum = sum(arr[:k])
15
    for i in range(n - k + 1):
16
        skipped_effort = total_effort - window_sum + k
17
        min_effort = min(min_effort, skipped_effort)
18
        19
        # Slide the window to the right
20
        if i + k < n:
21
            window_sum = window_sum - arr[i] + arr[i + k]
22
    23
    return min_effort
24
25
# Efficient Input Handling with ASCII Conversion
26
data = input().encode('ascii', 'ignore').decode('ascii').strip().split(""\n"")
27
t = int(data[0])
28
index = 1
29
30
results = []
31
for _ in range(t):
32
    n, k = map(int, data[index].split())
33
    arr = list(map(int, data[index + 1].split()))
34
    results.append(str(minimum_effort(arr, k)))
35
    index += 2
36
37
# Fast Output
38
sys.stdout.write(""\n"".join(results) + ""\n"")
39",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054829
1390054817,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <vector>
4
#include <bits/stdc++.h>
5
6
using namespace std;
7
8
int findMinimumCost(const string& servers) {
9
    int n = servers.size();
10
    11
    // Try removing servers from the beginning
12
    int minCost = INT_MAX;
13
    14
    for (int frontRemove = 0; frontRemove <= n; frontRemove++) {
15
        // Try removing servers from the end
16
        for (int endRemove = 0; endRemove <= n - frontRemove; endRemove++) {
17
            // Skip if we're not removing anything
18
            if (frontRemove == 0 && endRemove == 0) continue;
19
            20
            // Calculate the remaining server configuration
21
            string remainingServers = servers.substr(frontRemove, n - frontRemove - endRemove);
22
            23
            // Count idle servers remaining
24
            int idleServersRemaining = count(remainingServers.begin(), remainingServers.end(), '0');
25
            26
            // Count active servers removed
27
            int activeServersRemoved = 0;
28
            for (int i = 0; i < frontRemove; i++) {
29
                if (servers[i] == '1') activeServersRemoved++;
30
            }
31
            for (int i = n - endRemove; i < n; i++) {
32
                if (servers[i] == '1') activeServersRemoved++;
33
            }
34
            35
            // Calculate cost
36
            int cost = max(idleServersRemaining, activeServersRemoved);
37
            38
            // Update minimum cost
39
            minCost = min(minCost, cost);
40
        }
41
    }
42
    43
    return minCost;
44
}
45
46
int main() {
47
    int t;
48
    cin >> t;
49
    50
    vector<string> testCases;
51
    for (int i = 0; i < t; i++) {
52
        string servers;
53
        cin >> servers;
54
        testCases.push_back(servers);
55
    }
56
    57
    for (const string& servers : testCases) {
58
        cout << findMinimumCost(servers) << endl;
59
    }
60
    61
    return 0;
62
}",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054817
1390054819,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner s = new Scanner(System.in);
6
        int t = s.nextInt();  // Number of test cases
7
        8
        while (t-- > 0) {
9
            int n = s.nextInt();
10
            int k = s.nextInt();
11
            int[] arr = new int[n];
12
13
            for (int i = 0; i < n; i++) {
14
                arr[i] = s.nextInt();
15
            }
16
17
            // Using a queue to track the index of negative numbers
18
            Queue<Integer> queue = new LinkedList<>();
19
            int i = 0;
20
21
            // Process first window
22
            for (i = 0; i < k; i++) {
23
                if (arr[i] < 0) {
24
                    queue.add(i);
25
                }
26
            }
27
28
            // Process remaining windows
29
            for (; i < n; i++) {
30
                // Print first negative number of previous window
31
                if (!queue.isEmpty()) {
32
                    System.out.print(arr[queue.peek()] + "" "");
33
                } else {
34
                    System.out.print(""0 "");
35
                }
36
37
                // Remove elements that are out of this window
38
                while (!queue.isEmpty() && queue.peek() <= i - k) {
39
                    queue.poll();
40
                }
41
42
                // Add current element if it's negative
43
                if (arr[i] < 0) {
44
                    queue.add(i);
45
                }
46
            }
47
48
            // Print for last window
49
            if (!queue.isEmpty()) {
50
                System.out.print(arr[queue.peek()] + "" "");
51
            } else {
52
                System.out.print(""0 "");
53
            }
54
55
            System.out.println();
56
        }
57
        s.close();
58
    }
59
}",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054819
1390054818,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
        # get indices for active servers ('1')
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        # Precompute A: A[i] = positions[i] - i
18
        A = [positions[i] - i for i in range(m)]
19
        20
        # check(X) returns True if there exists a window in A
21
        # such that:
22
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
23
        # and A[j] - A[i] <= X.
24
        def check(X):
25
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                # slide j as far as possible while A[j]-A[i] <= X
33
                while j < m and A[j] - A[i] <= X:
34
                    j += 1
35
                # j now is one past the last index satisfying condition, so the window has length (j - i)
36
                if j - i >= m - X:
37
                    return True
38
            return False
39
40
        # Binary search for the minimum X
41
        lo, hi, ans = 0, n, n
42
        while lo <= hi:
43
            mid = (lo + hi) // 2
44
            if check(mid):
45
                ans = mid
46
                hi = mid - 1
47
            else:
48
                lo = mid + 1
49
        out_lines.append(str(ans))
50
    51
    sys.stdout.write(""\n"".join(out_lines))
52
    53
if __name__ == '__main__':
54
    solve()",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054818
1390054814,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
12
        benefits = []
13
        for i in range(n):
14
            benefit = a[i] - (n - i - 1)
15
            benefits.append((benefit, i))
16
        17
        benefits.sort(reverse=True)
18
19
        skipped = [False] * n
20
21
        for i in range(k):
22
            _, idx = benefits[i]
23
            skipped[idx] = True
24
25
        total_effort = 0
26
        penalty = 0  
27
        for i in range(n):
28
            if skipped[i]:
29
                penalty += 1
30
            else:
31
                total_effort += a[i] + penalty
32
33
        print(total_effort)
34
35
threading.Thread(target=main).start()",64,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054814
1390054812,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
7
using namespace std;
8
9
int main() {
10
    ios::sync_with_stdio(false);
11
    cin.tie(nullptr);
12
    13
    int T;
14
    cin >> T;
15
    while (T--) {
16
        string s;
17
        cin >> s;
18
        int n = s.size();
19
        20
        // Build prefix sums for zeros and ones.
21
        vector<int> prefix0(n + 1, 0), prefix1(n + 1, 0);
22
        for (int i = 0; i < n; i++) {
23
            prefix0[i + 1] = prefix0[i] + (s[i] == '0');
24
            prefix1[i + 1] = prefix1[i] + (s[i] == '1');
25
        }
26
        int totalOnes = prefix1[n];
27
28
        // Binary search for the minimal cost C in the range [0, n].
29
        int low = 0, high = n, ans = n;
30
        while (low <= high) {
31
            int mid = (low + high) / 2;
32
            bool feasible = false;
33
34
            for (int l = 0; l <= n; l++) {
35
                int allowed = prefix0[l] + mid;
36
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
37
                if (r - 1 < l) continue; 
38
                int r_max = r - 1;
39
                int onesKept = prefix1[r_max] - prefix1[l];
40
                if (onesKept >= totalOnes - mid) {
41
                    feasible = true;
42
                    break;
43
                }
44
            }
45
46
            if (feasible) {
47
                ans = mid;
48
                high = mid - 1;
49
            } else {
50
                low = mid + 1;
51
            }
52
        }
53
54
        cout << ans << ""\n"";
55
    }
56
57
    return 0;
58
}
59",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054812
1390054813,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
    if k == n:
3
        return 0
4
    5
    total_effort = sum(strengths)
6
    min_effort = total_effort
7
8
    for skip_index in range(n - k + 1):
9
        effort = sum(strengths[:skip_index]) + sum(s + k for s in strengths[skip_index + k:])
10
        min_effort = min(min_effort, effort)
11
12
    return min_effort
13
14
T = int(input())
15
for _ in range(T):
16
    n, k = map(int, input().split())
17
    strengths = list(map(int, input().split()))
18
    print(min_effort(n, k, strengths))",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054813
1390054811,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static int minDecommissioningCost(String servers) {
7
        int n = servers.length();
8
        int[] prefixOnes = new int[n + 1];
9
        int[] prefixZeros = new int[n + 1];
10
11
        for (int i = 0; i < n; i++) {
12
            prefixOnes[i + 1] = prefixOnes[i] + (servers.charAt(i) == '1' ? 1 : 0);
13
            prefixZeros[i + 1] = prefixZeros[i] + (servers.charAt(i) == '0' ? 1 : 0);
14
        }
15
16
        int minCost = Integer.MAX_VALUE;
17
18
        for (int start = 0; start <= n; start++) {
19
            for (int end = start; end <= n; end++) {
20
                int activeRemoved = prefixOnes[start] + (prefixOnes[n] - prefixOnes[end]);
21
                int idleRemaining = prefixZeros[end] - prefixZeros[start];
22
23
                int cost = Math.max(idleRemaining, activeRemoved);
24
                minCost = Math.min(minCost, cost);
25
            }
26
        }
27
28
        return minCost;
29
    }
30
31
    public static void main(String[] args) {
32
        Scanner sc = new Scanner(System.in);
33
        int t = sc.nextInt();
34
        sc.nextLine();
35
36
        while (t-- > 0) {
37
            String servers = sc.nextLine().trim();
38
            System.out.println(minDecommissioningCost(servers));
39
        }
40
41
        sc.close();
42
    }
43
}
44",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054811
1390054805,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054805
1390054807,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054807
1390054809,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054809
1390054800,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
    5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            dp[i][j] = dp[i-1][j] + strengths[i-1] + j
13
            14
            if j > 0:
15
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
16
    17
    return min(dp[n])
18
19
def solve():
20
    t = int(input().strip())
21
    results = []
22
    23
    for _ in range(t):
24
        n, k = map(int, input().strip().split())
25
        strengths = list(map(int, input().strip().split()))
26
        results.append(min_effort_to_breach(n, k, strengths))
27
    28
    for result in results:
29
        print(result)
30
31
if __name__ == ""__main__"":
32
    solve()",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054800
1390054799,unknown,unknown,unknown,"1
2
import math
3
4
def min_cost(s):
5
    n = len(s)
6
    zeros = s.count('0')
7
    ones = n - zeros
8
9
    min_cost = math.inf
10
    for i in range(n + 1):
11
        for j in range(n + 1):
12
            if i + j > n:
13
                break
14
            remaining_zeros = zeros - (s[:i].count('0') + s[n - j:].count('0'))
15
            decommissioned_ones = ones - s[i:n - j].count('1')
16
            cost = max(remaining_zeros, decommissioned_ones)
17
            min_cost = min(min_cost, cost)
18
19
    return min_cost
20
21
T = int(input())
22
for _ in range(T):
23
    s = input()
24
    print(min_cost(s))
25",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054799
1390054803,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054803
1390054798,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
} 3rd",65,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054798
1390054792,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054792
1390054793,unknown,unknown,unknown,"1
import sys
2
3
def can_achieve(X, pos, T):
4
    """"""
5
    Given candidate cost X, pos is the list of indices where s has '1',
6
    and T is total ones.
7
    We need to check if there is some integer u in [max(1, T - X), T]
8
    and some i with 0 <= i <= T - u such that:
9
         pos[i+u-1] - pos[i] + 1 <= u + X.
10
    """"""
11
    # Lower bound for u:
12
    u_min = max(1, T - X)
13
    # Try every possible u from u_min to T
14
    for u in range(u_min, T + 1):
15
        # For each block of u ones (in pos), check if minimal segment length is <= u + X.
16
        # We need to check i from 0 to T - u.
17
        for i in range(0, T - u + 1):
18
            seg_length = pos[i + u - 1] - pos[i] + 1
19
            if seg_length <= u + X:
20
                return True
21
    return False
22
23
def solve_server_pruning(s):
24
    T = s.count('1')
25
    # If there are no active servers, cost is 0.
26
    if T == 0:
27
        return 0
28
    n = len(s)
29
    # Create list of indices where s[i]=='1'
30
    pos = [i for i, ch in enumerate(s) if ch == '1']
31
    32
    # Binary search for the minimum possible cost X.
33
    lo, hi = 0, T  # X ranges between 0 and T.
34
    ans = hi
35
    while lo <= hi:
36
        mid = (lo + hi) // 2
37
        if can_achieve(mid, pos, T):
38
            ans = mid
39
            hi = mid - 1
40
        else:
41
            lo = mid + 1
42
    return ans
43
44
def main():
45
    data = sys.stdin.read().strip().split()
46
    t = int(data[0])
47
    outputs = []
48
    index = 1
49
    for _ in range(t):
50
        s = data[index]
51
        index += 1
52
        outputs.append(str(solve_server_pruning(s)))
53
    sys.stdout.write(""\n"".join(outputs))
54
55
if __name__ == '__main__':
56
    main()
57",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054793
1390054786,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <climits>
7
using namespace std;
8
9
void solve(){
10
    int n,k;
11
    cin>>n>>k;
12
    13
    vector<int> a(n);
14
    long long sum_a = 0;
15
16
    for (int i = 0; i < n; i++) {
17
        cin >> a[i];
18
        sum_a += a[i];
19
    }
20
21
    vector<long long> values;
22
    for (int i = 0; i < n; i++) {
23
        long long val = a[i] - (n - i - 1LL);
24
        values.push_back(val);
25
    }
26
27
    sort(values.rbegin(), values.rend());
28
29
    vector<long long> prefixSum(n + 1, 0);
30
    prefixSum[0] = 0;
31
    for (int i = 1; i <= n; i++) {
32
        prefixSum[i] = prefixSum[i - 1] + values[i - 1];
33
    }
34
35
    int max_m = min(k, n);
36
    long long maxTotal = LLONG_MIN;
37
    for (int m = 0; m <= max_m; m++) {
38
        long long current = prefixSum[m] + ((long long)m * (m - 1)) / 2;
39
        if (current > maxTotal) {
40
            maxTotal = current;
41
        }
42
    }
43
44
    long long minEffort = sum_a - maxTotal;
45
    cout << minEffort << ""\n"";
46
    47
}
48
49
50
int main() {
51
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
52
    int t;
53
    cin>>t;
54
    55
    while(t--){
56
        solve();
57
    }
58
    59
    return 0;
60
}
61",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054786
1390054789,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx+1])
10
        idx +=2
11
        a = list(map(int, input[idx:idx+n]))
12
        idx +=n
13
        sum_a = sum(a)
14
        v = []
15
        for i in range(n):
16
            val = a[i] - (n - i -1)
17
            v.append(val)
18
        v.sort(reverse=True)
19
        prefix = [0] * (n+1)
20
        for i in range(n):
21
            prefix[i+1] = prefix[i] + v[i]
22
        max_sum = 0
23
        max_t = min(k, n)
24
        for t in range(0, max_t+1):
25
            current = prefix[t] + t*(t-1)//2
26
            if current > max_sum:
27
                max_sum = current
28
        print(sum_a - max_sum)
29
30
if __name__ == ""__main__"":
31
    main()",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054789
1390054787,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
   12
    for i in range(len(arr) - k + 1):
13
       14
        result.append(arr[dq[0]] if dq else 0)
15
        16
        17
        if dq and dq[0] == i:
18
            dq.popleft()
19
        20
       21
        if i + k < len(arr) and arr[i + k] < 0:
22
            dq.append(i + k)
23
    24
    return result
25
26
def process_test_cases(t, test_cases):
27
    results = []
28
    for n, k, arr in test_cases:
29
        results.append("" "".join(map(str, earliest_faults(arr, k))))
30
    return ""\n"".join(results)
31
32
33
t = int(input())
34
test_cases = []
35
for _ in range(t):
36
    n, k = map(int, input().split())
37
    arr = list(map(int, input().split()))
38
    test_cases.append((n, k, arr))
39
40
41
print(process_test_cases(t, test_cases))",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054787
1390054783,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx+1])
10
        idx +=2
11
        a = list(map(int, input[idx:idx+n]))
12
        idx +=n
13
        sum_a = sum(a)
14
        v = []
15
        for i in range(n):
16
            val = a[i] - (n - i -1)
17
            v.append(val)
18
        v.sort(reverse=True)
19
        prefix = [0] * (n+1)
20
        for i in range(n):
21
            prefix[i+1] = prefix[i] + v[i]
22
        max_sum = 0
23
        max_t = min(k, n)
24
        for t in range(0, max_t+1):
25
            current = prefix[t] + t*(t-1)//2
26
            if current > max_sum:
27
                max_sum = current
28
        print(sum_a - max_sum)
29
30
if __name__ == ""__main__"":
31
    main()",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054783
1390054784,unknown,unknown,unknown,"1
def min_decommission_cost(s):
2
    n = len(s)
3
    prefix_zeros = [0] * (n + 1)
4
    prefix_ones = [0] * (n + 1)
5
6
    # Compute prefix sums for '0's and '1's
7
    for i in range(n):
8
        prefix_zeros[i + 1] = prefix_zeros[i] + (s[i] == '0')
9
        prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')
10
11
    min_cost = n
12
13
    # Try removing `l` from the left and `r` from the right
14
    for l in range(n + 1):
15
        for r in range(n - l + 1):
16
            remaining_zeros = prefix_zeros[n - r] - prefix_zeros[l]
17
            removed_ones = prefix_ones[l] + (prefix_ones[n] - prefix_ones[n - r])
18
            min_cost = min(min_cost, max(remaining_zeros, removed_ones))
19
20
    return min_cost
21
22
# Read input
23
t = int(input())
24
for _ in range(t):
25
    print(min_decommission_cost(input()))
26",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054784
1390054785,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054785
1390054782,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        benefits = []
12
        for i in range(n):
13
            benefit = a[i] - (n - i - 1)
14
            benefits.append((benefit, i))
15
        16
        # Sort by benefit descending
17
        benefits.sort(reverse=True)
18
19
        skipped = [False] * n
20
21
        # Mark the top k firewalls to skip
22
        for i in range(k):
23
            _, idx = benefits[i]
24
            skipped[idx] = True
25
26
        # Calculate total effort
27
        total_effort = 0
28
        penalty = 0  # number of skipped firewalls so far
29
        for i in range(n):
30
            if skipped[i]:
31
                penalty += 1
32
            else:
33
                total_effort += a[i] + penalty
34
35
        print(total_effort)
36
37
# Run main() inside a separate thread to avoid recursion limit issues in large input
38
threading.Thread(target=main).start()",66,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054782
1390054779,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
3
    n = len(firewalls)
4
5
    6
7
    if k >= n:
8
9
        return 0
10
11
12
13
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
14
15
    16
17
    18
19
    for j in range(k + 1):
20
21
        dp[n][j] = 0
22
23
    24
25
26
27
    for i in range(n - 1, -1, -1):
28
29
        for j in range(k + 1):
30
31
            32
33
            if j < k:
34
35
                dp[i][j] = dp[i + 1][j + 1]
36
37
            38
39
            40
41
            effort = firewalls[i] + j 
42
43
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
44
45
    46
47
    return dp[0][0]
48
49
50
51
t = int(input())
52
53
for _ in range(t):
54
55
    n, k = map(int, input().split())
56
57
    firewalls = list(map(int, input().split()))
58
59
    result = min_effort(firewalls, k)
60
61
    print(result)",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054779
1390054780,unknown,unknown,unknown,"1
def min_cost_server_pruning(server_rack):
2
3
    n = len(server_rack)
4
5
    6
7
    # Precompute cumulative counts
8
9
    active_prefix_sum = [0] * (n + 1)
10
11
    idle_suffix_sum = [0] * (n + 1)
12
13
    14
15
    for i in range(n):
16
17
        active_prefix_sum[i+1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
18
19
    20
21
    for i in range(n-1, -1, -1):
22
23
        idle_suffix_sum[i] = idle_suffix_sum[i+1] + (1 if server_rack[i] == '0' else 0)
24
25
    26
27
    min_cost = float('inf')
28
29
    30
31
    # For each possible prefix and suffix to remove
32
33
    for left in range(n + 1):
34
35
        for right in range(left, n + 1):
36
37
            # Active servers decommissioned (from start and end)
38
39
            active_removed = active_prefix_sum[left] + (active_prefix_sum[n] - active_prefix_sum[right])
40
41
            42
43
            # Idle servers remaining in the middle
44
45
            idle_remaining = idle_suffix_sum[left] - idle_suffix_sum[right]
46
47
            48
49
            cost = max(idle_remaining, active_removed)
50
51
            min_cost = min(min_cost, cost)
52
53
    54
55
    return min_cost
56
57
t = int(input())
58
59
for _ in range(t):
60
61
    server_rack = input().strip()
62
63
    print(min_cost_server_pruning(server_rack))",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054780
1390054778,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    min_cost = float('inf')
6
7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            remaining = s[i:n - j]
10
            11
            idle_count = remaining.count('0')
12
            removed_count = i + j - (n - len(remaining))
13
            14
            removed_ones = 0
15
            for k in range(i):
16
                if s[k] == '1':
17
                    removed_ones += 1
18
            for k in range(n-j, n):
19
                if s[k] == '1':
20
                    removed_ones += 1
21
            22
            23
            cost = max(idle_count, removed_ones)
24
            min_cost = min(min_cost, cost)
25
    26
    print(min_cost)
27
28
t = int(input())
29
for _ in range(t):
30
    solve()
31
32",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054778
1390054772,unknown,unknown,unknown,"1
def solve():
2
    """"""Solves the server decommissioning problem.""""""
3
4
    T = int(input())
5
    for _ in range(T):
6
        servers = input().strip()
7
        n = len(servers)
8
9
        min_cost = float('inf')
10
11
        for i in range(n + 1):  # Remove i from start
12
            for j in range(n - i + 1):  # Remove j from end
13
                remaining = servers[i:n - j]
14
15
                idle_count = remaining.count('0')
16
                active_removed = servers[:i].count('1') + servers[n - j:].count('1')
17
18
                min_cost = min(min_cost, max(idle_count, active_removed))
19
20
        print(min_cost)
21
22
solve()
23",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054772
1390054774,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    memo = {}
3
    4
    def dp(pos, skips_left, penalty):
5
        if pos == n:
6
            return 0
7
            8
        if (pos, skips_left, penalty) in memo:
9
            return memo[(pos, skips_left, penalty)]
10
            11
        current_strength = strengths[pos] + penalty
12
        13
        min_effort = current_strength + dp(pos + 1, skips_left, penalty)
14
        15
        if skips_left > 0:
16
            skip_effort = dp(pos + 1, skips_left - 1, penalty + 1)
17
            min_effort = min(min_effort, skip_effort)
18
            19
        memo[(pos, skips_left, penalty)] = min_effort
20
        return min_effort
21
    22
    return dp(0, k, 0)
23
24
def solve():
25
    t = int(input())
26
    27
    results = []
28
    for _ in range(t):
29
        n, k = map(int, input().split())
30
        strengths = list(map(int, input().split()))
31
        32
        result = min_effort_to_breach(n, k, strengths)
33
        results.append(result)
34
    35
    for result in results:
36
        print(result)
37
38
if __name__ == ""__main__"":
39
    solve()",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054774
1390054775,unknown,unknown,unknown,"1
import sys  
2
from itertools import accumulate  
3
4
def min_effort(arr, k):  
5
    n = len(arr)  
6
    T = sum(arr)  
7
    A = [arr[i] + (i + 1) for i in range(n)]  
8
    A.sort(reverse=True)  
9
    P = [0] + list(accumulate(A))  
10
    m_max = min(k, n)  
11
    best = float('inf')  
12
    13
    for m in range(m_max + 1):  
14
        cost = T + m * n - (m * m - m) // 2 - P[m]  
15
        if cost < best:  
16
            best = cost  
17
            18
    return best  
19
20
def solve():  
21
    data = sys.stdin.read().strip().split()  
22
    if not data:  
23
        return  
24
    t = int(data[0])  
25
    index = 1  
26
    res = []  
27
    28
    for _ in range(t):  
29
        n = int(data[index])  
30
        index += 1  
31
        k = int(data[index])  
32
        index += 1  
33
        arr = list(map(int, data[index:index + n]))  
34
        index += n  
35
        res.append(str(min_effort(arr, k)))  
36
        37
    sys.stdout.write(""\n"".join(res) + ""\n"")  
38
39
if __name__ == ""__main__"":  
40
    solve()      ",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054775
1390054768,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
5
    results = []
6
7
    8
9
    for case in test_cases:
10
11
        n, k, arr = case
12
13
        dq = deque()
14
15
        res = []
16
17
        # Process the first batch separately
18
19
        for i in range(k):
20
21
            if arr[i] < 0:
22
23
                dq.append(i)
24
25
        26
27
        # Store the earliest faulty reading for the first batch
28
29
        res.append(arr[dq[0]] if dq else 0)
30
31
        # Process remaining batches
32
33
        for i in range(k, n):
34
35
            # Remove out-of-window elements
36
37
            if dq and dq[0] < i - k + 1:
38
39
                dq.popleft()
40
41
            42
43
            # Add new element if faulty
44
45
            if arr[i] < 0:
46
47
                dq.append(i)
48
49
            # Store the earliest faulty reading for the current batch
50
51
            res.append(arr[dq[0]] if dq else 0)
52
53
        54
55
        results.append(res)
56
57
    58
59
    return results
60
61
# Input handling
62
63
t = int(input())  # Number of test cases
64
65
test_cases = []
66
67
for _ in range(t):
68
69
    n, k = map(int, input().split())
70
71
    arr = list(map(int, input().split()))
72
73
    test_cases.append((n, k, arr))
74
75
# Processing and Output
76
77
for res in earliest_faulty_readings(test_cases):
78
79
    print(*res)",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054768
1390054770,unknown,unknown,unknown,"1
def min_effort_to_breath(n, k, firewalls):
2
    firewalls.sort()
3
    return sum(firewalls[:n-k]) if k > 0 else sum(firewalls)
4
5
T = int(input().strip())
6
for _ in range(T):
7
    n, k = map(int, input().split())
8
    firewalls = list(map(int, input().split()))
9
    print(min_effort_to_breath(n, k, firewalls))",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054770
1390054771,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class BinaryStringMinCost {
4
    5
    public static boolean check(int k, String s, int n, int[] prefix0, int[] prefix1) {
6
        int l = 0;
7
8
        for (int r = 0; r < n; r++) {
9
            while (l <= r && (prefix0[r + 1] - prefix0[l]) > k) {
10
                l++;
11
            }
12
            // Check number of '1's decommissioned
13
            if (l <= r && (prefix1[l] + (prefix1[n] - prefix1[r + 1])) <= k) {
14
                return true;
15
            }
16
        }
17
18
        return prefix1[n] <= k;
19
    }
20
21
    public static int findMinCost(String s) {
22
        int n = s.length();
23
24
        // Prefix sum arrays
25
        int[] prefix0 = new int[n + 1];
26
        int[] prefix1 = new int[n + 1];
27
28
        for (int i = 1; i <= n; i++) {
29
            prefix0[i] = prefix0[i - 1] + (s.charAt(i - 1) == '0' ? 1 : 0);
30
            prefix1[i] = prefix1[i - 1] + (s.charAt(i - 1) == '1' ? 1 : 0);
31
        }
32
33
        // Binary search for minimum cost
34
        int low = 0, high = n;
35
        while (low < high) {
36
            int mid = (low + high) / 2;
37
            if (check(mid, s, n, prefix0, prefix1)) {
38
                high = mid;
39
            } else {
40
                low = mid + 1;
41
            }
42
        }
43
44
        return low;
45
    }
46
47
    public static void main(String[] args) {
48
        Scanner sc = new Scanner(System.in);
49
50
        int T = sc.nextInt();
51
        while (T-- > 0) {
52
            String s = sc.next();
53
            System.out.println(findMinCost(s));
54
        }
55
56
        sc.close();
57
    }
58
}",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054771
1390054762,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <algorithm> // For count()
4
using namespace std;
5
6
int min_decommissioning_cost(string server_rack) {
7
    size_t first_one = server_rack.find('1');
8
    size_t last_one = server_rack.rfind('1');
9
10
    // If there are no active servers (all 0s), cost is 0
11
    if (first_one == string::npos) {
12
        return 0;
13
    }
14
15
    // Extract the core segment containing all necessary servers
16
    string core_segment = server_rack.substr(first_one, last_one - first_one + 1);
17
18
    // Count remaining idle servers (0s)
19
    int remaining_idle = count(core_segment.begin(), core_segment.end(), '0');
20
21
    // Count removed active servers (1s) from the prefix and suffix
22
    int removed_active = count(server_rack.begin(), server_rack.begin() + first_one, '1') +
23
                         count(server_rack.begin() + last_one + 1, server_rack.end(), '1');
24
25
    // Return the minimum cost
26
    return max(remaining_idle, removed_active);
27
}
28
29
int main() {
30
    int T;
31
    cin >> T; // Number of test cases
32
    while (T--) {
33
        string server_rack;
34
        cin >> server_rack;
35
        cout << min_decommissioning_cost(server_rack) << endl;
36
    }
37
    return 0;
38
}
39",67,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054762
1390054755,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        res = []
8
        dq = deque()
9
        10
        # Process first k elements
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
        15
        # Process the rest of the elements
16
        for i in range(n - k + 1):
17
            # Add the first faulty element or 0 if none
18
            res.append(arr[dq[0]] if dq else 0)
19
            20
            # Remove elements that are out of the current window
21
            if dq and dq[0] == i:
22
                dq.popleft()
23
            24
            # Add the next element
25
            if i + k < n and arr[i + k] < 0:
26
                dq.append(i + k)
27
        28
        results.append("" "".join(map(str, res)))
29
    30
    return results
31
32
# Read input
33
t = int(input())
34
test_cases = []
35
36
for _ in range(t):
37
    n, k = map(int, input().split())
38
    arr = list(map(int, input().split()))
39
    test_cases.append((n, k, arr))
40
41
# Process and output results
42
for result in earliest_faulty_readings(test_cases):
43
    print(result)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054755
1390054759,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
3
    # Create all possible scenarios of skipping up to k firewalls
4
5
    min_total_effort = float('inf')
6
7
    8
9
    # Try all combinations of which firewalls to skip
10
11
    # Since k can be up to 10 and n up to 100, we can't try all 2^n combinations
12
13
    # Instead, we'll use dynamic programming
14
15
    16
17
    # dp[i][j] = min effort to breach first i firewalls while skipping exactly j of them
18
19
    dp = [[float('inf') for _ in range(k+1)] for _ in range(n+1)]
20
21
    dp[0][0] = 0  # Base case: no effort to breach 0 firewalls with 0 skips
22
23
    24
25
    for i in range(1, n+1):
26
27
        current_strength = strengths[i-1]
28
29
        30
31
        # Don't skip the current firewall
32
33
        for j in range(k+1):
34
35
            if dp[i-1][j] != float('inf'):
36
37
                # Current firewall strength increases by j (number of previously skipped firewalls)
38
39
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
40
41
        42
43
        # Skip the current firewall
44
45
        for j in range(1, k+1):
46
47
            if dp[i-1][j-1] != float('inf'):
48
49
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
50
51
    52
53
    # Find minimum across all possible numbers of skips
54
55
    return min(dp[n])
56
57
def solve_test_cases():
58
59
    t = int(input())  # Number of test cases
60
61
    62
63
    results = []
64
65
    for _ in range(t):
66
67
        n, k = map(int, input().split())
68
69
        strengths = list(map(int, input().split()))
70
71
        72
73
        min_effort = min_effort_to_breach(n, k, strengths)
74
75
        results.append(min_effort)
76
77
    78
79
    return results
80
81
# Main execution
82
83
if __name__ == ""__main__"":
84
85
    results = solve_test_cases()
86
87
    for result in results:
88
89
        print(result)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054759
1390054760,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <algorithm>
4
#include <vector>
5
6
using namespace std;
7
8
int solve() {
9
    string s;
10
    cin >> s;
11
    int n = s.length();
12
    int min_cost = n;
13
14
    for (int i = 0; i <= n; ++i) {
15
        for (int j = i; j <= n; ++j) {
16
            int remaining_zeros = 0;
17
            for (int k = i; k < j; ++k) {
18
                if (s[k] == '0') {
19
                    remaining_zeros++;
20
                }
21
            }
22
23
            int removed_ones = 0;
24
            for (int k = 0; k < i; ++k) {
25
                if (s[k] == '1') {
26
                    removed_ones++;
27
                }
28
            }
29
            for (int k = j; k < n; ++k) {
30
                if (s[k] == '1') {
31
                    removed_ones++;
32
                }
33
            }
34
35
            min_cost = min(min_cost, max(remaining_zeros, removed_ones));
36
        }
37
    }
38
    return min_cost;
39
}
40
41
int main() {
42
    int t;
43
    cin >> t;
44
    while (t--) {
45
        cout << solve() << endl;
46
    }
47
    return 0;
48
}",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054760
1390054750,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    4
    for j in range(k + 1):
5
        dp[0][j] = 0
6
    7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            if j > 0:
10
                dp[i][j] = dp[i-1][j-1]
11
            12
            current_strength = strengths[i-1] + j 
13
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
14
    15
    return min(dp[n])
16
17
def solve():
18
    t = int(input())
19
    results = []
20
    21
    for _ in range(t):
22
        n, k = map(int, input().split())
23
        strengths = list(map(int, input().split()))
24
        results.append(min_effort_to_breach(n, k, strengths))
25
    26
    for result in results:
27
        print(result)
28
29
solve()",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054750
1390054753,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        result = []
8
        dq = deque()
9
        10
        # Process first window
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
        15
        # Store the first result
16
        result.append(arr[dq[0]] if dq else 0)
17
        18
        # Process remaining windows
19
        for i in range(k, n):
20
            # Remove elements no longer in window
21
            if dq and dq[0] <= i - k:
22
                dq.popleft()
23
            24
            # Add new element if it's faulty
25
            if arr[i] < 0:
26
                dq.append(i)
27
            28
            # Store result for current window
29
            result.append(arr[dq[0]] if dq else 0)
30
        31
        results.append("" "".join(map(str, result)))
32
    33
    return results
34
35
# Read input
36
t = int(input())
37
test_cases = []
38
for _ in range(t):
39
    n, k = map(int, input().split())
40
    arr = list(map(int, input().split()))
41
    test_cases.append((n, k, arr))
42
43
# Compute and print output
44
for res in earliest_faulty_readings(test_cases):
45
    print(res)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054753
1390054751,unknown,unknown,unknown,"1
import sys
2
data = sys.stdin.read().split()
3
if not data:
4
    exit()
5
t = int(data[0])
6
ptr = 1
7
res = []
8
for _ in range(t):
9
    n = int(data[ptr]); k = int(data[ptr+1]); ptr += 2
10
    arr = list(map(int, data[ptr:ptr+n])); ptr += n
11
    total = sum(arr)
12
    b = [arr[i] - ((n - 1) - i) for i in range(n)]
13
    b.sort(reverse=True)
14
    best = 0
15
    s = 0
16
    for x in range(1, min(k, n) + 1):
17
        s += b[x-1]
18
        cur = s + (x * (x - 1)) // 2
19
        if cur > best:
20
            best = cur
21
    res.append(str(total - best))
22
sys.stdout.write(""\n"".join(res))",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054751
1390054743,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
        5
    impacts = []
6
    7
    for i in range(n):
8
        impact = strengths[i] - (n - i - 1)
9
        impacts.append((impact, i))
10
    11
    impacts.sort(reverse=True)
12
    13
    to_skip = set(impacts[i][1] for i in range(k))
14
    15
    total_effort = 0
16
    penalty = 0
17
    18
    for i in range(n):
19
        if i in to_skip:
20
            penalty += 1
21
        else:
22
            total_effort += strengths[i] + penalty
23
    24
    return total_effort
25
26
def solve_test_cases():
27
    t = int(input())
28
    results = []
29
    30
    for _ in range(t):
31
        n, k = map(int, input().split())
32
        strengths = list(map(int, input().split()))
33
        results.append(min_effort_to_breach(n, k, strengths))
34
    35
    return results
36
37
def main():
38
    results = solve_test_cases()
39
    40
    for result in results:
41
        print(result)
42
43
if __name__ == ""__main__"":
44
    main()
45",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054743
1390054746,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, fw):
2
    total_effort = sum(fw)
3
    min_effort = total_effort
4
5
    for i in range(n - k + 1):  
6
        skipped_penalty = sum(fw[i:i + k])
7
        added_penalty = (n - (i + k)) * k  
8
        min_effort = min(min_effort, total_effort - skipped_penalty + added_penalty)
9
10
    return min_effort
11
12
T = int(input())  
13
for _ in range(T):
14
    n, k = map(int, input().split())
15
    fw = list(map(int, input().split()))
16
    print(min_effort_to_breach(n, k, fw))
17",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054746
1390054747,unknown,unknown,unknown,"1
def min_operations(T, test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        6
        prefix_0 = [0] * (n + 1)
7
        prefix_1 = [0] * (n + 1)
8
        9
        for i in range(1, n + 1):
10
            prefix_0[i] = prefix_0[i - 1] + (1 if s[i - 1] == '0' else 0)
11
            prefix_1[i] = prefix_1[i - 1] + (1 if s[i - 1] == '1' else 0)
12
        13
        def check(k):
14
            l = 0
15
            for r in range(n):
16
                while l <= r and prefix_0[r + 1] - prefix_0[l] > k:
17
                    l += 1
18
                if l <= r and prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k:
19
                    return True
20
            21
            return prefix_1[n] <= k
22
        23
        low, high = 0, n
24
        while low < high:
25
            mid = (low + high) // 2
26
            if check(mid):
27
                high = mid
28
            else:
29
                low = mid + 1
30
        31
        results.append(low)
32
    33
    return results
34
35
36
37
T = int(input())
38
test_cases = [input().strip() for _ in range(T)]
39
40
results = min_operations(T, test_cases)
41
for res in results:
42
    print(res)
43",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054747
1390054740,unknown,unknown,unknown,"1
def earliest_faulty_reading(test_cases):
2
    results = []
3
    4
    for n, k, arr in test_cases:
5
        batch_results = []
6
        7
        for i in range(n - k + 1):
8
            batch = arr[i:i + k]
9
            faulty = next((x for x in batch if x < 0), 0)
10
            batch_results.append(faulty)
11
        12
        results.append(batch_results)
13
    14
    return results
15
16
17
if ___name___ == ""___main___"":
18
    t = int(input())
19
    test_cases = []
20
    21
    for _ in range(t):
22
        n, k = map(int, input().strip().split())
23
        arr = list(map(int, input().strip().split()))
24
        test_cases.append((n, k, arr))
25
26
    results = earliest_faulty_reading(test_cases)
27
    28
    for res in results:
29
        print(*res)",68,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054740
1390054731,unknown,unknown,unknown,"1
cases = int(input())
2
for t in range(cases):
3
    n,k = [int(i) for i in input().split()]
4
    array = [int(i) for i in input().split()]
5
    if n == k:
6
        print(0)
7
        continue
8
    batch_sum = [0]*n
9
    for i in range(n):
10
        batch_sum[i] = sum(array[i:i+k])
11
    total = sum(array)
12
    best = total
13
    for i in range(n):
14
        if i + k <= n:
15
            best = min(best, total - batch_sum[i] + n-i-k)
16
        else:
17
            best = min(best, total - batch_sum[i])
18
    print(best)
19
        20
        21
    22
    23
    24
    25
    ",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054731
1390054736,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void findEarliestFaultyReadings(int *arr, int n, int k) {
5
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
6
    int front = 0, rear = 0;
7
    int queue[n];
8
    9
    // Process the first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) {
12
            queue[rear++] = i;
13
        }
14
    }
15
    16
    // Store result for the first batch
17
    result[0] = (front < rear) ? arr[queue[front]] : 0;
18
    19
    // Process the remaining windows
20
    for (int i = k; i < n; i++) {
21
        // Remove elements not within the window
22
        while (front < rear && queue[front] <= i - k) {
23
            front++;
24
        }
25
        26
        // Add new element if it's faulty
27
        if (arr[i] < 0) {
28
            queue[rear++] = i;
29
        }
30
        31
        // Store result for current batch
32
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
33
    }
34
    35
    // Print the result
36
    for (int i = 0; i < n - k + 1; i++) {
37
        printf(""%d "", result[i]);
38
    }
39
    printf(""\n"");
40
    41
    free(result);
42
}
43
44
int main() {
45
    int t;
46
    scanf(""%d"", &t);
47
    48
    while (t--) {
49
        int n, k;
50
        scanf(""%d %d"", &n, &k);
51
        int arr[n];
52
        53
        for (int i = 0; i < n; i++) {
54
            scanf(""%d"", &arr[i]);
55
        }
56
        57
        findEarliestFaultyReadings(arr, n, k);
58
    }
59
    60
    return 0;
61
}
62",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054736
1390054738,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
import sys
3
4
def main():
5
    input = sys.stdin.read
6
    data = input().split(""\n"")
7
    8
    t = int(data[0])  # Number of test cases
9
    index = 1
10
11
    results = []
12
    for _ in range(t):
13
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
14
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
15
        index += 2
16
        17
        if k >= n:
18
            results.append(""0"")
19
            continue
20
        21
        # Calculate the impact of each firewall: strength + index
22
        impact = [(strengths[i] + i, i) for i in range(n)]
23
        24
        # Sort firewalls by impact (higher impact should be skipped first)
25
        impact.sort(reverse=True)
26
        27
        # Select the top k firewalls to skip
28
        to_skip = set(idx for _, idx in impact[:k])
29
        30
        # Compute the minimal effort
31
        effort = 0
32
        skipped = 0
33
        34
        for i in range(n):
35
            if i in to_skip:
36
                skipped += 1
37
            else:
38
                effort += strengths[i] + skipped
39
        40
        results.append(str(effort))
41
    42
    # Print all results at once (faster output handling)
43
    sys.stdout.write(""\n"".join(results) + ""\n"")
44
45
if _name_ == ""_main_"":
46
    main()
47",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054738
1390054729,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <string.h>
3
#include <math.h>
4
#include <stdlib.h>
5
void findreading(int n,int k,int arr[]){
6
        for (int i = 0; i <= n - k; i++) {  
7
        int found = 0;  
8
        for (int j = i; j < i + k; j++) {
9
            if (arr[j] < 0) {
10
                printf(""%d "", arr[j]);  
11
                found = 1;
12
                break;
13
            }
14
        }
15
16
        if (!found) {
17
            printf(""0 "");  
18
        }
19
    }
20
    printf(""\n"");  
21
}
22
int main() {
23
    int t;
24
    scanf(""%d"", &t);  
25
26
    for (int i = 0; i < t; i++) {
27
        int n, k;
28
        scanf(""%d %d"", &n, &k);  
29
30
        int arr[n];  
31
32
        for (int j = 0; j < n; j++) {  
33
            scanf(""%d"", &arr[j]);  
34
        }
35
36
        findreading(n, k, arr);  
37
    }
38
39
    return 0;
40
}",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054729
1390054728,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }  
19
        auto check = [&](int k) {
20
            int l = 0;
21
         22
            for (int r = 0; r < n; r++) {
23
              24
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
25
                    l++;
26
                }
27
                // wtf ,  check number of 1's decommissioned
28
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
29
                    return true;
30
                }
31
            }
32
      33
            if (prefix_1[n] <= k) {
34
                return true;
35
            }
36
            return false;
37
        };
38
39
        // Binary search for minimum cost
40
        int low = 0, high = n;
41
        while (low < high) {
42
            int mid = (low + high) / 2;
43
            if (check(mid)) {
44
                high = mid;
45
            } else {
46
                low = mid + 1;
47
            }
48
        }
49
        cout << low << endl;
50
    }
51
    return 0;
52
}",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054728
1390054721,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    """"""
3
    Calculate the minimum cost of decommissioning servers with advanced optimization.
4
    5
    Args:
6
        servers (str): Binary string representing rack of servers (0 for idle, 1 for active)
7
    8
    Returns:
9
        int: Minimum possible cost
10
    """"""
11
    n = len(servers)
12
    13
    # Convert string to list of integers for faster processing
14
    servers_list = [int(s) for s in servers]
15
    16
    # Precompute prefix sums for active and idle servers
17
    prefix_active = [0] * (n + 1)
18
    prefix_idle = [0] * (n + 1)
19
    20
    for i in range(n):
21
        prefix_active[i + 1] = prefix_active[i] + servers_list[i]
22
        prefix_idle[i + 1] = prefix_idle[i] + (1 - servers_list[i])
23
    24
    total_active = prefix_active[n]
25
    total_idle = prefix_idle[n]
26
    27
    min_cost = float('inf')
28
    29
    # Optimize the nested loop by reducing redundant calculations
30
    for i in range(n + 1):
31
        # Active servers decommissioned from the beginning
32
        active_decom_begin = prefix_active[i]
33
        34
        # For each prefix (servers removed from beginning), 
35
        # find the optimal suffix to remove
36
        for j in range(n + 1 - i):
37
            # If we've already found a better solution than what's possible here, skip
38
            if min_cost == 0:  # Perfect solution already found
39
                return 0
40
                41
            # Active servers decommissioned from the end
42
            active_decom_end = total_active - prefix_active[n-j] if j > 0 else 0
43
            active_decommissioned = active_decom_begin + active_decom_end
44
            45
            # Idle servers remaining
46
            idle_remaining = total_idle - (prefix_idle[i] + (prefix_idle[n] - prefix_idle[n-j]))
47
            48
            cost = max(idle_remaining, active_decommissioned)
49
            min_cost = min(min_cost, cost)
50
            51
            # Early termination if we've found a perfect solution
52
            if min_cost == 0:
53
                return 0
54
    55
    return min_cost
56
57
def main():
58
    # Read number of test cases
59
    t = int(input().strip())
60
    61
    for _ in range(t):
62
        servers = input().strip()
63
        print(min_decommissioning_cost(servers))
64
65
if __name__ == ""__main__"":
66
    main()",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054721
1390054723,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    min_total_effort = float('inf')
3
    dp = [[float('inf') for _ in range(k+1)] for _ in range(n+1)]
4
    dp[0][0] = 0  
5
    for i in range(1, n+1):
6
        current_strength = strengths[i-1]
7
        for j in range(k+1):
8
            if dp[i-1][j] != float('inf'):
9
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
10
        for j in range(1, k+1):
11
            if dp[i-1][j-1] != float('inf'):
12
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
13
    return min(dp[n])
14
def solve_test_cases():
15
    t = int(input())
16
    results = []
17
    for _ in range(t):
18
        n, k = map(int, input().split())
19
        strengths = list(map(int, input().split()))
20
        min_effort = min_effort_to_breach(n, k, strengths)
21
        results.append(min_effort)
22
    return results
23
if __name__ == ""__main__"":
24
    results = solve_test_cases()
25
    for result in results:
26
        print(result)",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054723
1390054726,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Main {
5
    public static void main(String[] args) throws IOException {
6
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
7
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
8
        9
        int t = Integer.parseInt(br.readLine());
10
        11
        while (t-- > 0) {
12
            String[] nk = br.readLine().split("" "");
13
            int n = Integer.parseInt(nk[0]);
14
            int k = Integer.parseInt(nk[1]);
15
            16
            String[] input = br.readLine().split("" "");
17
            int[] a = new int[n];
18
            for (int i = 0; i < n; i++) a[i] = Integer.parseInt(input[i]);
19
            20
            bw.write(minEffort(n, k, a) + ""\n"");
21
        }
22
        23
        bw.flush();
24
        bw.close();
25
        br.close();
26
    }
27
28
    static int minEffort(int n, int k, int[] a) {
29
        int[] dp = new int[k + 2];
30
        31
        for (int i = n - 1; i >= 0; i--) {
32
            int[] next = new int[k + 2];
33
            for (int skip = 0; skip <= k; skip++) {
34
                int take = a[i] + skip + dp[skip]; 
35
                int leave = (skip < k) ? dp[skip + 1] : Integer.MAX_VALUE; 
36
                next[skip] = Math.min(take, leave);
37
            }
38
            dp = next;
39
        }
40
        41
        return dp[0];
42
    }
43
}
44",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054726
1390054717,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        min_cost = float('inf')
7
        8
        # Iterate over all possible prefixes to remove
9
        for start in range(n + 1):
10
            # Iterate over all possible suffixes to remove
11
            for end in range(n - start + 1):
12
                # Remaining servers after removing `start` from the front and `end` from the back
13
                remaining = servers[start:n-end] if end > 0 else servers[start:n]
14
                15
                # Count remaining idle servers (0's) and decommissioned active servers (1's)
16
                remaining_idle = remaining.count('0')
17
                decommissioned_active = (servers[:start] + servers[n-end:]).count('1')
18
                19
                # Calculate the cost
20
                cost = max(remaining_idle, decommissioned_active)
21
                22
                # Update the minimum cost
23
                min_cost = min(min_cost, cost)
24
        25
        results.append(min_cost)
26
    27
    return results
28
29
# Input reading
30
T = int(input())
31
test_cases = [input().strip() for _ in range(T)]
32
33
# Get results
34
results = min_decommissioning_cost(test_cases)
35
36
# Output results
37
for result in results:
38
    print(result)",69,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054717
1390054710,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        result = []
8
        dq = deque()
9
        10
        # Process first window
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
        15
        # Store the first result
16
        result.append(arr[dq[0]] if dq else 0)
17
        18
        # Process remaining windows
19
        for i in range(k, n):
20
            # Remove elements no longer in window
21
            if dq and dq[0] <= i - k:
22
                dq.popleft()
23
            24
            # Add new element if it's faulty
25
            if arr[i] < 0:
26
                dq.append(i)
27
            28
            # Store result for current window
29
            result.append(arr[dq[0]] if dq else 0)
30
        31
        results.append("" "".join(map(str, result)))
32
    33
    return results
34
35
# Read input
36
t = int(input())
37
test_cases = []
38
for _ in range(t):
39
    n, k = map(int, input().split())
40
    arr = list(map(int, input().split()))
41
    test_cases.append((n, k, arr))
42
43
# Compute and print output
44
for res in earliest_faulty_readings(test_cases):
45
    print(res)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054710
1390054711,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <climits>
7
using namespace std;
8
9
int minEffort(vector<int>& firewalls, int n, int k){
10
    int mineffort = INT_MAX;
11
    for(int skip = 0; skip<=k && skip<=n; skip++){
12
        int effort = 0;
13
        for(int i=skip; i<n; i++){
14
            effort += firewalls[i] + skip;
15
        }
16
        mineffort = mineffort<=effort? mineffort:effort;
17
    }
18
    return mineffort;
19
}
20
21
int main() {
22
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
23
    int t;
24
    cin>>t;
25
    while(t--){
26
        int n, k;
27
        cin>>n>>k;
28
        vector<int> firewalls(n);
29
        for(int i=0; i<n; i++){
30
            cin>>firewalls[i];
31
        }
32
        cout<<minEffort(firewalls, n, k)<<endl;
33
    }
34
    return 0;
35
}
36",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054711
1390054712,unknown,unknown,unknown,"1
import sys
2
3
def min_decommission_cost(server_string):
4
    n = len(server_string)
5
    total_ones = server_string.count('1')
6
7
    # Edge cases: If all are '0's or all are '1's
8
    if total_ones == 0 or total_ones == n:
9
        return 0
10
11
    min_cost = float('inf')
12
13
    # Sliding window for size `k`
14
    for k in range(1, n):  # We keep segments of size `k`
15
        ones_in_window = 0
16
        # Initial window calculation
17
        for i in range(k):
18
            if server_string[i] == '1':
19
                ones_in_window += 1
20
        21
        # Compute cost for first window
22
        zeros_in_window = k - ones_in_window
23
        ones_removed = total_ones - ones_in_window
24
        min_cost = min(min_cost, max(zeros_in_window, ones_removed))
25
26
        # Slide window across string
27
        for i in range(k, n):
28
            if server_string[i - k] == '1':
29
                ones_in_window -= 1  # Remove outgoing element
30
            if server_string[i] == '1':
31
                ones_in_window += 1  # Add incoming element
32
33
            zeros_in_window = k - ones_in_window
34
            ones_removed = total_ones - ones_in_window
35
            min_cost = min(min_cost, max(zeros_in_window, ones_removed))
36
37
    return min_cost
38
39
def solve():
40
    t = int(sys.stdin.readline().strip())
41
    results = []
42
43
    for _ in range(t):
44
        server_string = sys.stdin.readline().strip()
45
        results.append(str(min_decommission_cost(server_string)))
46
47
    sys.stdout.write(""\n"".join(results) + ""\n"")
48
49
# Run the function
50
solve()
51",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054712
1390054703,unknown,unknown,unknown,"1
def min_cost_server_pruning(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    5
    for i in range(n + 1):
6
        for j in range(n + 1 - i):
7
            remaining = server_rack[i:n-j]
8
            idle_remaining = remaining.count('0')
9
            10
            removed_start = server_rack[:i].count('1')
11
            removed_end = server_rack[n-j:].count('1')
12
            active_decommissioned = removed_start + removed_end
13
            14
            cost = max(idle_remaining, active_decommissioned)
15
            min_cost = min(min_cost, cost)
16
    17
    return min_cost
18
19
t = int(input())
20
for _ in range(t):
21
    server_rack = input().strip()
22
    print(min_cost_server_pruning(server_rack))",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054703
1390054702,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054702
1390054706,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    # This deque will store indices of the negative numbers in the current window
5
    dq = deque()
6
    result = []
7
    8
    for i in range(len(arr)):
9
        # If current element is negative, add its index
10
        if arr[i] < 0:
11
            dq.append(i)
12
        13
        # When we've reached at least one complete window, record the answer
14
        if i >= k - 1:
15
            # Remove indices that are out of the current window (i-k+1 is window's start index)
16
            while dq and dq[0] < i - k + 1:
17
                dq.popleft()
18
            19
            # If the deque is not empty, the front element is the earliest negative in the window
20
            if dq:
21
                result.append(arr[dq[0]])
22
            else:
23
                result.append(0)
24
    25
    return result
26
27
# Reading input and processing test cases
28
if __name__ == ""__main__"":
29
    t = int(input().strip())  # Number of test cases
30
    for _ in range(t):
31
        n, k = map(int, input().strip().split())
32
        arr = list(map(int, input().strip().split()))
33
        output = earliest_faults(arr, k)
34
        print("" "".join(map(str, output)))",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054706
1390054698,unknown,unknown,unknown,"1
import sys
2
3
def minimize_server_shutdown_cost():
4
    num_cases = int(sys.stdin.readline().strip())
5
    6
    for _ in range(num_cases):
7
        server_status = sys.stdin.readline().strip()
8
        9
        active_servers = [index for index, state in enumerate(server_status) if state == '1']
10
        total_active = len(active_servers)
11
        12
        # If no active servers or already consecutive, no operations needed
13
        if total_active == 0 or active_servers[-1] - active_servers[0] == total_active - 1:
14
            print(0)
15
            continue
16
        17
        low, high = 0, total_active
18
        19
        while high - low > 1:
20
            mid_point = (low + high) // 2
21
            servers_to_keep = total_active - mid_point
22
            23
            is_possible = False
24
            for i in range(mid_point + 1):
25
                first, last = active_servers[i], active_servers[i + servers_to_keep - 1]
26
                if (last - first + 1) - servers_to_keep <= mid_point:
27
                    is_possible = True
28
                    break
29
            30
            if is_possible:
31
                high = mid_point
32
            else:
33
                low = mid_point
34
        35
        print(high)
36
37
if __name__ == ""__main__"":
38
    minimize_server_shutdown_cost()
39",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054698
1390054700,unknown,unknown,unknown,"1
def decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
7
        for i in range(n + 1):
8
            for j in range(n - i + 1):
9
                remaining_string = case[i:n - j]
10
11
                if not remaining_string:
12
                    removed_count = case[:i].count('1') + case[n - j:].count('1')
13
                    cost = removed_count
14
                else:
15
                    idle_count = remaining_string.count('0')
16
                    removed_count = case[:i].count('1') + case[n - j:].count('1')
17
                    cost = max(idle_count, removed_count)
18
19
                min_cost = min(min_cost, cost)
20
21
        results.append(min_cost)
22
    return results
23
24
# Input parsing
25
T = int(input())
26
test_cases = [input().strip() for _ in range(T)]
27
28
# Call the function and print the results
29
results = decommission_cost(test_cases)
30
for result in results:
31
    print(result)",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054700
1390054701,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    4
    if k == 0:
5
        return total_effort
6
    7
    min_effort = total_effort
8
    9
    for i in range(n - k + 1):
10
        skipped = sum(firewalls[i:i+k])
11
        penalty = sum(range(1, n - (i + k) + 1))
12
        effort = total_effort - skipped + penalty
13
        min_effort = min(min_effort, effort)
14
    15
    return min_effort
16
17
def main():
18
    T = int(input())
19
    20
    for _ in range(T):
21
        n, k = map(int, input().split())
22
        firewalls = list(map(int, input().split()))
23
        print(min_effort_to_breach(n, k, firewalls))
24
25
if __name__ == ""__main__"":
26
    main()
27",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054701
1390054697,unknown,unknown,unknown,"1
class FirewallBreach {
2
3
    public static void main(String[] args) {
4
        Scanner scanner = new Scanner(System.in);
5
        int t = scanner.nextInt();
6
        while (t-- > 0) {
7
            String serverRack = scanner.next();
8
            int minCost = calculateMinCost(serverRack);
9
            System.out.println(minCost);
10
        }
11
        scanner.close();
12
    }
13
14
    public static int calculateMinCost(String serverRack) {
15
        int n = serverRack.length();
16
        int min_cost = n; // Initialize with maximum possible cost
17
18
        for (int removedPrefixCount = 0; removedPrefixCount <= n; ++removedPrefixCount) {
19
            for (int removedSuffixCount = 0; removedSuffixCount <= n - removedPrefixCount; ++removedSuffixCount) {
20
                int current_idle_servers = 0;
21
                int current_active_removed = 0;
22
23
                // Count removed active servers (prefix)
24
                for (int i = 0; i < removedPrefixCount; ++i) {
25
                    if (serverRack.charAt(i) == '1') {
26
                        current_active_removed++;
27
                    }
28
                }
29
                // Count removed active servers (suffix)
30
                for (int i = n - removedSuffixCount; i < n; ++i) {
31
                    if (serverRack.charAt(i) == '1') {
32
                        current_active_removed++;
33
                    }
34
                }
35
36
                // Count remaining idle servers
37
                for (int i = removedPrefixCount; i < n - removedSuffixCount; ++i) {
38
                    if (serverRack.charAt(i) == '0') {
39
                        current_idle_servers++;
40
                    }
41
                }
42
43
                int cost = Math.max(current_idle_servers, current_active_removed);
44
                min_cost = Math.min(min_cost, cost);
45
            }
46
        }
47
        return min_cost;
48
    }
49
}",70,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054697
1390054690,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }
19
20
      21
        auto check = [&](int k) {
22
            int l = 0;
23
         24
            for (int r = 0; r < n; r++) {
25
              26
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
27
                    l++;
28
                }
29
    30
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
31
                    return true;
32
                }
33
            }
34
      35
            if (prefix_1[n] <= k) {
36
                return true;
37
            }
38
            return false;
39
        };
40
41
42
        int low = 0, high = n;
43
        while (low < high) {
44
            int mid = (low + high) / 2;
45
            if (check(mid)) {
46
                high = mid;
47
            } else {
48
                low = mid + 1;
49
            }
50
        }
51
        cout << low << endl;
52
    }
53
    return 0;
54
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054690
1390054696,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        benefits = []
12
        for i in range(n):
13
            benefit = a[i] - (n - i - 1)
14
            benefits.append((benefit, i))
15
        16
        benefits.sort(reverse=True)
17
18
        skipped = [False] * n
19
20
        for i in range(k):
21
            _, idx = benefits[i]
22
            skipped[idx] = True
23
24
        25
        total_effort = 0
26
        penalty = 0  
27
        for i in range(n):
28
            if skipped[i]:
29
                penalty += 1
30
            else:
31
                total_effort += a[i] + penalty
32
33
        print(total_effort)
34
35
threading.Thread(target=main).start()",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054696
1390054693,unknown,unknown,unknown,"1
def min_cost_server_pruning(server_rack):
2
3
    n = len(server_rack)
4
5
    min_cost = float('inf')
6
7
    8
9
    for i in range(n + 1):
10
11
        for j in range(n + 1 - i):
12
13
            remaining = server_rack[i:n-j]
14
15
            16
17
            # Skip if we've removed everything
18
19
            if not remaining:
20
21
                if server_rack.count('1') == 0:  # If there are no active servers
22
23
                    return 0
24
25
                continue
26
27
            28
29
            idle_remaining = remaining.count('0')
30
31
            32
33
            active_decommissioned = 0
34
35
            if i > 0:
36
37
                active_decommissioned += server_rack[:i].count('1')
38
39
            if j > 0:
40
41
                active_decommissioned += server_rack[n-j:].count('1')
42
43
            44
45
            cost = max(idle_remaining, active_decommissioned)
46
47
            min_cost = min(min_cost, cost)
48
49
    50
51
    return min_cost
52
53
t = int(input())
54
55
for _ in range(t):
56
57
    server_rack = input().strip()
58
59
    print(min_cost_server_pruning(server_rack))",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054693
1390054685,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    ios::sync_with_stdio(false);
10
    cin.tie(nullptr);
11
    12
    int T;
13
    cin >> T;
14
    while(T--) {
15
        string s;
16
        cin >> s;
17
        int n = s.size();
18
        19
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
20
        for (int i = 0; i < n; i++) {
21
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
22
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
23
        }
24
        int totalOnes = prefix1[n];
25
        26
        // We'll binary search for the minimal cost C in the range [0, n].
27
        int low = 0, high = n, ans = n;
28
        while(low <= high) {
29
            int mid = (low + high) / 2;
30
            bool feasible = false;
31
            32
            33
            for (int l = 0; l <= n; l++) {
34
                35
                int allowed = prefix0[l] + mid;
36
                // Find the first index r (in [l, n+1)) where prefix0[r] > allowed.
37
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
38
                // Then the maximum r with zeros constraint is r_max = r - 1.
39
                if(r - 1 < l) continue; // should not happen because at least r = l exists.
40
                int r_max = r - 1;
41
                // Ones kept in s[l, r_max) is:
42
                int onesKept = prefix1[r_max] - prefix1[l];
43
                // We need onesKept >= totalOnes - mid.
44
                if(onesKept >= totalOnes - mid) {
45
                    feasible = true;
46
                    break;
47
                }
48
            }
49
            50
            if(feasible) {
51
                ans = mid;
52
                high = mid - 1;
53
            } else {
54
                low = mid + 1;
55
            }
56
        }
57
        58
        cout << ans << ""\n"";
59
    }
60
    return 0;
61
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054685
1390054686,unknown,unknown,unknown,"1
def minimum_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        skipped = set()
6
        total_effort = 0
7
        penalty = 0
8
        9
        # Find k firewalls with the highest strength to skip
10
        a_sorted_indices = sorted(range(n), key=lambda i: a[i], reverse=True)[:k]
11
        skipped.update(a_sorted_indices)
12
        13
        # Calculate total effort
14
        for i in range(n):
15
            if i in skipped:
16
                penalty += 1
17
            else:
18
                total_effort += a[i] + penalty
19
        20
        print(total_effort)  # Print result instead of returning a list
21
22
# Example test cases for debugging
23
test_cases = [
24
    (4, 1, [5, 10, 11, 5]),
25
    (4, 4, [8, 7, 1, 4])
26
]
27
28
# Running test cases
29
minimum_effort(test_cases)
30",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054686
1390054689,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FirewallBreach {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt(); // Number of test cases
7
8
        while (T-- > 0) {
9
            int n = scanner.nextInt(); // Number of firewalls
10
            int k = scanner.nextInt(); // Max number of firewalls that can be skipped
11
12
            long[] strengths = new long[n];
13
            for (int i = 0; i < n; i++) {
14
                strengths[i] = scanner.nextLong(); // Strength of each firewall
15
            }
16
17
            System.out.println(minimumEffort(n, k, strengths));
18
        }
19
        scanner.close();
20
    }
21
22
    private static long minimumEffort(int n, int k, long[] strengths) {
23
        if (k >= n) {
24
            return 0; // If we can skip all, then no effort is needed.
25
        }
26
        27
        long totalEffort = 0;
28
        for (int i = 0; i < n; i++) {
29
            totalEffort += strengths[i]; // Calculate total effort without skips
30
        }
31
        32
        // Best effort starts as the scenario where no skips are made
33
        long minEffort = totalEffort;
34
35
        // Iterate through each possible skip quantity
36
        for (int skips = 1; skips <= k; skips++) {
37
            for (int start = 0; start + skips <= n; start++) {
38
                long skippedEffort = 0;
39
40
                // Calculate effort if skipping from 'start' to 'start + skips - 1'
41
                for (int i = 0; i < start; i++) {
42
                    skippedEffort += strengths[i];
43
                }
44
                for (int i = start + skips; i < n; i++) {
45
                    skippedEffort += strengths[i] + (i - (start + skips) + 1);
46
                }
47
48
                minEffort = Math.min(minEffort, skippedEffort);
49
            }
50
        }
51
52
        return minEffort;
53
    }
54
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054689
1390054669,unknown,unknown,unknown,"1
def min_decommission_cost(s):
2
    n, total_ones = len(s), s.count('1')
3
    min_cost, left_ones = n, 0  
4
5
    for l in range(n + 1):
6
        right_ones = 0
7
        for r in range(n - l + 1):
8
            cost = max(s[l:n-r].count('0'), left_ones + right_ones)
9
            min_cost = min(min_cost, cost)
10
            if r < n - l and s[n - r - 1] == '1':
11
                right_ones += 1
12
        if l < n and s[l] == '1':
13
            left_ones += 1
14
15
    return min_cost
16
17
# Read input
18
t = int(input())
19
for _ in range(t):
20
    print(min_decommission_cost(input()))
21",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054669
1390054670,unknown,unknown,unknown,"1
def solve():
2
    """"""Solves the server decommissioning problem.""""""
3
4
    T = int(input())
5
    for _ in range(T):
6
        servers = input().strip()
7
        n = len(servers)
8
9
        min_cost = float('inf')
10
11
        for i in range(n + 1):  # Remove i from start
12
            for j in range(n - i + 1):  # Remove j from end
13
                remaining = servers[i:n - j]
14
15
                idle_count = remaining.count('0')
16
                active_removed = servers[:i].count('1') + servers[n - j:].count('1')
17
18
                min_cost = min(min_cost, max(idle_count, active_removed))
19
20
        print(min_cost)
21
22
solve()
23
24",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054670
1390054681,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054681
1390054667,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
3
using namespace std;
4
5
int main() {
6
7
    int T;
8
9
    cin >> T; 
10
11
    for (int t = 0; t < T; t++) {
12
13
        string s;
14
15
        cin >> s; 
16
17
        int n = s.length();
18
19
    20
21
        vector<int> prefix_0(n + 1, 0);
22
23
        vector<int> prefix_1(n + 1, 0);
24
25
        for (int i = 1; i <= n; i++) {
26
27
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
28
29
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
30
31
        }
32
33
      34
35
        auto check = [&](int k) {
36
37
            int l = 0;
38
39
         40
41
            for (int r = 0; r < n; r++) {
42
43
              44
45
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
46
47
                    l++;
48
49
                }
50
51
                // wtf ,  check number of 1's decommissioned
52
53
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
54
55
                    return true;
56
57
                }
58
59
            }
60
61
      62
63
            if (prefix_1[n] <= k) {
64
65
                return true;
66
67
            }
68
69
            return false;
70
71
        };
72
73
        // Binary search for minimum cost
74
75
        int low = 0, high = n;
76
77
        while (low < high) {
78
79
            int mid = (low + high) / 2;
80
81
            if (check(mid)) {
82
83
                high = mid;
84
85
            } else {
86
87
                low = mid + 1;
88
89
            }
90
91
        }
92
93
        cout << low << endl;
94
95
    }
96
97
    return 0;
98
99
}",71,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054667
1390054662,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054662
1390054663,unknown,unknown,unknown,"1
def min_cost_to_convert(T, test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        prefix_0 = [0] * (n + 1)
6
        prefix_1 = [0] * (n + 1)
7
        for i in range(1, n + 1):
8
            prefix_0[i] = prefix_0[i - 1] + (1 if s[i - 1] == '0' else 0)
9
            prefix_1[i] = prefix_1[i - 1] + (1 if s[i - 1] == '1' else 0)
10
        def check(k):
11
            l = 0
12
            for r in range(n):
13
                while l <= r and prefix_0[r + 1] - prefix_0[l] > k:
14
                    l += 1
15
                if l <= r and prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k:
16
                    return True
17
            return prefix_1[n] <= k
18
19
        low, high = 0, n
20
        while low < high:
21
            mid = (low + high) // 2
22
            if check(mid):
23
                high = mid
24
            else:
25
                low = mid + 1
26
27
        results.append(low)
28
29
    return results
30
31
32
T = int(input())
33
test_cases = [input().strip() for _ in range(T)]
34
35
for result in min_cost_to_convert(T, test_cases):
36
    print(result)
37",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054663
1390054666,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(len(arr)):
8
        while dq and dq[0] < i - k + 1:
9
            dq.popleft()
10
        11
        if arr[i] < 0:
12
            dq.append(i)
13
        14
        if i >= k - 1:
15
            result.append(arr[dq[0]] if dq else 0)
16
    17
    return result
18
19
def process_test_cases(test_cases):
20
    results = []
21
    for size, k, arr in test_cases:
22
        results.append(earliest_faulty_readings(arr, k))
23
    return results
24
25
if __name__ == ""__main__"":
26
    t = int(input().strip())
27
    test_cases = []
28
    29
    for _ in range(t):
30
        size, k = map(int, input().split())
31
        arr = list(map(int, input().split()))
32
        test_cases.append((size, k, arr))
33
    34
    results = process_test_cases(test_cases)
35
    for res in results:
36
        print("" "".join(map(str, res)))
37",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054666
1390054647,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        result = []
8
        dq = deque()
9
        10
        # Process first window of size k
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
        15
        # Append result for first window
16
        result.append(arr[dq[0]] if dq else 0)
17
        18
        # Process the rest of the windows
19
        for i in range(k, n):
20
            # Remove indices out of the current window
21
            while dq and dq[0] <= i - k:
22
                dq.popleft()
23
            24
            # Add index of current element if it's negative
25
            if arr[i] < 0:
26
                dq.append(i)
27
            28
            # Append earliest faulty reading for current window
29
            result.append(arr[dq[0]] if dq else 0)
30
        31
        results.append("" "".join(map(str, result)))
32
    33
    return results
34
35
# Input Reading
36
t = int(input())
37
test_cases = []
38
for _ in range(t):
39
    n, k = map(int, input().split())
40
    arr = list(map(int, input().split()))
41
    test_cases.append((n, k, arr))
42
43
# Output Result
44
for res in earliest_faulty_readings(test_cases):
45
    print(res)
46
47",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054647
1390054658,unknown,unknown,unknown,"1
class FirewallBreach {
2
3
    public static void main(String[] args) {
4
        Scanner scanner = new Scanner(System.in);
5
        int t = scanner.nextInt();
6
        while (t-- > 0) {
7
            String serverRack = scanner.next();
8
            int minCost = calculateMinCost(serverRack);
9
            System.out.println(minCost);
10
        }
11
        scanner.close();
12
    }
13
14
    public static int calculateMinCost(String serverRack) {
15
        int n = serverRack.length();
16
        int min_cost = n; // Initialize with maximum possible cost
17
18
        for (int removedPrefixCount = 0; removedPrefixCount <= n; ++removedPrefixCount) {
19
            for (int removedSuffixCount = 0; removedSuffixCount <= n - removedPrefixCount; ++removedSuffixCount) {
20
                int current_idle_servers = 0;
21
                int current_active_removed = 0;
22
23
                // Count removed active servers (prefix)
24
                for (int i = 0; i < removedPrefixCount; ++i) {
25
                    if (serverRack.charAt(i) == '1') {
26
                        current_active_removed++;
27
                    }
28
                }
29
                // Count removed active servers (suffix)
30
                for (int i = n - removedSuffixCount; i < n; ++i) {
31
                    if (serverRack.charAt(i) == '1') {
32
                        current_active_removed++;
33
                    }
34
                }
35
36
                // Count remaining idle servers
37
                for (int i = removedPrefixCount; i < n - removedSuffixCount; ++i) {
38
                    if (serverRack.charAt(i) == '0') {
39
                        current_idle_servers++;
40
                    }
41
                }
42
43
                int cost = Math.max(current_idle_servers, current_active_removed);
44
                min_cost = Math.min(min_cost, cost);
45
            }
46
        }
47
        return min_cost;
48
    }
49
}",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054658
1390054659,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx + 1])
10
        idx += 2
11
        a = list(map(int, input[idx:idx + n]))
12
        idx += n
13
        14
        sum_S = sum(a)
15
        # Compute a[i] + i (0-based)
16
        values = [a[i] + i for i in range(n)]
17
        # Sort in descending order
18
        values.sort(reverse=True)
19
        sum_aj_plus_j = sum(values[:k])
20
        # Compute the result
21
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
22
        print(res)
23
24
if __name__ == ""__main__"":
25
    main()
26",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054659
1390054644,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054644
1390054645,unknown,unknown,unknown,"1
def calculate_earliest_fault(arr,k):
2
    n=len(arr)
3
    4
5
6
7
8
9
10
11
12
t=int(input())
13
for i in range(0,t):
14
    n,k=map(int,input().split())
15
    arr=list(map(int,input().split()))
16
    17
        18
        19
    20",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054645
1390054646,unknown,unknown,unknown,"1
def min_decommission_cost(s: str) -> int:
2
    n = len(s)
3
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
4
    T = len(ones_pos)
5
    6
    if T == 0:
7
        return 0
8
    9
    zeros_total = s.count('0')
10
    ans = min(zeros_total, T) 
11
    12
    for X in range(1, T + 1):
13
        for i in range(0, T - X + 1):
14
            left = ones_pos[i]
15
            right = ones_pos[i + X - 1]
16
            length = right - left + 1
17
            zeros_in_block = length - X
18
            candidate = max(zeros_in_block, T - X)
19
            ans = min(ans, candidate)
20
    21
    return ans
22
23
if __name__ == '__main__':
24
    T = int(input().strip())
25
    for _ in range(T):
26
        s = input().strip()
27
        print(min_decommission_cost(s))",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054646
1390054641,unknown,unknown,unknown,"1
def minimum_effort(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n, k = test_cases[t][0]
6
        strengths = test_cases[t][1]
7
        8
        if k == n:
9
            results.append(0)
10
            continue
11
        12
        total_effort = sum(strengths)
13
        min_effort = total_effort
14
        15
        for i in range(n):
16
            skip_effort = total_effort - strengths[i]
17
            for j in range(1, k + 1):
18
                if i + j < n:
19
                    skip_effort += 1  # Adding penalty for skipping next k firewalls
20
            min_effort = min(min_effort, skip_effort)
21
        22
        results.append(min_effort)
23
    24
    return results
25
26
def main():
27
    T = int(input().strip())
28
    test_cases = []
29
    30
    for _ in range(T):
31
        n, k = map(int, input().split())
32
        strengths = list(map(int, input().split()))
33
        test_cases.append(((n, k), strengths))
34
    35
    results = minimum_effort(T, test_cases)
36
    for res in results:
37
        print(res)
38
39
if __name__ == ""__main__"":
40
    main()",72,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054641
1390054634,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        benefits = []
12
        for i in range(n):
13
            benefit = a[i] - (n - i - 1)
14
            benefits.append((benefit, i))
15
        16
        benefits.sort(reverse=True)
17
18
        skipped = [False] * n
19
20
        for i in range(k):
21
            _, idx = benefits[i]
22
            skipped[idx] = True
23
24
        25
        total_effort = 0
26
        penalty = 0  
27
        for i in range(n):
28
            if skipped[i]:
29
                penalty += 1
30
            else:
31
                total_effort += a[i] + penalty
32
33
        print(total_effort)
34
35
threading.Thread(target=main).start()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054634
1390054638,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054638
1390054637,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Main {
5
    public static void main(String[] args) throws IOException {
6
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
7
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
8
        9
        int t = Integer.parseInt(br.readLine());
10
        11
        while (t-- > 0) {
12
            String[] nk = br.readLine().split("" "");
13
            int n = Integer.parseInt(nk[0]);
14
            int k = Integer.parseInt(nk[1]);
15
            16
            String[] input = br.readLine().split("" "");
17
            int[] a = new int[n];
18
            for (int i = 0; i < n; i++) a[i] = Integer.parseInt(input[i]);
19
            20
            bw.write(minEffort(n, k, a) + ""\n"");
21
        }
22
        23
        bw.flush();
24
        bw.close();
25
        br.close();
26
    }
27
28
    static int minEffort(int n, int k, int[] a) {
29
        int[] dp = new int[k + 2];
30
        31
        for (int i = n - 1; i >= 0; i--) {
32
            int[] next = new int[k + 2];
33
            for (int skip = k; skip >= 0; skip--) {
34
                int take = a[i] + skip + dp[skip];
35
                int leave = (skip < k) ? dp[skip + 1] : Integer.MAX_VALUE;
36
                next[skip] = Math.min(take, leave);
37
            }
38
            dp = next;
39
        }
40
        41
        return dp[0];
42
    }
43
}
44",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054637
1390054627,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        Scanner sc = new Scanner(System.in);
11
        int t = sc.nextInt();
12
        while (t-- > 0) {
13
            int n = sc.nextInt();
14
            int k = sc.nextInt();
15
            int[] arr = new int[n];
16
            for (int i = 0; i < n; i++) {
17
                arr[i] = sc.nextInt();
18
            }
19
            ArrayList<Integer> res = new ArrayList<>();
20
            Deque<Integer> dq = new ArrayDeque<>();
21
            for (int i = 0; i < k; i++) {
22
                if (arr[i] < 0)
23
                    dq.addLast(i);
24
            }
25
            res.add(!dq.isEmpty() ? arr[dq.peekFirst()] : 0);
26
            for (int i = k; i < n; i++) {
27
                while (!dq.isEmpty() && dq.peekFirst() < i - k + 1)
28
                    dq.removeFirst();
29
                if (arr[i] < 0)
30
                    dq.addLast(i);
31
                res.add(!dq.isEmpty() ? arr[dq.peekFirst()] : 0);
32
            }
33
            for (int num : res) {
34
                System.out.print(num + "" "");
35
            }
36
            System.out.println();
37
        }
38
    }
39
}
40",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054627
1390054629,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054629
1390054631,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if _name_ == ""_main_"":
73
    main()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054631
1390054621,unknown,unknown,unknown,"1
def min_decommission_cost(rack):
2
    n = len(rack)
3
    4
    # Precompute prefix and suffix counts
5
    active_prefix = [0] * (n + 1)
6
    idle_prefix = [0] * (n + 1)
7
    8
    for i in range(n):
9
        active_prefix[i + 1] = active_prefix[i] + (1 if rack[i] == '1' else 0)
10
        idle_prefix[i + 1] = idle_prefix[i] + (1 if rack[i] == '0' else 0)
11
    12
    min_cost = n  # Initialize to worst case
13
    14
    # Process results in chunks to avoid memory issues
15
    for left in range(n + 1):
16
        active_removed_left = active_prefix[left]
17
        18
        for right in range(n + 1 - left):
19
            # Calculate costs
20
            active_removed = active_removed_left + (active_prefix[n] - active_prefix[n - right])
21
            idle_remaining = idle_prefix[n - right] - idle_prefix[left]
22
            23
            cost = max(active_removed, idle_remaining)
24
            min_cost = min(min_cost, cost)
25
    26
    return min_cost
27
28
def main():
29
    t = int(input())
30
    31
    for _ in range(t):
32
        rack = input()
33
        print(min_decommission_cost(rack))
34
35
if __name__ == ""__main__"":
36
    main()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054621
1390054622,unknown,unknown,unknown,"1
import sys, bisect
2
data = sys.stdin.read().split()
3
if not data:
4
    exit()
5
t = int(data[0])
6
ptr = 1
7
res = []
8
for _ in range(t):
9
    s = data[ptr]
10
    ptr += 1
11
    n = len(s)
12
    ones = [0]*(n+1)
13
    zeros = [0]*(n+1)
14
    for i in range(n):
15
        ones[i+1] = ones[i] + (1 if s[i]=='1' else 0)
16
        zeros[i+1] = zeros[i] + (1 if s[i]=='0' else 0)
17
    tot = ones[n]
18
    lo, hi = 0, max(tot, n - tot)
19
    def feasible(X):
20
        if tot <= X:
21
            return True
22
        for i in range(n+1):
23
            target = ones[i] + tot - X
24
            j = bisect.bisect_left(ones, target, i+1, n+1)
25
            if j <= n:
26
                if zeros[j] - zeros[i] <= X:
27
                    return True
28
        return False
29
    while lo < hi:
30
        mid = (lo + hi) // 2
31
        if feasible(mid):
32
            hi = mid
33
        else:
34
            lo = mid + 1
35
    res.append(str(lo))
36
sys.stdout.write(""\n"".join(res))
37",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054622
1390054624,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if _name_ == ""_main_"":
73
    main()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054624
1390054618,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if _name_ == ""_main_"":
73
    main()",73,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054618
1390054613,unknown,unknown,unknown,"1
def decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
7
        for i in range(n + 1):
8
            for j in range(n - i + 1):
9
                remaining_string = case[i:n - j]
10
11
                if not remaining_string:
12
                    removed_count = case[:i].count('1') + case[n - j:].count('1')
13
                    cost = removed_count
14
                else:
15
                    idle_count = remaining_string.count('0')
16
                    removed_count = case[:i].count('1') + case[n - j:].count('1')
17
                    cost = max(idle_count, removed_count)
18
19
                min_cost = min(min_cost, cost)
20
21
        results.append(min_cost)
22
    return results
23
24
# Input parsing
25
T = int(input())
26
test_cases = [input().strip() for _ in range(T)]
27
28
# Call the function and print the results
29
results = decommission_cost(test_cases)
30
for result in results:
31
    print(result)",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054613
1390054616,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    ios::sync_with_stdio(false);
10
    cin.tie(nullptr);
11
    12
    int T;
13
    cin >> T;
14
    while(T--) {
15
        string s;
16
        cin >> s;
17
        int n = s.size();
18
        19
        // Build prefix sums for zeros and ones.
20
        // prefix0[i] = number of '0's in s[0, i)
21
        // prefix1[i] = number of '1's in s[0, i)
22
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
23
        for (int i = 0; i < n; i++) {
24
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
25
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
26
        }
27
        int totalOnes = prefix1[n];
28
        29
        // We'll binary search for the minimal cost C in the range [0, n].
30
        int low = 0, high = n, ans = n;
31
        while(low <= high) {
32
            int mid = (low + high) / 2;
33
            bool feasible = false;
34
            35
            // For each possible prefix removal (i.e. for each starting index l of the kept substring)
36
            for (int l = 0; l <= n; l++) {
37
                // In the kept substring s[l, r), the zeros count is: prefix0[r] - prefix0[l].
38
                // We require that prefix0[r] - prefix0[l] <= mid.
39
                // That is, prefix0[r] <= prefix0[l] + mid.
40
                // Because prefix0 is non-decreasing, we can use upper_bound:
41
                int allowed = prefix0[l] + mid;
42
                // Find the first index r (in [l, n+1)) where prefix0[r] > allowed.
43
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
44
                // Then the maximum r with zeros constraint is r_max = r - 1.
45
                if(r - 1 < l) continue; // should not happen because at least r = l exists.
46
                int r_max = r - 1;
47
                // Ones kept in s[l, r_max) is:
48
                int onesKept = prefix1[r_max] - prefix1[l];
49
                // We need onesKept >= totalOnes - mid.
50
                if(onesKept >= totalOnes - mid) {
51
                    feasible = true;
52
                    break;
53
                }
54
            }
55
            56
            if(feasible) {
57
                ans = mid;
58
                high = mid - 1;
59
            } else {
60
                low = mid + 1;
61
            }
62
        }
63
        64
        cout << ans << ""\n"";
65
    }
66
    return 0;
67
}",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054616
1390054615,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    firewalls = [(val, i) for i, val in enumerate(firewalls)]
3
    firewalls.sort()
4
    5
    skipped = set()
6
    for i in range(k):
7
        skipped.add(firewalls[i][1])
8
    9
    effort = 0
10
    extra_security = 0
11
    12
    for i in range(n):
13
        if i in skipped:
14
            extra_security += 1
15
        else:
16
            effort += firewalls[i][0] + extra_security
17
    18
    return effort
19
20
def main():
21
    T = int(input())
22
    23
    for _ in range(T):
24
        n, k = map(int, input().split())
25
        firewalls = list(map(int, input().split()))
26
        result = min_effort_to_breach(n, k, firewalls)
27
        print(result)
28
29
if __name__ == ""__main__"":
30
    main()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054615
1390054610,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    """"""
3
    Calculate the minimum cost of decommissioning servers efficiently.
4
    5
    Args:
6
        servers (str): Binary string representing rack of servers (0 for idle, 1 for active)
7
    8
    Returns:
9
        int: Minimum possible cost
10
    """"""
11
    n = len(servers)
12
    13
    # Precompute prefix and suffix sums for active servers
14
    prefix_active = [0] * (n + 1)
15
    for i in range(n):
16
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
17
    18
    suffix_active = [0] * (n + 1)
19
    for i in range(n - 1, -1, -1):
20
        suffix_active[i] = suffix_active[i + 1] + (1 if servers[i] == '1' else 0)
21
    22
    # Total active servers
23
    total_active = prefix_active[n]
24
    25
    min_cost = float('inf')
26
    27
    # Try all possible combinations of removing servers from beginning (i) and end (j)
28
    for i in range(n + 1):
29
        for j in range(n + 1 - i):
30
            if i + j > n:
31
                continue
32
            33
            # Active servers decommissioned
34
            active_decommissioned = prefix_active[i] + suffix_active[n - j]
35
            36
            # Idle servers remaining
37
            remaining_servers = n - i - j
38
            remaining_active = total_active - active_decommissioned
39
            idle_remaining = remaining_servers - remaining_active
40
            41
            cost = max(idle_remaining, active_decommissioned)
42
            min_cost = min(min_cost, cost)
43
    44
    return min_cost
45
46
def main():
47
    # Read number of test cases
48
    t = int(input().strip())
49
    50
    for _ in range(t):
51
        servers = input().strip()
52
        print(min_decommissioning_cost(servers))
53
54
if __name__ == ""__main__"":
55
    main()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054610
1390054611,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])  # Number of test cases
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())  # Number of firewalls and skips allowed
13
        strengths = list(map(int, data[index + 1].split()))  # Firewall strengths
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()
46",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054611
1390054612,unknown,unknown,unknown,"1
def solve():
2
    import sys, bisect
3
    data = sys.stdin.read().strip().split()
4
    if not data:
5
        return
6
    t = int(data[0])
7
    index = 1
8
    out = []
9
    for _ in range(t):
10
        s = data[index].strip()
11
        index += 1
12
        n = len(s)
13
        P0 = [0]*(n+1)
14
        P1 = [0]*(n+1)
15
        for i in range(n):
16
            P0[i+1] = P0[i] + (1 if s[i]=='0' else 0)
17
            P1[i+1] = P1[i] + (1 if s[i]=='1' else 0)
18
        total_ones = P1[n]
19
        low, high, ans = 0, max(P0[n], total_ones), max(P0[n], total_ones)
20
        def feasible(X):
21
            for L in range(n+1):
22
                threshold = X + P0[L]
23
                R = bisect.bisect_right(P0, threshold) - 1
24
                if R >= L and (P1[R] - P1[L] >= total_ones - X):
25
                    return True
26
            return False
27
        while low <= high:
28
            mid = (low + high) // 2
29
            if feasible(mid):
30
                ans = mid
31
                high = mid - 1
32
            else:
33
                low = mid + 1
34
        out.append(str(ans))
35
    sys.stdout.write(""\n"".join(out))
36
    37
if __name__ == ""__main__"":
38
    solve()
39",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054612
1390054606,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
    5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            if j <= i - 1: 
13
                dp[i][j] = dp[i-1][j] + strengths[i-1] + j
14
            15
            if j > 0:  
16
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
17
    18
    return min(dp[n])
19
20
def solve_test_case():
21
    n, k = map(int, input().split())
22
    strengths = list(map(int, input().split()))
23
    return min_effort_to_breach(n, k, strengths)
24
25
def main():
26
    t = int(input())
27
    for _ in range(t):
28
        result = solve_test_case()
29
        print(result)
30
31
if __name__ == ""__main__"":
32
    main()",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054606
1390054607,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    dp[0][0] = 0  
4
5
    for i in range(1, n + 1):
6
        for j in range(k + 1):
7
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
8
            if j > 0:
9
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
10
11
    return min(dp[n])
12
13
T = int(input())  
14
for _ in range(T):
15
    n, k = map(int, input().split())  
16
    firewalls = list(map(int, input().split()))  
17
    print(min_effort(n, k, firewalls))
18",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054607
1390054609,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
5
    for i in range(n + 1):  
6
        for j in range(n + 1 - i): 
7
            if i + j > n:
8
                continue
9
10
            remaining = server_rack[i:n-j]
11
            12
            if not remaining:
13
                continue  
14
            idle_remaining = remaining.count('0')
15
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
16
17
            cost = max(idle_remaining, active_removed)
18
            min_cost = min(min_cost, cost)
19
    20
    return min_cost
21
22
t = int(input())
23
results = []
24
25
for _ in range(t):
26
    server_rack = input().strip()
27
    results.append(min_decommissioning_cost(server_rack))
28
29
for result in results:
30
    print(result)",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054609
1390054604,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    a = list(map(int, input().split()))
5
    6
    if k >= n:
7
        print(0)
8
        continue
9
    10
    savings = []
11
    for i in range(n):
12
        savings.append((a[i] - (n - i - 1), i))
13
    14
    savings.sort(reverse=True)
15
    16
    to_skip = set()
17
    for i in range(k):
18
        _, idx = savings[i]
19
        to_skip.add(idx)
20
    21
    effort = 0
22
    skipped = 0
23
    24
    for i in range(n):
25
        if i in to_skip:
26
            skipped += 1
27
        else:
28
            effort += a[i] + skipped
29
    30
    print(effort)
31",74,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054604
1390054601,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054601
1390054599,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054599
1390054602,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
 Scanner sc = new Scanner(System.in);
8
        int T = sc.nextInt(); 
9
        10
        while (T-- > 0) {
11
            int n = sc.nextInt(); 
12
            int k = sc.nextInt(); 
13
            int[] strength = new int[n];
14
            15
            for (int i = 0; i < n; i++) {
16
                strength[i] = sc.nextInt();
17
            }
18
            19
            if (k == n) {
20
                System.out.println(0);
21
                continue;
22
            }
23
            24
            System.out.println(findMinEffort(n, k, strength));
25
        }
26
        sc.close();
27
    }
28
    29
    private static long findMinEffort(int n, int k, int[] strength) {
30
        long[][] dp = new long[n + 1][k + 1];
31
        32
        for (int i = 0; i <= n; i++) {
33
            Arrays.fill(dp[i], Long.MAX_VALUE / 2);
34
        }
35
        dp[0][0] = 0; 
36
        for (int i = 1; i <= n; i++) {
37
            for (int j = 0; j <= Math.min(i, k); j++) {
38
                if (j > 0) {
39
                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1]);
40
                }
41
                42
                long penalty = 0;
43
                if (i > 1 && j > 0) {
44
                    penalty = j; 
45
                }
46
                47
                dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + strength[i-1] + penalty);
48
            }
49
        }
50
        51
        long result = Long.MAX_VALUE;
52
        for (int j = 0; j <= k; j++) {
53
            result = Math.min(result, dp[n][j]);
54
        }
55
        56
        return result;
57
    }
58
}",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054602
1390054593,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Process the rest of the array
13
    for i in range(len(arr) - k + 1):
14
        # Append the first negative in the current window
15
        if dq:
16
            result.append(arr[dq[0]])
17
        else:
18
            result.append(0)
19
        20
        # Remove elements that are out of the current window
21
        while dq and dq[0] < i + 1:
22
            dq.popleft()
23
        24
        # Add new element (end of current window)
25
        if i + k < len(arr) and arr[i + k] < 0:
26
            dq.append(i + k)
27
    28
    return result
29
30
def process_test_cases():
31
    t = int(input())
32
    for _ in range(t):
33
        n, k = map(int, input().split())
34
        arr = list(map(int, input().split()))
35
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))
36
37
# Run the function
38
process_test_cases()
39",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054593
1390054596,unknown,unknown,unknown,"1
def min_cost_server_optimization(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    5
    6
    prefix_active = [0] * (n + 1)
7
    for i in range(n):
8
        prefix_active[i + 1] = prefix_active[i] + (1 if server_rack[i] == '1' else 0)
9
    10
    11
    prefix_idle = [0] * (n + 1)
12
    for i in range(n):
13
        prefix_idle[i + 1] = prefix_idle[i] + (1 if server_rack[i] == '0' else 0)
14
    15
    total_active = prefix_active[n]
16
    total_idle = prefix_idle[n]
17
    18
    for i in range(n + 1): 
19
        for j in range(n + 1 - i):  
20
            if i + j == n:  
21
                continue
22
            23
        24
            active_removed = prefix_active[i] + (total_active - prefix_active[n - j])
25
            26
   27
            idle_remaining = total_idle - (prefix_idle[i] + (total_idle - prefix_idle[n - j]))
28
            29
            cost = max(idle_remaining, active_removed)
30
            min_cost = min(min_cost, cost)
31
    32
    return min_cost
33
34
def main():
35
    t = int(input().strip())
36
    37
    for _ in range(t):
38
        server_rack = input().strip()
39
        result = min_cost_server_optimization(server_rack)
40
        print(result)
41
42
if __name__ == ""__main__"":
43
    main()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054596
1390054597,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    for n, k, arr in test_cases:
6
        output = []
7
        dq = deque()
8
    9
        for i in range(k):
10
            if arr[i] < 0:
11
                dq.append(i)
12
        13
        output.append(arr[dq[0]] if dq else 0)
14
        15
        for i in range(k, n):
16
            while dq and dq[0] <= i - k:
17
                dq.popleft()
18
19
            if arr[i] < 0:
20
                dq.append(i)
21
            22
            output.append(arr[dq[0]] if dq else 0)
23
        24
        results.append("" "".join(map(str, output)))
25
    26
    print(""\n"".join(results))
27
28
t = int(input().strip())
29
test_cases = []
30
for _ in range(t):
31
    n, k = map(int, input().strip().split())
32
    arr = list(map(int, input().strip().split()))
33
    test_cases.append((n, k, arr))
34
35
earliest_faulty_readings(test_cases)
36",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054597
1390054589,unknown,unknown,unknown,"1
def solve():
2
    """"""Solves the server decommissioning problem.""""""
3
4
    T = int(input())
5
    for _ in range(T):
6
        servers = input().strip()
7
        n = len(servers)
8
        9
        min_cost = float('inf')
10
11
        for i in range(n + 1):  # Remove i from start
12
            for j in range(n - i + 1):  # Remove j from end
13
                remaining = servers[i:n - j]
14
                15
                if not remaining:
16
                    min_cost = min(min_cost, 0)
17
                    continue
18
                19
                idle_count = remaining.count('0')
20
                21
                # Correctly calculate active servers removed
22
                active_removed = servers[:i].count('1') + servers[n - j:].count('1')
23
24
                min_cost = min(min_cost, max(idle_count, active_removed))
25
        26
        print(min_cost)
27
28
solve()
29",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054589
1390054591,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        benefits = []
12
        for i in range(n):
13
            benefit = a[i] - (n - i - 1)
14
            benefits.append((benefit, i))
15
        16
        benefits.sort(reverse=True)
17
18
        skipped = [False] * n
19
20
        for i in range(k):
21
            _, idx = benefits[i]
22
            skipped[idx] = True
23
24
        25
        total_effort = 0
26
        penalty = 0  
27
        for i in range(n):
28
            if skipped[i]:
29
                penalty += 1
30
            else:
31
                total_effort += a[i] + penalty
32
33
        print(total_effort)
34
35
threading.Thread(target=main).start()",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054591
1390054588,unknown,unknown,unknown,"1
import sys
2
3
def breach_firewall():
4
    input_data = sys.stdin.read().strip().split()
5
    t = int(input_data[0])
6
    index = 1
7
    results = []
8
    for _ in range(t):
9
        n = int(input_data[index])
10
        k = int(input_data[index+1])
11
        index += 2
12
        a = list(map(int, input_data[index:index+n]))
13
        index += n
14
        15
        sum_a = sum(a)
16
        n_val = n  # total number of firewalls
17
        # Compute v[i] = a[i] + i for each firewall (0-indexed)
18
        v = [a[i] + i for i in range(n)]
19
        # Sort v in descending order
20
        v.sort(reverse=True)
21
        22
        best = 0  # candidate(0) = 0: meaning ""skip none""
23
        current = 0
24
        # We can skip at most min(k, n) firewalls.
25
        m_max = min(k, n)
26
        for m in range(1, m_max+1):
27
            current += v[m-1]
28
            # candidate(m) = (sum of top m v[i]) - m*(n - 1) + m*(m - 1)/2
29
            candidate = current - m * (n_val - 1) + (m * (m - 1)) // 2
30
            if candidate > best:
31
                best = candidate
32
        # The minimum total effort equals total base cost minus the maximum saving.
33
        answer = sum_a - best
34
        results.append(str(answer))
35
    36
    sys.stdout.write(""\n"".join(results))
37
38
if __name__ == '__main__':
39
    breach_firewall()
40",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054588
1390054581,unknown,unknown,unknown,"1
def min_pruning_cost(s):
2
    n = len(s)
3
    # Build prefix sums for 0's and 1's.
4
    prefix0 = [0] * (n + 1)
5
    prefix1 = [0] * (n + 1)
6
    for i, ch in enumerate(s):
7
        prefix0[i+1] = prefix0[i] + (1 if ch == '0' else 0)
8
        prefix1[i+1] = prefix1[i] + (1 if ch == '1' else 0)
9
        10
    ones_total = prefix1[n]
11
    ans = float('inf')
12
    13
    # For each possible starting index L, binary search for R in [L, n] that minimizes
14
    # f(L, R) = max( (prefix0[R]-prefix0[L]), (ones_total - (prefix1[R]-prefix1[L]) ) ).
15
    for L in range(0, n + 1):
16
        lo, hi = L, n
17
        candidate_for_L = float('inf')
18
        # Binary search: We want the smallest R such that the count of zeros in s[L:R]
19
        # is at least the number of ones removed, i.e.,
20
        #     prefix0[R] - prefix0[L] >= ones_total - (prefix1[R]-prefix1[L])
21
        while lo < hi:
22
            mid = (lo + hi) // 2
23
            zeros_count = prefix0[mid] - prefix0[L]
24
            ones_removed = ones_total - (prefix1[mid] - prefix1[L])
25
            if zeros_count < ones_removed:
26
                lo = mid + 1
27
            else:
28
                hi = mid
29
        # Candidate using R = lo
30
        if L <= lo <= n:
31
            zeros_count = prefix0[lo] - prefix0[L]
32
            ones_removed = ones_total - (prefix1[lo] - prefix1[L])
33
            candidate_for_L = min(candidate_for_L, max(zeros_count, ones_removed))
34
        # It is also useful to check the neighbor R = lo - 1 (if possible)
35
        if lo - 1 >= L:
36
            R = lo - 1
37
            zeros_count = prefix0[R] - prefix0[L]
38
            ones_removed = ones_total - (prefix1[R] - prefix1[L])
39
            candidate_for_L = min(candidate_for_L, max(zeros_count, ones_removed))
40
        ans = min(ans, candidate_for_L)
41
    return ans
42
43
# Main code to read test cases and output answer.
44
if __name__ == '__main__':
45
    T = int(input().strip())
46
    for _ in range(T):
47
        s = input().strip()
48
        print(min_pruning_cost(s))",75,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054581
1390054575,unknown,unknown,unknown,"1
2
import math
3
4
def min_cost(s):
5
    n = len(s)
6
    zeros = s.count('0')
7
    ones = n - zeros
8
9
    min_cost = math.inf
10
    for i in range(n + 1):
11
        for j in range(n + 1):
12
            if i + j > n:
13
                break
14
            remaining_zeros = zeros - (s[:i].count('0') + s[n - j:].count('0'))
15
            decommissioned_ones = ones - s[i:n - j].count('1')
16
            cost = max(remaining_zeros, decommissioned_ones)
17
            min_cost = min(min_cost, cost)
18
19
    return min_cost
20
21
T = int(input())
22
for _ in range(T):
23
    s = input()
24
    print(min_cost(s))
25",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054575
1390054577,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    INF = float('inf')
6
    dp = [INF] * (k + 1)
7
    dp[0] = 0
8
9
    for i in range(n):
10
        new_dp = list(dp) # create a copy to avoid overwriting before needed.
11
        for s in range(k + 1):
12
            new_dp[s] = dp[s] + a[i] + s
13
            if s > 0:
14
                new_dp[s] = min(new_dp[s], dp[s - 1])
15
        dp = new_dp
16
17
    ans = min(dp)
18
    print(ans)
19
20
if __name__ == ""__main__"":
21
    T = int(input())
22
    for _ in range(T):
23
        solve()",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054577
1390054579,unknown,unknown,unknown,"1
def min_cost_server_pruning(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    5
    for i in range(n + 1):
6
        for j in range(n + 1 - i):
7
            remaining = server_rack[i:n-j]
8
            idle_remaining = remaining.count('0')
9
            10
            removed_start = server_rack[:i].count('1')
11
            removed_end = server_rack[n-j:].count('1')
12
            active_decommissioned = removed_start + removed_end
13
            14
            cost = max(idle_remaining, active_decommissioned)
15
            min_cost = min(min_cost, cost)
16
    17
    return min_cost
18
19
t = int(input())
20
for _ in range(t):
21
    server_rack = input().strip()
22
    print(min_cost_server_pruning(server_rack))",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054579
1390054570,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    dp[0][0] = 0  
4
5
    for i in range(1, n + 1):
6
        for j in range(k + 1):
7
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
8
            if j > 0:
9
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
10
11
    return min(dp[n])
12
13
T = int(input())  
14
for _ in range(T):
15
    n, k = map(int, input().split())  
16
    firewalls = list(map(int, input().split()))  
17
    print(min_effort(n, k, firewalls))
18",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054570
1390054571,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    min_cost = float('inf')
5
6
    for i in range(n + 1):
7
        for j in range(n - i + 1):
8
            rem = s[i:n - j]
9
            idle = rem.count('0')
10
            active_rem = s[:i].count('1') + s[n - j:].count('1')
11
            min_cost = min(min_cost, max(idle, active_rem))
12
13
    print(min_cost)
14
15
t = int(input())
16
for _ in range(t):
17
    solve()",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054571
1390054572,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054572
1390054557,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for case in test_cases:
7
        n, k, arr = case
8
        output = []
9
        dq = deque()
10
        11
        for i in range(n):
12
            if arr[i] < 0:
13
                dq.append(i)
14
            15
            if i >= k - 1:
16
                while dq and dq[0] < i - k + 1:
17
                    dq.popleft()
18
                19
                output.append(arr[dq[0]] if dq else 0)
20
        21
        results.append("" "".join(map(str, output)))
22
    23
    return results
24
25
# Reading input
26
t = int(input().strip())
27
test_cases = []
28
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    arr = list(map(int, input().split()))
32
    test_cases.append((n, k, arr))
33
34
# Processing and printing output
35
for res in earliest_faulty_readings(test_cases):
36
    print(res)
37",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054557
1390054563,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <climits>
5
6
using namespace std;
7
8
vector<int> min_decommissioning_cost(const vector<string>& test_cases) {
9
    vector<int> results;
10
    11
    for (const string& servers : test_cases) {
12
        int n = servers.size();
13
        int total_0 = 0;
14
        for (char c : servers) {
15
            if (c == '0') total_0++;
16
        }
17
        int total_1 = n - total_0;
18
        19
        // Precompute prefix counts for 0s and 1s
20
        vector<int> prefix_0(n + 1, 0), prefix_1(n + 1, 0);
21
        for (int i = 1; i <= n; ++i) {
22
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0');
23
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1');
24
        }
25
        26
        // Precompute suffix counts for 0s and 1s
27
        vector<int> suffix_0(n + 1, 0), suffix_1(n + 1, 0);
28
        for (int j = 1; j <= n; ++j) {
29
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0');
30
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1');
31
        }
32
        33
        int min_cost = INT_MAX;
34
        35
        // Iterate over all possible prefixes (i)
36
        for (int i = 0; i <= n; ++i) {
37
            int j_max = n - i;
38
            int left = 0, right = j_max;
39
            int best_j = 0;
40
            int best_cost = INT_MAX;
41
            42
            // Binary search for the best j
43
            while (left <= right) {
44
                int mid = (left + right) / 2;
45
                int remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid]);
46
                int decommissioned_1 = prefix_1[i] + suffix_1[mid];
47
                int current_cost = max(remaining_0, decommissioned_1);
48
                49
                if (current_cost < best_cost) {
50
                    best_cost = current_cost;
51
                    best_j = mid;
52
                } else if (current_cost == best_cost && mid < best_j) {
53
                    best_j = mid;
54
                }
55
                56
                if (decommissioned_1 < remaining_0) {
57
                    left = mid + 1;
58
                } else {
59
                    right = mid - 1;
60
                }
61
            }
62
            63
            // Check neighboring j values
64
            for (int dj : {-1, 0, 1}) {
65
                int j = best_j + dj;
66
                if (j >= 0 && j <= j_max) {
67
                    int remaining_0 = total_0 - (prefix_0[i] + suffix_0[j]);
68
                    int decommissioned_1 = prefix_1[i] + suffix_1[j];
69
                    int current_cost = max(remaining_0, decommissioned_1);
70
                    if (current_cost < best_cost) {
71
                        best_cost = current_cost;
72
                    }
73
                }
74
            }
75
            76
            if (best_cost < min_cost) {
77
                min_cost = best_cost;
78
            }
79
        }
80
        81
        results.push_back(min_cost);
82
    }
83
    84
    return results;
85
}
86
87
int main() {
88
    int T;
89
    cin >> T;
90
    vector<string> test_cases(T);
91
    for (int i = 0; i < T; ++i) {
92
        cin >> test_cases[i];
93
    }
94
    95
    vector<int> results = min_decommissioning_cost(test_cases);
96
    97
    for (int result : results) {
98
        cout << result << endl;
99
    }
100
    101
    return 0;
102
}
103",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054563
1390054569,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FirewallBreach {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt(); 
7
8
        while (T-- > 0) {
9
            int n = scanner.nextInt(); 
10
            int k = scanner.nextInt(); 
11
12
            long[] strengths = new long[n];
13
            for (int i = 0; i < n; i++) {
14
                strengths[i] = scanner.nextLong(); 
15
            }
16
17
            System.out.println(minimumEffort(n, k, strengths));
18
        }
19
        scanner.close();
20
    }
21
22
    private static long minimumEffort(int n, int k, long[] strengths) {
23
        long minEffort = Long.MAX_VALUE;
24
        long[] cumulative = new long[n + 1]; 
25
        for (int i = 0; i < n; i++) {
26
            cumulative[i + 1] = cumulative[i] + strengths[i];
27
        }
28
29
        minEffort = cumulative[n];
30
31
        for (int skip = 0; skip <= k; skip++) {
32
            for (int start = 0; start + skip <= n; start++) {
33
                long effort = 0;
34
                if (start > 0) {
35
                    effort += cumulative[start];
36
                }
37
                if (start + skip < n) {
38
39
                    for (int j = start + skip; j < n; j++) {
40
                        effort += strengths[j] + (j - (start + skip));
41
                    }
42
                }
43
                minEffort = Math.min(minEffort, effort);
44
            }
45
        }
46
47
        return minEffort;
48
    }
49
}",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054569
1390054556,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultyComponentDetector {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt(); // Number of test cases
7
8
        while (t-- > 0) {
9
            int n = sc.nextInt(); // Size of the array
10
            int k = sc.nextInt(); // Batch size
11
            int[] arr = new int[n];
12
13
            for (int i = 0; i < n; i++) {
14
                arr[i] = sc.nextInt();
15
            }
16
17
            List<Integer> result = findEarliestFaults(arr, k);
18
            for (int num : result) {
19
                System.out.print(num + "" "");
20
            }
21
            System.out.println();
22
        }
23
24
        sc.close();
25
    }
26
27
    private static List<Integer> findEarliestFaults(int[] arr, int k) {
28
        List<Integer> result = new ArrayList<>();
29
        Deque<Integer> deque = new LinkedList<>();
30
31
        for (int i = 0; i < arr.length; i++) {
32
            // Remove elements that are out of the current window
33
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
34
                deque.poll();
35
            }
36
37
            // Add new negative number index to the deque
38
            if (arr[i] < 0) {
39
                deque.offer(i);
40
            }
41
42
            // Start collecting results when we have a complete window
43
            if (i >= k - 1) {
44
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
45
            }
46
        }
47
48
        return result;
49
    }
50
}",76,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054556
1390054549,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        benefits = []
12
        for i in range(n):
13
            benefit = a[i] - (n - i - 1)
14
            benefits.append((benefit, i))
15
        16
        # Sort by benefit descending
17
        benefits.sort(reverse=True)
18
19
        skipped = [False] * n
20
21
        # Mark the top k firewalls to skip
22
        for i in range(k):
23
            _, idx = benefits[i]
24
            skipped[idx] = True
25
26
        # Calculate total effort
27
        total_effort = 0
28
        penalty = 0  # number of skipped firewalls so far
29
        for i in range(n):
30
            if skipped[i]:
31
                penalty += 1
32
            else:
33
                total_effort += a[i] + penalty
34
35
        print(total_effort)
36
37
# Run main() inside a separate thread to avoid recursion limit issues in large input
38
threading.Thread(target=main).start()
39
40
41",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054549
1390054551,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
3
    left = 0
4
5
    zeros = 0
6
7
    max_ones = 0
8
9
    n = len(s)
10
11
    for right in range(n):
12
13
        if s[right] == '0':
14
15
            zeros += 1
16
17
        while zeros > k:
18
19
            if s[left] == '0':
20
21
                zeros -= 1
22
23
            left += 1
24
25
        current_ones = (right - left + 1) - zeros
26
27
        max_ones = max(max_ones, current_ones)
28
29
    30
31
    return max_ones
32
33
def main():
34
35
    T = int(input())
36
37
    for _ in range(T):
38
39
        s = input().strip()
40
41
        n = len(s)
42
43
        total_ones = s.count('1')
44
45
        # Calculate max consecutive ones
46
47
        max_consecutive_ones = 0
48
49
        current = 0
50
51
        for c in s:
52
53
            if c == '1':
54
55
                current += 1
56
57
                max_consecutive_ones = max(max_consecutive_ones, current)
58
59
            else:
60
61
                current = 0
62
63
        if total_ones == 0 or total_ones == max_consecutive_ones:
64
65
            print(0)
66
67
            continue
68
69
        total_zeros = n - total_ones
70
71
        low, high = 0, max(total_ones, total_zeros)
72
73
        answer = high
74
75
        while low <= high:
76
77
            mid = (low + high) // 2
78
79
            required_ones = max(0, total_ones - mid)
80
81
            if required_ones == 0:
82
83
                answer = mid
84
85
                high = mid - 1
86
87
                continue
88
89
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
90
91
            if max_ones >= required_ones:
92
93
                answer = mid
94
95
                high = mid - 1
96
97
            else:
98
99
                low = mid + 1
100
101
        print(answer)
102
103
if __name__ == ""__main__"":
104
105
    main()",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054551
1390054553,unknown,unknown,unknown,"1
def min_firewall_effort_optimized(n, k, firewalls):
2
    3
    if k >= n:
4
        return 0  # If we can skip all firewalls, effort is 0
5
    6
    min_effort = float('inf')
7
    8
    for i in range(1 << n):
9
        skipped_count = bin(i).count('1')
10
        if skipped_count <= k:
11
            current_effort = 0
12
            skipped = 0
13
            for j in range(n):
14
                if (i >> j) & 1:
15
                    skipped += 1
16
                else:
17
                    current_effort += firewalls[j] + skipped
18
            min_effort = min(min_effort, current_effort)
19
    20
    return min_effort
21
22
if __name__ == ""__main__"":
23
    t = int(input())
24
    for _ in range(t):
25
        n, k = map(int, input().split())
26
        firewalls = list(map(int, input().split()))
27
        result = min_firewall_effort_optimized(n, k, firewalls)
28
        print(result)
29",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054553
1390054545,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }
19
20
      21
        auto check = [&](int k) {
22
            int l = 0;
23
         24
            for (int r = 0; r < n; r++) {
25
              26
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
27
                    l++;
28
                }
29
                // wtf ,  check number of 1's decommissioned
30
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
31
                    return true;
32
                }
33
            }
34
      35
            if (prefix_1[n] <= k) {
36
                return true;
37
            }
38
            return false;
39
        };
40
41
        // Binary search for minimum cost
42
        int low = 0, high = n;
43
        while (low < high) {
44
            int mid = (low + high) / 2;
45
            if (check(mid)) {
46
                high = mid;
47
            } else {
48
                low = mid + 1;
49
            }
50
        }
51
        cout << low << endl;
52
    }
53
    return 0;
54
}",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054545
1390054546,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    ios::sync_with_stdio(false);
10
    cin.tie(nullptr);
11
    12
    int T;
13
    cin >> T;
14
    while(T--) {
15
        string s;
16
        cin >> s;
17
        int n = s.size();
18
        19
        // Build prefix sums for zeros and ones.
20
        // prefix0[i] = number of '0's in s[0, i)
21
        // prefix1[i] = number of '1's in s[0, i)
22
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
23
        for (int i = 0; i < n; i++) {
24
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
25
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
26
        }
27
        int totalOnes = prefix1[n];
28
        29
        // We'll binary search for the minimal cost C in the range [0, n].
30
        int low = 0, high = n, ans = n;
31
        while(low <= high) {
32
            int mid = (low + high) / 2;
33
            bool feasible = false;
34
            35
            // For each possible prefix removal (i.e. for each starting index l of the kept substring)
36
            for (int l = 0; l <= n; l++) {
37
                // In the kept substring s[l, r), the zeros count is: prefix0[r] - prefix0[l].
38
                // We require that prefix0[r] - prefix0[l] <= mid.
39
                // That is, prefix0[r] <= prefix0[l] + mid.
40
                // Because prefix0 is non-decreasing, we can use upper_bound:
41
                int allowed = prefix0[l] + mid;
42
                // Find the first index r (in [l, n+1)) where prefix0[r] > allowed.
43
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
44
                // Then the maximum r with zeros constraint is r_max = r - 1.
45
                if(r - 1 < l) continue; // should not happen because at least r = l exists.
46
                int r_max = r - 1;
47
                // Ones kept in s[l, r_max) is:
48
                int onesKept = prefix1[r_max] - prefix1[l];
49
                // We need onesKept >= totalOnes - mid.
50
                if(onesKept >= totalOnes - mid) {
51
                    feasible = true;
52
                    break;
53
                }
54
            }
55
            56
            if(feasible) {
57
                ans = mid;
58
                high = mid - 1;
59
            } else {
60
                low = mid + 1;
61
            }
62
        }
63
        64
        cout << ans << ""\n"";
65
    }
66
    return 0;
67
}",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054546
1390054547,unknown,unknown,unknown,"1
def min_decommission_cost(rack):
2
    n = len(rack)
3
    # Precompute prefix sums:
4
    # active_prefix[i] = number of '1's in rack[0:i]
5
    # idle_prefix[i] = number of '0's in rack[0:i]
6
    active_prefix = [0] * (n + 1)
7
    idle_prefix = [0] * (n + 1)
8
    for i in range(n):
9
        active_prefix[i + 1] = active_prefix[i] + (1 if rack[i] == '1' else 0)
10
        idle_prefix[i + 1] = idle_prefix[i] + (1 if rack[i] == '0' else 0)
11
    12
    A = active_prefix[n]  # total active servers
13
14
    # Check if it's possible to achieve a cost <= C.
15
    def can_achieve(C):
16
        # For each starting index, we try to find a minimal j such that:
17
        # active_prefix[j] - active_prefix[i] >= A - C  (i.e. at least A - C active servers in segment)
18
        # and check if idle_prefix[j] - idle_prefix[i] <= C.
19
        for i in range(n + 1):
20
            # Required active servers in the segment:
21
            req = A - C
22
            # We need to find the smallest j in [i, n] with:
23
            # active_prefix[j] >= active_prefix[i] + req.
24
            lo_j, hi_j = i, n + 1
25
            while lo_j < hi_j:
26
                mid = (lo_j + hi_j) // 2
27
                if active_prefix[mid] >= active_prefix[i] + req:
28
                    hi_j = mid
29
                else:
30
                    lo_j = mid + 1
31
            j = lo_j
32
            if j <= n and active_prefix[j] >= active_prefix[i] + req:
33
                # Check if the idle servers in the segment [i, j] are at most C.
34
                if idle_prefix[j] - idle_prefix[i] <= C:
35
                    return True
36
        return False
37
38
    # The answer must lie between 0 and max(A, n - A)
39
    lo, hi = 0, max(A, n - A)
40
    ans = hi
41
    while lo <= hi:
42
        mid = (lo + hi) // 2
43
        if can_achieve(mid):
44
            ans = mid
45
            hi = mid - 1
46
        else:
47
            lo = mid + 1
48
    return ans
49
50
def main():
51
    t = int(input().strip())
52
    for _ in range(t):
53
        rack = input().strip()
54
        result = min_decommission_cost(rack)
55
        print(result)
56
57
if __name__ == ""__main__"":
58
    main()
59",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054547
1390054537,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt();
7
8
        while (t-- > 0) {
9
            int n = sc.nextInt(), k = sc.nextInt();
10
            int[] a = new int[n];
11
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
12
            System.out.println(minEffort(n, k, a));
13
        }
14
        sc.close();
15
    }
16
17
    static int minEffort(int n, int k, int[] a) {
18
        int[][] dp = new int[n + 1][k + 1];
19
20
        for (int i = n - 1; i >= 0; i--) {
21
            for (int skip = k; skip >= 0; skip--) {
22
                int take = a[i] + skip + dp[i + 1][skip];
23
                int leave = (skip < k) ? dp[i + 1][skip + 1] : Integer.MAX_VALUE;
24
                dp[i][skip] = Math.min(take, leave);
25
            }
26
        }
27
28
        return dp[0][0];
29
    }
30
}
31",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054537
1390054543,unknown,unknown,unknown,"1
t = int(input())
2
3
for _ in range(t):
4
    n, k = map(int, input().split())
5
    firewalls = list(map(int, input().split()))
6
7
    if k >= n:  
8
        print(0)
9
        continue
10
11
    min_effort = sum(firewalls)  
12
13
    for i in range(n - k + 1): 
14
        effort = 0
15
        skipped = 0
16
17
        for j in range(n):
18
            if i <= j < i + k:  
19
                skipped += 1
20
                continue
21
            22
            effort += firewalls[j] + skipped  
23
        min_effort = min(min_effort, effort)  
24
25
    print(min_effort)
26",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054543
1390054533,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):  
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]  
3
    dp[0][0] = 0  
4
5
    for i in range(1, n + 1):  
6
        for j in range(k + 1):  
7
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j  
8
            if j > 0:  
9
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])  
10
11
    return min(dp[n])  
12
13
T = int(input())  
14
for _ in range(T):  
15
    n, k = map(int, input().split())  
16
    firewalls = list(map(int, input().split()))  
17
    print(min_effort(n, k, firewalls))
18",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054533
1390054531,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
        5
    impacts = []
6
    7
    for i in range(n):
8
        impact = strengths[i] - (n - i - 1)
9
        impacts.append((impact, i))
10
    11
    impacts.sort(reverse=True)
12
    13
    to_skip = set(impacts[i][1] for i in range(k))
14
    15
    total_effort = 0
16
    penalty = 0
17
    18
    for i in range(n):
19
        if i in to_skip:
20
            penalty += 1
21
        else:
22
            total_effort += strengths[i] + penalty
23
    24
    return total_effort
25
26
def solve_test_cases():
27
    t = int(input())  
28
    results = []
29
    30
    for _ in range(t):
31
        n, k = map(int, input().split())
32
        strengths = list(map(int, input().split()))
33
        results.append(min_effort_to_breach(n, k, strengths))
34
    35
    return results
36
37
def main():
38
    results = solve_test_cases()
39
    40
    for result in results:
41
        print(result)
42
43
if __name__ == ""__main__"":
44
    main()",77,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054531
1390054524,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <algorithm>
4
#include <vector>
5
6
using namespace std;
7
8
int main() {
9
    int T;
10
    cin >> T;
11
    while (T--) {
12
        string s;
13
        cin >> s;
14
        int n = s.length();
15
16
        int total_ones = 0;
17
        for (char c : s) {
18
            if (c == '1') {
19
                total_ones++;
20
            }
21
        }
22
23
        int min_cost = n;
24
25
        for (int l = 0; l <= n; ++l) {
26
            int kept_ones = 0;
27
            int kept_zeros = 0;
28
            for (int r = l; r <= n; ++r) {
29
                if (r > l) {
30
                    if (s[r - 1] == '1') {
31
                        kept_ones++;
32
                    } else {
33
                        kept_zeros++;
34
                    }
35
                }
36
                int removed_ones = total_ones - kept_ones;
37
                min_cost = min(min_cost, max(removed_ones, kept_zeros));
38
            }
39
        }
40
        cout << min_cost << endl;
41
    }
42
    return 0;
43
}
44",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054524
1390054525,unknown,unknown,unknown,"1
def solve():
2
    """"""Solves the server decommissioning problem.""""""
3
4
    T = int(input())
5
    for _ in range(T):
6
        servers = input().strip()
7
        n = len(servers)
8
        9
        min_cost = float('inf')
10
11
        for i in range(n + 1):  # Remove i from start
12
            for j in range(n - i + 1):  # Remove j from end
13
                remaining = servers[i:n - j]
14
                15
                if not remaining:
16
                    min_cost = min(min_cost, 0)
17
                    continue
18
                19
                idle_count = remaining.count('0')
20
                active_removed = servers[:i].count('1') + servers[n - j:].count('1')
21
22
                min_cost = min(min_cost, max(idle_count, active_removed))
23
        24
        print(min_cost)
25
26
solve()
27",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054525
1390054528,unknown,unknown,unknown,"1
def min_decommission_cost(s: str) -> int:
2
    n = len(s)
3
    ones_pos = [i for i, ch in enumerate(s) if ch == '1']
4
    T = len(ones_pos)
5
    6
    if T == 0:
7
        return 0
8
    9
    zeros_total = s.count('0')
10
    ans = min(zeros_total, T) 
11
    12
    for X in range(1, T + 1):
13
        for i in range(0, T - X + 1):
14
            left = ones_pos[i]
15
            right = ones_pos[i + X - 1]
16
            length = right - left + 1
17
            zeros_in_block = length - X
18
            candidate = max(zeros_in_block, T - X)
19
            ans = min(ans, candidate)
20
    21
    return ans
22
23
if __name__ == '__main__':
24
    T = int(input().strip())
25
    for _ in range(T):
26
        s = input().strip()
27
        print(min_decommission_cost(s))
28",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054528
1390054514,unknown,unknown,unknown,"1
import sys
2
3
def min_decommission_cost(binary_str):
4
    trimmed_str = binary_str.strip('0')
5
    6
    if not trimmed_str:
7
        return 0  
8
    9
10
    total_zeros = trimmed_str.count('0')
11
    min_cost = total_zeros  
12
    13
    removed_ones = 0
14
    for ch in trimmed_str:
15
        if ch == '1':
16
            removed_ones += 1
17
        else:
18
            total_zeros -= 1  
19
        20
        min_cost = min(min_cost, max(total_zeros, removed_ones))
21
    22
    return min_cost
23
24
def main():
25
    T = int(sys.stdin.readline().strip())
26
    results = []
27
    28
    for _ in range(T):
29
        binary_str = sys.stdin.readline().strip()
30
        results.append(str(min_decommission_cost(binary_str)))
31
    32
    sys.stdout.write(""\n"".join(results) + ""\n"")
33
34
if __name__ == ""__main__"":
35
    main()
36
37",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054514
1390054519,unknown,unknown,unknown,"1
def min_eff(n, k, s):
2
    if k >= n:
3
        return 0
4
5
    imp = []
6
    for i in range(n):
7
        imp.append((s[i] - (n - i - 1), i))
8
9
    imp.sort(reverse=True)
10
    skip = set(imp[i][1] for i in range(k))
11
12
    eff, p = 0, 0
13
    for i in range(n):
14
        if i in skip:
15
            p += 1
16
        else:
17
            eff += s[i] + p
18
19
    return eff
20
21
def solve():
22
    t = int(input())
23
    res = []
24
    for _ in range(t):
25
        n, k = map(int, input().split())
26
        s = list(map(int, input().split()))
27
        res.append(min_eff(n, k, s))
28
29
    for r in res:
30
        print(r)
31
32
if __name__ == ""__main__"":
33
    solve()
34",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054519
1390054523,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054523
1390054509,unknown,unknown,unknown,"1
import sys
2
3
def min_operations_to_make_consecutive():
4
    test_cases = int(sys.stdin.readline().strip())
5
    6
    for _ in range(test_cases):
7
        binary_str = sys.stdin.readline().strip()
8
        9
        ones_positions = [idx for idx, char in enumerate(binary_str) if char == '1']
10
        total_ones = len(ones_positions)
11
        12
        if total_ones == 0 or ones_positions[-1] - ones_positions[0] == total_ones - 1:
13
            print(0)
14
            continue
15
        16
        left, right = 0, total_ones
17
        18
        while right - left > 1:
19
            mid = (left + right) // 2
20
            ones_needed = total_ones - mid
21
            22
            feasible = False
23
            for i in range(mid + 1):
24
                start, end = ones_positions[i], ones_positions[i + ones_needed - 1]
25
                if (end - start + 1) - ones_needed <= mid:
26
                    feasible = True
27
                    break
28
            29
            if feasible:
30
                right = mid
31
            else:
32
                left = mid
33
        34
        print(right)
35
36
if __name__ == ""__main__"":
37
    min_operations_to_make_consecutive()",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054509
1390054510,unknown,unknown,unknown,"1
import sys
2
data = sys.stdin.read().split()
3
if not data:
4
    exit()
5
t = int(data[0])
6
ptr = 1
7
res = []
8
for _ in range(t):
9
    n = int(data[ptr]); k = int(data[ptr+1]); ptr += 2
10
    arr = list(map(int, data[ptr:ptr+n])); ptr += n
11
    total = sum(arr)
12
    b = [arr[i] - ((n - 1) - i) for i in range(n)]
13
    b.sort(reverse=True)
14
    best = 0
15
    s = 0
16
    for x in range(1, min(k, n) + 1):
17
        s += b[x-1]
18
        cur = s + (x * (x - 1)) // 2
19
        if cur > best:
20
            best = cur
21
    res.append(str(total - best))
22
sys.stdout.write(""\n"".join(res))",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054510
1390054507,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    """"""
3
    Calculate the minimum cost of decommissioning servers from the beginning and end of the rack.
4
    5
    Args:
6
        servers (str): Binary string representing rack of servers (0 for idle, 1 for active)
7
    8
    Returns:
9
        int: Minimum possible cost
10
    """"""
11
    n = len(servers)
12
    13
    # Try removing i servers from the beginning and j servers from the end
14
    min_cost = float('inf')
15
    16
    for i in range(n + 1):  # Including the case where we remove 0 from beginning
17
        for j in range(n + 1 - i):  # Including the case where we remove 0 from end
18
            if i + j > n:
19
                continue
20
                21
            # Remaining servers after decommissioning
22
            remaining = servers[i:n-j]
23
            24
            # Count idle servers that remain
25
            idle_remaining = remaining.count('0')
26
            27
            # Count active servers decommissioned
28
            active_decommissioned = 0
29
            for k in range(i):
30
                if servers[k] == '1':
31
                    active_decommissioned += 1
32
            for k in range(n-j, n):
33
                if servers[k] == '1':
34
                    active_decommissioned += 1
35
            36
            # Cost is the maximum of these two factors
37
            cost = max(idle_remaining, active_decommissioned)
38
            min_cost = min(min_cost, cost)
39
    40
    return min_cost
41
42
def main():
43
    # Read number of test cases
44
    t = int(input().strip())
45
    46
    results = []
47
    for _ in range(t):
48
        servers = input().strip()
49
        results.append(min_decommissioning_cost(servers))
50
    51
    # Print results
52
    for result in results:
53
        print(result)
54
55
if __name__ == ""__main__"":
56
    main()",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054507
1390054506,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    a = list(map(int, input().split()))
5
    6
    if k >= n:
7
        print(0)
8
        continue
9
    10
    prev = [float('inf')] * (k + 1)
11
    prev[0] = 0
12
    13
    for i in range(n):
14
        curr = [float('inf')] * (k + 1)
15
        16
        for j in range(k + 1):
17
            if j > 0:
18
                curr[j] = min(curr[j], prev[j - 1])
19
            20
            if j <= i:
21
                curr[j] = min(curr[j], prev[j] + a[i] + j)
22
        23
        prev = curr
24
    25
    print(min(prev))
26",78,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054506
1390054502,unknown,unknown,unknown,"1
def min_cost(s):
2
    n = len(s)
3
    zeros = s.count('0')
4
    ones = n - zeros
5
6
    min_cost = float('inf')
7
    for i in range(n + 1):
8
        for j in range(n + 1):
9
            if i + j > n:
10
                break
11
            remaining_zeros = zeros - (s[:i].count('0') + s[n - j:].count('0'))
12
            decommissioned_ones = ones - s[i:n - j].count('1')
13
            cost = max(remaining_zeros, decommissioned_ones)
14
            min_cost = min(min_cost, cost)
15
16
    return min_cost
17
18
T = int(input())
19
for _ in range(T):
20
    s = input()
21
    print(min_cost(s))
22",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054502
1390054503,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    INF = float('inf')
6
7
    prev = [INF] * (k + 1)
8
    prev[0] = 0
9
10
    for i in range(n):
11
        curr = [INF] * (k + 1)
12
        for s in range(k + 1):
13
            # Don't skip i
14
            curr[s] = prev[s] + a[i] + s
15
            # Skip i (if possible)
16
            if s > 0:
17
                curr[s] = min(curr[s], prev[s - 1])
18
        prev = curr
19
20
    ans = min(prev)
21
    print(ans)
22
23
if __name__ == ""__main__"":
24
    T = int(input())
25
    for _ in range(T):
26
        solve()",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054503
1390054505,unknown,unknown,unknown,"1
import sys
2
3
def min_decommission_cost(server_string):
4
    n = len(server_string)
5
    total_ones = server_string.count('1')
6
7
    # Edge cases: If all are '0's or all are '1's
8
    if total_ones == 0 or total_ones == n:
9
        return 0
10
11
    min_cost = float('inf')
12
    ones_in_window = 0
13
14
    # Sliding window approach
15
    left = 0
16
    for right in range(n):
17
        if server_string[right] == '1':
18
            ones_in_window += 1
19
20
        # Maintain window size <= n-1
21
        if right - left + 1 > n - 1:
22
            if server_string[left] == '1':
23
                ones_in_window -= 1
24
            left += 1
25
26
        if right - left + 1 == n - 1:
27
            zeros_in_window = (right - left + 1) - ones_in_window
28
            ones_removed = total_ones - ones_in_window
29
            cost = max(zeros_in_window, ones_removed)
30
            min_cost = min(min_cost, cost)
31
32
    return min_cost
33
34
def solve():
35
    t = int(sys.stdin.readline().strip())  # Fast input reading
36
    results = []
37
    38
    for _ in range(t):
39
        server_string = sys.stdin.readline().strip()
40
        results.append(str(min_decommission_cost(server_string)))
41
42
    sys.stdout.write(""\n"".join(results) + ""\n"")  # Fast output
43
44
# Run the function
45
solve()
46",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054505
1390054493,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    T = int(sys.stdin.readline().strip())
5
    for _ in range(T):
6
        n, k = map(int, sys.stdin.readline().split())
7
        a = list(map(int, sys.stdin.readline().split()))
8
        9
        sum_a = sum(a)
10
        values = [a[i] - (n - i - 1) for i in range(n)]
11
        values.sort(reverse=True)
12
        prefix_sum = [0] * (n + 1)
13
        for i in range(1, n + 1):
14
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
15
        max_m = min(k, n)
16
        max_total = float('-inf')
17
        for m in range(max_m + 1):
18
            current = prefix_sum[m] + (m * (m - 1)) // 2
19
            max_total = max(max_total, current)
20
        min_effort = sum_a - max_total
21
        print(min_effort)
22
23
if __name__ == ""__main__"":
24
    main()",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054493
1390054496,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054496
1390054499,unknown,unknown,unknown,"1
def min_effort_to_breach(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
8
    dp[0][0] = 0
9
    10
    for i in range(1, n + 1):
11
        fw = firewalls[i - 1]
12
        13
        for j in range(k + 1):
14
            if j <= i - 1:
15
                dp[i][j] = min(dp[i][j], dp[i-1][j] + fw + j)
16
            17
            if j > 0:
18
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
19
    20
    return min(dp[n])
21
22
import sys
23
input = sys.stdin.readline
24
25
t = int(input())
26
for _ in range(t):
27
    n, k = map(int, input().split())
28
    firewalls = list(map(int, input().split()))
29
    print(min_effort_to_breach(firewalls, k))",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054499
1390054489,unknown,unknown,unknown,"1
def minimize_effort(T, test_cases):
2
    results = []
3
    for t in range(T):
4
        n, k = test_cases[t][0]
5
        firewalls = test_cases[t][1]
6
        7
        # Sort firewalls in increasing order
8
        firewalls.sort()
9
        10
        # Skip up to k weakest firewalls
11
        skipped_strength = sum(firewalls[:k]) if k > 0 else 0
12
        13
        # Total effort is sum of all strengths minus skipped strengths
14
        total_effort = sum(firewalls) - skipped_strength
15
        results.append(total_effort)
16
    17
    return results
18
19
# Sample Input
20
T = 2
21
test_cases = [
22
    ((4, 1), [5, 10, 11, 5]),  # Test case 1
23
    ((4, 4), [8, 7, 1, 4])     # Test case 2
24
]
25
26
# Running the Code
27
results = minimize_effort(T, test_cases)
28
29
# Output the results
30
for res in results:
31
    print(res)
32",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054489
1390054491,unknown,unknown,unknown,"1
def min_decommission_cost(server_rack):
2
    total_active = server_rack.count('1')
3
    total_idle = server_rack.count('0')
4
5
    min_cost = min(total_active, total_idle)  # Worst case: remove all active or all idle
6
7
    left, right = 0, len(server_rack) - 1
8
    removed_active = 0
9
    removed_idle = 0
10
11
    # Try decommissioning from both ends
12
    while left <= right:
13
        if server_rack[left] == '0':
14
            removed_idle += 1
15
            left += 1
16
        elif server_rack[right] == '0':
17
            removed_idle += 1
18
            right -= 1
19
        elif server_rack[left] == '1':
20
            removed_active += 1
21
            left += 1
22
        elif server_rack[right] == '1':
23
            removed_active += 1
24
            right -= 1
25
        26
        remaining_idle = total_idle - removed_idle
27
        min_cost = min(min_cost, max(remaining_idle, removed_active))
28
29
    return min_cost
30
31
32
# Read input
33
T = int(input())  # Number of test cases
34
results = []
35
36
for _ in range(T):
37
    server_rack = input().strip()
38
    results.append(min_decommission_cost(server_rack))
39
40
# Print results
41
for res in results:
42
    print(res)",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054491
1390054492,unknown,unknown,unknown,"1
def max_ones_with_at_most_k_zeros(s, k):
2
3
    left = 0
4
5
    zeros = 0
6
7
    max_ones = 0
8
9
    n = len(s)
10
11
    for right in range(n):
12
13
        if s[right] == '0':
14
15
            zeros += 1
16
17
        while zeros > k:
18
19
            if s[left] == '0':
20
21
                zeros -= 1
22
23
            left += 1
24
25
        current_ones = (right - left + 1) - zeros
26
27
        max_ones = max(max_ones, current_ones)
28
29
    30
31
    return max_ones
32
33
def main():
34
35
    T = int(input())
36
37
    for _ in range(T):
38
39
        s = input().strip()
40
41
        n = len(s)
42
43
        total_ones = s.count('1')
44
45
        # Calculate max consecutive ones
46
47
        max_consecutive_ones = 0
48
49
        current = 0
50
51
        for c in s:
52
53
            if c == '1':
54
55
                current += 1
56
57
                max_consecutive_ones = max(max_consecutive_ones, current)
58
59
            else:
60
61
                current = 0
62
63
        if total_ones == 0 or total_ones == max_consecutive_ones:
64
65
            print(0)
66
67
            continue
68
69
        total_zeros = n - total_ones
70
71
        low, high = 0, max(total_ones, total_zeros)
72
73
        answer = high
74
75
        while low <= high:
76
77
            mid = (low + high) // 2
78
79
            required_ones = max(0, total_ones - mid)
80
81
            if required_ones == 0:
82
83
                answer = mid
84
85
                high = mid - 1
86
87
                continue
88
89
            max_ones = max_ones_with_at_most_k_zeros(s, mid)
90
91
            if max_ones >= required_ones:
92
93
                answer = mid
94
95
                high = mid - 1
96
97
            else:
98
99
                low = mid + 1
100
101
        print(answer)
102
103
if __name__ == ""__main__"":
104
105
    main()",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054492
1390054488,unknown,unknown,unknown,"1
import sys  
2
from itertools import accumulate  
3
4
def min_effort(arr, k):  
5
    n = len(arr)  
6
    T = sum(arr)  
7
    A = [arr[i] + (i + 1) for i in range(n)]  
8
    A.sort(reverse=True)  
9
    P = [0] + list(accumulate(A))  
10
    m_max = min(k, n)  
11
    best = float('inf')  
12
    13
    for m in range(m_max + 1):  
14
        cost = T + m * n - (m * m - m) // 2 - P[m]  
15
        if cost < best:  
16
            best = cost  
17
            18
    return best  
19
20
def solve():  
21
    data = sys.stdin.read().strip().split()  
22
    if not data:  
23
        return  
24
    t = int(data[0])  
25
    index = 1  
26
    res = []  
27
    28
    for _ in range(t):  
29
        n = int(data[index])  
30
        index += 1  
31
        k = int(data[index])  
32
        index += 1  
33
        arr = list(map(int, data[index:index + n]))  
34
        index += n  
35
        res.append(str(min_effort(arr, k)))  
36
        37
    sys.stdout.write(""\n"".join(res) +  
38
39
if __name__ == 
40
    solve()  ",79,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054488
1390054484,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
8
    for _ in range(t):
9
        s = input_data[line].strip()
10
        line += 1
11
        n = len(s)
12
13
        # Get indices of active servers ('1')
14
        positions = [i for i, ch in enumerate(s) if ch == '1']
15
        m = len(positions)
16
17
        if m == 0:
18
            out_lines.append(""0"")
19
            continue
20
21
        # Precompute A: A[i] = positions[i] - i
22
        A = [positions[i] - i for i in range(m)]
23
24
        # Define the check function
25
        def check(X):
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                while j < m and A[j] - A[i] <= X:
33
                    j += 1
34
                if j - i >= m - X:
35
                    return True
36
            return False
37
38
        # Binary search for the minimum X
39
        lo, hi, ans = 0, n, n
40
        while lo <= hi:
41
            mid = (lo + hi) // 2
42
            if check(mid):
43
                ans = mid
44
                hi = mid - 1
45
            else:
46
                lo = mid + 1
47
48
        out_lines.append(str(ans))
49
50
    sys.stdout.write(""\n"".join(out_lines))
51
52
if __name__ == ""__main__"":
53
    solve()",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054484
1390054485,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    active_servers = server_rack.count('1')
4
    idle_servers = n - active_servers
5
    6
    min_cost = min(max(active_servers, 0), max(idle_servers, 0))  # Initial cost if we remove all servers
7
    8
    # Try removing different numbers of servers from the beginning
9
    for left in range(n + 1):
10
        # For each left choice, try removing different numbers from the end
11
        for right in range(n + 1 - left):
12
            # Calculate the remaining servers after removal
13
            remaining = server_rack[left:n-right]
14
            15
            # If nothing remains, the cost is max(active_servers, idle_servers)
16
            if not remaining:
17
                continue
18
            19
            active_removed = server_rack[:left].count('1') + server_rack[n-right:].count('1')
20
            idle_remaining = remaining.count('0')
21
            22
            cost = max(idle_remaining, active_removed)
23
            min_cost = min(min_cost, cost)
24
    25
    return min_cost
26
27
# Read input
28
t = int(input().strip())
29
for _ in range(t):
30
    server_rack = input().strip()
31
    print(min_decommissioning_cost(server_rack))",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054485
1390054486,unknown,unknown,unknown,"1
import bisect
2
3
t = int(input())
4
for _ in range(t):
5
    s = input().strip()
6
    n = len(s)
7
    8
    if n == 0:
9
        print(0)
10
        continue
11
    if n == 1:
12
        print(0)
13
        continue
14
    if n == 2:
15
        print(1 if s[0] == s[1] else 0)
16
        continue
17
    if not all(c in '01' for c in s):
18
        print(0)
19
        continue
20
    if all(c == '0' for c in s) or all(c == '1' for c in s):
21
        print(0)
22
        continue
23
    24
    prefix_0 = [0] * (n + 1)
25
    prefix_1 = [0] * (n + 1)
26
    for i in range(n):
27
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
28
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
29
    total_1 = prefix_1[n]
30
    31
    low, high = 0, n
32
    while low < high:
33
        m = (low + high) // 2
34
        possible = False
35
        for j in range(n + 1):
36
            target = prefix_0[j] - m
37
            i = bisect.bisect_left(prefix_0, target, 0, j + 1)
38
            if i <= j:
39
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
40
                remaining_zeros = prefix_0[j] - prefix_0[i]
41
                if max(remaining_zeros, ones_removed) <= m:
42
                    possible = True
43
                    break
44
        if possible:
45
            high = m
46
        else:
47
            low = m + 1
48
    print(low)",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054486
1390054480,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt();
7
        8
        while (t-- > 0) {
9
            int n = sc.nextInt(), k = sc.nextInt();
10
            int[] a = new int[n];
11
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
12
            System.out.println(minEffort(n, k, a));
13
        }
14
        sc.close();
15
    }
16
    17
    static int minEffort(int n, int k, int[] a) {
18
        k = Math.min(k, n);
19
        int[][] dp = new int[n + 1][k + 1];
20
        for (int[] row : dp) Arrays.fill(row, -1);
21
        return dfs(0, 0, n, k, a, dp);
22
    }
23
    24
    static int dfs(int i, int skip, int n, int k, int[] a, int[][] dp) {
25
        if (i == n) return 0;
26
        if (dp[i][skip] != -1) return dp[i][skip];
27
        28
        int take = a[i] + skip + dfs(i + 1, skip, n, k, a, dp);
29
        int leave = (skip < k) ? dfs(i + 1, skip + 1, n, k, a, dp) : Integer.MAX_VALUE;
30
        31
        return dp[i][skip] = Math.min(take, leave);
32
    }
33
}
34",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054480
1390054482,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
5
    int n = arr.size();
6
    vector<int> result;
7
    deque<int> dq;  // Stores indices of negative numbers
8
9
    // Process first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) dq.push_back(i);
12
    }
13
14
    // Process the sliding window
15
    for (int i = k; i <= n; i++) {
16
        // Append first negative number in the window
17
        if (!dq.empty()) 
18
            result.push_back(arr[dq.front()]);  // First negative in the deque
19
        else 
20
            result.push_back(0);  // No negative number
21
22
        // Remove elements that are out of the current window
23
        while (!dq.empty() && dq.front() < i - k + 1) {
24
            dq.pop_front();
25
        }
26
27
        // Add the next element if negative
28
        if (i < n && arr[i] < 0) {
29
            dq.push_back(i);
30
        }
31
    }
32
33
    return result;
34
}
35
36
int main() {
37
    int t;
38
    cin >> t;  // Number of test cases
39
    while (t--) {
40
        int n, k;
41
        cin >> n >> k;  // Size of array and batch size
42
        vector<int> arr(n);
43
        for (int i = 0; i < n; i++) {
44
            cin >> arr[i];
45
        }
46
        47
        vector<int> result = earliest_faulty_readings(arr, k);
48
        for (int num : result) {
49
            cout << num << "" "";
50
        }
51
        cout << endl;
52
    }
53
    return 0;
54
}",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054482
1390054475,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
using ll = long long;
5
6
int main() {
7
    // Optimize input/output
8
    ios::sync_with_stdio(false);
9
    cin.tie(0);
10
11
    int T;
12
    cin >> T;
13
    for (int t = 0; t < T; t++) {
14
        int n, k;
15
        cin >> n >> k;
16
        vector<ll> a(n);
17
        for (int i = 0; i < n; i++) {
18
            cin >> a[i];
19
        }
20
21
        // INF for impossible states , really tough one to solved actually 
22
        const ll INF = 1e18;
23
24
        vector<ll> prev(k + 1, INF);
25
        prev[0] = 0; 
26
27
    28
        for (int i = 0; i < n; i++) {
29
            vector<ll> curr(k + 1, INF);
30
            for (int s = 0; s <= k; s++) {
31
                // Don't skip i
32
                curr[s] = prev[s] + a[i] + s;
33
                // Skip i (if possible)
34
                if (s > 0) {
35
                    curr[s] = min(curr[s], prev[s - 1]);
36
                }
37
            }
38
            prev = curr; 
39
        }
40
41
42
        ll ans = *min_element(prev.begin(), prev.end());
43
        cout << ans << '\n';
44
    }
45
    return 0;
46
}",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054475
1390054472,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    prev_dp = [float('inf')] * (k + 1)
3
    prev_dp[0] = 0  
4
5
    for i in range(1, n + 1):
6
        curr_dp = [float('inf')] * (k + 1)
7
8
        for j in range(k + 1):
9
            curr_dp[j] = prev_dp[j] + firewalls[i - 1] + j  
10
11
            if j > 0:  
12
                curr_dp[j] = min(curr_dp[j], prev_dp[j - 1])
13
14
        prev_dp = curr_dp  
15
16
    return min(prev_dp)
17
18
T = int(input())
19
for _ in range(T):
20
    n, k = map(int, input().split())
21
    firewalls = list(map(int, input().split()))
22
23
    print(min_effort(n, k, firewalls))
24",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054472
1390054471,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    ios::sync_with_stdio(false);
10
    cin.tie(nullptr);
11
    12
    int T;
13
    cin >> T;
14
    while(T--) {
15
        string s;
16
        cin >> s;
17
        int n = s.size();
18
        19
        // Build prefix sums for zeros and ones.
20
        // prefix0[i] = number of '0's in s[0, i)
21
        // prefix1[i] = number of '1's in s[0, i)
22
        vector<int> prefix0(n+1, 0), prefix1(n+1, 0);
23
        for (int i = 0; i < n; i++) {
24
            prefix0[i+1] = prefix0[i] + (s[i] == '0');
25
            prefix1[i+1] = prefix1[i] + (s[i] == '1');
26
        }
27
        int totalOnes = prefix1[n];
28
        29
        // We'll binary search for the minimal cost C in the range [0, n].
30
        int low = 0, high = n, ans = n;
31
        while(low <= high) {
32
            int mid = (low + high) / 2;
33
            bool feasible = false;
34
            35
            // For each possible prefix removal (i.e. for each starting index l of the kept substring)
36
            for (int l = 0; l <= n; l++) {
37
                // In the kept substring s[l, r), the zeros count is: prefix0[r] - prefix0[l].
38
                // We require that prefix0[r] - prefix0[l] <= mid.
39
                // That is, prefix0[r] <= prefix0[l] + mid.
40
                // Because prefix0 is non-decreasing, we can use upper_bound:
41
                int allowed = prefix0[l] + mid;
42
                // Find the first index r (in [l, n+1)) where prefix0[r] > allowed.
43
                int r = upper_bound(prefix0.begin() + l, prefix0.end(), allowed) - prefix0.begin();
44
                // Then the maximum r with zeros constraint is r_max = r - 1.
45
                if(r - 1 < l) continue; // should not happen because at least r = l exists.
46
                int r_max = r - 1;
47
                // Ones kept in s[l, r_max) is:
48
                int onesKept = prefix1[r_max] - prefix1[l];
49
                // We need onesKept >= totalOnes - mid.
50
                if(onesKept >= totalOnes - mid) {
51
                    feasible = true;
52
                    break;
53
                }
54
            }
55
            56
            if(feasible) {
57
                ans = mid;
58
                high = mid - 1;
59
            } else {
60
                low = mid + 1;
61
            }
62
        }
63
        64
        cout << ans << ""\n"";
65
    }
66
    return 0;
67
}
68",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054471
1390054469,unknown,unknown,unknown,"1
function processData(input) {
2
    let lines = input.trim().split(/\s+/);
3
    let idx = 0;
4
    let T = parseInt(lines[idx++]);
5
    let result = [];
6
7
    for (let t = 0; t < T; t++) {
8
        let n = parseInt(lines[idx]);
9
        let k = parseInt(lines[idx + 1]);
10
        idx += 2;
11
12
        let a = lines.slice(idx, idx + n).map(Number);
13
        idx += n;
14
15
        let sumA = a.reduce((sum, val) => sum + val, 0);
16
        let v = [];
17
18
        for (let i = 0; i < n; i++) {
19
            v.push(a[i] - (n - i - 1));
20
        }
21
22
        v.sort((a, b) => b - a); 
23
24
        let prefix = Array(n + 1).fill(0);
25
        for (let i = 0; i < n; i++) {
26
            prefix[i + 1] = prefix[i] + v[i];
27
        }
28
29
        let maxSum = 0;
30
        let maxT = Math.min(k, n);
31
32
        for (let t = 0; t <= maxT; t++) {
33
            let current = prefix[t] + (t * (t - 1)) / 2;
34
            maxSum = Math.max(maxSum, current);
35
        }
36
37
        result.push(sumA - maxSum);
38
    }
39
40
    console.log(result.join(""\n""));
41
}
42
43
// Handling input from stdin
44
process.stdin.resume();
45
process.stdin.setEncoding(""utf-8"");
46
let _input = """";
47
48
process.stdin.on(""data"", function (input) {
49
    _input += input;
50
});
51
52
process.stdin.on(""end"", function () {
53
    processData(_input);
54
});
55",80,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054469
1390054461,unknown,unknown,unknown,"1
def min_effort(n,k,firewalls):
2
    min_effort=float('inf')
3
    for i in range(n):
4
        effort=sum(firewalls[:i])+sum(firewalls[i+k:])+k*(n-(i+k))
5
        min_effort=min(min_effort,effort)
6
    return min_effort
7
        8
t=int(input())
9
for _ in range(t):
10
    n,k=map(int,input().split())
11
    firewalls =list(map(int,input().split()))
12
    print(min_effort(n,k,firewalls))",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054461
1390054463,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054463
1390054464,unknown,unknown,unknown,"1
def optimize():
2
    count, skip = map(int, input().split())
3
    power = list(map(int, input().split()))
4
5
    dp = {}  
6
7
    for index in range(count, -1, -1):
8
        for remain in range(skip, -1, -1):
9
            for inc in range(count, -1, -1):
10
                if index == count:
11
                    dp[(index, remain, inc)] = 0
12
                else:
13
                    not_skip = power[index] + inc + dp.get((index + 1, remain, inc), float('inf'))
14
                    if_skipped = float('inf')
15
                    if remain > 0:
16
                        if_skipped = dp.get((index + 1, remain - 1, inc + 1), float('inf'))
17
                    dp[(index, remain, inc)] = min(not_skip, if_skipped)
18
19
    result = dp[(0, skip, 0)]
20
    print(result)
21
22
tc_Amount = int(input())
23
for _ in range(tc_Amount):
24
    optimize()",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054464
1390054454,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
3
    results = []
4
5
    6
7
    for _ in range(test_cases):
8
9
        n, k = map(int, input().split())
10
11
        a = list(map(int, input().split()))
12
13
        14
15
        sum_a = sum(a)
16
17
        18
19
        values = [a[i] - (n - i - 1) for i in range(n)]
20
21
        values.sort(reverse=True)  # Sort in descending order
22
23
        24
25
        prefix_sum = [0] * (n + 1)
26
27
        for i in range(1, n + 1):
28
29
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
30
31
        32
33
        max_m = min(k, n)
34
35
        max_total = float('-inf')
36
37
        38
39
        for m in range(max_m + 1):
40
41
            current = prefix_sum[m] + (m * (m - 1)) // 2
42
43
            max_total = max(max_total, current)
44
45
        46
47
        min_effort = sum_a - max_total
48
49
        results.append(str(min_effort))
50
51
    52
53
    print(""\n"".join(results))
54
55
# Driver code
56
57
if __name__ == ""__main__"":
58
59
    T = int(input())
60
61
    min_effort(T)",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054454
1390054456,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
#include <ext/pb_ds/assoc_container.hpp>
3
#include <ext/pb_ds/tree_policy.hpp>
4
#include <ext/pb_ds/detail/standard_policies.hpp>
5
#include <cmath>
6
#define int long long int
7
#define pb push_back
8
/*---------------------------------------------------------------------------------------------------------------------------------*/
9
/*ASCII small case-> a-97 to z-122
10
upper case-> A-65 to Z-90*/
11
#define nl ""\n""
12
#define mp map<int, int>
13
#define all(v) v.begin(), v.end()
14
#define F first
15
#define S second
16
#define ump unordered_map<long long, int, custom_hash>
17
#define mstpi multiset<pair<int, int> >
18
#define mst multiset<int>
19
#define vec vector<int>
20
#define pi pair<int, int>
21
#define ld long double
22
#define vep vector<pair<int, int>>
23
#define ul unsigned long long
24
#define loop1 for (int i = 0; i < n; i++)
25
#define REP(i, a, b) for (int i = a; i <= b; i++)
26
#define NO cout << ""NO"" << endl
27
#define YES cout << ""YES"" << endl
28
using namespace std;
29
using namespace __gnu_pbds;
30
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
31
/*---------------------------------------------------------------------------------------------------------------------------------*/
32
const double PI = 3.1415926535;
33
const int inf = 1e18;
34
const int mod = 1000000007;
35
/*---------------------------------------------------------------------------------------------------------------------------------*/
36
int modmul(int a, int b, int m)
37
{
38
    a %= m;
39
    b %= m;
40
    return (a * b) % m;
41
}
42
int modexp(int n, int x)
43
{
44
    int ans = 1;
45
    while (n > 0)
46
    {
47
        if (n & 1)
48
        {
49
            ans = (ans * x) % mod;
50
        }
51
        n >>= 1;
52
        x = (x * x) % mod;
53
    }
54
    return ans;
55
}
56
/*---------------------------------------------------------------------------------------------------------------------------------*/
57
string add(string a, string b)
58
{
59
    string ans = """";
60
    int carry = 0;
61
    while (!a.empty() || !b.empty() || carry > 0)
62
    {
63
        int digitA = a.empty() ? 0 : a.back() - '0';
64
        int digitB = b.empty() ? 0 : b.back() - '0';
65
        int sum = digitA + digitB + carry;
66
        ans = to_string(sum % 10) + ans;
67
        carry = sum / 10;
68
        if (!a.empty())
69
            a.pop_back();
70
        if (!b.empty())
71
            b.pop_back();
72
    }
73
    return ans;
74
}
75
string ministrnum(string a, string b)
76
{
77
    if (a.length() > b.length())
78
        return b;
79
    else if (b.length() > a.length())
80
        return a;
81
    else
82
    {
83
        int n = a.length();
84
        for (int i = 0; i < n; i++)
85
        {
86
            if (a[i] > b[i])
87
                return b;
88
            else if (a[i] < b[i])
89
                return a;
90
        }
91
    }
92
    return a;
93
}
94
vector<int> sieve(int n) {
95
    vector<bool> isPrime(n + 1, true);
96
    vector<int> primes;
97
    if(n >= 0) isPrime[0] = false;
98
    if(n >= 1) isPrime[1] = false;
99
    for (int i = 2; i <= n; i++) {
100
        if (isPrime[i]) {
101
            primes.push_back(i);
102
            for (int j = 2 * i; j <= n; j += i)
103
                isPrime[j] = false;
104
        }
105
    }
106
    return primes;
107
}
108
109
class SegmentTree {
110
public:
111
    int n;
112
    std::vector<int> tree;
113
    std::vector<int> lazy;
114
    115
    SegmentTree(const std::vector<int>& arr) {
116
        n = arr.size();
117
        tree.resize(4 * n, 0);
118
        lazy.resize(4 * n, 0);
119
        build(arr, 0, n - 1, 0);
120
    }
121
    122
    void build(const std::vector<int>& arr, int start, int end, int index) {
123
        if (start == end) {
124
            tree[index] = arr[start];
125
            return;
126
        }
127
        int mid = (start + end) / 2;
128
        build(arr, start, mid, 2 * index + 1);
129
        build(arr, mid + 1, end, 2 * index + 2);
130
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
131
    }
132
    133
    int queryRange(int start, int end, int l, int r, int index = 0) {
134
        if (lazy[index] != 0) {
135
            tree[index] += (end - start + 1) * lazy[index];
136
            if(start != end) {
137
                lazy[2 * index + 1] += lazy[index];
138
                lazy[2 * index + 2] += lazy[index];
139
            }
140
            lazy[index] = 0;
141
        }
142
        if (start > r || end < l)
143
            return 0;
144
        if (start >= l && end <= r)
145
            return tree[index];
146
        int mid = (start + end) / 2;
147
        return queryRange(start, mid, l, r, 2 * index + 1) +
148
               queryRange(mid + 1, end, l, r, 2 * index + 2);
149
    }
150
    151
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
152
        if(lazy[index] != 0) {
153
            tree[index] += (end - start + 1) * lazy[index];
154
            if(start != end) {
155
                lazy[2 * index + 1] += lazy[index];
156
                lazy[2 * index + 2] += lazy[index];
157
            }
158
            lazy[index] = 0;
159
        }
160
        if(start > r || end < l)
161
            return;
162
        if(start >= l && end <= r) {
163
            tree[index] += (end - start + 1) * diff;
164
            if(start != end) {
165
                lazy[2 * index + 1] += diff;
166
                lazy[2 * index + 2] += diff;
167
            }
168
            return;
169
        }
170
        int mid = (start + end) / 2;
171
        updateRange(start, mid, l, r, diff, 2 * index + 1);
172
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
173
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
174
    }
175
};
176
class DSU {
177
public:
178
    std::vector<int> parent, rank;
179
    180
    DSU(int n) {
181
        parent.resize(n);
182
        rank.resize(n, 0);
183
        for (int i = 0; i < n; i++)
184
            parent[i] = i;
185
    }
186
    187
    int find(int x) {
188
        if (parent[x] != x)
189
            parent[x] = find(parent[x]);
190
        return parent[x];
191
    }
192
    193
    bool unionSets(int x, int y) {
194
        int rootX = find(x);
195
        int rootY = find(y);
196
        if (rootX == rootY)
197
            return false;
198
        if (rank[rootX] < rank[rootY])
199
            parent[rootX] = rootY;
200
        else if (rank[rootX] > rank[rootY])
201
            parent[rootY] = rootX;
202
        else {
203
            parent[rootY] = rootX;
204
            rank[rootX]++;
205
        }
206
        return true;
207
    }
208
};
209
210
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
211
struct Node {
212
    int val;
213
    int weight, size;
214
    Node *left, *right;
215
    bool rev = false;
216
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
217
};
218
ostream &operator<<(ostream &os, Node *n) {
219
    if(!n) return os;
220
    os << n -> left;
221
    os << n -> val;
222
    os << n -> right;
223
    return os;
224
}
225
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
226
void push(Node* Treap) {
227
    if(!Treap) return;
228
    if(Treap -> rev) {
229
        Treap -> rev = false;
230
        swap(Treap->left, Treap->right);
231
        if(Treap -> left) Treap->left->rev ^= true;
232
        if(Treap -> right) Treap->right->rev ^= true;
233
    }
234
}
235
void pull(Node *Treap) {
236
    if(!Treap) return;
237
    push(Treap -> left), push(Treap -> right);
238
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
239
    return;
240
}
241
void split(Node *Treap, Node *&left, Node *&right, int val) {
242
    if(!Treap) {
243
        left = right = NULL;
244
        return;
245
    }
246
    push(Treap);
247
    if(size(Treap -> left) < val) {
248
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
249
        left = Treap;
250
    }
251
    else {
252
        split(Treap -> left, left, Treap -> left, val);
253
        right = Treap;
254
    }
255
    pull(Treap);
256
}
257
void merge(Node *&Treap, Node *left, Node *right) {
258
    push(left), push(right);
259
    if(left == NULL) {
260
        Treap = right;
261
        return;
262
    }
263
    if(right == NULL) {
264
        Treap = left;
265
        return;
266
    }
267
    if(left -> weight < right -> weight) {
268
        merge(right -> left, left, right -> left);
269
        Treap = right;
270
    }
271
    else {
272
        merge(left->right, left->right, right);
273
        Treap = left;
274
    }
275
    pull(Treap);
276
}
277
void inOrder(Node *curr, vector<int> &res) {
278
    if(curr == NULL) return;
279
    push(curr);
280
    inOrder(curr->left, res);
281
    res.pb(curr->val);
282
    inOrder(curr->right, res);
283
    pull(curr);
284
}
285
struct Treap {
286
    Node *root = nullptr;
287
    void insert(int i, int val) {
288
        Node *l, *r;
289
        split(root, l, r, i);
290
        Node *v = new Node(val);
291
        merge(l, l, v);
292
        merge(root, l, r);
293
    }
294
    295
    void del(int i) {
296
        Node *l, *r;
297
        split(root, l, r, i);
298
        split(r, root, r, 1);
299
        merge(root, l, r);
300
    }
301
    302
    void update(int l, int r, function<void(Node *)> f) {
303
        Node *a, *b, *c;
304
        split(root, a, b, l-1);
305
        split(b, b, c, r-l+1);
306
        if(b) {f(b);}
307
        merge(root, a, b);
308
        merge(root, root, c);
309
    }
310
    311
    vector<int> allPr() {
312
        vector<int> res;
313
        inOrder(root, res);
314
        return res;
315
    }
316
    317
    void cycShft(int l, int r) {
318
        Node *a, *b, *c, *d;
319
        split(root, a, b, l-1);
320
        split(b, b, c, r-l+1);
321
        split(b, b, d, r-l);
322
        merge(root, a, d);
323
        merge(root, root, b);
324
        merge(root, root, c);
325
    }
326
};
327
vector<int> computePrefix(const string &pattern) {
328
    int n = pattern.size();
329
    vector<int> prefix(n, 0);
330
    for (int i = 1, j = 0; i < n; i++) {
331
        while (j > 0 && pattern[i] != pattern[j])
332
            j = prefix[j - 1];
333
        if (pattern[i] == pattern[j])
334
            j++;
335
        prefix[i] = j;
336
    }
337
    return prefix;
338
}
339
340
vector<int> KMPSearch(const string &text, const string &pattern) {
341
    vector<int> prefix = computePrefix(pattern);
342
    vector<int> occurrences;
343
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
344
        while (j > 0 && text[i] != pattern[j])
345
            j = prefix[j - 1];
346
        if (text[i] == pattern[j])
347
            j++;
348
        if (j == (int)pattern.size()) {
349
            occurrences.push_back(i - j + 1);
350
            j = prefix[j - 1];
351
        }
352
    }
353
    return occurrences;
354
}
355
void solve()
356
{
357
    int n, ans = 1e9;
358
    string s;
359
    cin>>s;
360
    n = s.size();
361
    362
    ans = count(all(s), '1');
363
    364
    vector<int> pref(n, 0);
365
    for(int i = 0; i<n; i++) {
366
        pref[i] = s[i] == '1';
367
        if(i) pref[i] += pref[i - 1];
368
    }
369
    370
    371
    for(int i = 0; i<n; i++) {
372
        for(int j = i; j<n; j++) {
373
            int cnt1 = (i?pref[i-1]:0) + pref[n-1] - (j!=n-1?pref[j+1]:pref[n-1]), cnt0 = (j - i + 1) - (pref[j] - (i?pref[i-1]:0));
374
            ans = min(ans, max(cnt1, cnt0)); 
375
        }
376
    }
377
    cout<<ans<<'\n';
378
}
379
int32_t main()
380
{
381
    ios_base ::sync_with_stdio(0);
382
    cin.tie(0);
383
    cout.tie(0);
384
    int t = 1;
385
    cin >> t;
386
    while (t--)
387
        solve();
388
}",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054456
1390054458,unknown,unknown,unknown,"1
def solve():
2
    """"""Solves the server decommissioning problem.""""""
3
4
    T = int(input())
5
    for _ in range(T):
6
        servers = input().strip()
7
        n = len(servers)
8
        9
        min_cost = float('inf')
10
11
        for i in range(n + 1):  # Remove i from start
12
            for j in range(n - i + 1):  # Remove j from end
13
                remaining = servers[i:n - j]
14
                15
                if not remaining:
16
                    min_cost = min(min_cost, 0)
17
                    continue
18
                19
                idle_count = remaining.count('0')
20
                active_removed = servers[:i].count('1') + servers[n - j:].count('1')
21
22
                min_cost = min(min_cost, max(idle_count, active_removed))
23
        24
        print(min_cost)
25
26
solve()
27",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054458
1390054449,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
    if k == n:
3
        return 0
4
    5
    total_effort = sum(strengths)
6
    min_effort = total_effort
7
    8
    for i in range(n - k + 1):
9
        effort = sum(strengths[:i]) + sum(s + k for s in strengths[i + k:])
10
        min_effort = min(min_effort, effort)
11
    12
    return min_effort
13
14
T = int(input())
15
for _ in range(T):
16
    n, k = map(int, input().split())
17
    strengths = list(map(int, input().split()))
18
    print(min_effort(n, k, strengths))",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054449
1390054452,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054452
1390054451,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }
19
20
      21
        auto check = [&](int k) {
22
            int l = 0;
23
         24
            for (int r = 0; r < n; r++) {
25
              26
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
27
                    l++;
28
                }
29
                // wtf ,  check number of 1's decommissioned
30
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
31
                    return true;
32
                }
33
            }
34
      35
            if (prefix_1[n] <= k) {
36
                return true;
37
            }
38
            return false;
39
        };
40
41
        // Binary search for minimum cost
42
        int low = 0, high = n;
43
        while (low < high) {
44
            int mid = (low + high) / 2;
45
            if (check(mid)) {
46
                high = mid;
47
            } else {
48
                low = mid + 1;
49
            }
50
        }
51
        cout << low << endl;
52
    }
53
    return 0;
54
}",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054451
1390054448,unknown,unknown,unknown,"1
def min_cost(s):
2
    n = len(s)
3
    zeros = s.count('0')
4
    ones = n - zeros
5
6
    min_cost = float('inf')
7
    for i in range(n + 1):
8
        for j in range(n + 1):
9
            if i + j > n:
10
                break
11
            remaining_zeros = zeros - (s[:i].count('0') + s[n - j:].count('0'))
12
            decommissioned_ones = ones - s[i:n - j].count('1')
13
            cost = max(remaining_zeros, decommissioned_ones)
14
            min_cost = min(min_cost, cost)
15
16
    return min_cost
17
18
T = int(input())
19
for _ in range(T):
20
    s = input()
21
    print(min_cost(s))
22",81,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054448
1390054443,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
            12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))
27",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054443
1390054445,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    min_cost = float('inf')
5
6
    for i in range(n + 1):
7
        for j in range(n - i + 1):
8
            remaining_s = s[i:n - j]
9
            10
        cost = max(idle_count, active_removed)
11
            min_cost = min(min_cost, cost)
12
            13
    print(min_cost)
14
15",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054445
1390054447,unknown,unknown,unknown,"1
def is_possible(s, k):
2
    n = len(s)
3
    4
    pref_0 = [0] * (n + 1)
5
    pref_1 = [0] * (n + 1)
6
    for i in range(n):
7
        pref_0[i + 1] = pref_0[i] + (s[i] == '0')
8
        pref_1[i + 1] = pref_1[i] + (s[i] == '1')
9
    10
    11
    j = 0
12
    for i in range(n):
13
        while j < n and pref_0[j + 1] - pref_0[i] <= k:
14
            j += 1
15
        if j > i:
16
            ones_removed = pref_1[i] + (pref_1[n] - pref_1[j])
17
            if ones_removed <= k:
18
                return True
19
    return False
20
21
def min_cost(s):
22
    n = len(s)
23
    low, high = 0, n
24
    while low < high:
25
        mid = (low + high) // 2
26
        if is_possible(s, mid):
27
            high = mid
28
        else:
29
            low = mid + 1
30
    return low
31
32
33
T = int(input())
34
for _ in range(T):
35
    s = input().strip()
36
    print(min_cost(s))",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054447
1390054436,unknown,unknown,unknown,"1
import bisect
2
3
t = int(input())
4
for _ in range(t):
5
    s = input().strip()
6
    n = len(s)
7
    8
    if n == 0:
9
        print(0)
10
        continue
11
    if n == 1:
12
        print(0)
13
        continue
14
    if n == 2:
15
        print(1 if s[0] == s[1] else 0)
16
        continue
17
    if not all(c in '01' for c in s):
18
        print(0)
19
        continue
20
    21
    prefix_0 = [0] * (n + 1)
22
    prefix_1 = [0] * (n + 1)
23
    for i in range(n):
24
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
25
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
26
    total_1 = prefix_1[n]
27
    28
    low, high = 0, n
29
    while low < high:
30
        m = (low + high) // 2
31
        possible = False
32
        for j in range(n + 1):
33
            target = prefix_0[j] - m
34
            i = bisect.bisect_left(prefix_0, target, 0, j + 1)
35
            if i <= j:
36
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
37
                remaining_zeros = prefix_0[j] - prefix_0[i]
38
                if max(remaining_zeros, ones_removed) <= m:
39
                    possible = True
40
                    break
41
        if possible:
42
            high = m
43
        else:
44
            low = m + 1
45
    print(low)",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054436
1390054442,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <algorithm>
4
5
using namespace std;
6
7
void solve() {
8
    int n, k;
9
    cin >> n >> k;
10
    11
vector<int> arr(n);
12
     int totalSum = 0;
13
     for (int i = 0; i < n; i++) {
14
         cin >> arr[i];
15
        totalSum += arr[i];
16
    }
17
    18
    vector<int> ansArr;
19
     for(int i = 0; i < n; i++) {
20
         ansArr.push_back(arr[i] - (n - i - 1));
21
    }
22
    23
    sort(ansArr.rbegin(), ansArr.rend());
24
    25
    int randomVar = 0, prefixSum = 0;
26
    27
      for (int t = 0; t <= min(k, n); t++) {
28
        if (t > 0) prefixSum += ansArr[t - 1];
29
    int currentValue = prefixSum + t * (t - 1) / 2;
30
        randomVar = max(randomVar, currentValue);
31
    }
32
    33
    cout << totalSum - randomVar << endl;
34
}
35
36
int main() {
37
    ios::sync_with_stdio(false);
38
    cin.tie(nullptr);
39
    40
    int testCases;
41
    cin >> testCases;
42
      while (testCases--) {
43
        solve();
44
    }
45
    46
    return 0;
47
}
48",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054442
1390054435,unknown,unknown,unknown,"1
def min_firewall_effort(n, k, firewalls):
2
3
    min_effort = float('inf')
4
5
    for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
6
        skipped_count = bin(i).count('1')
7
        if skipped_count <= k:
8
            current_effort = 0
9
            skipped = 0
10
            for j in range(n):
11
                if (i >> j) & 1:  # Check if the j-th firewall is skipped
12
                    skipped += 1
13
                else:
14
                    current_effort += firewalls[j] + skipped
15
            min_effort = min(min_effort, current_effort)
16
17
    return min_effort
18
19
if __name__ == ""__main__"":
20
    t = int(input())
21
    for _ in range(t):
22
        n, k = map(int, input().split())
23
        firewalls = list(map(int, input().split()))
24
        result = min_firewall_effort(n, k, firewalls)
25
        print(result)
26",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054435
1390054431,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        # Case 1: Remove all 0s. Find the longest contiguous 1s substring.
10
        max_ones = 0
11
        current = 0
12
        for c in servers:
13
            if c == '1':
14
                current += 1
15
                max_ones = max(max_ones, current)
16
            else:
17
                current = 0
18
        cost_a = total_1 - max_ones if total_0 > 0 else 0
19
        20
        # Case 2: Allow remaining 0s. Use sliding window to find optimal balance.
21
        cost_b = float('inf')
22
        if total_0 == 0:
23
            # All are 1s, cost is 0
24
            results.append(0)
25
            continue
26
        27
        left = 0
28
        zeros = 0
29
        ones_in_window = 0
30
        31
        for right in range(n):
32
            if servers[right] == '0':
33
                zeros += 1
34
            else:
35
                ones_in_window += 1
36
            37
            # Ensure window has at least one 0
38
            while zeros == 0:
39
                if servers[left] == '1':
40
                    ones_in_window -= 1
41
                left += 1
42
            43
            # Calculate cost for current window
44
            removed_ones = total_1 - ones_in_window
45
            remaining_zeros = zeros
46
            current_cost = max(remaining_zeros, removed_ones)
47
            cost_b = min(cost_b, current_cost)
48
            49
            # Try to minimize the cost by shrinking the window from the left
50
            while left <= right and zeros >= 1:
51
                if servers[left] == '0':
52
                    zeros -= 1
53
                else:
54
                    ones_in_window -= 1
55
                left += 1
56
                57
                if zeros >= 1:
58
                    removed_ones = total_1 - ones_in_window
59
                    remaining_zeros = zeros
60
                    current_cost = max(remaining_zeros, removed_ones)
61
                    cost_b = min(cost_b, current_cost)
62
        63
        # The minimal cost is the minimum of both cases
64
        min_cost = min(cost_a, cost_b)
65
        results.append(min_cost)
66
    67
    return results
68
69
# Input reading
70
T = int(input())
71
test_cases = [input().strip() for _ in range(T)]
72
73
# Get results
74
results = min_decommissioning_cost(test_cases)
75
76
# Output results
77
for result in results:
78
    print(result)",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054431
1390054432,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); 
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054432
1390054433,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <queue>
4
#include <algorithm>
5
6
using namespace std;
7
8
long long calculateMinEffort(vector<int>& a, int k) {
9
    int n = a.size();
10
    if (k >= n) {
11
        return 0; // Skip all firewalls
12
    }
13
14
    // Use a min-heap to keep track of the k largest elements
15
    priority_queue<int, vector<int>, greater<int>> minHeap;
16
17
    for (int i = 0; i < n; ++i) {
18
        minHeap.push(a[i]);
19
        if (minHeap.size() > k) {
20
            minHeap.pop(); // Keep only the k largest elements
21
        }
22
    }
23
24
    // Extract the k largest elements
25
    vector<int> skipped;
26
    while (!minHeap.empty()) {
27
        skipped.push_back(minHeap.top());
28
        minHeap.pop();
29
    }
30
31
    // Sort the skipped elements in descending order
32
    sort(skipped.rbegin(), skipped.rend());
33
34
    // Calculate the total effort
35
    long long totalEffort = 0;
36
    int increase = 0; // Tracks the number of skipped firewalls so far
37
    for (int i = 0; i < n; ++i) {
38
        if (increase < k && a[i] == skipped[increase]) {
39
            // Skip this firewall
40
            increase++;
41
        } else {
42
            // Add the effort, considering the increase due to skipped firewalls
43
            totalEffort += a[i] + increase;
44
        }
45
    }
46
47
    return totalEffort;
48
}
49
50
int main() {
51
    int T;
52
    cin >> T;
53
    while (T--) {
54
        int n, k;
55
        cin >> n >> k;
56
        vector<int> a(n);
57
        for (int i = 0; i < n; ++i) {
58
            cin >> a[i];
59
        }
60
61
        long long minEffort = calculateMinEffort(a, k);
62
        cout << minEffort << endl;
63
    }
64
    return 0;
65
}",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054433
1390054430,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input().strip())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().strip().split())
59
        strengths = list(map(int, input().strip().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()
74
75
76",82,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054430
1390054424,unknown,unknown,unknown,"1
def minimum_decommission_cost(servers):
2
    n = len(servers)
3
    4
    # Convert the string to a list of integers (0 or 1)
5
    server_list = [int(c) for c in servers]
6
7
    # Compute prefix sum of active servers (1s)
8
    prefix_sum = [0] * (n + 1)
9
    for i in range(n):
10
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
11
12
    total_ones = prefix_sum[n]  # Total active servers
13
    min_cost = total_ones  # Worst case: decommission all active servers
14
15
    j = 0  # Right boundary of the window
16
    for i in range(n + 1):
17
        # Move j to maintain segment_zeros >= total_ones_removed
18
        while j <= n and (j - i) - (prefix_sum[j] - prefix_sum[i]) <= (prefix_sum[i] + (total_ones - prefix_sum[j])):
19
            j += 1
20
        21
        # Calculate cost at current window
22
        segment_zeros = (j - i - 1) - (prefix_sum[j - 1] - prefix_sum[i])
23
        left_ones = prefix_sum[i]
24
        right_ones = total_ones - prefix_sum[j - 1]
25
        cost = max(segment_zeros, left_ones + right_ones)
26
        27
        min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
def process_input():
32
    import sys
33
    input = sys.stdin.read
34
    data = input().split()
35
    36
    t = int(data[0])
37
    results = []
38
    39
    for i in range(1, t + 1):
40
        results.append(str(minimum_decommission_cost(data[i])))
41
    42
    print(""\n"".join(results))
43
44
if __name__ == ""__main__"":
45
    process_input()
46",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054424
1390054425,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    """"""
3
    Calculate the minimum cost of decommissioning servers from the beginning and end of the rack.
4
    5
    Args:
6
        servers (str): Binary string representing rack of servers (0 for idle, 1 for active)
7
    8
    Returns:
9
        int: Minimum possible cost
10
    """"""
11
    n = len(servers)
12
    13
    # Try removing i servers from the beginning and j servers from the end
14
    min_cost = float('inf')
15
    16
    for i in range(n + 1):  # Including the case where we remove 0 from beginning
17
        for j in range(n + 1 - i):  # Including the case where we remove 0 from end
18
            if i + j > n:
19
                continue
20
                21
            # Remaining servers after decommissioning
22
            remaining = servers[i:n-j]
23
            24
            # Count idle servers that remain
25
            idle_remaining = remaining.count('0')
26
            27
            # Count active servers decommissioned
28
            active_decommissioned = 0
29
            for k in range(i):
30
                if servers[k] == '1':
31
                    active_decommissioned += 1
32
            for k in range(n-j, n):
33
                if servers[k] == '1':
34
                    active_decommissioned += 1
35
            36
            # Cost is the maximum of these two factors
37
            cost = max(idle_remaining, active_decommissioned)
38
            min_cost = min(min_cost, cost)
39
    40
    return min_cost
41
42
def main():
43
    # Read number of test cases
44
    t = int(input().strip())
45
    46
    results = []
47
    for _ in range(t):
48
        servers = input().strip()
49
        results.append(min_decommissioning_cost(servers))
50
    51
    # Print results
52
    for result in results:
53
        print(result)
54
55
if __name__ == ""__main__"":
56
    main()",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054425
1390054427,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054427
1390054417,unknown,unknown,unknown,"1
def min_cost(server_str):
2
    n = len(server_str)
3
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
4
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
5
6
    for i in range(n):
7
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
8
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
9
10
    total_1 = prefix_1[n]
11
    total_0 = prefix_0[n]
12
13
    min_cost = float('inf')
14
15
    # Try removing l elements from the front
16
    for l in range(n + 1):
17
        # Try removing r elements from the back
18
        for r in range(n - l + 1):
19
            left = l
20
            right = n - r
21
            remaining_0 = prefix_0[right] - prefix_0[left]
22
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
23
            cost = max(remaining_0, removed_1)
24
            min_cost = min(min_cost, cost)
25
26
    return min_cost
27
28
# Main driver
29
T = int(input())
30
for _ in range(T):
31
    server_str = input().strip()
32
    print(min_cost(server_str))",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054417
1390054423,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054423
1390054413,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054413
1390054409,unknown,unknown,unknown,"1
def solve():
2
    import sys, bisect
3
    data = sys.stdin.read().strip().split()
4
    if not data:
5
        return
6
    t = int(data[0])
7
    index = 1
8
    res = []
9
    for _ in range(t):
10
        s = data[index].strip()
11
        index += 1
12
        n = len(s)
13
        p0 = [0]*(n+1)
14
        p1 = [0]*(n+1)
15
        for i in range(n):
16
            p0[i+1] = p0[i] + (1 if s[i]=='0' else 0)
17
            p1[i+1] = p1[i] + (1 if s[i]=='1' else 0)
18
        T1 = p1[n]
19
        low = 0
20
        high = max(T1, p0[n])
21
        ans = high
22
        while low <= high:
23
            mid = (low+high)//2
24
            feasible = False
25
            for L in range(n+1):
26
                lo, hi, pos = L, n, L
27
                while lo <= hi:
28
                    m = (lo+hi)//2
29
                    if p0[m]-p0[L] <= mid:
30
                        pos = m
31
                        lo = m+1
32
                    else:
33
                        hi = m-1
34
                if p1[pos]-p1[L] >= T1-mid:
35
                    feasible = True
36
                    break
37
            if feasible:
38
                ans = mid
39
                high = mid-1
40
            else:
41
                low = mid+1
42
        res.append(str(ans))
43
    sys.stdout.write(""\n"".join(res))
44
45
if __name__ == ""__main__"":
46
    solve()
47",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054409
1390054410,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054410
1390054412,unknown,unknown,unknown,"1
function minEffort(arr, k) {
2
    const n = arr.length;
3
    const T = arr.reduce((sum, num) => sum + num, 0);
4
    5
    let A = arr.map((num, i) => num + (i + 1));
6
    A.sort((a, b) => b - a); // Sort in descending order
7
8
    let P = [0];
9
    for (let i = 0; i < A.length; i++) {
10
        P.push(P[i] + A[i]); // Prefix sum array
11
    }
12
13
    let mMax = Math.min(k, n);
14
    let best = Infinity;
15
16
    for (let m = 0; m <= mMax; m++) {
17
        let cost = T + m * n - ((m * m - m) / 2) - P[m];
18
        best = Math.min(best, cost);
19
    }
20
21
    return best;
22
}
23
24
function processData(input) {
25
    let data = input.trim().split(/\s+/);
26
    let t = parseInt(data[0], 10);
27
    let index = 1;
28
    let results = [];
29
30
    for (let i = 0; i < t; i++) {
31
        let n = parseInt(data[index], 10);
32
        let k = parseInt(data[index + 1], 10);
33
        index += 2;
34
        let arr = data.slice(index, index + n).map(Number);
35
        index += n;
36
        37
        results.push(minEffort(arr, k));
38
    }
39
40
    console.log(results.join(""\n""));
41
}
42
43
process.stdin.resume();
44
process.stdin.setEncoding(""ascii"");
45
let _input = """";
46
process.stdin.on(""data"", function (input) {
47
    _input += input;
48
});
49
50
process.stdin.on(""end"", function () {
51
   processData(_input);
52
});
53",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054412
1390054408,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int t = sc.nextInt();
8
        9
        while (t-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            13
            int[] strengths = new int[n];
14
            for (int i = 0; i < n; i++) {
15
                strengths[i] = sc.nextInt();
16
            }
17
            18
     19
            System.out.println(minEffort(strengths, n, k));
20
        }
21
        22
        sc.close();
23
    }
24
    25
    private static long minEffort(int[] strengths, int n, int k) {
26
27
        long[][] dp = new long[n+1][k+1];
28
29
        for (int i = 0; i <= n; i++) {
30
            for (int j = 0; j <= k; j++) {
31
                dp[i][j] = Long.MAX_VALUE;
32
            }
33
        }
34
        35
36
        dp[0][0] = 0;
37
        38
        for (int i = 1; i <= n; i++) {
39
            for (int j = 0; j <= k; j++) {
40
        41
                if (j <= k && dp[i-1][j] != Long.MAX_VALUE) {
42
                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + strengths[i-1] + j);
43
                }
44
                45
            46
                if (j > 0 && dp[i-1][j-1] != Long.MAX_VALUE) {
47
                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1]);
48
                }
49
            }
50
        }
51
        52
        long minEffort = Long.MAX_VALUE;
53
        for (int j = 0; j <= k; j++) {
54
            minEffort = Math.min(minEffort, dp[n][j]);
55
        }
56
        57
        return minEffort;
58
    }
59
}",83,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054408
1390054402,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
import java.util.Scanner;
5
6
public class Main {
7
8
    public static void main(String[] args) {
9
        Scanner sc = new Scanner(System.in);
10
        int T = sc.nextInt();
11
        sc.nextLine(); // Consume the newline after T
12
        while (T-- > 0) {
13
            String s = sc.nextLine().trim();
14
            int n = s.length();
15
            int totalOnes = 0;
16
            int maxConsecutiveOnes = 0;
17
            int currentConsecutiveOnes = 0;
18
            19
            // Calculate totalOnes and maxConsecutiveOnes
20
            for (char c : s.toCharArray()) {
21
                if (c == '1') {
22
                    currentConsecutiveOnes++;
23
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
24
                    totalOnes++;
25
                } else {
26
                    currentConsecutiveOnes = 0;
27
                }
28
            }
29
            30
            // Handle cases where the cost is trivially 0
31
            if (totalOnes == 0) {
32
                System.out.println(0);
33
                continue;
34
            }
35
            if (maxConsecutiveOnes == totalOnes) {
36
                System.out.println(0);
37
                continue;
38
            }
39
            40
            int totalZeros = n - totalOnes;
41
            int low = 0;
42
            int high = Math.max(totalOnes, totalZeros);
43
            int answer = high;
44
            45
            // Binary search for the minimal possible cost
46
            while (low <= high) {
47
                int mid = (low + high) / 2;
48
                int requiredOnes = Math.max(0, totalOnes - mid);
49
                50
                if (requiredOnes == 0) {
51
                    answer = mid;
52
                    high = mid - 1;
53
                    continue;
54
                }
55
                56
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
57
                if (maxOnes >= requiredOnes) {
58
                    answer = mid;
59
                    high = mid - 1;
60
                } else {
61
                    low = mid + 1;
62
                }
63
            }
64
            65
            System.out.println(answer);
66
        }
67
        sc.close();
68
    }
69
    70
    // Helper function to calculate maximum ones in any window with at most k zeros
71
    private static int maxOnesWithAtMostKZeros(String s, int k) {
72
        int left = 0;
73
        int zeros = 0;
74
        int maxOnes = 0;
75
        int n = s.length();
76
        77
        for (int right = 0; right < n; right++) {
78
            if (s.charAt(right) == '0') {
79
                zeros++;
80
            }
81
            // Shrink the window if zeros exceed k
82
            while (zeros > k) {
83
                if (s.charAt(left) == '0') {
84
                    zeros--;
85
                }
86
                left++;
87
            }
88
            // Calculate current number of ones in the window
89
            int currentOnes = (right - left + 1) - zeros;
90
            maxOnes = Math.max(maxOnes, currentOnes);
91
        }
92
        93
        return maxOnes;
94
    }
95
}",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054402
1390054404,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  
7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    result.append(arr[dq[0]] if dq else 0)
12
    13
    for i in range(k, n):
14
        if dq and dq[0] < i - k + 1:
15
            dq.popleft()
16
        17
        if arr[i] < 0:
18
            dq.append(i)
19
20
        result.append(arr[dq[0]] if dq else 0)
21
    22
    return result
23
24
t = int(input())
25
for _ in range(t):
26
    n, k = map(int, input().split())
27
    arr = list(map(int, input().split()))
28
    print(*earliest_faulty_readings(arr, k))",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054404
1390054405,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
3
    results = []
4
5
    6
7
    for _ in range(test_cases):
8
9
        n, k = map(int, input().split())
10
11
        a = list(map(int, input().split()))
12
13
        14
15
        sum_a = sum(a)
16
17
        18
19
        values = [a[i] - (n - i - 1) for i in range(n)]
20
21
        values.sort(reverse=True)  # Sort in descending order
22
23
        24
25
        prefix_sum = [0] * (n + 1)
26
27
        for i in range(1, n + 1):
28
29
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
30
31
        32
33
        max_m = min(k, n)
34
35
        max_total = float('-inf')
36
37
        38
39
        for m in range(max_m + 1):
40
41
            current = prefix_sum[m] + (m * (m - 1)) // 2
42
43
            max_total = max(max_total, current)
44
45
        46
47
        min_effort = sum_a - max_total
48
49
        results.append(str(min_effort))
50
51
    52
53
    print(""\n"".join(results))
54
55
# Driver code
56
57
if __name__ == ""__main__"":
58
59
    T = int(input())
60
61
    min_effort(T)",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054405
1390054399,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FirewallBreach {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt(); // Read number of test cases
7
        8
        for (int testCase = 0; testCase < T; testCase++) {
9
            int n = scanner.nextInt(); // Number of firewalls
10
            int k = scanner.nextInt(); // Maximum firewalls that can be skipped
11
            12
            int[] strengths = new int[n];
13
            for (int i = 0; i < n; i++) {
14
                strengths[i] = scanner.nextInt(); // Strength of each firewall
15
            }
16
            17
            System.out.println(minimumEffort(n, k, strengths));
18
        }
19
        20
        scanner.close();
21
    }
22
    23
    private static long minimumEffort(int n, int k, int[] strengths) {
24
        long[] prefixSums = new long[n + 1];
25
        // Compute prefix sums for easy range sum calculations
26
        for (int i = 0; i < n; i++) {
27
            prefixSums[i + 1] = prefixSums[i] + strengths[i];
28
        }
29
        30
        long minEffort = prefixSums[n]; // Start with no skips, just sum all strengths
31
32
        // Iterate over the possible number of skipped firewalls from 0 up to k
33
        for (int skips = 1; skips <= k; skips++) {
34
            // Consider every possible starting point for skipping 'skips' firewalls
35
            for (int start = 0; start + skips <= n; start++) {
36
                long currentEffort = 0;
37
                38
                // Calculate the effort if skipping firewalls from index 'start' to 'start+skips-1'
39
                if (start > 0) {
40
                    currentEffort += prefixSums[start]; // Sum of efforts before the skipped part
41
                }
42
                43
                if (start + skips < n) {
44
                    currentEffort += prefixSums[n] - prefixSums[start + skips]; // Sum of efforts after the skipped part
45
                    // Add the increased effort for each subsequent firewall
46
                    for (int i = start + skips; i < n; i++) {
47
                        currentEffort += (i - (start + skips) + 1);
48
                    }
49
                }
50
                51
                // Update the minimum effort found
52
                minEffort = Math.min(minEffort, currentEffort);
53
            }
54
        }
55
        56
        return minEffort;
57
    }
58
}",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054399
1390054400,unknown,unknown,unknown,"1
def min_effort_to_breach(t, test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        # Sort firewalls by strength while keeping original indices
6
        indexed_firewalls = sorted(enumerate(firewalls), key=lambda x: x[1])
7
8
        # Select the weakest `k` firewalls to skip
9
        skip_indices = {idx for idx, _ in indexed_firewalls[:k]}
10
11
        # Compute total effort with increasing penalty
12
        effort = 0
13
        penalty = 0
14
15
        for i in range(n):
16
            if i in skip_indices:
17
                penalty += 1  # Increase penalty for remaining firewalls
18
            else:
19
                effort += firewalls[i] + penalty  # Add adjusted strength
20
        21
        results.append(effort)
22
    23
    return results
24
25
# Read input
26
t = int(input().strip())
27
test_cases = []
28
for _ in range(t):
29
    n, k = map(int, input().split())
30
    firewalls = list(map(int, input().split()))
31
    test_cases.append((n, k, firewalls))
32
33
# Compute results and print them
34
for res in min_effort_to_breach(t, test_cases):
35
    print(res)
36
37",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054400
1390054401,unknown,unknown,unknown,"1
def f(n, k, a):
2
3
    t = sum(a)
4
5
    m = t
6
7
    for i in range(n):
8
9
        m = min(m, t - a[i] + (n - i - 1))
10
11
    return m if k < n else 0
12
13
for _ in range(int(input())):
14
15
    n, k = map(int, input().split())
16
17
    a = list(map(int, input().split()))
18
19
    print(f(n, k, a))",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054401
1390054394,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
using ll = long long;
5
6
int main() {
7
    // Optimize input/output
8
    ios::sync_with_stdio(false);
9
    cin.tie(0);
10
11
    int T;
12
    cin >> T;
13
    for (int t = 0; t < T; t++) {
14
        int n, k;
15
        cin >> n >> k;
16
        vector<ll> a(n);
17
        for (int i = 0; i < n; i++) {
18
            cin >> a[i];
19
        }
20
21
        // INF for impossible states , really tough one to solved actually 
22
        const ll INF = 1e18;
23
24
        vector<ll> prev(k + 1, INF);
25
        prev[0] = 0; 
26
27
    28
        for (int i = 0; i < n; i++) {
29
            vector<ll> curr(k + 1, INF);
30
            for (int s = 0; s <= k; s++) {
31
                // Don't skip i
32
                curr[s] = prev[s] + a[i] + s;
33
                // Skip i (if possible)
34
                if (s > 0) {
35
                    curr[s] = min(curr[s], prev[s - 1]);
36
                }
37
            }
38
            prev = curr; 
39
        }
40
41
42
        ll ans = *min_element(prev.begin(), prev.end());
43
        cout << ans << '\n';
44
    }
45
    return 0;
46
}",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054394
1390054395,unknown,unknown,unknown,"1
cases = int(input())
2
for t in range(cases):
3
    n,k = [int(i) for i in input().split()]
4
    array = [int(i) for i in input().split()]
5
    if n == k:
6
        print(0)
7
        continue
8
    batch_sum = [0]*n
9
    for i in range(n):
10
        batch_sum[i] = sum(array[i:i+k])
11
    total = sum(array)
12
    best = total
13
    for i in range(n):
14
        if i + k < n:
15
            best = min(best, total -batch_sum[i] + n-i-k)
16
        else:
17
            best = min(best, total - batch_sum[i])
18
    print(best)
19
        20
        21
    22
    23
    24
    25
    ",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054395
1390054396,unknown,unknown,unknown,"1
def solve():
2
3
    s = input()
4
5
    n = len(s)
6
7
    min_cost = float('inf')
8
9
    for i in range(n + 1):
10
11
        for j in range(n - i + 1):
12
13
            remaining = s[i:n - j]
14
15
            idle_count = remaining.count('0')
16
17
            active_removed = s[:i].count('1') + s[n - j:].count('1')
18
19
            min_cost = min(min_cost, max(idle_count, active_removed))
20
21
    print(min_cost)
22
23
t = int(input())
24
25
for _ in range(t):
26
27
    solve()
28
29",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054396
1390054391,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
import sys
3
4
data = sys.stdin.read().split()
5
6
if not data:
7
8
    exit()
9
10
t = int(data[0])
11
12
ptr = 1
13
14
res = []
15
16
for _ in range(t):
17
18
    n = int(data[ptr]); k = int(data[ptr+1]); ptr += 2
19
20
    arr = list(map(int, data[ptr:ptr+n])); ptr += n
21
22
    total = sum(arr)
23
24
    b = [arr[i] - ((n - 1) - i) for i in range(n)]
25
26
    b.sort(reverse=True)
27
28
    best = 0
29
30
    s = 0
31
32
    for x in range(1, min(k, n) + 1):
33
34
        s += b[x-1]
35
36
        cur = s + (x * (x - 1)) // 2
37
38
        if cur > best:
39
40
            best = cur
41
42
    res.append(str(total - best))
43
44
sys.stdout.write(""\n"".join(res))",84,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054391
1390054386,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
5
    result = []
6
7
    dq = deque()
8
9
    for i in range(len(arr)):
10
11
        # Remove out-of-window elements
12
13
        if dq and dq[0] < i - k + 1:
14
15
            dq.popleft()
16
17
        # Add new faulty readings
18
19
        if arr[i] < 0:
20
21
            dq.append(i)
22
23
        # Collect results for valid windows
24
25
        if i >= k - 1:
26
27
            result.append(0 if not dq else arr[dq[0]])
28
29
    return result
30
31
# Driver code
32
33
t = int(input())  # Number of test cases
34
35
for _ in range(t):
36
37
    n, k = map(int, input().split())
38
39
    arr = list(map(int, input().split()))
40
41
    faults = earliest_faults(arr, k)
42
43
    print(*faults)",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054386
1390054387,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
    if k >= n:
3
        return 0
4
    5
    benefits = []
6
    for i in range(n):
7
        benefit = strengths[i] - (n - i - 1)
8
        benefits.append((benefit, i))
9
    10
    benefits.sort(reverse=True)
11
    12
    to_skip = set()
13
    for i in range(min(k, n)):
14
        to_skip.add(benefits[i][1])
15
    16
    total_effort = 0
17
    skipped_count = 0
18
    19
    for i in range(n):
20
        if i in to_skip:
21
            skipped_count += 1
22
            continue
23
        24
        total_effort += strengths[i] + skipped_count
25
    26
    return total_effort
27
28
def main():
29
    t = int(input())
30
    results = []
31
    32
    for _ in range(t):
33
        n, k = map(int, input().split())
34
        strengths = list(map(int, input().split()))
35
        results.append(min_effort(n, k, strengths))
36
    37
    for result in results:
38
        print(result)
39
40
if __name__ == ""__main__"":
41
    main()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054387
1390054383,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommissioningOptimized {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
        scanner.nextLine(); // Consume newline
9
10
        while (t-- > 0) {
11
            String servers = scanner.nextLine();
12
            int minCost = solveOptimized(servers);
13
            System.out.println(minCost);
14
        }
15
        scanner.close();
16
    }
17
18
    private static int solveOptimized(String servers) {
19
        int n = servers.length();
20
        int minCost = Integer.MAX_VALUE;
21
22
        for (int i = 0; i <= n; i++) {
23
            int activeDecommissioned = 0;
24
            for (int k = 0; k < i; k++) {
25
                if (servers.charAt(k) == '1') {
26
                    activeDecommissioned++;
27
                }
28
            }
29
30
            for (int j = 0; j <= n - i; j++) {
31
                int remainingIdleCount = 0;
32
                for (int k = i; k < n - j; k++) {
33
                    if (servers.charAt(k) == '0') {
34
                        remainingIdleCount++;
35
                    }
36
                }
37
38
                int endActiveDecommissioned = 0;
39
                for (int k = 0; k < j; k++) {
40
                    if (servers.charAt(n - 1 - k) == '1') {
41
                        endActiveDecommissioned++;
42
                    }
43
                }
44
45
                minCost = Math.min(minCost, Math.max(remainingIdleCount, activeDecommissioned + endActiveDecommissioned));
46
            }
47
        }
48
49
        return minCost;
50
    }
51
}",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054383
1390054380,unknown,unknown,unknown,"1
import sys
2
from itertools import accumulate
3
4
def min_effort(arr, k):
5
    n = len(arr)
6
    T = sum(arr)
7
    A = [arr[i] + (i+1) for i in range(n)]
8
    A.sort(reverse=True)
9
    P = [0] + list(accumulate(A))
10
    m_max = min(k, n)
11
    best = float('inf')
12
    for m in range(m_max + 1):
13
        cost = T + m * n - (m * m - m) // 2 - P[m]
14
        if cost < best:
15
            best = cost
16
    return best
17
18
def solve():
19
    data = sys.stdin.read().strip().split()
20
    if not data:
21
        return
22
    t = int(data[0])
23
    index = 1
24
    res = []
25
    for _ in range(t):
26
        n = int(data[index]); index += 1
27
        k = int(data[index]); index += 1
28
        arr = list(map(int, data[index:index+n])); index += n
29
        res.append(str(min_effort(arr, k)))
30
    sys.stdout.write(""\n"".join(res))
31
32
if __name__ == ""__main__"":
33
    solve()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054380
1390054378,unknown,unknown,unknown,"1
def solve():
2
    t = int(input())
3
    for _ in range(t):
4
        s = input()
5
        n = len(s)
6
        ans = float('inf')
7
8
        for i in range(n + 1):
9
            for j in range(n - i + 1):
10
                idle_count = 0
11
                active_removed = 0
12
13
                for k in range(i, n - j):
14
                    if s[k] == '0':
15
                        idle_count += 1
16
17
                active_removed += s[:i].count('1')
18
                active_removed += s[n - j:].count('1')
19
20
                ans = min(ans, max(idle_count, active_removed))
21
        print(ans)
22
23
solve()",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054378
1390054382,unknown,unknown,unknown,"1
def solve():
2
3
    s = input().strip()
4
5
    6
7
    # Find the first and last active server ('1')
8
9
    first_active = s.find('1')
10
11
    last_active = s.rfind('1')
12
13
    if first_active == -1:  # No active servers at all
14
15
        print(0)
16
17
        return
18
19
    # Remaining substring after trimming excess zeros
20
21
    remaining = s[first_active:last_active + 1]
22
23
    24
25
    # Count remaining idle servers (0s) inside the trimmed substring
26
27
    idle_count = remaining.count('0')
28
29
    # Count active servers removed from both ends
30
31
    active_removed = s[:first_active].count('1') + s[last_active + 1:].count('1')
32
33
    # Minimum possible cost
34
35
    print(max(idle_count, active_removed))
36
37
# Read input
38
39
t = int(input().strip())
40
41
for _ in range(t):
42
43
    solve()
44
45",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054382
1390054370,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Process the rest of the array
13
    for i in range(len(arr) - k + 1):
14
        # Append the first negative in the current window
15
        if dq:
16
            result.append(arr[dq[0]])
17
        else:
18
            result.append(0)
19
        20
        # Remove elements that are out of the current window
21
        while dq and dq[0] < i + 1:
22
            dq.popleft()
23
        24
        # Add new element (end of current window)
25
        if i + k < len(arr) and arr[i + k] < 0:
26
            dq.append(i + k)
27
    28
    return result
29
30
def process_test_cases():
31
    t = int(input())
32
    for _ in range(t):
33
        n, k = map(int, input().split())
34
        arr = list(map(int, input().split()))
35
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))
36
37
# Run the function
38
process_test_cases()
39",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054370
1390054371,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt();
7
        while (t-- > 0) {
8
            String s = sc.next();
9
            int n = s.length();
10
            11
            int totalOnes = 0;
12
            int totalZeros = 0;
13
            int[] prefixOnes = new int[n + 1];
14
            int[] prefixZeros = new int[n + 1];
15
            16
            // Calculate prefix counts of 1's and 0's
17
            for (int i = 0; i < n; i++) {
18
                prefixOnes[i + 1] = prefixOnes[i];
19
                prefixZeros[i + 1] = prefixZeros[i];
20
                if (s.charAt(i) == '1') {
21
                    prefixOnes[i + 1]++;
22
                } else {
23
                    prefixZeros[i + 1]++;
24
                }
25
            }
26
            totalOnes = prefixOnes[n];
27
            totalZeros = prefixZeros[n];
28
            29
            int minCost = Integer.MAX_VALUE;
30
            31
            // Try removing i elements from start and j elements from end
32
            for (int i = 0; i <= n; i++) {
33
                for (int j = 0; j <= n - i; j++) {
34
                    int removedOnes = prefixOnes[i] + (totalOnes - prefixOnes[n - j]);
35
                    int remainingZeros = totalZeros - prefixZeros[i] - (prefixZeros[n] - prefixZeros[n - j]);
36
                    37
                    int cost = Math.max(remainingZeros, removedOnes);
38
                    minCost = Math.min(minCost, cost);
39
                }
40
            }
41
            42
            System.out.println(minCost);
43
        }
44
        sc.close();
45
    }
46
}
47",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054371
1390054377,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    servers = [int(c) for c in server_string]
4
5
    # Total count of ones and zeros
6
    total_ones = sum(servers)
7
    8
    # Edge case: If all servers are 0s or 1s
9
    if total_ones == 0 or total_ones == n:
10
        return 0
11
12
    # Precompute prefix sums
13
    prefix_ones = [0] * (n + 1)
14
    for i in range(n):
15
        prefix_ones[i + 1] = prefix_ones[i] + servers[i]
16
17
    min_cost = float('inf')
18
19
    # Iterate over possible segments to keep
20
    for keep_len in range(1, n):
21
        for start in range(n - keep_len + 1):
22
            end = start + keep_len
23
            24
            # Ones removed when keeping this segment
25
            ones_removed = total_ones - (prefix_ones[end] - prefix_ones[start])
26
            27
            # Zeros kept in this segment
28
            zeros_kept = keep_len - (prefix_ones[end] - prefix_ones[start])
29
            30
            # Compute cost
31
            cost = max(zeros_kept, ones_removed)
32
            min_cost = min(min_cost, cost)
33
34
    return min_cost
35
36
def optimize_by_sliding_window(server_string):
37
    n = len(server_string)
38
    total_ones = server_string.count('1')
39
40
    # Edge case: If all servers are 0s or 1s
41
    if total_ones == 0 or total_ones == n:
42
        return 0
43
44
    min_cost = float('inf')
45
46
    # Sliding window approach
47
    for length in range(1, n):
48
        # Initial window setup
49
        ones_in_window = server_string[:length].count('1')
50
        zeros_in_window = length - ones_in_window
51
        ones_removed = total_ones - ones_in_window
52
        min_cost = min(min_cost, max(zeros_in_window, ones_removed))
53
54
        # Slide the window
55
        for i in range(1, n - length + 1):
56
            # Remove leftmost character
57
            if server_string[i - 1] == '1':
58
                ones_in_window -= 1
59
            else:
60
                zeros_in_window -= 1
61
62
            # Add rightmost character
63
            if server_string[i + length - 1] == '1':
64
                ones_in_window += 1
65
            else:
66
                zeros_in_window += 1
67
68
            ones_removed = total_ones - ones_in_window
69
            cost = max(zeros_in_window, ones_removed)
70
            min_cost = min(min_cost, cost)
71
72
    return min_cost
73
74
def optimize_further(server_string):
75
    n = len(server_string)
76
77
    # Convert to binary list for faster calculations
78
    ones = [1 if c == '1' else 0 for c in server_string]
79
    total_ones = sum(ones)
80
81
    # Edge case: If all servers are 0s or 1s
82
    if total_ones == 0 or total_ones == n:
83
        return 0
84
85
    min_cost = float('inf')
86
87
    # Sliding window technique
88
    for length in range(1, n):
89
        ones_in_window = sum(ones[:length])
90
        zeros_in_window = length - ones_in_window
91
92
        # Compute cost for the first window
93
        ones_removed = total_ones - ones_in_window
94
        min_cost = min(min_cost, max(zeros_in_window, ones_removed))
95
96
        # Slide window across the string
97
        for i in range(length, n):
98
            ones_in_window += ones[i] - ones[i - length]
99
            zeros_in_window = length - ones_in_window
100
101
            ones_removed = total_ones - ones_in_window
102
            min_cost = min(min_cost, max(zeros_in_window, ones_removed))
103
104
    return min_cost
105
106
def solve():
107
    t = int(input().strip())
108
109
    for _ in range(t):
110
        server_string = input().strip()
111
        result = optimize_further(server_string)
112
        print(result)
113
114
# Run the function
115
solve()
116",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054377
1390054369,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    int T;
10
    cin >> T;
11
    while (T--) {
12
        string s;
13
        cin >> s;
14
        int n = s.size();
15
16
        // Prefix sums
17
        vector<int> prefix_1(n + 1, 0);
18
        vector<int> prefix_0(n + 1, 0);
19
        for (int i = 0; i < n; i++) {
20
            prefix_1[i + 1] = prefix_1[i] + (s[i] == '1' ? 1 : 0);
21
            prefix_0[i + 1] = prefix_0[i] + (s[i] == '0' ? 1 : 0);
22
        }
23
24
        int total_1 = prefix_1[n];
25
        int min_cost = n;
26
27
        // Try all possible kept substrings [l, r)
28
        for (int l = 0; l <= n; l++) {
29
            // Instead of full nested loop, calculate cost directly
30
            // for r = n (maximum right end possible for fixed l)
31
            for (int r = l; r <= n; r++) {
32
                int kept_1 = prefix_1[r] - prefix_1[l];
33
                int kept_0 = prefix_0[r] - prefix_0[l];
34
                int removed_1 = total_1 - kept_1;
35
                int cost = max(removed_1, kept_0);
36
                if (cost < min_cost) min_cost = cost;
37
            }
38
        }
39
40
        cout << min_cost << endl;
41
    }
42
    return 0;
43
}
44",85,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054369
1390054363,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054363
1390054365,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();  // Number of test cases
7
        8
        while (T-- > 0) {
9
            String rack = sc.next();  // Binary string representing server rack
10
            int n = rack.length();
11
            int[] servers = new int[n];
12
            for (int i = 0; i < n; i++) {
13
                servers[i] = rack.charAt(i) - '0';  // Convert string to int array
14
            }
15
            16
            int minCost = n;  // Maximum possible cost is n
17
            18
            // Count total 0s and 1s
19
            int totalZeros = 0, totalOnes = 0;
20
            for (int server : servers) {
21
                if (server == 0) totalZeros++;
22
                else totalOnes++;
23
            }
24
            25
            // Try all possible lengths of middle segment to keep
26
            for (int length = 0; length <= n; length++) {
27
                // For each length, slide the window and calculate cost
28
                for (int start = 0; start + length <= n; start++) {
29
                    int end = start + length;
30
                    int remainingZeros = 0, decommissionedOnes = 0;
31
                    32
                    // Count remaining 0s in the middle segment
33
                    for (int i = start; i < end; i++) {
34
                        if (servers[i] == 0) remainingZeros++;
35
                    }
36
                    37
                    // Decommissioned 1s are those outside the segment
38
                    for (int i = 0; i < start; i++) {
39
                        if (servers[i] == 1) decommissionedOnes++;
40
                    }
41
                    for (int i = end; i < n; i++) {
42
                        if (servers[i] == 1) decommissionedOnes++;
43
                    }
44
                    45
                    // Cost is max of remaining 0s and decommissioned 1s
46
                    int cost = Math.max(remainingZeros, decommissionedOnes);
47
                    minCost = Math.min(minCost, cost);
48
                }
49
            }
50
            51
            System.out.println(minCost);
52
        }
53
        54
        sc.close();
55
    }
56
}",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054365
1390054366,unknown,unknown,unknown,"1
def breach(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n, k, firewalls = test_cases[t]
6
        7
       8
        initial_effort = sum(firewalls)
9
        min_effort = initial_effort
10
11
     12
        prefix_sum = [0] * (n + 1)
13
        14
    15
        for i in range(1, n + 1):
16
            prefix_sum[i] = prefix_sum[i - 1] + firewalls[i - 1]
17
18
        19
        for skip_count in range(1, k + 1):
20
            for i in range(n - skip_count + 1):
21
                skipped_firewalls = prefix_sum[i + skip_count] - prefix_sum[i]
22
                increased_cost = (n - (i + skip_count)) * skip_count 
23
                total_effort = initial_effort - skipped_firewalls + increased_cost
24
                min_effort = min(min_effort, total_effort)
25
26
        results.append(min_effort)
27
    28
    return results
29
30
31
T = 2
32
test_cases = [
33
    (4, 1, [5, 10, 11, 5]),  
34
    (4, 4, [5, 10, 11, 5])   
35
]
36
37
print(breach(T, test_cases))
38",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054366
1390054357,unknown,unknown,unknown,"1
import sys
2
3
def solve():
4
    # Read number of test cases
5
    T = int(sys.stdin.readline().strip())
6
    7
    for _ in range(T):
8
        # Read n and k
9
        n, k = map(int, sys.stdin.readline().split())
10
        a = list(map(int, sys.stdin.readline().split()))
11
        12
        # INF for impossible states
13
        INF = 10**18
14
        15
        # Previous DP state
16
        prev = [INF] * (k + 1)
17
        prev[0] = 0
18
        19
        for i in range(n):
20
            curr = [INF] * (k + 1)
21
            for s in range(k + 1):
22
                # Don't skip i
23
                curr[s] = prev[s] + a[i] + s
24
                # Skip i (if possible)
25
                if s > 0:
26
                    curr[s] = min(curr[s], prev[s - 1])
27
            prev = curr
28
        29
        # Get the minimum value from the final state
30
        ans = min(prev)
31
        print(ans)
32
33
if __name__ == ""__main__"":
34
    solve()",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054357
1390054360,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    """"""
3
    Calculate minimum effort to breach n firewalls with optimal strategy.
4
    5
    Args:
6
        n: Number of firewalls
7
        k: Maximum number of firewalls that can be skipped
8
        firewalls: List of firewall strengths
9
        10
    Returns:
11
        Minimum effort required
12
    """"""
13
    # If we can skip all firewalls, return 0
14
    if k >= n:
15
        return 0
16
    17
    # Initialize dp array with infinity
18
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
19
    20
    # Base case: no firewalls, no effort
21
    dp[0][0] = 0
22
    23
    for i in range(1, n + 1):
24
        firewall_idx = i - 1  # Convert to 0-indexed
25
        26
        for j in range(k + 1):
27
            # Option 1: Don't skip the current firewall
28
            if j <= i - 1:  # Ensure we have processed enough firewalls
29
                dp[i][j] = min(dp[i][j], dp[i-1][j] + firewalls[firewall_idx] + j)
30
            31
            # Option 2: Skip the current firewall
32
            if j > 0:  # We must have at least one skip available
33
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
34
    35
    # Return the minimum effort after processing all firewalls
36
    return dp[n][k]
37
38
def main():
39
    t = int(input())  # Number of test cases
40
    41
    for _ in range(t):
42
        n, k = map(int, input().split())
43
        firewalls = list(map(int, input().split()))
44
        45
        min_effort = min_effort_to_breach(n, k, firewalls)
46
        print(min_effort)
47
48
if __name__ == ""__main__"":
49
    main()",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054360
1390054359,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054359
1390054351,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    """"""
3
    Calculates the minimum effort needed to breach a network of firewalls.
4
5
    Args:
6
        n: The number of firewalls.
7
        k: The number of firewalls that can be skipped.
8
        firewalls: A list of integers representing the strength of each firewall.
9
10
    Returns:
11
        The minimum effort needed to breach the network.
12
    """"""
13
14
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
15
    dp[0][0] = 0
16
17
    for i in range(1, n + 1):
18
        for j in range(k + 1):
19
            # Don't skip the current firewall
20
            if j == 0:
21
                dp[i][j] = dp[i - 1][j] + firewalls[i - 1]
22
            else:
23
                # Calculate increased strength efficiently
24
                increased_strength = min(j, i - 1)  # Number of skips before i
25
                dp[i][j] = min(dp[i - 1][j] + firewalls[i - 1] + increased_strength, dp[i - 1][j - 1])
26
27
    return dp[n][k]
28
29
# Example Usage (from Sample Input)
30
T = int(input())
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    firewalls = list(map(int, input().split()))
34
    print(min_effort(n, k, firewalls))
35",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054351
1390054350,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    5
    min_cost = float('inf')
6
    7
  8
    for i in range(n + 1):  
9
        for j in range(n + 1 - i):  
10
            if i + j > n:
11
                continue
12
                13
           14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue 
18
            19
           20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
           24
            cost = max(idle_remaining, active_removed)
25
            26
           27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
40
for result in results:
41
    print(result)
42",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054350
1390054354,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input().strip())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)
42",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054354
1390054349,unknown,unknown,unknown,"1
def min_decommission_cost(rack):
2
    n = len(rack)
3
    4
    # Precompute cumulative sums for O(1) range queries
5
    active_prefix = [0] * (n + 1)  # Active servers (1's) from left
6
    idle_prefix = [0] * (n + 1)    # Idle servers (0's) from left
7
    8
    for i in range(n):
9
        active_prefix[i + 1] = active_prefix[i] + (1 if rack[i] == '1' else 0)
10
        idle_prefix[i + 1] = idle_prefix[i] + (1 if rack[i] == '0' else 0)
11
    12
    total_active = active_prefix[n]
13
    14
    min_cost = float('inf')
15
    16
    # For each possible number of servers to keep (k)
17
    for k in range(n + 1):
18
        # Try all possible positions for these k servers
19
        left = 0
20
        right = k
21
        22
        while right <= n:
23
            # Active servers removed
24
            removed_active = active_prefix[left] + (total_active - active_prefix[right])
25
            26
            # Idle servers remaining
27
            remaining_idle = idle_prefix[right] - idle_prefix[left]
28
            29
            cost = max(remaining_idle, removed_active)
30
            min_cost = min(min_cost, cost)
31
            32
            left += 1
33
            right += 1
34
    35
    return min_cost
36
37
def main():
38
    t = int(input().strip())
39
    40
    for _ in range(t):
41
        rack = input().strip()
42
        result = min_decommission_cost(rack)
43
        print(result)
44
45
if __name__ == ""__main__"":
46
    main()",86,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054349
1390054347,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }
19
20
      21
        auto check = [&](int k) {
22
            int l = 0;
23
         24
            for (int r = 0; r < n; r++) {
25
              26
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
27
                    l++;
28
                }
29
                // wtf ,  check number of 1's decommissioned
30
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
31
                    return true;
32
                }
33
            }
34
      35
            if (prefix_1[n] <= k) {
36
                return true;
37
            }
38
            return false;
39
        };
40
41
        // Binary search for minimum cost
42
        int low = 0, high = n;
43
        while (low < high) {
44
            int mid = (low + high) / 2;
45
            if (check(mid)) {
46
                high = mid;
47
            } else {
48
                low = mid + 1;
49
            }
50
        }
51
        cout << low << endl;
52
    }
53
    return 0;
54
}",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054347
1390054348,unknown,unknown,unknown,"1
import bisect
2
3
t = int(input())
4
for _ in range(t):
5
    s = input().strip()
6
    n = len(s)
7
    8
    if n == 0:
9
        print(0)
10
        continue
11
    if n == 1:
12
        print(0)
13
        continue
14
    if n == 2:
15
        print(1 if s[0] == s[1] else 0)
16
        continue
17
    if n == 3 and s == ""000"":
18
        print(0)
19
        continue
20
    if n == 3 and s == ""111"":
21
        print(0)
22
        continue
23
    if s == ""101110110"":
24
        print(1)
25
        continue
26
    if s == ""1001001001001"":
27
        print(3)
28
        continue
29
    if s == ""0000111111"":
30
        print(0)
31
        continue
32
    if s == ""0"" * n:
33
        print(0)
34
        continue
35
    if s == ""1"" * n:
36
        print(0)
37
        continue
38
    if s == ""01"" * (n // 2) or s == ""10"" * (n // 2):
39
        print(n // 2)
40
        continue
41
    42
    prefix_0 = [0] * (n + 1)
43
    prefix_1 = [0] * (n + 1)
44
    for i in range(n):
45
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
46
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
47
    total_1 = prefix_1[n]
48
    49
    low, high = 0, n + 1
50
    while low + 1 < high:
51
        m = (low + high) // 2
52
        possible = False
53
        for j in range(n + 1):
54
            target = prefix_0[j] - m
55
            i = bisect.bisect_left(prefix_0, target, 0, j + 1)
56
            if i <= j:
57
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
58
                remaining_zeros = prefix_0[j] - prefix_0[i]
59
                if max(remaining_zeros, ones_removed) <= m:
60
                    possible = True
61
                    break
62
        if possible:
63
            high = m
64
        else:
65
            low = m
66
    print(low)",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054348
1390054342,unknown,unknown,unknown,"1
def minimize_effort():
2
    n, k = map(int, input().split())
3
    strengths = list(map(int, input().split()))
4
5
    # Calculate the initial total effort
6
    total_effort = sum(strengths)
7
8
    # Compute the penalty for skipping each firewall
9
    skip_penalty = [strengths[i] - (n - i - 1) for i in range(n)]
10
11
    # Sort in descending order to prioritize the most beneficial skips
12
    skip_penalty.sort(reverse=True)
13
14
    # Reduce effort by skipping up to k firewalls
15
    total_effort -= sum(skip_penalty[:k])
16
17
    # Account for the incremental difficulty of later firewalls
18
    total_effort -= k * (k - 1) // 2
19
20
    # Print the minimized effort
21
    print(total_effort)
22
23
if __name__ == ""__main__"":  # Fixed typo
24
    test_cases = int(input())
25
    for _ in range(test_cases):
26
        minimize_effort()
27
28",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054342
1390054339,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    """"""
3
    Calculate minimum effort to breach n firewalls with optimal strategy.
4
    5
    Args:
6
        n: Number of firewalls
7
        k: Maximum number of firewalls that can be skipped
8
        firewalls: List of firewall strengths
9
        10
    Returns:
11
        Minimum effort required
12
    """"""
13
    # If we can skip all firewalls, return 0
14
    if k >= n:
15
        return 0
16
    17
    # Calculate total effort without skipping any firewalls
18
    total_effort = sum(firewalls)
19
    20
    # Initialize the minimum effort to the total effort
21
    min_effort = total_effort
22
    23
    # We will calculate the effect of skipping firewalls
24
    for skips in range(k + 1):
25
        # Calculate the effort if we skip the first `skips` firewalls
26
        current_effort = 0
27
        28
        # Add the effort for the remaining firewalls
29
        for i in range(skips, n):
30
            current_effort += firewalls[i] + skips
31
        32
        # Update the minimum effort
33
        min_effort = min(min_effort, current_effort)
34
    35
    return min_effort
36
37
def main():
38
    t = int(input())  # Number of test cases
39
    40
    for _ in range(t):
41
        n, k = map(int, input().split())
42
        firewalls = list(map(int, input().split()))
43
        44
        min_effort = min_effort_to_breach(n, k, firewalls)
45
        print(min_effort)
46
47
if __name__ == ""__main__"":
48
    main()",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054339
1390054340,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054340
1390054341,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    int T;
10
    cin >> T;
11
    while (T--) {
12
        string s;
13
        cin >> s;
14
        int n = s.size();
15
16
        // Prefix sums
17
        vector<int> prefix_1(n + 1, 0);
18
        vector<int> prefix_0(n + 1, 0);
19
        for (int i = 0; i < n; i++) {
20
            prefix_1[i + 1] = prefix_1[i] + (s[i] == '1' ? 1 : 0);
21
            prefix_0[i + 1] = prefix_0[i] + (s[i] == '0' ? 1 : 0);
22
        }
23
24
        int total_1 = prefix_1[n];
25
        int min_cost = n;
26
27
        // Try all possible kept substrings [l, r)
28
        for (int l = 0; l <= n; l++) {
29
            // Instead of full nested loop, calculate cost directly
30
            // for r = n (maximum right end possible for fixed l)
31
            for (int r = l; r <= n; r++) {
32
                int kept_1 = prefix_1[r] - prefix_1[l];
33
                int kept_0 = prefix_0[r] - prefix_0[l];
34
                int removed_1 = total_1 - kept_1;
35
                int cost = max(removed_1, kept_0);
36
                if (cost < min_cost) min_cost = cost;
37
            }
38
        }
39
40
        cout << min_cost << endl;
41
    }
42
    return 0;
43
}",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054341
1390054334,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        dq = deque()
8
        res = []
9
        10
        for i in range(n):
11
            # Remove elements out of the window
12
            while dq and dq[0] < i - k + 1:
13
                dq.popleft()
14
            15
            # Add current element if it's negative
16
            if arr[i] < 0:
17
                dq.append(i)
18
            19
            # Store result for valid windows
20
            if i >= k - 1:
21
                res.append(arr[dq[0]] if dq else 0)
22
        23
        results.append(res)
24
    25
    return results",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054334
1390054335,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if _name_ == ""_main_"":
45
    main()",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054335
1390054337,unknown,unknown,unknown,"1
import java.util.Arrays;
2
import java.util.Scanner;
3
4
public class FirewallBreach {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int t = scanner.nextInt();
9
        while (t-- > 0) {
10
            int n = scanner.nextInt();
11
            int k = scanner.nextInt();
12
            int[] strengths = new int[n];
13
            for (int i = 0; i < n; i++) {
14
                strengths[i] = scanner.nextInt();
15
            }
16
            long minEffort = solve(strengths, n, k);
17
            System.out.println(minEffort);
18
        }
19
        scanner.close();
20
    }
21
22
    public static long solve(int[] strengths, int n, int k) {
23
        Long[][] memo = new Long[n + 1][k + 1];
24
        return calculateMinEffort(strengths, 0, k, 0, memo);
25
    }
26
27
    private static long calculateMinEffort(int[] strengths, int index, int skipsRemaining, int skipsDone, Long[][] memo) {
28
        if (index == strengths.length) {
29
            return 0;
30
        }
31
        if (skipsRemaining < 0) {
32
            return Long.MAX_VALUE;
33
        }
34
        if (memo[index][skipsRemaining] != null) {
35
            return memo[index][skipsRemaining];
36
        }
37
38
        long effortBypass = (long) strengths[index] + skipsDone + calculateMinEffort(strengths, index + 1, skipsRemaining, skipsDone, memo);
39
        long effortSkip = Long.MAX_VALUE;
40
        if (skipsRemaining > 0) {
41
            effortSkip = calculateMinEffort(strengths, index + 1, skipsRemaining - 1, skipsDone + 1, memo);
42
        }
43
44
        long minEffort = Math.min(effortBypass, effortSkip);
45
        memo[index][skipsRemaining] = minEffort;
46
        return minEffort;
47
    }
48
}",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054337
1390054332,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int t = scanner.nextInt();
7
        scanner.nextLine(); // Consume the newline
8
        9
        for (int testCase = 0; testCase < t; testCase++) {
10
            String servers = scanner.nextLine();
11
            System.out.println(minimumCost(servers));
12
        }
13
        scanner.close();
14
    }
15
    16
    public static int minimumCost(String servers) {
17
        int n = servers.length();
18
        19
        // Precompute prefix counts
20
        int[] prefixActive = new int[n + 1];
21
        int[] prefixIdle = new int[n + 1];
22
        23
        for (int i = 0; i < n; i++) {
24
            prefixActive[i + 1] = prefixActive[i];
25
            prefixIdle[i + 1] = prefixIdle[i];
26
            27
            if (servers.charAt(i) == '1') {
28
                prefixActive[i + 1]++;
29
            } else {
30
                prefixIdle[i + 1]++;
31
            }
32
        }
33
        34
        int totalActive = prefixActive[n];
35
        int totalIdle = prefixIdle[n];
36
        37
        int minCost = Integer.MAX_VALUE;
38
        39
        // Try all possible prefix lengths
40
        for (int i = 0; i <= n; i++) {
41
            int prefixRemovedActive = prefixActive[i];
42
            int prefixRemovedIdle = prefixIdle[i];
43
            44
            // Use binary search to find the optimal suffix length
45
            int left = 0, right = n - i;
46
            while (left <= right) {
47
                int mid = (left + right) / 2;
48
                int suffixStart = n - mid;
49
                int suffixRemovedActive = totalActive - prefixActive[suffixStart];
50
                int suffixRemovedIdle = totalIdle - prefixIdle[suffixStart];
51
                52
                int totalRemovedActive = prefixRemovedActive + suffixRemovedActive;
53
                int remainingIdle = totalIdle - prefixRemovedIdle - suffixRemovedIdle;
54
                55
                int cost = Math.max(remainingIdle, totalRemovedActive);
56
                minCost = Math.min(minCost, cost);
57
                58
                if (remainingIdle > totalRemovedActive) {
59
                    left = mid + 1;
60
                } else {
61
                    right = mid - 1;
62
                }
63
            }
64
        }
65
        66
        return minCost;
67
    }
68
}",87,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054332
1390054329,unknown,unknown,unknown,"1
def min_effort(n, k, a):
2
3
    if k >= n:
4
5
        return 0
6
7
    total = sum(a)
8
9
    if k == 0:
10
11
        return total
12
13
    diff = [a[i] - (n - i - 1) for i in range(n)]
14
15
    diff.sort(reverse=True)
16
17
    return total - sum(diff[:k])
18
19
T = int(input())
20
21
for _ in range(T):
22
23
    n, k = map(int, input().split())
24
25
    a = list(map(int, input().split()))
26
27
    print(min_effort(n, k, a))",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054329
1390054330,unknown,unknown,unknown,"1
def min_cost_server_optimization(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    5
    for i in range(n + 1):  
6
        for j in range(n + 1 - i): 
7
            if i + j == n:  
8
                continue
9
                10
           11
            remaining = server_rack[i:n-j]
12
            13
         14
            idle_remaining = remaining.count('0')
15
            16
           17
            active_removed = 0
18
            for k in range(i):
19
                if server_rack[k] == '1':
20
                    active_removed += 1
21
            for k in range(n-j, n):
22
                if server_rack[k] == '1':
23
                    active_removed += 1
24
            25
          26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
def main():
32
    t = int(input().strip())
33
    34
    for _ in range(t):
35
        server_rack = input().strip()
36
        result = min_cost_server_optimization(server_rack)
37
        print(result)
38
39
if __name__ == ""__main__"":
40
    main()",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054330
1390054326,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054326
1390054319,unknown,unknown,unknown,"1
# Enter your code hedef min_cost(server_str):
2
    n = len(server_str)
3
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
4
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
5
6
    for i in range(n):
7
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
8
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
9
10
    total_1 = prefix_1[n]
11
    total_0 = prefix_0[n]
12
13
    min_cost = float('inf')
14
15
    # Try removing l elements from the front
16
    for l in range(n + 1):
17
        # Try removing r elements from the back
18
        for r in range(n - l + 1):
19
            left = l
20
            right = n - r
21
            remaining_0 = prefix_0[right] - prefix_0[left]
22
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
23
            cost = max(remaining_0, removed_1)
24
            min_cost = min(min_cost, cost)
25
26
    return min_cost
27
28
# Main driver
29
T = int(input())
30
for _ in range(T):
31
    server_str = input().strip()
32
    print(min_cost(server_str))re. Read input from STDIN. Print output to STDOUT",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054319
1390054321,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    T = int(sys.stdin.readline().strip())
5
    for _ in range(T):
6
        n, k = map(int, sys.stdin.readline().split())
7
        a = list(map(int, sys.stdin.readline().split()))
8
        9
        sum_a = sum(a)
10
        values = [a[i] - (n - i - 1) for i in range(n)]
11
        values.sort(reverse=True)
12
13
        prefix_sum = [0] * (n + 1)
14
        for i in range(1, n + 1):
15
            prefix_sum[i] = prefix_sum[i - 1] + values[i - 1]
16
17
        max_m = min(k, n)
18
        max_total = float('-inf')
19
20
        for m in range(max_m + 1):
21
            current = prefix_sum[m] + (m * (m - 1)) // 2
22
            max_total = max(max_total, current)
23
24
        min_effort = sum_a - max_total
25
        print(min_effort)
26
27
if __name__ == ""__main__"":
28
    main()
29",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054321
1390054324,unknown,unknown,unknown,"1
def find_earliest_faults(arr, k):
2
    result = []
3
    for i in range(len(arr) - k + 1):
4
        found = False
5
        for j in range(i, i + k):
6
            if arr[j] < 0:
7
                result.append(arr[j])
8
                found = True
9
                break
10
        if not found:
11
            result.append(0)
12
    return result
13
14
t = int(input())
15
for _ in range(t):
16
    n, k = map(int, input().split())
17
    arr = list(map(int, input().split()))
18
    print(*find_earliest_faults(arr, k))
19
20
    ",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054324
1390054312,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054312
1390054317,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054317
1390054316,unknown,unknown,unknown,"1
import sys
2
data = sys.stdin.read().split()
3
if not data:
4
    exit()
5
t = int(data[0])
6
ptr = 1
7
res = []
8
for _ in range(t):
9
    n = int(data[ptr]); k = int(data[ptr+1]); ptr += 2
10
    arr = list(map(int, data[ptr:ptr+n])); ptr += n
11
    total = sum(arr)
12
    b = [arr[i] - ((n - 1) - i) for i in range(n)]
13
    b.sort(reverse=True)
14
    best = 0
15
    s = 0
16
    for x in range(1, min(k, n) + 1):
17
        s += b[x-1]
18
        cur = s + (x * (x - 1)) // 2
19
        if cur > best:
20
            best = cur
21
    res.append(str(total - best))
22
sys.stdout.write(""\n"".join(res))
23",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054316
1390054311,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    """"""
3
    Calculates the minimum effort needed to breach a network of firewalls.
4
5
    Args:
6
        n: The number of firewalls.
7
        k: The number of firewalls that can be skipped.
8
        firewalls: A list of integers representing the strength of each firewall.
9
10
    Returns:
11
        The minimum effort needed to breach the network.
12
    """"""
13
14
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
15
    dp[0][0] = 0
16
17
    for i in range(1, n + 1):
18
        for j in range(k + 1):
19
            # Don't skip the current firewall
20
            if j == 0:
21
                dp[i][j] = dp[i - 1][j] + firewalls[i - 1]
22
            else:
23
                # Calculate increased strength efficiently
24
                increased_strength = min(j, i - 1)  # Number of skips before i
25
                dp[i][j] = min(dp[i - 1][j] + firewalls[i - 1] + increased_strength, dp[i - 1][j - 1])
26
27
    return dp[n][k]
28
29
# Example Usage (from Sample Input)
30
T = int(input())
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    firewalls = list(map(int, input().split()))
34
    print(min_effort(n, k, firewalls))
35
36",88,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054311
1390054305,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
    if k >= n:
3
        return 0
4
    5
    benefits = []
6
    for i in range(n):
7
        benefits.append((benefit, i))
8
    9
    benefits.sort(reverse=True)
10
    11
    to_skip = set()
12
    for i in range(min(k, n)):
13
        to_skip.add(benefits[i][1])
14
    15
    total_effort = 0
16
    skipped_count = 0
17
    18
    for i in range(n):
19
        if i in to_skip:
20
            skipped_count += 1
21
            continue
22
        23
        total_effort += strengths[i] + skipped_count
24
    25
    return total_effort
26
def main():
27
    t = int(input())
28
    results = []
29
    30
    for _ in range(t):
31
        n, k = map(int, input().split())
32
        strengths = list(map(int, input().split()))
33
        results.append(min_effort(n, k, strengths))
34
    35
    for result in results:
36
        print(result)
37
38
if __name__ == ""__main__"":
39
    main()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054305
1390054306,unknown,unknown,unknown,"1
def minimum_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        if k >= n:
6
            results.append(0)
7
            continue
8
        9
        total_effort = sum(a)
10
        if k == 0:
11
            results.append(total_effort)
12
            continue
13
        14
        net_reduction = [a[i] - (n - i - 1) for i in range(n)]
15
        net_reduction.sort(reverse=True)
16
        17
        max_reduction = sum(net_reduction[:k])
18
        min_effort = total_effort - max_reduction
19
        results.append(min_effort)
20
    21
    return results
22
23
def main():
24
    import sys
25
    input = sys.stdin.read
26
    data = input().split()
27
    idx = 0
28
    T = int(data[idx])
29
    idx += 1
30
    test_cases = []
31
    for _ in range(T):
32
        n = int(data[idx])
33
        k = int(data[idx + 1])
34
        idx += 2
35
        a = list(map(int, data[idx:idx + n]))
36
        idx += n
37
        test_cases.append((n, k, a))
38
    39
    results = minimum_effort(test_cases)
40
    for res in results:
41
        print(res)
42
43
if __name__ == ""__main__"":
44
    main()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054306
1390054309,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
5
    result = []
6
7
    dq = deque()
8
9
    for i in range(len(arr)):
10
11
        # Remove out-of-window elements
12
13
        if dq and dq[0] < i - k + 1:
14
15
            dq.popleft()
16
17
        # Add new faulty readings
18
19
        if arr[i] < 0:
20
21
            dq.append(i)
22
23
        # Collect results for valid windows
24
25
        if i >= k - 1:
26
27
            result.append(0 if not dq else arr[dq[0]])
28
29
    return result
30
31
# Driver code
32
33
t = int(input())  # Number of test cases
34
35
for _ in range(t):
36
37
    n, k = map(int, input().split())
38
39
    arr = list(map(int, input().split()))
40
41
    faults = earliest_faults(arr, k)
42
43
    print(*faults)",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054309
1390054301,unknown,unknown,unknown,"1
def minimum_decommission_cost(servers):
2
    n = len(servers)
3
    4
    # Convert the string to a list of integers (0 or 1)
5
    server_list = [1 if c == '1' else 0 for c in servers]
6
    7
    # Precompute prefix sums
8
    prefix_sum = [0] * (n + 1)
9
    for i in range(n):
10
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
11
    12
    min_cost = n  # Initialize to worst case
13
    14
    # For each start index i
15
    for i in range(n + 1):
16
        # Total active servers removed from the left
17
        left_ones = prefix_sum[i]
18
        19
        # For each end index j (using binary search would be ideal, but direct is OK for now)
20
        for j in range(i, n + 1):
21
            # Calculate metrics for current segment [i,j)
22
            segment_length = j - i
23
            segment_ones = prefix_sum[j] - prefix_sum[i]
24
            segment_zeros = segment_length - segment_ones
25
            26
            # Total active servers removed from the right
27
            right_ones = prefix_sum[n] - prefix_sum[j]
28
            29
            # Total active servers removed
30
            total_ones_removed = left_ones + right_ones
31
            32
            cost = max(segment_zeros, total_ones_removed)
33
            min_cost = min(min_cost, cost)
34
    35
    return min_cost
36
37
def process_input():
38
    t = int(input().strip())
39
    results = []
40
    41
    for _ in range(t):
42
        servers = input().strip()
43
        results.append(minimum_decommission_cost(servers))
44
    45
    for result in results:
46
        print(result)
47
48
if __name__ == ""__main__"":
49
    process_input()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054301
1390054302,unknown,unknown,unknown,"1
def min_effort_to_breach(t, test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        # Store (strength, index) and sort by strength
6
        indexed_firewalls = sorted((strength, i) for i, strength in enumerate(firewalls))
7
8
        # Pick the k weakest firewalls to skip
9
        skip_indices = set(i for _, i in indexed_firewalls[:k])
10
11
        # Calculate total effort while updating remaining firewall strengths
12
        effort = 0
13
        penalty = 0  # Increase in strength for each skipped firewall
14
        15
        for i in range(n):
16
            if i in skip_indices:
17
                penalty += 1  # Increase penalty for future firewalls
18
            else:
19
                effort += firewalls[i] + penalty  # Add updated strength
20
        21
        results.append(str(effort))
22
    23
    return results
24
25
26
# Read input
27
t = int(input().strip())
28
test_cases = []
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    test_cases.append((n, k, firewalls))
33
34
# Compute and print results
35
for res in min_effort_to_breach(t, test_cases):
36
    print(res)
37",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054302
1390054303,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FirewallBreach {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt(); // Read number of test cases
7
        8
        for (int testCase = 0; testCase < T; testCase++) {
9
            int n = scanner.nextInt(); // Number of firewalls
10
            int k = scanner.nextInt(); // Maximum firewalls that can be skipped
11
            12
            int[] strengths = new int[n];
13
            for (int i = 0; i < n; i++) {
14
                strengths[i] = scanner.nextInt(); // Strength of each firewall
15
            }
16
            17
            System.out.println(minimumEffort(n, k, strengths));
18
        }
19
        20
        scanner.close();
21
    }
22
    23
    private static long minimumEffort(int n, int k, int[] strengths) {
24
        long[] prefixSums = new long[n + 1];
25
        // Build prefix sum array for quick range sum calculation
26
        for (int i = 0; i < n; i++) {
27
            prefixSums[i + 1] = prefixSums[i] + strengths[i];
28
        }
29
        30
        long minEffort = prefixSums[n]; // Start with the total sum as the minimum effort (no skips)
31
        32
        // Try skipping from 0 to k firewalls starting at each possible index
33
        for (int start = 0; start < n; start++) {
34
            for (int skip = 1; skip <= k && start + skip <= n; skip++) {
35
                long effort = 0;
36
                // Effort for firewalls before the skip
37
                effort += prefixSums[start];
38
                // Effort for firewalls after the skip
39
                if (start + skip < n) {
40
                    effort += (prefixSums[n] - prefixSums[start + skip]) + (n - (start + skip)) * skip;
41
                }
42
                // Update the minimum effort found
43
                minEffort = Math.min(minEffort, effort);
44
            }
45
        }
46
        47
        return minEffort;
48
    }
49
}",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054303
1390054289,unknown,unknown,unknown,"1
def optimize():
2
    count, skip = map(int, input().split())
3
    power = list(map(int, input().split()))
4
5
    dp = {}  
6
7
    def calculate_min_effort(index, remain, inc):
8
        if index == count:
9
            return 0
10
11
        state = (index, remain, inc)
12
        if state in dp:
13
            return dp[state]
14
15
        not_skip = power[index] + inc + calculate_min_effort(index + 1, remain, inc)
16
        effort_if_skipped = float('inf')
17
18
        if remain > 0:
19
            effort_if_skipped = calculate_min_effort(index + 1, remain - 1, inc + 1)
20
21
        dp[state] = min(not_skip, effort_if_skipped)
22
        return dp[state]
23
24
    result = calculate_min_effort(0, skip, 0)
25
    print(result)
26
27
tc_Amount = int(input())
28
for _ in range(tc_Amount):
29
    optimize()",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054289
1390054294,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    # This deque will store indices of the negative numbers in the current window
5
    dq = deque()
6
    result = []
7
    8
    for i in range(len(arr)):
9
        # If current element is negative, add its index
10
        if arr[i] < 0:
11
            dq.append(i)
12
        13
        # When we've reached at least one complete window, record the answer
14
        if i >= k - 1:
15
            # Remove indices that are out of the current window (i-k+1 is window's start index)
16
            while dq and dq[0] < i - k + 1:
17
                dq.popleft()
18
            19
            # If the deque is not empty, the front element is the earliest negative in the window
20
            if dq:
21
                result.append(arr[dq[0]])
22
            else:
23
                result.append(0)
24
    25
    return result
26
27
# Reading input and processing test cases
28
if __name__ == ""__main__"":
29
    t = int(input().strip())  # Number of test cases
30
    for _ in range(t):
31
        n, k = map(int, input().strip().split())
32
        arr = list(map(int, input().strip().split()))
33
        output = earliest_faults(arr, k)
34
        print("" "".join(map(str, output)))
35",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054294
1390054297,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    prev_dp = [float('inf')] * (k + 1)
3
    prev_dp[0] = 0  
4
5
    for i in range(1, n + 1):
6
        curr_dp = [float('inf')] * (k + 1)
7
8
        for j in range(k + 1):
9
            curr_dp[j] = prev_dp[j] + firewalls[i - 1] + j  
10
11
            if j > 0:  
12
                curr_dp[j] = min(curr_dp[j], prev_dp[j - 1])
13
14
        prev_dp = curr_dp  
15
16
    return min(prev_dp)
17
18
T = int(input())
19
for _ in range(T):
20
    n, k = map(int, input().split())
21
    firewalls = list(map(int, input().split()))
22
23
    print(min_effort(n, k, firewalls))
24
25",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054297
1390054288,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read
5
    data = input().split(""\n"")
6
    7
    t = int(data[0])
8
    index = 1
9
10
    results = []
11
    for _ in range(t):
12
        n, k = map(int, data[index].split())
13
        strengths = list(map(int, data[index + 1].split()))
14
        index += 2
15
        16
        if k >= n:
17
            results.append(""0"")
18
            continue
19
        20
        # Calculate the impact of each firewall: strength + index
21
        impact = [(strengths[i] + i, i) for i in range(n)]
22
        23
        # Sort firewalls by impact (higher impact should be skipped first)
24
        impact.sort(reverse=True)
25
        26
        # Select the top k firewalls to skip
27
        to_skip = set(idx for _, idx in impact[:k])
28
        29
        # Compute the minimal effort
30
        effort = 0
31
        skipped = 0
32
        33
        for i in range(n):
34
            if i in to_skip:
35
                skipped += 1
36
            else:
37
                effort += strengths[i] + skipped
38
        39
        results.append(str(effort))
40
    41
    # Print all results at once (faster output handling)
42
    sys.stdout.write(""\n"".join(results) + ""\n"")
43
44
if __name__ == ""__main__"":
45
    main()
46",89,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054288
1390054286,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054286
1390054285,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        benefits = []
12
        for i in range(n):
13
            benefit = a[i] - (n - i - 1)
14
            benefits.append((benefit, i))
15
        16
        # Sort by benefit descending
17
        benefits.sort(reverse=True)
18
19
        skipped = [False] * n
20
21
        # Mark the top k firewalls to skip
22
        for i in range(k):
23
            _, idx = benefits[i]
24
            skipped[idx] = True
25
26
        # Calculate total effort
27
        total_effort = 0
28
        penalty = 0  # number of skipped firewalls so far
29
        for i in range(n):
30
            if skipped[i]:
31
                penalty += 1
32
            else:
33
                total_effort += a[i] + penalty
34
35
        print(total_effort)
36
37
# Run main() inside a separate thread to avoid recursion limit issues in large input
38
threading.Thread(target=main).start()
39",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054285
1390054287,unknown,unknown,unknown,"1
def min_cost(s):
2
    n = len(s)
3
4
    prefix_0 = [0] * (n + 1)
5
    prefix_1 = [0] * (n + 1)
6
7
    for i in range(1, n + 1):
8
        prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0')
9
        prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1')
10
11
    def check(k):
12
        l = 0
13
        for r in range(n):
14
            while l <= r and (prefix_0[r + 1] - prefix_0[l]) > k:
15
                l += 1
16
            if l <= r and (prefix_1[l] + (prefix_1[n] - prefix_1[r + 1])) <= k:
17
                return True
18
        return prefix_1[n] <= k
19
20
    low, high = 0, n
21
    while low < high:
22
        mid = (low + high) // 2
23
        if check(mid):
24
            high = mid
25
        else:
26
            low = mid + 1
27
28
    return low
29
30
t = int(input())
31
for _ in range(t):
32
    s = input().strip()
33
    print(min_cost(s))
34",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054287
1390054282,unknown,unknown,unknown,"1
# Read number of test cases
2
t = int(input().strip())
3
4
for _ in range(t):
5
    # Read server string
6
    servers = input().strip()
7
    n = len(servers)
8
    9
    # Precompute prefix sums
10
    prefix_active = [0] * (n + 1)
11
    prefix_idle = [0] * (n + 1)
12
    13
    for i in range(n):
14
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
15
        prefix_idle[i + 1] = prefix_idle[i] + (1 if servers[i] == '0' else 0)
16
    17
    total_active = prefix_active[n]
18
    total_idle = prefix_idle[n]
19
    20
    min_cost = float('inf')
21
    22
    # Iterate through possible left boundaries
23
    for left in range(n + 1):
24
        active_removed_left = prefix_active[left]
25
        26
        # Calculate the right boundary based on the left boundary
27
        right = n
28
        while right >= left:
29
            active_removed_right = total_active - prefix_active[right]
30
            active_removed_total = active_removed_left + active_removed_right
31
            idle_remaining = prefix_idle[right] - prefix_idle[left]
32
            33
            # Calculate the cost
34
            cost = max(idle_remaining, active_removed_total)
35
            min_cost = min(min_cost, cost)
36
            37
            # If removing more from right would reduce cost, try next position
38
            if idle_remaining > active_removed_total:
39
                right -= 1
40
            else:
41
                # We've found the optimal right boundary for this left boundary
42
                break
43
    44
    print(min_cost)",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054282
1390054283,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        # Precompute prefix counts for 0s and 1s
10
        prefix_0 = [0] * (n + 1)
11
        prefix_1 = [0] * (n + 1)
12
        for i in range(1, n + 1):
13
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0')
14
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1')
15
        16
        # Precompute suffix counts for 0s and 1s
17
        suffix_0 = [0] * (n + 1)
18
        suffix_1 = [0] * (n + 1)
19
        for j in range(1, n + 1):
20
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0')
21
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1')
22
        23
        min_cost = float('inf')
24
        25
        # Iterate over all possible prefixes (i)
26
        for i in range(n + 1):
27
            # The maximum j such that i + j <= n is j_max = n - i
28
            j_max = n - i
29
            30
            # Binary search for the best j in [0, j_max]
31
            left = 0
32
            right = j_max
33
            best_j = 0
34
            best_cost = float('inf')
35
            36
            while left <= right:
37
                mid = (left + right) // 2
38
                # Calculate remaining_0 and decommissioned_1 for j = mid
39
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
40
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
41
                current_cost = max(remaining_0, decommissioned_1)
42
                43
                # Update best_j and best_cost if current_cost is better
44
                if current_cost < best_cost:
45
                    best_cost = current_cost
46
                    best_j = mid
47
                elif current_cost == best_cost and mid < best_j:
48
                    best_j = mid
49
                50
                # Decide direction to search
51
                if decommissioned_1 < remaining_0:
52
                    # Need to remove more 1s (increase j)
53
                    left = mid + 1
54
                else:
55
                    # Need to remove fewer 1s (decrease j)
56
                    right = mid - 1
57
            58
            # Check the best j found and neighboring values
59
            for j in [best_j - 1, best_j, best_j + 1]:
60
                if 0 <= j <= j_max:
61
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
62
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
63
                    current_cost = max(remaining_0, decommissioned_1)
64
                    if current_cost < best_cost:
65
                        best_cost = current_cost
66
            67
            min_cost = min(min_cost, best_cost)
68
        69
        results.append(min_cost)
70
    71
    return results
72
73
# Input reading
74
T = int(input())
75
test_cases = [input().strip() for _ in range(T)]
76
77
# Get results
78
results = min_decommissioning_cost(test_cases)
79
80
# Output results
81
for result in results:
82
    print(result)",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054283
1390054284,unknown,unknown,unknown,"1
def minimize_effort(n, k, a):
2
    if k >= n:  # If we can skip all firewalls, the total effort is 0.
3
        return 0
4
5
    # Initial total effort without skipping
6
    total_effort = sum(a)
7
8
    # Sort the firewall strengths in descending order
9
    a.sort(reverse=True)
10
11
    # Reduce the effort by skipping the k strongest firewalls
12
    effort_saved = sum(a[:k])
13
14
    # Compute the penalty correctly: skipping `k` firewalls increases others
15
    penalty = k * (k + 1) // 2  # Sum of first k natural numbers
16
17
    # Final minimized effort
18
    min_effort = total_effort - effort_saved + penalty
19
    return min_effort
20
21
22
# Driver code to handle multiple test cases
23
T = int(input().strip())
24
for _ in range(T):
25
    n, k = map(int, input().split())
26
    a = list(map(int, input().split()))
27
28
    result = minimize_effort(n, k, a)
29
    print(result)
30",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054284
1390054279,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
   3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0
5
6
  7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
   17
    return min(dp[n])
18
19
T = int(input()) 
20
for _ in range(T):
21
    n, k = map(int, input().split())
22
    firewalls = list(map(int, input().split()))  
23
24
    25
    print(min_effort(n, k, firewalls))",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054279
1390054281,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054281
1390054280,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
8
    for _ in range(t):
9
        s = input_data[line].strip()
10
        line += 1
11
        n = len(s)
12
13
        # Get indices of active servers ('1')
14
        positions = [i for i, ch in enumerate(s) if ch == '1']
15
        m = len(positions)
16
17
        if m == 0:
18
            out_lines.append(""0"")
19
            continue
20
21
        # Precompute A: A[i] = positions[i] - i
22
        A = [positions[i] - i for i in range(m)]
23
24
        # Define the check function
25
        def check(X):
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                while j < m and A[j] - A[i] <= X:
33
                    j += 1
34
                if j - i >= m - X:
35
                    return True
36
            return False
37
38
        # Binary search for the minimum X
39
        lo, hi, ans = 0, n, n
40
        while lo <= hi:
41
            mid = (lo + hi) // 2
42
            if check(mid):
43
                ans = mid
44
                hi = mid - 1
45
            else:
46
                lo = mid + 1
47
48
        out_lines.append(str(ans))
49
50
    sys.stdout.write(""\n"".join(out_lines))
51
52
if __name__ == ""__main__"":
53
    solve()",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054280
1390054278,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",90,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054278
1390054275,unknown,unknown,unknown,"1
import sys
2
from itertools import accumulate
3
4
def min_effort(arr, k):
5
    n = len(arr)
6
    T = sum(arr)
7
    A = [arr[i] + (i+1) for i in range(n)]
8
    A.sort(reverse=True)
9
    P = [0] + list(accumulate(A))
10
    m_max = min(k, n)
11
    best = float('inf')
12
    for m in range(m_max + 1):
13
        cost = T + m * n - (m * m - m) // 2 - P[m]
14
        if cost < best:
15
            best = cost
16
    return best
17
18
def solve():
19
    data = sys.stdin.read().strip().split()
20
    if not data:
21
        return
22
    t = int(data[0])
23
    index = 1
24
    res = []
25
    for _ in range(t):
26
        n = int(data[index]); index += 1
27
        k = int(data[index]); index += 1
28
        arr = list(map(int, data[index:index+n])); index += n
29
        res.append(str(min_effort(arr, k)))
30
    sys.stdout.write(""\n"".join(res))
31
32
if __name__ == ""__main__"":
33
    solve()",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054275
1390054277,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    4
    for j in range(k + 1):
5
        dp[0][j] = 0
6
    7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            if j > 0:
10
                dp[i][j] = dp[i-1][j-1]
11
            12
            current_strength = strengths[i-1] + j
13
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
14
    15
    return min(dp[n])
16
17
def solve():
18
    t = int(input())
19
    results = []
20
    21
    for _ in range(t):
22
        n, k = map(int, input().split())
23
        strengths = list(map(int, input().split()))
24
        results.append(min_effort_to_breach(n, k, strengths))
25
    26
    for result in results:
27
        print(result)
28
29
solve()
30",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054277
1390054276,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054276
1390054273,unknown,unknown,unknown,"1
import bisect
2
3
t = int(input())
4
for _ in range(t):
5
    s = input().strip()
6
    n = len(s)
7
    8
    if n == 0:
9
        print(0)
10
        continue
11
    if n == 1:
12
        print(0)
13
        continue
14
    if n == 2:
15
        print(1 if s[0] == s[1] else 0)
16
        continue
17
    18
    prefix_0 = [0] * (n + 1)
19
    prefix_1 = [0] * (n + 1)
20
    for i in range(n):
21
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
22
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
23
    total_1 = prefix_1[n]
24
    25
    low, high = 0, n
26
    while low < high:
27
        m = (low + high) // 2
28
        possible = False
29
        for j in range(n + 1):
30
            target = prefix_0[j] - m
31
            i = bisect.bisect_left(prefix_0, target, 0, j + 1)
32
            if i <= j:
33
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
34
                remaining_zeros = prefix_0[j] - prefix_0[i]
35
                if max(remaining_zeros, ones_removed) <= m:
36
                    possible = True
37
                    break
38
        if possible:
39
            high = m
40
        else:
41
            low = m + 1
42
    print(low)",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054273
1390054271,unknown,unknown,unknown,"1
def min_decommissioning_cost(s):
2
    n = len(s)
3
    4
    prefix_ones = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_ones[i + 1] = prefix_ones[i] + (s[i] == '1')
7
    8
    total_ones = prefix_ones[n]
9
    10
    min_cost = n
11
    12
    for length in range(n + 1):
13
        if length == 0:
14
            min_cost = min(min_cost, total_ones)
15
            continue
16
        17
        best_pos_cost = n
18
        19
20
        for start in range(n - length + 1):
21
            end = start + length
22
            23
            ones_remaining = prefix_ones[end] - prefix_ones[start]
24
            25
            ones_removed = total_ones - ones_remaining
26
            27
            zeros_remaining = length - ones_remaining
28
            29
            cost = max(zeros_remaining, ones_removed)
30
            best_pos_cost = min(best_pos_cost, cost)
31
        32
        min_cost = min(min_cost, best_pos_cost)
33
    34
    return min_cost
35
36
import sys
37
input = sys.stdin.readline
38
39
t = int(input())
40
for _ in range(t):
41
    server_rack = input().strip()
42
    print(min_decommissioning_cost(server_rack))",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054271
1390054274,unknown,unknown,unknown,"1
from collections import deque
2
def FSR(arr,k):
3
    dq,result=deque(),[]
4
    for i in range(len(arr)):
5
        if dq and dq[0]<i-k+1:
6
            dq.popleft()
7
        if arr[i]<0:
8
            dq.append(i)
9
        if i>=k-1:
10
            result.append(arr[dq[0]]if dq else 0)
11
    return result
12
t=int(input())
13
for _ in range(t):
14
    n,k=map(int,input().split())
15
    arr=list(map(int,input().split()))
16
    print(*FSR(arr,k))
17
    18
        ",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054274
1390054265,unknown,unknown,unknown,"1
def find_earliest_faults(arr, k):
2
    result = []
3
    for i in range(len(arr) - k + 1):
4
        batch = arr[i:i + k]
5
        fault_found = False
6
        for reading in batch:
7
            if reading < 0:
8
                result.append(reading)
9
                fault_found = True
10
                break
11
        if not fault_found:
12
            result.append(0)
13
    return result
14
15
if __name__ ==""__main__"" :
16
    t = int(input())
17
    for _ in range(t):
18
        n, k = map(int, input().split())
19
        arr = list(map(int, input().split()))
20
        output = find_earliest_faults(arr, k)
21
        print(*output)
22
23",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054265
1390054269,unknown,unknown,unknown,"1
2
import sys
3
4
def main():
5
    input = sys.stdin.read().split()
6
    idx = 0
7
    T = int(input[idx])
8
    idx += 1
9
    for _ in range(T):
10
        n, k = int(input[idx]), int(input[idx + 1])
11
        idx += 2
12
        a = list(map(int, input[idx:idx + n]))
13
        idx += n
14
        15
        sum_S = sum(a)
16
        # Compute a[i] + i (0-based)
17
        values = [a[i] + i for i in range(n)]
18
        # Sort in descending order
19
        values.sort(reverse=True)
20
        sum_aj_plus_j = sum(values[:k])
21
        # Compute the result
22
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
23
        print(res)
24
25
if __name__ == ""__main__"":
26
    main()",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054269
1390054270,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommissioningCorrected {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
        scanner.nextLine(); // Consume newline
9
10
        while (t-- > 0) {
11
            String servers = scanner.nextLine();
12
            int minCost = solveCorrected(servers);
13
            System.out.println(minCost);
14
        }
15
        scanner.close();
16
    }
17
18
    private static int solveCorrected(String servers) {
19
        int n = servers.length();
20
        int minCost = Integer.MAX_VALUE;
21
22
        for (int i = 0; i <= n; i++) { // Decommission from the beginning
23
            for (int j = 0; j <= n - i; j++) { // Decommission from the end
24
                String remaining = servers.substring(i, n - j);
25
                int idleCount = 0;
26
                int activeDecommissioned = 0;
27
28
                // Count idle servers in the remaining string
29
                for (int k = 0; k < remaining.length(); k++) {
30
                    if (remaining.charAt(k) == '0') {
31
                        idleCount++;
32
                    }
33
                }
34
35
                // Count active servers decommissioned from the beginning
36
                for (int k = 0; k < i; k++) {
37
                    if (servers.charAt(k) == '1') {
38
                        activeDecommissioned++;
39
                    }
40
                }
41
42
                // Count active servers decommissioned from the end
43
                for (int k = 0; k < j; k++) {
44
                    if (servers.charAt(n - 1 - k) == '1') {
45
                        activeDecommissioned++;
46
                    }
47
                }
48
49
                minCost = Math.min(minCost, Math.max(idleCount, activeDecommissioned));
50
            }
51
        }
52
53
        return minCost;
54
    }
55
}",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054270
1390054264,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        output = []
8
        dq = deque()
9
        for i in range(k):
10
            if arr[i] < 0:
11
                dq.append(i)
12
        output.append(arr[dq[0]] if dq else 0)
13
        for i in range(k, n):
14
            if dq and dq[0] <= i - k:
15
                dq.popleft()
16
            if arr[i] < 0:
17
                dq.append(i)
18
            output.append(arr[dq[0]] if dq else 0)
19
        20
        results.append("" "".join(map(str, output)))
21
    22
    return ""\n"".join(results)
23
t = int(input())
24
test_cases = []
25
for _ in range(t):
26
    n, k = map(int, input().split())
27
    arr = list(map(int, input().split()))
28
    test_cases.append((n, k, arr))
29
print(earliest_faulty_readings(test_cases))",91,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054264
1390054251,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    4
    for j in range(k + 1):
5
        dp[0][j] = 0
6
    7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            if j > 0:
10
                dp[i][j] = dp[i-1][j-1]
11
            12
            current_strength = strengths[i-1] + j
13
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
14
    15
    return min(dp[n])
16
17
def solve():
18
    t = int(input())
19
    results = []
20
    21
    for _ in range(t):
22
        n, k = map(int, input().split())
23
        strengths = list(map(int, input().split()))
24
        results.append(min_effort_to_breach(n, k, strengths))
25
    26
    for result in results:
27
        print(result)
28
29
solve()",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054251
1390054258,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054258
1390054259,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <bits/stdc++.h>
7
using namespace std;
8
9
int solve(vector<int>&arr, int i, int skip, int inc,vector<vector<int>>&dp) {
10
    int n = arr.size();
11
    if(i==n){
12
        return 0;
13
    }
14
    if(dp[i][skip]!=-1)return dp[i][skip];
15
    //skip
16
    int ans = INT_MAX;
17
    if(skip) {
18
        ans = min(ans,solve(arr,i+1,skip-1,inc+1,dp));
19
    }
20
    //no skip
21
    ans = min(ans,arr[i]+inc + solve(arr,i+1,skip,inc,dp));
22
    return dp[i][skip]= ans;
23
}
24
25
26
int main() {
27
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
28
    int t;
29
    cin>>t;
30
    while(t--) {
31
        int n,skip;
32
        cin>>n>>skip;
33
        vector<int>arr;
34
        vector<vector<int>>dp(n,vector<int>(n+1,-1));
35
        while(n--) {
36
            int a;
37
            cin>>a;
38
            arr.push_back(a);
39
        }
40
        cout<<solve(arr,0,skip,0,dp)<<endl;
41
    }
42
    return 0;
43
}",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054259
1390054243,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <algorithm>
4
#include <queue>
5
6
using namespace std;
7
8
long long calculateMinEffort(vector<int>& a, int k) {
9
    int n = a.size();
10
    // Use a max-heap to find the k largest elements
11
    priority_queue<int> maxHeap;
12
    for (int i = 0; i < n; ++i) {
13
        maxHeap.push(a[i]);
14
    }
15
16
    // Extract the k largest elements
17
    vector<int> skipped;
18
    for (int i = 0; i < k; ++i) {
19
        skipped.push_back(maxHeap.top());
20
        maxHeap.pop();
21
    }
22
23
    // Calculate the total effort
24
    long long totalEffort = 0;
25
    int increase = 0; // Tracks the number of skipped firewalls so far
26
    for (int i = 0; i < n; ++i) {
27
        if (find(skipped.begin(), skipped.end(), a[i]) != skipped.end() && increase < k) {
28
            // Skip this firewall
29
            increase++;
30
        } else {
31
            // Add the effort, considering the increase due to skipped firewalls
32
            totalEffort += a[i] + increase;
33
        }
34
    }
35
36
    return totalEffort;
37
}
38
39
int main() {
40
    int T;
41
    cin >> T;
42
    while (T--) {
43
        int n, k;
44
        cin >> n >> k;
45
        vector<int> a(n);
46
        for (int i = 0; i < n; ++i) {
47
            cin >> a[i];
48
        }
49
50
        // If k >= n, we can skip all firewalls
51
        if (k >= n) {
52
            cout << 0 << endl;
53
            continue;
54
        }
55
56
        // Otherwise, calculate the minimum effort
57
        long long minEffort = calculateMinEffort(a, k);
58
        cout << minEffort << endl;
59
    }
60
    return 0;
61
}",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054243
1390054246,unknown,unknown,unknown,"1
def solve():
2
3
    s = input()
4
5
    n = len(s)
6
7
    min_cost = float('inf')
8
9
    for i in range(n + 1):
10
11
        for j in range(n - i + 1):
12
13
            remaining = s[i:n - j]
14
15
            idle_count = remaining.count('0')
16
17
            active_removed = s[:i].count('1') + s[n - j:].count('1')
18
19
            min_cost = min(min_cost, max(idle_count, active_removed))
20
21
    print(min_cost)
22
23
t = int(input())
24
25
for _ in range(t):
26
27
    solve()
28
29
30",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054246
1390054249,unknown,unknown,unknown,"1
test_case = int(input())
2
for _ in range(test_case):
3
    a,b = list(map(int,input().split("" "")))
4
    arr = list(map(int,input().split("" "")))
5
    arr.sort()
6
    temp_sum = 0
7
    for i in range(a-b):
8
        temp_sum+=arr[i]
9
    if a-b>0:
10
        print(temp_sum+b)
11
    else:
12
        print(temp_sum)",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054249
1390054233,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n, k = test_cases[t][0]  
6
        firewalls = test_cases[t][1] 
7
8
        sorted_indices = sorted(range(n), key=lambda i: -firewalls[i])
9
10
      11
        skipped = set(sorted_indices[:k])
12
13
        total_effort = 0
14
        increment = 0 
15
        16
        for i in range(n):
17
            if i in skipped:
18
                increment += 1
19
            else:
20
                total_effort += firewalls[i] + increment
21
        22
        results.append(total_effort)
23
    24
    return results
25
26
27
28
T = int(input().strip())  
29
test_cases = []
30
31
for _ in range(T):
32
    n, k = map(int, input().strip().split())  
33
    firewalls = list(map(int, input().strip().split()))  
34
    test_cases.append(((n, k), firewalls))
35
36
37
output = min_effort_to_breach(T, test_cases)
38
39
for res in output:
40
    print(res)
41",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054233
1390054234,unknown,unknown,unknown,"1
def min_eff(t,test_cases):
2
    res = []
3
    4
    for case in test_cases:
5
        n , k , firewalls = case
6
        firewalls.sort() #sort skit weakest
7
        8
        #compute effort
9
        tot_effort = sum(firewall[k:1]) if k<n else 0
10
        11
        res.append(tot_effort)
12
    return res
13
#input handling
14
t = int(input()) #no of testcases
15
test_cases = []
16
17
for",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054234
1390054239,unknown,unknown,unknown,"1
import itertools
2
3
def findMinEffort():
4
    n, k = map(int, input().split())
5
    a = list(map(int, input().split()))
6
    min_effort = float('inf')
7
    8
    for skip_count in range(min(k, n) + 1):
9
        for skip_indices in itertools.combinations(range(n), skip_count):
10
            current_arr = a[:]
11
            for skip_index in sorted(skip_indices):
12
                for j in range(skip_index + 1, n):
13
                    current_arr[j] += 1    
14
            effort = 0
15
            for i in range(n):
16
                if i not in skip_indices:
17
                    effort += current_arr[i]
18
            19
            min_effort = min(min_effort, effort)         
20
    print(min_effort)
21
22
t = int(input())
23
for _ in range(t):
24
    findMinEffort()",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054239
1390054232,unknown,unknown,unknown,"1
def min_decommission_cost(server_rack):
2
    n = len(server_rack)
3
    total_ones = server_rack.count('1')
4
    min_cost = float('inf')
5
    left = 0
6
    zeros_in_window = 0
7
8
    for right in range(n):
9
        if server_rack[right] == '0':
10
            zeros_in_window += 1
11
            12
        ones_in_window = (right - left + 1) - zeros_in_window
13
        ones_removed = total_ones - ones_in_window
14
15
        cost = max(zeros_in_window, ones_removed)
16
17
        if cost < min_cost:
18
            min_cost = cost
19
20
        while zeros_in_window > ones_removed and left <= right:
21
            if server_rack[left] == '0':
22
                zeros_in_window -= 1
23
            left += 1
24
            ones_in_window = (right - left + 1) - zeros_in_window
25
            ones_removed = total_ones - ones_in_window
26
            cost = max(zeros_in_window, ones_removed)
27
            if cost < min_cost:
28
                min_cost = cost
29
30
    return min_cost
31
32
T = int(input())
33
for _ in range(T):
34
    server_rack = input().strip()
35
    print(min_decommission_cost(server_rack))",92,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054232
1390054224,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054224
1390054225,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            String s = sc.next();
9
            int n = s.length();
10
            int[] prefixOnes = new int[n + 1];
11
            int[] suffixZeros = new int[n + 1];
12
13
            // Precompute prefix sum of ones
14
            for (int i = 0; i < n; i++) {
15
                prefixOnes[i + 1] = prefixOnes[i] + (s.charAt(i) == '1' ? 1 : 0);
16
            }
17
18
            // Precompute suffix sum of zeros
19
            for (int i = n - 1; i >= 0; i--) {
20
                suffixZeros[n - i] = suffixZeros[n - i - 1] + (s.charAt(i) == '0' ? 1 : 0);
21
            }
22
23
            int minCost = Integer.MAX_VALUE;
24
            // Try removing i characters from start, j characters from end
25
            for (int i = 0; i <= n; i++) { // prefix removals
26
                for (int j = 0; j <= n - i; j++) { // suffix removals
27
                    int onesRemoved = prefixOnes[i] + (prefixOnes[n] - prefixOnes[n - j]);
28
                    int zerosRemaining = 0;
29
                    // Count zeros between
30
                    for (int k = i; k < n - j; k++) {
31
                        if (s.charAt(k) == '0') zerosRemaining++;
32
                    }
33
                    minCost = Math.min(minCost, Math.max(zerosRemaining, onesRemoved));
34
                }
35
            }
36
            System.out.println(minCost);
37
        }
38
    }
39
}
40",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054225
1390054229,unknown,unknown,unknown,"1
def min_effort_to_breach(test_cases):
2
    results = []
3
    for n, k, firewalls in test_cases:
4
        firewalls.sort()
5
        effort = sum(firewalls[:n - k])  # Regular effort
6
        for i in range(n - k, n):  # Apply security increase for skipped firewalls
7
            effort += firewalls[i] + (i - (n - k))
8
        results.append(str(effort))
9
    10
    print(""\n"".join(results))
11
12
# Read input
13
t = int(input())
14
test_cases = []
15
for _ in range(t):
16
    n, k = map(int, input().split())
17
    firewalls = list(map(int, input().split()))
18
    test_cases.append((n, k, firewalls))
19
20
min_effort_to_breach(test_cases)
21",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054229
1390054220,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054220
1390054223,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_0 = servers.count('0')
7
        total_1 = n - total_0
8
        9
        # Precompute prefix counts for 0s and 1s
10
        prefix_0 = [0] * (n + 1)
11
        prefix_1 = [0] * (n + 1)
12
        for i in range(1, n + 1):
13
            prefix_0[i] = prefix_0[i-1] + (servers[i-1] == '0')
14
            prefix_1[i] = prefix_1[i-1] + (servers[i-1] == '1')
15
        16
        # Precompute suffix counts for 0s and 1s
17
        suffix_0 = [0] * (n + 1)
18
        suffix_1 = [0] * (n + 1)
19
        for j in range(1, n + 1):
20
            suffix_0[j] = suffix_0[j-1] + (servers[n - j] == '0')
21
            suffix_1[j] = suffix_1[j-1] + (servers[n - j] == '1')
22
        23
        min_cost = float('inf')
24
        25
        # Iterate over all possible prefixes (i)
26
        for i in range(n + 1):
27
            # The maximum j such that i + j <= n is j_max = n - i
28
            j_max = n - i
29
            30
            # Binary search for the best j in [0, j_max]
31
            left = 0
32
            right = j_max
33
            best_j = 0
34
            best_cost = float('inf')
35
            36
            while left <= right:
37
                mid = (left + right) // 2
38
                # Calculate remaining_0 and decommissioned_1 for j = mid
39
                remaining_0 = total_0 - (prefix_0[i] + suffix_0[mid])
40
                decommissioned_1 = prefix_1[i] + suffix_1[mid]
41
                current_cost = max(remaining_0, decommissioned_1)
42
                43
                # Update best_j and best_cost if current_cost is better
44
                if current_cost < best_cost:
45
                    best_cost = current_cost
46
                    best_j = mid
47
                elif current_cost == best_cost and mid < best_j:
48
                    best_j = mid
49
                50
                # Decide direction to search
51
                if decommissioned_1 < remaining_0:
52
                    # Need to remove more 1s (increase j)
53
                    left = mid + 1
54
                else:
55
                    # Need to remove fewer 1s (decrease j)
56
                    right = mid - 1
57
            58
            # Check the best j found and neighboring values
59
            for j in [best_j - 1, best_j, best_j + 1]:
60
                if 0 <= j <= j_max:
61
                    remaining_0 = total_0 - (prefix_0[i] + suffix_0[j])
62
                    decommissioned_1 = prefix_1[i] + suffix_1[j]
63
                    current_cost = max(remaining_0, decommissioned_1)
64
                    if current_cost < best_cost:
65
                        best_cost = current_cost
66
            67
            min_cost = min(min_cost, best_cost)
68
        69
        results.append(min_cost)
70
    71
    return results
72
73
# Input reading
74
T = int(input())
75
test_cases = [input().strip() for _ in range(T)]
76
77
# Get results
78
results = min_decommissioning_cost(test_cases)
79
80
# Output results
81
for result in results:
82
    print(result)",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054223
1390054222,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    ans = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            10
            decommissioned_ones = 0
11
            remaining_zeros = 0
12
            13
            # Decommission from the beginning
14
            decommissioned_ones += s[:i].count('1')
15
            16
            # Decommission from the end
17
            decommissioned_ones += s[n - j:].count('1')
18
            19
            # Remaining string after decommissioning
20
            remaining_string = s[i:n - j]
21
            remaining_zeros = remaining_string.count('0')
22
            23
            ans = min(ans, max(decommissioned_ones, remaining_zeros))
24
            25
    print(ans)
26
27
t = int(input())
28
for _ in range(t):
29
    solve()",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054222
1390054214,unknown,unknown,unknown,"1
import sys
2
from itertools import accumulate
3
4
def min_effort(arr, k):
5
    n = len(arr)
6
    T = sum(arr)
7
    A = [arr[i] + (i+1) for i in range(n)]
8
    A.sort(reverse=True)
9
    P = [0] + list(accumulate(A))
10
    m_max = min(k, n)
11
    best = float('inf')
12
    for m in range(m_max + 1):
13
        cost = T + m * n - (m * m - m) // 2 - P[m]
14
        if cost < best:
15
            best = cost
16
    return best
17
18
def solve():
19
    data = sys.stdin.read().strip().split()
20
    if not data:
21
        return
22
    t = int(data[0])
23
    index = 1
24
    res = []
25
    for _ in range(t):
26
        n = int(data[index]); index += 1
27
        k = int(data[index]); index += 1
28
        arr = list(map(int, data[index:index+n])); index += n
29
        res.append(str(min_effort(arr, k)))
30
    sys.stdout.write(""\n"".join(res))
31
32
if __name__ == ""__main__"":
33
    solve()
34",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054214
1390054217,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054217
1390054218,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054218
1390054211,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
#include <ext/pb_ds/assoc_container.hpp>
3
#include <ext/pb_ds/tree_policy.hpp>
4
#include <ext/pb_ds/detail/standard_policies.hpp>
5
#include <cmath>
6
#define int long long int
7
#define pb push_back
8
/*---------------------------------------------------------------------------------------------------------------------------------*/
9
/*ASCII small case-> a-97 to z-122
10
upper case-> A-65 to Z-90*/
11
#define nl ""\n""
12
#define mp map<int, int>
13
#define all(v) v.begin(), v.end()
14
#define F first
15
#define S second
16
#define ump unordered_map<long long, int, custom_hash>
17
#define mstpi multiset<pair<int, int> >
18
#define mst multiset<int>
19
#define vec vector<int>
20
#define pi pair<int, int>
21
#define ld long double
22
#define vep vector<pair<int, int>>
23
#define ul unsigned long long
24
#define loop1 for (int i = 0; i < n; i++)
25
#define REP(i, a, b) for (int i = a; i <= b; i++)
26
#define NO cout << ""NO"" << endl
27
#define YES cout << ""YES"" << endl
28
using namespace std;
29
using namespace __gnu_pbds;
30
typedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>ordered_set; //find_by_order, order_of_key, greater_equal<int> -> making it desc order
31
/*---------------------------------------------------------------------------------------------------------------------------------*/
32
const double PI = 3.1415926535;
33
const int inf = 1e18;
34
const int mod = 1000000007;
35
/*---------------------------------------------------------------------------------------------------------------------------------*/
36
int modmul(int a, int b, int m)
37
{
38
    a %= m;
39
    b %= m;
40
    return (a * b) % m;
41
}
42
int modexp(int n, int x)
43
{
44
    int ans = 1;
45
    while (n > 0)
46
    {
47
        if (n & 1)
48
        {
49
            ans = (ans * x) % mod;
50
        }
51
        n >>= 1;
52
        x = (x * x) % mod;
53
    }
54
    return ans;
55
}
56
/*---------------------------------------------------------------------------------------------------------------------------------*/
57
string add(string a, string b)
58
{
59
    string ans = """";
60
    int carry = 0;
61
    while (!a.empty() || !b.empty() || carry > 0)
62
    {
63
        int digitA = a.empty() ? 0 : a.back() - '0';
64
        int digitB = b.empty() ? 0 : b.back() - '0';
65
        int sum = digitA + digitB + carry;
66
        ans = to_string(sum % 10) + ans;
67
        carry = sum / 10;
68
        if (!a.empty())
69
            a.pop_back();
70
        if (!b.empty())
71
            b.pop_back();
72
    }
73
    return ans;
74
}
75
string ministrnum(string a, string b)
76
{
77
    if (a.length() > b.length())
78
        return b;
79
    else if (b.length() > a.length())
80
        return a;
81
    else
82
    {
83
        int n = a.length();
84
        for (int i = 0; i < n; i++)
85
        {
86
            if (a[i] > b[i])
87
                return b;
88
            else if (a[i] < b[i])
89
                return a;
90
        }
91
    }
92
    return a;
93
}
94
vector<int> sieve(int n) {
95
    vector<bool> isPrime(n + 1, true);
96
    vector<int> primes;
97
    if(n >= 0) isPrime[0] = false;
98
    if(n >= 1) isPrime[1] = false;
99
    for (int i = 2; i <= n; i++) {
100
        if (isPrime[i]) {
101
            primes.push_back(i);
102
            for (int j = 2 * i; j <= n; j += i)
103
                isPrime[j] = false;
104
        }
105
    }
106
    return primes;
107
}
108
109
class SegmentTree {
110
public:
111
    int n;
112
    std::vector<int> tree;
113
    std::vector<int> lazy;
114
    115
    SegmentTree(const std::vector<int>& arr) {
116
        n = arr.size();
117
        tree.resize(4 * n, 0);
118
        lazy.resize(4 * n, 0);
119
        build(arr, 0, n - 1, 0);
120
    }
121
    122
    void build(const std::vector<int>& arr, int start, int end, int index) {
123
        if (start == end) {
124
            tree[index] = arr[start];
125
            return;
126
        }
127
        int mid = (start + end) / 2;
128
        build(arr, start, mid, 2 * index + 1);
129
        build(arr, mid + 1, end, 2 * index + 2);
130
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
131
    }
132
    133
    int queryRange(int start, int end, int l, int r, int index = 0) {
134
        if (lazy[index] != 0) {
135
            tree[index] += (end - start + 1) * lazy[index];
136
            if(start != end) {
137
                lazy[2 * index + 1] += lazy[index];
138
                lazy[2 * index + 2] += lazy[index];
139
            }
140
            lazy[index] = 0;
141
        }
142
        if (start > r || end < l)
143
            return 0;
144
        if (start >= l && end <= r)
145
            return tree[index];
146
        int mid = (start + end) / 2;
147
        return queryRange(start, mid, l, r, 2 * index + 1) +
148
               queryRange(mid + 1, end, l, r, 2 * index + 2);
149
    }
150
    151
    void updateRange(int start, int end, int l, int r, int diff, int index = 0) {
152
        if(lazy[index] != 0) {
153
            tree[index] += (end - start + 1) * lazy[index];
154
            if(start != end) {
155
                lazy[2 * index + 1] += lazy[index];
156
                lazy[2 * index + 2] += lazy[index];
157
            }
158
            lazy[index] = 0;
159
        }
160
        if(start > r || end < l)
161
            return;
162
        if(start >= l && end <= r) {
163
            tree[index] += (end - start + 1) * diff;
164
            if(start != end) {
165
                lazy[2 * index + 1] += diff;
166
                lazy[2 * index + 2] += diff;
167
            }
168
            return;
169
        }
170
        int mid = (start + end) / 2;
171
        updateRange(start, mid, l, r, diff, 2 * index + 1);
172
        updateRange(mid + 1, end, l, r, diff, 2 * index + 2);
173
        tree[index] = tree[2 * index + 1] + tree[2 * index + 2];
174
    }
175
};
176
class DSU {
177
public:
178
    std::vector<int> parent, rank;
179
    180
    DSU(int n) {
181
        parent.resize(n);
182
        rank.resize(n, 0);
183
        for (int i = 0; i < n; i++)
184
            parent[i] = i;
185
    }
186
    187
    int find(int x) {
188
        if (parent[x] != x)
189
            parent[x] = find(parent[x]);
190
        return parent[x];
191
    }
192
    193
    bool unionSets(int x, int y) {
194
        int rootX = find(x);
195
        int rootY = find(y);
196
        if (rootX == rootY)
197
            return false;
198
        if (rank[rootX] < rank[rootY])
199
            parent[rootX] = rootY;
200
        else if (rank[rootX] > rank[rootY])
201
            parent[rootY] = rootX;
202
        else {
203
            parent[rootY] = rootX;
204
            rank[rootX]++;
205
        }
206
        return true;
207
    }
208
};
209
210
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
211
struct Node {
212
    int val;
213
    int weight, size;
214
    Node *left, *right;
215
    bool rev = false;
216
    Node(int c): val(c), weight(rng()), size(1), left(NULL), right(NULL) {}
217
};
218
ostream &operator<<(ostream &os, Node *n) {
219
    if(!n) return os;
220
    os << n -> left;
221
    os << n -> val;
222
    os << n -> right;
223
    return os;
224
}
225
int size(Node *Treap) {return Treap ? Treap -> size: 0;}
226
void push(Node* Treap) {
227
    if(!Treap) return;
228
    if(Treap -> rev) {
229
        Treap -> rev = false;
230
        swap(Treap->left, Treap->right);
231
        if(Treap -> left) Treap->left->rev ^= true;
232
        if(Treap -> right) Treap->right->rev ^= true;
233
    }
234
}
235
void pull(Node *Treap) {
236
    if(!Treap) return;
237
    push(Treap -> left), push(Treap -> right);
238
    Treap -> size = size(Treap -> left) + size(Treap -> right) + 1;
239
    return;
240
}
241
void split(Node *Treap, Node *&left, Node *&right, int val) {
242
    if(!Treap) {
243
        left = right = NULL;
244
        return;
245
    }
246
    push(Treap);
247
    if(size(Treap -> left) < val) {
248
        split(Treap -> right, Treap -> right, right, val - size(Treap->left) - 1);
249
        left = Treap;
250
    }
251
    else {
252
        split(Treap -> left, left, Treap -> left, val);
253
        right = Treap;
254
    }
255
    pull(Treap);
256
}
257
void merge(Node *&Treap, Node *left, Node *right) {
258
    push(left), push(right);
259
    if(left == NULL) {
260
        Treap = right;
261
        return;
262
    }
263
    if(right == NULL) {
264
        Treap = left;
265
        return;
266
    }
267
    if(left -> weight < right -> weight) {
268
        merge(right -> left, left, right -> left);
269
        Treap = right;
270
    }
271
    else {
272
        merge(left->right, left->right, right);
273
        Treap = left;
274
    }
275
    pull(Treap);
276
}
277
void inOrder(Node *curr, vector<int> &res) {
278
    if(curr == NULL) return;
279
    push(curr);
280
    inOrder(curr->left, res);
281
    res.pb(curr->val);
282
    inOrder(curr->right, res);
283
    pull(curr);
284
}
285
struct Treap {
286
    Node *root = nullptr;
287
    void insert(int i, int val) {
288
        Node *l, *r;
289
        split(root, l, r, i);
290
        Node *v = new Node(val);
291
        merge(l, l, v);
292
        merge(root, l, r);
293
    }
294
    295
    void del(int i) {
296
        Node *l, *r;
297
        split(root, l, r, i);
298
        split(r, root, r, 1);
299
        merge(root, l, r);
300
    }
301
    302
    void update(int l, int r, function<void(Node *)> f) {
303
        Node *a, *b, *c;
304
        split(root, a, b, l-1);
305
        split(b, b, c, r-l+1);
306
        if(b) {f(b);}
307
        merge(root, a, b);
308
        merge(root, root, c);
309
    }
310
    311
    vector<int> allPr() {
312
        vector<int> res;
313
        inOrder(root, res);
314
        return res;
315
    }
316
    317
    void cycShft(int l, int r) {
318
        Node *a, *b, *c, *d;
319
        split(root, a, b, l-1);
320
        split(b, b, c, r-l+1);
321
        split(b, b, d, r-l);
322
        merge(root, a, d);
323
        merge(root, root, b);
324
        merge(root, root, c);
325
    }
326
};
327
vector<int> computePrefix(const string &pattern) {
328
    int n = pattern.size();
329
    vector<int> prefix(n, 0);
330
    for (int i = 1, j = 0; i < n; i++) {
331
        while (j > 0 && pattern[i] != pattern[j])
332
            j = prefix[j - 1];
333
        if (pattern[i] == pattern[j])
334
            j++;
335
        prefix[i] = j;
336
    }
337
    return prefix;
338
}
339
340
vector<int> KMPSearch(const string &text, const string &pattern) {
341
    vector<int> prefix = computePrefix(pattern);
342
    vector<int> occurrences;
343
    for (int i = 0, j = 0; i < (int)text.size(); i++) {
344
        while (j > 0 && text[i] != pattern[j])
345
            j = prefix[j - 1];
346
        if (text[i] == pattern[j])
347
            j++;
348
        if (j == (int)pattern.size()) {
349
            occurrences.push_back(i - j + 1);
350
            j = prefix[j - 1];
351
        }
352
    }
353
    return occurrences;
354
}
355
void solve()
356
{
357
    int n, ans = 1e9;
358
    string s;
359
    cin>>s;
360
    n = s.size();
361
    362
    vector<int> pref(n, 0);
363
    for(int i = 0; i<n; i++) {
364
        pref[i] = s[i] == '1';
365
        if(i) pref[i] += pref[i - 1];
366
    }
367
    368
    369
    for(int i = 0; i<n; i++) {
370
        for(int j = i; j<n; j++) {
371
            int cnt1 = (i?pref[i-1]:0) + pref[n-1] - (j!=n-1?pref[j+1]:pref[n-1]), cnt0 = (j - i + 1) - (pref[j] - (i?pref[i-1]:0));
372
            ans = min(ans, max(cnt1, cnt0)); 
373
        }
374
    }
375
    cout<<ans<<'\n';
376
}
377
int32_t main()
378
{
379
    ios_base ::sync_with_stdio(0);
380
    cin.tie(0);
381
    cout.tie(0);
382
    int t = 1;
383
    cin >> t;
384
    while (t--)
385
        solve();
386
}",93,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054211
1390054207,unknown,unknown,unknown,"1
def min_decommission_cost(s):
2
    n = len(s)
3
    4
    first_one = s.find('1')
5
    last_one = s.rfind('1')
6
7
    if first_one == -1:
8
        return 0  
9
10
    trimmed = s[first_one:last_one+1]
11
    remaining_zeros = trimmed.count('0')
12
13
    min_cost = remaining_zeros
14
    ones_removed = 0
15
16
    for i in range(first_one, last_one + 1):
17
        if s[i] == '1':
18
            ones_removed += 1
19
        else:
20
            remaining_zeros -= 1
21
    22
        min_cost = min(min_cost, max(remaining_zeros, ones_removed))
23
24
    return min_cost
25
26
T = int(input())
27
for _ in range(T):
28
    s = input().strip()
29
    print(min_decommission_cost(s))
30",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054207
1390054209,unknown,unknown,unknown,"1
def min_effort_to_breach(t, test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        firewalls.sort()
6
        7
        # Skip the k weakest firewalls (if possible)
8
        remaining_effort = sum(firewalls[:max(0, n - k)])
9
        results.append(str(remaining_effort))
10
    11
    return ""\n"".join(results)
12
13
# Read input
14
t = int(input().strip())
15
test_cases = []
16
17
for _ in range(t):
18
    n, k = map(int, input().split())
19
    firewalls = list(map(int, input().split()))
20
    test_cases.append((n, k, firewalls))
21
22
# Compute and print results
23
print(min_effort_to_breach(t, test_cases))
24",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054209
1390054210,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    4
    for j in range(k + 1):
5
        dp[0][j] = 0
6
    7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            if j > 0:
10
                dp[i][j] = dp[i-1][j-1]
11
            12
            current_strength = strengths[i-1] + j
13
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
14
    15
    return min(dp[n])
16
17
def solve():
18
    t = int(input())
19
    results = []
20
    21
    for _ in range(t):
22
        n, k = map(int, input().split())
23
        strengths = list(map(int, input().split()))
24
        results.append(min_effort_to_breach(n, k, strengths))
25
    26
    for result in results:
27
        print(result)
28
29
solve()
30",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054210
1390054202,unknown,unknown,unknown,"1
import java.util.*;
2
public class Main {
3
    public static void main(String[] args) {
4
        Scanner sc = new Scanner(System.in);
5
        int t = sc.nextInt();
6
        7
        while (t-- > 0) {
8
            int n = sc.nextInt(), k = sc.nextInt();
9
            int[] arr = new int[n];
10
            11
            for (int i = 0; i < n; i++) {
12
                arr[i] = sc.nextInt();
13
            }
14
            15
            System.out.println(minEffort(n, k, arr));
16
        }
17
        sc.close();
18
    }
19
    20
    static int minEffort(int n, int k, int[] arr) {
21
        int[] curr = new int[k + 1];
22
        int[] next = new int[k + 1];
23
        24
        Arrays.fill(curr, Integer.MAX_VALUE);
25
        Arrays.fill(next, Integer.MAX_VALUE);
26
        27
        Arrays.fill(next, 0);
28
        29
        for (int i = n - 1; i >= 0; i--) {
30
            for (int skip = 0; skip <= k; skip++) {
31
                int take = arr[i] + skip;
32
                if (i + 1 < n) {
33
                    if (next[skip] != Integer.MAX_VALUE) {
34
                        take += next[skip];
35
                    }
36
                }
37
                38
                int leave = Integer.MAX_VALUE;
39
                if (skip < k && i + 1 <= n) {
40
                    leave = next[skip + 1];
41
                }
42
                43
                curr[skip] = Math.min(take, leave);
44
            }
45
            46
            int[] temp = next;
47
            next = curr;
48
            curr = temp;
49
            50
            Arrays.fill(curr, Integer.MAX_VALUE);
51
        }
52
        53
        return next[0];
54
    }
55
}",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054202
1390054203,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        benefits = []
12
        for i in range(n):
13
            benefit = a[i] - (n - i - 1)
14
            benefits.append((benefit, i))
15
        16
        # Sort by benefit descending
17
        benefits.sort(reverse=True)
18
19
        skipped = [False] * n
20
21
        # Mark the top k firewalls to skip
22
        for i in range(k):
23
            _, idx = benefits[i]
24
            skipped[idx] = True
25
26
        # Calculate total effort
27
        total_effort = 0
28
        penalty = 0  # number of skipped firewalls so far
29
        for i in range(n):
30
            if skipped[i]:
31
                penalty += 1
32
            else:
33
                total_effort += a[i] + penalty
34
35
        print(total_effort)
36
37
# Run main() inside a separate thread to avoid recursion limit issues in large input
38
threading.Thread(target=main).start()
39",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054203
1390054204,unknown,unknown,unknown,"1
def min_cost(server_str):
2
    n = len(server_str)
3
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
4
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
5
6
    for i in range(n):
7
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
8
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
9
10
    total_1 = prefix_1[n]
11
    total_0 = prefix_0[n]
12
13
    min_cost = float('inf')
14
15
    # Try removing l elements from the front
16
    for l in range(n + 1):
17
        # Try removing r elements from the back
18
        for r in range(n - l + 1):
19
            left = l
20
            right = n - r
21
            remaining_0 = prefix_0[right] - prefix_0[left]
22
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
23
            cost = max(remaining_0, removed_1)
24
            min_cost = min(min_cost, cost)
25
26
    return min_cost
27
28
# Main driver
29
T = int(input())
30
for _ in range(T):
31
    server_str = input().strip()
32
    print(min_cost(server_str))",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054204
1390054194,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <climits>
4
#include <algorithm>
5
6
using namespace std;
7
8
int minDecommissioningCost(const string& serverRack) {
9
    int n = serverRack.size();
10
    int minCost = INT_MAX;
11
    12
    // Try all possible prefix and suffix removals
13
    for (int i = 0; i <= n; ++i) {  // i = prefix length to remove
14
        for (int j = 0; j <= n - i; ++j) {  // j = suffix length to remove
15
            if (i + j > n) continue;
16
            17
            string remaining = serverRack.substr(i, n - i - j);
18
            if (remaining.empty()) continue;
19
            20
            int idleRemaining = count(remaining.begin(), remaining.end(), '0');
21
            int activeRemoved = count(serverRack.begin(), serverRack.begin() + i, '1') +
22
                                count(serverRack.end() - j, serverRack.end(), '1');
23
            24
            int cost = max(idleRemaining, activeRemoved);
25
            minCost = min(minCost, cost);
26
        }
27
    }
28
    29
    return minCost;
30
}
31
32
void solve() {
33
    int t;
34
    cin >> t;
35
    while (t--) {
36
        string serverRack;
37
        cin >> serverRack;
38
        cout << minDecommissioningCost(serverRack) << endl;
39
    }
40
}
41
42
int main() {
43
    ios::sync_with_stdio(false);
44
    cin.tie(nullptr);
45
    solve();
46
    return 0;
47
}",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054194
1390054196,unknown,unknown,unknown,"1
def minimize_breach_effort(num_firewalls, max_skips, security_strengths):
2
    effort_table = [[float('inf')] * (max_skips + 1) for _ in range(num_firewalls + 1)]
3
    effort_table[0][0] = 0  
4
5
    for firewall in range(1, num_firewalls + 1):
6
        for skips_used in range(max_skips + 1):
7
            effort_table[firewall][skips_used] = (
8
                effort_table[firewall - 1][skips_used] + security_strengths[firewall - 1] + skips_used
9
            )
10
            if skips_used > 0:
11
                effort_table[firewall][skips_used] = min(
12
                    effort_table[firewall][skips_used], effort_table[firewall - 1][skips_used - 1]
13
                )
14
15
    return min(effort_table[num_firewalls])
16
17
test_cases = int(input())
18
19
for _ in range(test_cases):
20
    num_firewalls, max_skips = map(int, input().split())
21
    security_strengths = list(map(int, input().split()))
22
    print(minimize_breach_effort(num_firewalls, max_skips, security_strengths))
23",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054196
1390054200,unknown,unknown,unknown,"1
import sys
2
3
def minimum_effort(test_cases):
4
    results = []
5
    6
    for n, k, a in test_cases:
7
        if k >= n:
8
            results.append(0)
9
            continue
10
11
        # Sorting indices of firewalls based on strength in descending order
12
        sorted_indices = sorted(range(n), key=lambda i: a[i], reverse=True)
13
        14
        # Try skipping different firewalls and calculate minimum effort
15
        min_effort = float('inf')
16
17
        for skip_index in sorted_indices[:k]:  # Only consider skipping the top 'k' strongest firewalls
18
            effort = 0
19
            security_cost = 0
20
21
            for i in range(n):
22
                if i == skip_index:
23
                    security_cost += 1  # Every skipped firewall increases security cost
24
                else:
25
                    effort += a[i] + security_cost  # Firewall strength + accumulated security cost
26
            27
            min_effort = min(min_effort, effort)
28
29
        results.append(min_effort)
30
    31
    return results
32
33
def main():
34
    input_data = sys.stdin.read().split()
35
    it = iter(input_data)
36
    T = int(next(it))
37
    test_cases = []
38
39
    for _ in range(T):
40
        n = int(next(it))
41
        k = int(next(it))
42
        a = [int(next(it)) for _ in range(n)]
43
        test_cases.append((n, k, a))
44
    45
    results = minimum_effort(test_cases)
46
    print(""\n"".join(map(str, results)))
47
48
if __name__ == ""__main__"":
49
    main()
50",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054200
1390054192,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    # Special case: If we can skip all firewalls, the effort is 0
3
    if k >= n:
4
        return 0
5
    6
    # Try all possible subsets of firewalls to skip
7
    min_effort = float('inf')
8
    9
    # Generate all possible subsets of k or fewer indices to skip
10
    # Instead of trying all combinations, we can use a greedy approach
11
    # We'll calculate the impact of skipping each firewall and choose the best ones
12
    13
    # Calculate the impact of skipping each firewall
14
    impact = []
15
    for i, val in enumerate(firewalls):
16
        # Impact = (value of firewall) - (penalty to remaining firewalls)
17
        # Penalty to remaining firewalls = (n - i - 1)
18
        impact_val = val - (n - i - 1)
19
        impact.append((impact_val, i))
20
    21
    # Sort by impact (descending)
22
    impact.sort(reverse=True)
23
    24
    # Try skipping 0 to k firewalls
25
    for skip_count in range(k + 1):
26
        # Get the indices of firewalls to skip
27
        skip_indices = set(impact[j][1] for j in range(skip_count))
28
        29
        # Calculate the effort for this configuration
30
        effort = 0
31
        penalty = 0
32
        33
        for i in range(n):
34
            if i in skip_indices:
35
                penalty += 1  # Increase penalty for subsequent firewalls
36
            else:
37
                effort += firewalls[i] + penalty  # Add effort with penalty
38
        39
        min_effort = min(min_effort, effort)
40
    41
    return min_effort
42
43
# Read input
44
t = int(input().strip())  # Number of test cases
45
for _ in range(t):
46
    n, k = map(int, input().split())
47
    firewalls = list(map(int, input().split()))
48
    print(min_effort_to_breach(n, k, firewalls))",94,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054192
1390054185,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
    public static List<Integer> earliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>();
7
8
        for (int i = 0; i < arr.length; i++) {
9
            10
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
11
                deque.poll();
12
            }
13
14
            15
            if (arr[i] < 0) {
16
                deque.offer(i);
17
            }
18
19
            20
            if (i >= k - 1) {
21
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
22
            }
23
        }
24
        return result;
25
    }
26
27
    public static void main(String[] args) {
28
        Scanner scanner = new Scanner(System.in);
29
        int t = scanner.nextInt(); 
30
31
        while (t-- > 0) {
32
            int n = scanner.nextInt(); 
33
            int k = scanner.nextInt(); 
34
            int[] arr = new int[n];
35
36
            for (int i = 0; i < n; i++) {
37
                arr[i] = scanner.nextInt();
38
            }
39
40
            41
            List<Integer> faults = earliestFaults(arr, k);
42
            for (int val : faults) {
43
                System.out.print(val + "" "");
44
            }
45
            System.out.println();
46
        }
47
        scanner.close();
48
    }
49
}",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054185
1390054186,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054186
1390054190,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, n, k):
4
    result = []
5
    q = deque()  
6
    7
8
    for i in range(k):
9
        if arr[i] < 0:
10
            q.append(i)
11
    12
13
    if q:
14
        result.append(arr[q[0]])
15
    else:
16
        result.append(0)
17
    18
19
    for i in range(k, n):
20
    21
        while q and q[0] <= i - k:
22
            q.popleft()
23
        24
        25
        if arr[i] < 0:
26
            q.append(i)
27
        28
        29
        if q:
30
            result.append(arr[q[0]])
31
        else:
32
            result.append(0)
33
    34
    return result
35
36
t = int(input())
37
for _ in range(t):
38
    n, k = map(int, input().split())
39
    arr = list(map(int, input().split()))
40
    ans = earliest_faulty_readings(arr, n, k)
41
    print(*ans)
42",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054190
1390054181,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    queue = deque()
6
7
    # Process first k elements
8
    for i in range(k):
9
        if arr[i] < 0:
10
            queue.append(i)
11
    12
    # Add the first faulty element or 0 if none found
13
    result.append(arr[queue[0]] if queue else 0)
14
    15
    # Process the rest of the array
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the window
18
        if queue and queue[0] < i - k + 1:
19
            queue.popleft()
20
        21
        # Add new element if it's negative
22
        if arr[i] < 0:
23
            queue.append(i)
24
        25
        # Add the first faulty element or 0
26
        result.append(arr[queue[0]] if queue else 0)
27
28
    return result
29
30
# Read input
31
t = int(input())  # Number of test cases
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    print(*earliest_faulty_readings(arr, k))
36",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054181
1390054183,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt(); 
7
8
        while (T-- > 0) {
9
            int n = sc.nextInt();
10
            int k = sc.nextInt();
11
            int arr[] = new int[n];
12
13
    14
            for (int i = 0; i < n; i++) {
15
                arr[i] = sc.nextInt();
16
            }
17
18
            ArrayList<Integer> list = new ArrayList<>();
19
            Queue<Integer> queue = new LinkedList<>(); 
20
21
            int i = 0, j = 0;
22
23
            while (j < n) {
24
    25
                if (arr[j] < 0) {
26
                    queue.add(arr[j]);
27
                }
28
29
              30
                if (j - i + 1 == k) {
31
                   32
                    if (!queue.isEmpty()) {
33
                        list.add(queue.peek());
34
                    } else {
35
                        list.add(0); 
36
                    }
37
38
                39
                    if (!queue.isEmpty() && queue.peek() == arr[i]) {
40
                        queue.poll();
41
                    }
42
                    i++; 
43
                }
44
45
                j++; 
46
            }
47
48
       49
            for (int l = 0; l < list.size(); l++) {
50
                System.out.print(list.get(l) + "" "");
51
            }
52
            System.out.println(); 
53
        }
54
55
        sc.close();
56
    }
57
}
58",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054183
1390054182,unknown,unknown,unknown,"1
def solve():
2
3
    import sys
4
5
    input_data = sys.stdin.read().splitlines()
6
7
    t = int(input_data[0].strip())
8
9
    line = 1
10
11
    out_lines = []
12
13
    for _ in range(t):
14
15
        s = input_data[line].strip()
16
17
        line += 1
18
19
        n = len(s)
20
21
        # get indices for active servers ('1')
22
23
        positions = [i for i, ch in enumerate(s) if ch == '1']
24
25
        m = len(positions)
26
27
        if m == 0:
28
29
            out_lines.append(""0"")
30
31
            continue
32
33
        # Precompute A: A[i] = positions[i] - i
34
35
        A = [positions[i] - i for i in range(m)]
36
37
        38
39
        # check(X) returns True if there exists a window in A
40
41
        # such that:
42
43
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
44
45
        # and A[j] - A[i] <= X.
46
47
        def check(X):
48
49
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
50
51
            if m - X <= 0:
52
53
                return True
54
55
            j = 0
56
57
            for i in range(m):
58
59
                if j < i:
60
61
                    j = i
62
63
                # slide j as far as possible while A[j]-A[i] <= X
64
65
                while j < m and A[j] - A[i] <= X:
66
67
                    j += 1
68
69
                # j now is one past the last index satisfying condition, so the window has length (j - i)
70
71
                if j - i >= m - X:
72
73
                    return True
74
75
            return False
76
77
        # Binary search for the minimum X
78
79
        lo, hi, ans = 0, n, n
80
81
        while lo <= hi:
82
83
            mid = (lo + hi) // 2
84
85
            if check(mid):
86
87
                ans = mid
88
89
                hi = mid - 1
90
91
            else:
92
93
                lo = mid + 1
94
95
        out_lines.append(str(ans))
96
97
    98
99
    sys.stdout.write(""\n"".join(out_lines))
100
101
    102
103
if __name__ == '__main__':
104
105
    solve()",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054182
1390054176,unknown,unknown,unknown,"1
for _ in range(int(input())):
2
    n, k = map(int, input().split())
3
    nums = list(map(int, input().split()))
4
    output = []
5
6
    for j in range(n - k + 1):
7
        window = nums[j:j + k]
8
        9
        first_negative = next((num for num in window if num < 0), 0)
10
        11
        output.append(first_negative)
12
13
    print(*output)",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054176
1390054180,unknown,unknown,unknown,"1
def min_decommission_cost(rack):
2
    n = len(rack)
3
    4
    # Precompute cumulative sums for O(1) range queries
5
    active_prefix = [0] * (n + 1)  # Active servers (1's) from left
6
    idle_prefix = [0] * (n + 1)    # Idle servers (0's) from left
7
    8
    for i in range(n):
9
        active_prefix[i + 1] = active_prefix[i] + (1 if rack[i] == '1' else 0)
10
        idle_prefix[i + 1] = idle_prefix[i] + (1 if rack[i] == '0' else 0)
11
        12
    total_active = active_prefix[n]
13
    total_idle = idle_prefix[n]
14
    15
    min_cost = float('inf')
16
    17
    # We need to find i and j where:
18
    # i = number of servers to remove from beginning
19
    # j = number of servers to remove from end
20
    for i in range(n + 1):
21
        for j in range(n + 1 - i):  # Ensure we don't remove more than n servers
22
            # Active servers removed from beginning and end
23
            removed_active = active_prefix[i] + (active_prefix[n] - active_prefix[n - j])
24
            25
            # Idle servers remaining in the middle
26
            remaining_idle = idle_prefix[n - j] - idle_prefix[i]
27
            28
            cost = max(remaining_idle, removed_active)
29
            min_cost = min(min_cost, cost)
30
    31
    return min_cost
32
33
def main():
34
    t = int(input().strip())
35
    36
    for _ in range(t):
37
        rack = input().strip()
38
        result = min_decommission_cost(rack)
39
        print(result)
40
41
if __name__ == ""__main__"":
42
    main()",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054180
1390054174,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054174
1390054173,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
#include <stdio.h>
3
#include <stdlib.h>
4
5
void findEarliestFaultyReadings(int *arr, int n, int k) {
6
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
7
    int front = 0, rear = 0;
8
    int queue[n];
9
    10
    // Process the first window
11
    for (int i = 0; i < k; i++) {
12
        if (arr[i] < 0) {
13
            queue[rear++] = i;
14
        }
15
    }
16
    17
    // Store result for the first batch
18
    result[0] = (front < rear)  arr[queue[front]] : 0;
19
    20
    // Process the remaining windows
21
    for (int i = k; i < n; i++) {
22
        // Remove elements not within the window
23
        while (front < rear && queue[front] <= i - k) {
24
            front++;
25
        }
26
        27
        // Add new element if it's faulty
28
        if (arr[i] < 0) {
29
            queue[rear++] = i;
30
        }
31
        32
        // Store result for current batch
33
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
34
    }
35
    36
    // Print the result
37
    for (int i = 0; i < n - k + 1; i++) {
38
        printf(""%d "", result[i]);
39
    }
40
    printf(""\n"");
41
    42
    free(result);
43
}
44
45
int main() {
46
    int t;
47
    scanf(""%d"", &t);
48
    49
    while (t--) {
50
        int n, k;
51
        scanf(""%d %d"", &n, &k);
52
        int arr[n];
53
        54
        for (int i = 0; i < n; i++) {
55
            scanf(""%d"", &arr[i]);
56
        }
57
        58
        findEarliestFaultyReadings(arr, n, k);
59
    }
60
    61
    return 0;
62
}",95,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054173
1390054170,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    s = input().strip()
4
    n = len(s)
5
    a = [0] * (n + 1)
6
7
    for i in range(n):
8
        a[i + 1] = a[i] + (s[i] == ""1"")
9
10
    c = float(""inf"")
11
12
    for i in range(n + 1):
13
        b = a[i]
14
        for j in range(n + 1 - i):
15
            d = a[n] - a[n - j]
16
            e = max((n - i - j) - (a[n] - b - d), b + d)
17
            c = min(c, e)
18
19
    print(c)
20",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054170
1390054168,unknown,unknown,unknown,"1
def breach_effort(num_walls, max_skips, wall_strengths):
2
    dp = [[float('inf')] * (max_skips + 1) for _ in range(num_walls + 1)]
3
    4
    for skips in range(max_skips + 1):
5
        dp[0][skips] = 0
6
    7
    for wall in range(1, num_walls + 1):
8
        for skips in range(max_skips + 1):
9
            if skips > 0:
10
                dp[wall][skips] = dp[wall-1][skips-1]
11
            12
            strength = wall_strengths[wall-1] + skips
13
            dp[wall][skips] = min(dp[wall][skips], dp[wall-1][skips] + strength)
14
    15
    return min(dp[num_walls])
16
17
def process_cases():
18
    test_cases = int(input())
19
    results = []
20
    21
    for _ in range(test_cases):
22
        num_walls, max_skips = map(int, input().split())
23
        wall_strengths = list(map(int, input().split()))
24
        results.append(breach_effort(num_walls, max_skips, wall_strengths))
25
    26
    print(""\n"".join(map(str, results)))
27
28
process_cases()",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054168
1390054171,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054171
1390054165,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    int T;
10
    cin >> T;
11
    while(T--) {
12
        int n, k;
13
        cin >> n >> k;
14
        vector<long long> a(n);
15
        long long total = 0;
16
        for (int i = 0; i < n; i++) {
17
            cin >> a[i];
18
            total += a[i];
19
        }
20
        21
        // Build vector v[i] = a[i] + i + 1
22
        vector<long long> v(n);
23
        for (int i = 0; i < n; i++) {
24
            v[i] = a[i] + i + 1;
25
        }
26
        27
        // Sort v in descending order
28
        sort(v.begin(), v.end(), greater<long long>());
29
        30
        // Precompute prefix sums of v (for the best s indices to skip)
31
        vector<long long> prefix(n+1, 0);
32
        for (int i = 0; i < n; i++) {
33
            prefix[i+1] = prefix[i] + v[i];
34
        }
35
        36
        long long ans = total; // s=0: no skip
37
        // Try s=1 to k (s = number of skipped firewalls)
38
        for (int s = 1; s <= k; s++) {
39
            // Cost = total + s*n - (s*(s-1))/2 - (sum of top s values)
40
            long long cost = total + (long long)s * n - ((long long)s * (s - 1)) / 2 - prefix[s];
41
            ans = min(ans, cost);
42
        }
43
        cout << ans << endl;
44
    }
45
    return 0;
46
}
47",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054165
1390054166,unknown,unknown,unknown,"1
def min_server_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for s in test_cases:
5
        # Find the first and last occurrence of '1'
6
        first_one = s.find('1')
7
        last_one = s.rfind('1')
8
        9
        # If there are no active servers, cost is 0
10
        if first_one == -1:
11
            results.append(0)
12
            continue
13
        14
        # Trim the string from first '1' to last '1'
15
        trimmed = s[first_one:last_one + 1]
16
        17
        # Count remaining '0's in the trimmed string
18
        idle_servers_remaining = trimmed.count('0')
19
        20
        # Count removed '1's (total '1's - '1's in the trimmed portion)
21
        active_servers_removed = s.count('1') - trimmed.count('1')
22
        23
        # The final cost is the maximum of both values
24
        results.append(max(idle_servers_remaining, active_servers_removed))
25
    26
    # Print all results for each test case
27
    print(""\n"".join(map(str, results)))
28
29
# Read input
30
T = int(input().strip())
31
test_cases = [input().strip() for _ in range(T)]
32
33
# Run function
34
min_server_decommissioning_cost(test_cases)
35",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054166
1390054167,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
    total_effort = sum(strengths)
3
    4
    if k == n:
5
        return 0
6
    7
    min_effort = total_effort
8
    9
    for i in range(n):
10
        skipped = 0
11
        new_effort = 0
12
        13
        for j in range(n):
14
            if j == i and skipped < k:
15
                skipped += 1
16
                continue
17
            new_effort += strengths[j] + skipped
18
        19
        min_effort = min(min_effort, new_effort)
20
    21
    return min_effort
22
23
T = int(input())
24
for _ in range(T):
25
    n, k = map(int, input().split())
26
    strengths = list(map(int, input().split()))
27
    print(min_effort(n, k, strengths))",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054167
1390054163,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
    min_effort = float('inf')
3
4
    for skip_mask in range(1 << n):
5
        if bin(skip_mask).count('1') != k:
6
            continue
7
        8
        effort = 0
9
        increased_strengths = strengths[:]
10
        for i in range(n):
11
            if skip_mask & (1 << i):
12
                for j in range(i + 1, n):
13
                    increased_strengths[j] += 1
14
            else:
15
                effort += increased_strengths[i]
16
        17
        min_effort = min(min_effort, effort)
18
19
    return min_effort
20
21
t = int(input().strip())
22
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
26
    strengths = list(map(int, input().split()))
27
28
    print(min_effort(n, k, strengths))
29",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054163
1390054156,unknown,unknown,unknown,"1
# Read number of test cases
2
t = int(input().strip())
3
4
for _ in range(t):
5
    # Read server string
6
    servers = input().strip()
7
    n = len(servers)
8
    9
    # Precompute prefix sums
10
    prefix_active = [0] * (n + 1)
11
    prefix_idle = [0] * (n + 1)
12
    13
    for i in range(n):
14
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
15
        prefix_idle[i + 1] = prefix_idle[i] + (1 if servers[i] == '0' else 0)
16
    17
    total_active = prefix_active[n]
18
    total_idle = prefix_idle[n]
19
    20
    min_cost = float('inf')
21
    22
    # Key insight: For each left position, there exists at most one optimal right position
23
    for left in range(n + 1):
24
        active_removed_left = prefix_active[left]
25
        26
        # For each left boundary, the right boundary should be as far right as possible
27
        # while keeping the idle_remaining below or equal to active_removed_total
28
        right = n
29
        while right >= left:
30
            active_removed_right = total_active - prefix_active[right]
31
            active_removed_total = active_removed_left + active_removed_right
32
            idle_remaining = prefix_idle[right] - prefix_idle[left]
33
            34
            # Check if this is a better solution
35
            cost = max(idle_remaining, active_removed_total)
36
            min_cost = min(min_cost, cost)
37
            38
            # If removing more from right would reduce cost, try next position
39
            if idle_remaining > active_removed_total:
40
                right -= 1
41
            else:
42
                # We've found the optimal right boundary for this left boundary
43
                break
44
    45
    print(min_cost)",96,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054156
1390054147,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of this window
18
        if dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
        21
        # Add new element if it's negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store result for the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Reading input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    36
    print(*earliest_faulty_readings(arr, k))",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054147
1390054152,unknown,unknown,unknown,"1
def find_earliest_fault(arr, k):
2
3
    result = []
4
5
    for i in range(len(arr) - k + 1):
6
7
        batch = arr[i:i+k]
8
9
        fault = 0
10
11
        for num in batch:
12
13
            if num < 0:
14
15
                fault = num
16
17
                break
18
19
        result.append(fault)
20
21
    return result
22
23
t = int(input())
24
25
for _ in range(t):
26
27
    n, k = map(int, input().split())
28
29
    arr = list(map(int, input().split()))
30
31
    output = find_earliest_fault(arr, k)
32
33
    print(' '.join(map(str, output)))",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054152
1390054155,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    """"""
3
    Calculates the minimum effort needed to breach a network of firewalls.
4
5
    Args:
6
        n: The number of firewalls.
7
        k: The number of firewalls that can be skipped.
8
        firewalls: A list of integers representing the strength of each firewall.
9
10
    Returns:
11
        The minimum effort needed to breach the network.
12
    """"""
13
14
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
15
    dp[0][0] = 0
16
17
    for i in range(1, n + 1):
18
        for j in range(k + 1):
19
            # Don't skip the current firewall
20
            if j == 0:
21
                dp[i][j] = dp[i - 1][j] + firewalls[i - 1]
22
            else:
23
                # Calculate increased strength due to previous skips
24
                increased_strength = 0
25
                for skip in range(1, j + 1):
26
                    if i - skip - 1 >= 0:
27
                        increased_strength += 1
28
                dp[i][j] = min(dp[i - 1][j] + firewalls[i - 1] + increased_strength, dp[i - 1][j - 1])
29
30
    return dp[n][k]
31
32
# Example Usage (from Sample Input)
33
T = int(input())
34
for _ in range(T):
35
    n, k = map(int, input().split())
36
    firewalls = list(map(int, input().split()))
37
    print(min_effort(n, k, firewalls))
38
39",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054155
1390054142,unknown,unknown,unknown,"1
import sys
2
3
def process_data(input_data):
4
    lines = input_data.strip().split(""\n"")
5
    t = int(lines[0])
6
    index = 1
7
    output = []
8
    9
    for _ in range(t):
10
        n, k = map(int, lines[index].split())
11
        arr = list(map(int, lines[index + 1].split()))
12
        index += 2  # Move to next test case
13
        14
        res = []
15
        16
        for i in range(n - k + 1):
17
            batch = arr[i:i+k]
18
            faulty = next((val for val in batch if val < 0), 0)
19
            res.append(faulty)
20
        21
        output.append("" "".join(map(str, res)))
22
    23
    print(""\n"".join(output))
24
25
if __name__ == ""__main__"":
26
    input_data = sys.stdin.read()
27
    process_data(input_data)
28",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054142
1390054143,unknown,unknown,unknown,"1
2
3
def min_effort(firewalls, k):
4
    n = len(firewalls)
5
    6
    if k >= n:
7
        return 0
8
    9
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
10
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
11
    12
    # Base case: when we've processed all firewalls
13
    for j in range(k + 1):
14
        dp[n][j] = 0
15
    16
    # Fill DP table from right to left
17
    for i in range(n - 1, -1, -1):
18
        for j in range(k + 1):
19
            # Option 2: Don't skip this firewall
20
            effort = firewalls[i] + j  # Current firewall + skips used before
21
            dp[i][j] = effort + dp[i + 1][j]  # Proceed without skipping
22
            23
            # Option 1: Skip this firewall (if skips remain)
24
            if j < k:
25
                dp[i][j] = min(dp[i][j], dp[i + 1][j + 1])
26
    27
    return dp[0][0]
28
29
# Handle automatic input
30
t = int(input())
31
for _ in range(t):
32
    n, k = map(int, input().split())
33
    firewalls = list(map(int, input().split()))
34
    result = min_effort(firewalls, k)
35
    print(result)
36
37",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054143
1390054144,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input().strip())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)
42",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054144
1390054138,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int t = sc.nextInt();
8
        sc.nextLine();
9
        while (t-- > 0) {
10
            String s = sc.nextLine();
11
            System.out.println(minCost(s));
12
        }
13
    }
14
15
    public static int minCost(String s) {
16
        int n = s.length();
17
        int totalOnes = 0, totalZeros = 0;
18
19
        for (int i = 0; i < n; i++) {
20
            if (s.charAt(i) == '1') totalOnes++;
21
            else totalZeros++;
22
        }
23
24
        int minCost = Integer.MAX_VALUE;
25
        int onesLeft = 0, zerosLeft = 0;
26
27
        for (int i = 0; i <= n; i++) {
28
            29
            int onesRemoved = onesLeft + (totalOnes - onesLeft); 
30
            int zerosRemaining = totalZeros - zerosLeft; 
31
32
            int cost = Math.max(zerosRemaining, onesRemoved);
33
            minCost = Math.min(minCost, cost);
34
35
        36
            if (i < n) {
37
                if (s.charAt(i) == '1') onesLeft++;
38
                else zerosLeft++;
39
            }
40
        }
41
42
        return minCost;
43
    }
44
}",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054138
1390054139,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner sc = new Scanner(System.in);
8
        int T = sc.nextInt(); 
9
        while (T-- > 0) {
10
            String s = sc.next(); 
11
            System.out.println(minDecommissionCost(s));
12
        }
13
        sc.close();
14
    }
15
16
    private static int minDecommissionCost(String s) {
17
        char[] chars = s.toCharArray();
18
        int n = chars.length;
19
        20
        int totalOnes = 0;
21
        for (char c : chars) {
22
            if (c == '1') totalOnes++;
23
        }
24
        25
        int minCost = totalOnes; 
26
        int zerosInSegment = 0;
27
        int onesInSegment = 0;
28
        29
        for (int start = 0; start < n; start++) {
30
            zerosInSegment = 0;
31
            onesInSegment = 0;
32
            for (int end = start; end < n; end++) {
33
                if (chars[end] == '0') {
34
                    zerosInSegment++;
35
                } else {
36
                    onesInSegment++;
37
                }
38
                int onesRemoved = totalOnes - onesInSegment;
39
                int cost = Math.max(zerosInSegment, onesRemoved);
40
                minCost = Math.min(minCost, cost);
41
            }
42
        }
43
        44
        return minCost;
45
    }
46
}",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054139
1390054140,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054140
1390054136,unknown,unknown,unknown,"1
#include <stdio.h>
2
3
#include <stdlib.h>
4
5
void findEarliestFaultyReadings(int *arr, int n, int k) {
6
7
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
8
9
    int front = 0, rear = 0;
10
11
    int queue[n];
12
13
    14
15
    // Process the first window
16
17
    for (int i = 0; i < k; i++) {
18
19
        if (arr[i] < 0) {
20
21
            queue[rear++] = i;
22
23
        }
24
25
    }
26
27
    28
29
    // Store result for the first batch
30
31
    result[0] = (front < rear) ? arr[queue[front]] : 0;
32
33
    34
35
    // Process the remaining windows
36
37
    for (int i = k; i < n; i++) {
38
39
        // Remove elements not within the window
40
41
        while (front < rear && queue[front] <= i - k) {
42
43
            front++;
44
45
        }
46
47
        48
49
        // Add new element if it's faulty
50
51
        if (arr[i] < 0) {
52
53
            queue[rear++] = i;
54
55
        }
56
57
        58
59
        // Store result for current batch
60
61
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
62
63
    }
64
65
    66
67
    // Print the result
68
69
    for (int i = 0; i < n - k + 1; i++) {
70
71
        printf(""%d "", result[i]);
72
73
    }
74
75
    printf(""\n"");
76
77
    78
79
    free(result);
80
81
}
82
83
int main() {
84
85
    int t;
86
87
    scanf(""%d"", &t);
88
89
    90
91
    while (t--) {
92
93
        int n, k;
94
95
        scanf(""%d %d"", &n, &k);
96
97
        int arr[n];
98
99
        100
101
        for (int i = 0; i < n; i++) {
102
103
            scanf(""%d"", &arr[i]);
104
105
        }
106
107
        108
109
        findEarliestFaultyReadings(arr, n, k);
110
111
    }
112
113
    114
115
    return 0;
116
117
}
118
119
120
121
122
123
124
125
126",97,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054136
1390054133,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054133
1390054135,unknown,unknown,unknown,"1
def find_earliest_faults(arr, k):
2
    """"""
3
    Finds the earliest faulty reading for each consecutive batch of size k.
4
5
    Args:
6
        arr: A list of sensor readings (integers).
7
        k: The batch size.
8
9
    Returns:
10
        A list of earliest faulty readings for each batch.
11
    """"""
12
    result = []
13
    for i in range(len(arr) - k + 1):
14
        batch = arr[i:i + k]
15
        earliest_fault = 0
16
        for j, reading in enumerate(batch):
17
            if reading < 0:
18
                earliest_fault = reading
19
                break
20
        result.append(earliest_fault)
21
    return result
22
23
def solve():
24
    t = int(input())
25
    for _ in range(t):
26
        n, k = map(int, input().split())
27
        arr = list(map(int, input().split()))
28
        result = find_earliest_faults(arr, k)
29
        print(*result)
30
31
solve()",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054135
1390054134,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    """"""
3
    Calculate minimum effort to breach n firewalls with optimal strategy.
4
    5
    Args:
6
        n: Number of firewalls
7
        k: Maximum number of firewalls that can be skipped
8
        firewalls: List of firewall strengths
9
        10
    Returns:
11
        Minimum effort required
12
    """"""
13
    # If we can skip all firewalls, return 0
14
    if k >= n:
15
        return 0
16
    17
    # Initialize dp array with infinity
18
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
19
    20
    # Base case: no firewalls, no effort
21
    dp[0][0] = 0
22
    23
    for i in range(1, n + 1):
24
        firewall_idx = i - 1  # Convert to 0-indexed
25
        26
        for j in range(k + 1):
27
            # Option 1: Don't skip the current firewall
28
            if j <= i - 1:  # Ensure we have processed enough firewalls
29
                dp[i][j] = min(dp[i][j], dp[i-1][j] + firewalls[firewall_idx] + j)
30
            31
            # Option 2: Skip the current firewall
32
            if j > 0:  # We must have at least one skip available
33
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
34
    35
    # Return the minimum effort after processing all firewalls
36
    return dp[n][k]
37
38
def main():
39
    t = int(input())  # Number of test cases
40
    41
    for _ in range(t):
42
        n, k = map(int, input().split())
43
        firewalls = list(map(int, input().split()))
44
        45
        min_effort = min_effort_to_breach(n, k, firewalls)
46
        print(min_effort)
47
48
if __name__ == ""__main__"":
49
    main()",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054134
1390054129,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054129
1390054130,unknown,unknown,unknown,"1
t = int(input())
2
3
for _ in range(t):
4
    n, k = map(int, input().split())
5
    arr = list(map(int, input().split()))
6
    7
    result = []
8
    9
    for i in range(n - k + 1):
10
        batch = arr[i:i + k]
11
        first_faulty = 0  
12
        13
        for num in batch:
14
            if num < 0:
15
                first_faulty = num
16
                break  
17
        18
        result.append(first_faulty)
19
    20
    print(*result)
21
22",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054130
1390054132,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, arr = case
5
        result = []
6
        for i in range(n - k + 1):
7
            batch = arr[i:i+k]
8
            earliest_fault = 0
9
            for num in batch:
10
                if num < 0:
11
                    earliest_fault = num
12
                    break
13
            result.append(earliest_fault)
14
        results.append(result)
15
    return results
16
17
# Read input
18
t = int(input())
19
test_cases = []
20
for _ in range(t):
21
    n, k = map(int, input().split())
22
    arr = list(map(int, input().split()))
23
    test_cases.append((n, k, arr))
24
25
# Compute results
26
results = earliest_faulty_readings(test_cases)
27
28
# Output results
29
for result in results:
30
    print(' '.join(map(str, result)) + ' ')",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054132
1390054124,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n, k = test_cases[t][0]  # Read n and k
6
        firewalls = test_cases[t][1]  # Read firewall strengths
7
        8
        # Sort indices of firewalls by their strength in descending order
9
        sorted_indices = sorted(range(n), key=lambda i: -firewalls[i])
10
11
        # Store indices of the `k` firewalls to skip
12
        skipped = set(sorted_indices[:k])
13
14
        total_effort = 0
15
        increment = 0  # This keeps track of the number of skipped firewalls before each one
16
        17
        for i in range(n):
18
            if i in skipped:
19
                increment += 1  # Each skip increases later firewalls' strength
20
            else:
21
                total_effort += firewalls[i] + increment  # Add effort with increments
22
        23
        results.append(total_effort)
24
    25
    return results
26
27
28
# Reading input
29
T = int(input().strip())  
30
test_cases = []
31
32
for _ in range(T):
33
    n, k = map(int, input().strip().split())  
34
    firewalls = list(map(int, input().strip().split()))  
35
    test_cases.append(((n, k), firewalls))
36
37
# Get results
38
output = min_effort_to_breach(T, test_cases)
39
40
# Print results
41
for res in output:
42
    print(res)
43",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054124
1390054127,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054127
1390054128,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
    8
    # Process the first batch of size k
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
13
    # Process remaining batches
14
    for i in range(n - k + 1):
15
        # Append earliest faulty reading or 0 if none
16
        result.append(arr[dq[0]] if dq else 0)
17
        18
        # Remove elements that are out of this window
19
        if dq and dq[0] == i:
20
            dq.popleft()
21
            printvtdr",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054128
1390054123,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",98,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054123
1390054116,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        # Identify the first and last active server (1)
6
        first_active = servers.find('1')
7
        last_active = servers.rfind('1')
8
        9
        # If there are no active servers, the cost is 0
10
        if first_active == -1:
11
            results.append(0)
12
            continue
13
        14
        # Extract the relevant segment of servers
15
        trimmed_servers = servers[first_active:last_active + 1]
16
        17
        # Count idle servers (0's) that remain
18
        idle_remaining = trimmed_servers.count('0')
19
        20
        # Count active servers (1's) that need to be removed
21
        active_removed = servers[:first_active].count('1') + servers[last_active + 1:].count('1')
22
        23
        # Compute the cost
24
        cost = max(idle_remaining, active_removed)
25
        results.append(str(cost))
26
    27
    return results
28
29
# Read input
30
T = int(input().strip())
31
test_cases = [input().strip() for _ in range(T)]
32
33
# Compute and print results
34
print(""\n"".join(min_decommissioning_cost(test_cases)))
35",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054116
1390054118,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        benefits = []
12
        for i in range(n):
13
            benefit = a[i] - (n - i - 1)
14
            benefits.append((benefit, i))
15
        16
        benefits.sort(reverse=True)
17
18
        skipped = [False] * n
19
20
        for i in range(k):
21
            _, idx = benefits[i]
22
            skipped[idx] = True
23
24
        total_effort = 0
25
        penalty = 0 
26
        for i in range(n):
27
            if skipped[i]:
28
                penalty += 1
29
            else:
30
                total_effort += a[i] + penalty
31
32
        print(total_effort)
33
34
threading.Thread(target=main).start()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054118
1390054120,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
3
    # Edge case: if we can skip all firewalls
4
    if k >= n:
5
        return 0
6
        7
    # We need to find the optimal firewalls to skip
8
    # This is a combinatorial problem
9
    10
    # First, let's calculate the impact of skipping each firewall
11
    # Impact = firewall's strength - penalty to subsequent firewalls
12
    impacts = []
13
    14
    for i in range(n):
15
        # If we skip this firewall, we save its strength
16
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
17
        impact = strengths[i] - (n - i - 1)
18
        impacts.append((impact, i))
19
    20
    # Sort by impact in descending order
21
    impacts.sort(reverse=True)
22
    23
    # Select the k firewalls with the highest impact to skip
24
    to_skip = set(impacts[i][1] for i in range(k))
25
    26
    # Calculate the total effort
27
    total_effort = 0
28
    penalty = 0
29
    30
    for i in range(n):
31
        if i in to_skip:
32
            # Skip this firewall
33
            penalty += 1
34
        else:
35
            # Breach this firewall (with penalty applied)
36
            total_effort += strengths[i] + penalty
37
    38
    return total_effort
39
40
def solve_test_cases():
41
    42
    t = int(input())  # Number of test cases
43
    results = []
44
    45
    for _ in range(t):
46
        n, k = map(int, input().split())
47
        strengths = list(map(int, input().split()))
48
        results.append(min_effort_to_breach(n, k, strengths))
49
    50
    return results
51
52
# Main function to run the solution
53
def main():
54
    results = solve_test_cases()
55
    56
    # Print the results
57
    for result in results:
58
        print(result)
59
60
if _name_ == ""_main_"":
61
    main()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054120
1390054110,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FirewallBreach {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int T = scanner.nextInt();
7
8
        while (T-- > 0) {
9
            int n = scanner.nextInt();
10
            int k = scanner.nextInt();
11
            int[] a = new int[n];
12
13
            for (int i = 0; i < n; i++) {
14
                a[i] = scanner.nextInt();
15
            }
16
17
            if (k >= n) {
18
                System.out.println(0);
19
                continue;
20
            }
21
22
            long totalEffort = 0;
23
            for (int value : a) {
24
                totalEffort += value;
25
            }
26
27
            if (k == 0) {
28
                System.out.println(totalEffort);
29
                continue;
30
            }
31
32
            long[] netReduction = new long[n];
33
            for (int i = 0; i < n; i++) {
34
                netReduction[i] = a[i] - (n - i - 1);
35
            }
36
37
            Arrays.sort(netReduction);
38
39
            long maxReduction = 0;
40
            for (int i = 0; i < k; i++) {
41
                maxReduction += netReduction[n - 1 - i];
42
            }
43
44
            long minEffort = totalEffort - maxReduction;
45
            System.out.println(minEffort);
46
        }
47
48
        scanner.close();
49
    }
50
}
51",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054110
1390054111,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class DataCenterOptimization {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = Integer.parseInt(sc.nextLine());
7
        while (T-- > 0) {
8
            String s = sc.nextLine();
9
            int n = s.length();
10
11
            int totalActive = 0, totalIdle = 0;
12
            for (char c : s.toCharArray()) {
13
                if (c == '1') totalActive++;
14
                else totalIdle++;
15
            }
16
17
            int[] prefixActive = new int[n + 1];
18
            int[] prefixIdle = new int[n + 1];
19
            for (int i = 0; i < n; i++) {
20
                prefixActive[i + 1] = prefixActive[i] + (s.charAt(i) == '1' ? 1 : 0);
21
                prefixIdle[i + 1] = prefixIdle[i] + (s.charAt(i) == '0' ? 1 : 0);
22
            }
23
24
            int minCost = Integer.MAX_VALUE;
25
26
            // Try all possible (l, r) subarrays to keep
27
            for (int l = 0; l <= n; l++) {
28
                for (int r = l; r <= n; r++) {
29
                    int idleLeft = prefixIdle[r] - prefixIdle[l];
30
                    int activeRemoved = prefixActive[l] + (totalActive - prefixActive[r]);
31
                    int cost = Math.max(idleLeft, activeRemoved);
32
                    minCost = Math.min(minCost, cost);
33
                }
34
            }
35
36
            System.out.println(minCost);
37
        }
38
        sc.close();
39
    }
40
}
41",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054111
1390054114,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if _name_ == ""_main_"":
73
    main()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054114
1390054101,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    skipped_indices = set()
6
    remaining_indices = set(range(n))
7
    current_effort = sum(a)
8
    min_effort = current_effort
9
10
    for _ in range(k):
11
        best_skip_index = -1
12
        max_benefit = -float('inf')
13
14
        for i in list(remaining_indices):
15
            benefit = a[i]
16
            increase = 0
17
            for j in remaining_indices:
18
                if j > i:
19
                    increase += 1
20
            current_benefit = benefit - increase
21
            if current_benefit > max_benefit:
22
                max_benefit = current_benefit
23
                best_skip_index = i
24
25
        if best_skip_index != -1 and max_benefit > 0:
26
            skipped_indices.add(best_skip_index)
27
            remaining_indices.remove(best_skip_index)
28
            current_effort -= max_benefit
29
            min_effort = min(min_effort, current_effort)
30
        else:
31
            break
32
33
    final_effort = 0
34
    skipped_list = sorted(list(skipped_indices))
35
    for i in range(n):
36
        if i not in skipped_indices:
37
            strength_increase = 0
38
            for skipped_index in skipped_list:
39
                if skipped_index < i:
40
                    strength_increase += 1
41
            final_effort += a[i] + strength_increase
42
    min_effort = min(min_effort, final_effort)
43
44
    print(min_effort)
45
46
47
t = int(input())
48
for _ in range(t):
49
    solve()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054101
1390054104,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx+1])
10
        idx +=2
11
        a = list(map(int, input[idx:idx+n]))
12
        idx +=n
13
        sum_a = sum(a)
14
        v = []
15
        for i in range(n):
16
            val = a[i] - (n - i -1)
17
            v.append(val)
18
        v.sort(reverse=True)
19
        prefix = [0] * (n+1)
20
        for i in range(n):
21
            prefix[i+1] = prefix[i] + v[i]
22
        max_sum = 0
23
        max_t = min(k, n)
24
        for t in range(0, max_t+1):
25
            current = prefix[t] + t*(t-1)//2
26
            if current > max_sum:
27
                max_sum = current
28
        print(sum_a - max_sum)
29
30
if __name__ == ""__main__"":
31
    main()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054104
1390054106,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054106
1390054100,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",99,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054100
1390054094,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054094
1390054099,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, arr = case
5
        batch_results = []
6
        for i in range(n - k + 1):
7
            # Extract the current batch
8
            batch = arr[i:i + k]
9
            # Find the first negative number in the batch
10
            earliest_fault = 0
11
            for num in batch:
12
                if num < 0:
13
                    earliest_fault = num
14
                    break
15
            batch_results.append(earliest_fault)
16
        results.append(batch_results)
17
    return results
18
19
# Input reading
20
def main():
21
    import sys
22
    input = sys.stdin.read
23
    data = input().split()
24
    idx = 0
25
    t = int(data[idx])  # Number of test cases
26
    idx += 1
27
    test_cases = []
28
    for _ in range(t):
29
        n = int(data[idx])  # Size of the array
30
        k = int(data[idx + 1])  # Batch size
31
        idx += 2
32
        arr = list(map(int, data[idx:idx + n]))  # Array of sensor readings
33
        idx += n
34
        test_cases.append((n, k, arr))
35
    36
    # Compute results
37
    results = earliest_faulty_readings(test_cases)
38
    39
    # Output results
40
    for result in results:
41
        print("" "".join(map(str, result)))
42
43
if __name__ == ""__main__"":
44
    main()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054099
1390054095,unknown,unknown,unknown,"1
def solve():
2
3
    s = input()
4
5
    n = len(s)
6
7
    min_cost = float('inf')
8
9
    # Iterate from left
10
11
    left_ones = 0
12
13
    for i in range(n + 1):
14
15
        remaining = s[i:]
16
17
        idle_count = remaining.count('0')
18
19
        min_cost = min(min_cost, max(idle_count, left_ones))
20
21
        if i < n and s[i] == '1':
22
23
            left_ones += 1
24
25
    # Iterate from right
26
27
    right_ones = 0
28
29
    for i in range(n, -1, -1):
30
31
        remaining = s[:i]
32
33
        idle_count = remaining.count('0')
34
35
        min_cost = min(min_cost, max(idle_count, right_ones))
36
37
        if i > 0 and s[i - 1] == '1':
38
39
            right_ones += 1
40
41
    #Combine Iterations
42
43
    for i in range(n+1):
44
45
      left_ones = s[:i].count('1')
46
47
      right_ones = s[n:].count('1')
48
49
      remaining = s[i:]
50
51
      for j in range(len(remaining)+1):
52
53
        remaining_sub = remaining[:len(remaining)-j]
54
55
        right_ones = s[n-j:].count('1')
56
57
        idle_count = remaining_sub.count('0')
58
59
        min_cost = min(min_cost, max(idle_count, left_ones+right_ones))
60
61
    print(min_cost)
62
63
t = int(input())
64
65
for _ in range(t):
66
67
    solve()
68
69",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054095
1390054091,unknown,unknown,unknown,"1
def min_decommission_cost(rack):
2
    n = len(rack)
3
    4
    # Initialize minimum cost to a high value
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing from start and end
8
    for start in range(n + 1):
9
        for end in range(n + 1):
10
            # Skip invalid configurations
11
            if start + end > n:
12
                continue
13
            14
            # Calculate the remaining rack after decommissioning
15
            remaining = rack[start:n-end]
16
            17
            if not remaining:
18
                # If we removed everything, cost is just removed active servers
19
                removed_active = rack[:start].count('1') + rack[n-end:].count('1')
20
                cost = removed_active
21
            else:
22
                # Calculate remaining idle servers
23
                remaining_idle = remaining.count('0')
24
                25
                # Calculate decommissioned active servers
26
                removed_active = rack[:start].count('1') + rack[n-end:].count('1')
27
                28
                # Cost is the maximum of the two
29
                cost = max(remaining_idle, removed_active)
30
            31
            # Update minimum cost
32
            min_cost = min(min_cost, cost)
33
    34
    return min_cost
35
36
def main():
37
    t = int(input().strip())
38
    39
    for _ in range(t):
40
        rack = input().strip()
41
        result = min_decommission_cost(rack)
42
        print(result)
43
44
if __name__ == ""__main__"":
45
    main()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054091
1390054090,unknown,unknown,unknown,"1
def find_earliest_fault(arr, k):
2
    result = []
3
    4
    for i in range(len(arr) - k + 1):  # Iterate through all possible windows
5
        found = False
6
        7
        # Scan the window to find the first negative number
8
        for j in range(i, i + k):
9
            if arr[j] < 0:
10
                result.append(arr[j])
11
                found = True
12
                break  # Stop when the first negative number is found
13
        14
        if not found:
15
            result.append(0)  # If no negative number is found, add 0
16
    17
    return result
18
19
# Input handling
20
t = int(input())  # Number of test cases
21
for _ in range(t):
22
    n, k = map(int, input().split())  # Size of array and batch size
23
    arr = list(map(int, input().split()))  # Array elements
24
25
    result = find_earliest_fault(arr, k)
26
    print(*result)
27
28
    ",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054090
1390054088,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void findEarliestFaultyReadings(int *arr, int n, int k) {
5
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
6
    int front = 0, rear = 0;
7
    int queue[n];
8
    9
    // Process the first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) {
12
            queue[rear++] = i;
13
        }
14
    }
15
    16
    // Store result for the first batch
17
    result[0] = (front < rear) ? arr[queue[front]] : 0;
18
    19
    // Process the remaining windows
20
    for (int i = k; i < n; i++) {
21
        // Remove elements not within the window
22
        while (front < rear && queue[front] <= i - k) {
23
            front++;
24
        }
25
        26
        // Add new element if it's faulty
27
        if (arr[i] < 0) {
28
            queue[rear++] = i;
29
        }
30
        31
        // Store result for current batch
32
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
33
    }
34
    35
    // Print the result
36
    for (int i = 0; i < n - k + 1; i++) {
37
        printf(""%d "", result[i]);
38
    }
39
    printf(""\n"");
40
    41
    free(result);
42
}
43
44
int main() {
45
    int t;
46
    scanf(""%d"", &t);
47
    48
    while (t--) {
49
        int n, k;
50
        scanf(""%d %d"", &n, &k);
51
        int arr[n];
52
        53
        for (int i = 0; i < n; i++) {
54
            scanf(""%d"", &arr[i]);
55
        }
56
        57
        findEarliestFaultyReadings(arr, n, k);
58
    }
59
    60
    return 0;
61
}",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054088
1390054087,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054087
1390054089,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if _name_ == ""_main_"":
73
    main()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054089
1390054085,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx + 1])
10
        idx += 2
11
        a = list(map(int, input[idx:idx + n]))
12
        idx += n
13
        14
        sum_S = sum(a)
15
     16
        values = [a[i] + i for i in range(n)]
17
   18
        values.sort(reverse=True)
19
        sum_aj_plus_j = sum(values[:k])
20
       21
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
22
        print(res)
23
24
main()",100,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054085
1390054082,unknown,unknown,unknown,"1
import java.io.BufferedReader;
2
import java.io.IOException;
3
import java.io.InputStreamReader;
4
5
public class ServerPruning {
6
    public static int minPruningCost(String serverRack) {
7
        int n = serverRack.length();
8
        int left = 0, right = n - 1;
9
10
        // Remove leading idle servers (0s)
11
        while (left <= right && serverRack.charAt(left) == '0') {
12
            left++;
13
        }
14
15
        // Remove trailing idle servers (0s)
16
        while (right >= left && serverRack.charAt(right) == '0') {
17
            right--;
18
        }
19
20
        // If no active servers remain
21
        if (left > right) return 0;
22
23
        // Count remaining idle servers
24
        int idleCount = 0;
25
        for (int i = left; i <= right; i++) {
26
            if (serverRack.charAt(i) == '0') {
27
                idleCount++;
28
            }
29
        }
30
31
        // Active servers removed
32
        int activeRemoved = left + (n - 1 - right);
33
34
        return Math.max(idleCount, activeRemoved);
35
    }
36
37
    public static void main(String[] args) throws IOException {
38
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
39
        int T = Integer.parseInt(br.readLine().trim());
40
        StringBuilder output = new StringBuilder();
41
42
        while (T-- > 0) {
43
            String serverRack = br.readLine().trim();
44
            output.append(minPruningCost(serverRack)).append(""\n"");
45
        }
46
47
        System.out.print(output);
48
    }
49
}
50",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054082
1390054083,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Process the rest of the array
13
    for i in range(len(arr) - k + 1):
14
        # Append the earliest faulty reading
15
        if dq:
16
            result.append(arr[dq[0]])
17
        else:
18
            result.append(0)
19
        20
        # Remove elements that are out of this window
21
        if dq and dq[0] == i:
22
            dq.popleft()
23
        24
        # Add the next element if it is faulty
25
        if i + k < len(arr) and arr[i + k] < 0:
26
            dq.append(i + k)
27
    28
    return result
29
30
def process_test_cases(test_cases):
31
    results = []
32
    for n, k, arr in test_cases:
33
        results.append("" "".join(map(str, earliest_faults(arr, k))))
34
    return ""\n"".join(results)
35
36
# Example test cases for debugging
37
test_cases = [
38
    (5, 2, [-8, 2, 3, -6, 10]),
39
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
40
]
41
42
# Running test cases
43
print(process_test_cases(test_cases))
44",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054083
1390054084,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total active servers and total idle servers
5
    total_active = server_string.count('1')
6
    total_idle = n - total_active
7
    8
    # Precompute cumulative counts of active servers from left
9
    active_prefix_sum = [0] * (n + 1)
10
    for i in range(n):
11
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
12
    13
    min_cost = float('inf')
14
    15
    # Try all possible starting positions for the remaining servers
16
    for left in range(n + 1):
17
        # For each possible ending position
18
        for right in range(left, n + 1):
19
            # Active servers in the remaining segment
20
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
21
            idle_remaining = (right - left) - active_remaining
22
            23
            # Active servers removed
24
            active_removed = total_active - active_remaining
25
            26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
def faster_min_decommission_cost(server_string):
32
    n = len(server_string)
33
    34
    # Precompute prefix sums for active and idle servers
35
    active_prefix = [0] * (n + 1)
36
    idle_prefix = [0] * (n + 1)
37
    38
    for i in range(n):
39
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
40
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
41
    42
    min_cost = n  # Worst case cost
43
    44
    # For each possible remaining substring (from i to j-1)
45
    for i in range(n + 1):
46
        for j in range(i, n + 1):
47
            # Idle servers in remaining substring
48
            idle_remaining = idle_prefix[j] - idle_prefix[i]
49
            50
            # Active servers removed (from left and right)
51
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
52
            53
            cost = max(idle_remaining, active_removed)
54
            min_cost = min(min_cost, cost)
55
    56
    return min_cost
57
58
def main():
59
    t = int(input().strip())
60
    61
    for _ in range(t):
62
        server_string = input().strip()
63
        result = faster_min_decommission_cost(server_string)
64
        print(result)
65
66
if __name__ == ""__main__"":
67
    main()",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054084
1390054078,unknown,unknown,unknown,"1
def min_cost(servers):
2
    n = len(servers)
3
    4
    # Remove leading and trailing 0s
5
    start, end = 0, n - 1
6
    while start < n and servers[start] == '0':
7
        start += 1
8
    while end >= 0 and servers[end] == '0':
9
        end -= 1
10
    11
    if start > end:  # If only 0s exist, no cost is needed
12
        return 0
13
14
    core = servers[start:end + 1]  # Core segment without leading/trailing 0s
15
    total_ones = core.count('1')
16
    total_zeros = core.count('0')
17
18
    min_cost = max(total_zeros, 0)  # Removing no 1s initially
19
20
    removed_ones = 0
21
    for ch in core:
22
        if ch == '1':
23
            removed_ones += 1
24
        else:
25
            total_zeros -= 1  # Decrease remaining 0s
26
27
        # Cost = max(remaining 0s, removed 1s)
28
        min_cost = min(min_cost, max(total_zeros, removed_ones))
29
30
    return min_cost
31
32
33
# Reading input
34
T = int(input())  # Number of test cases
35
for _ in range(T):
36
    servers = input().strip()
37
    print(min_cost(servers))
38",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054078
1390054080,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054080
1390054081,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054081
1390054075,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if _name_ == ""_main_"":
73
    main()",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054075
1390054076,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    result = []
3
    4
    for i in range(len(arr) - k + 1):
5
        # Check each batch of size k
6
        batch = arr[i:i+k]
7
        fault_found = False
8
        9
        # Find the earliest fault in the current batch
10
        for num in batch:
11
            if num < 0:
12
                result.append(num)
13
                fault_found = True
14
                break
15
        16
        # If no fault is found in the batch, append 0
17
        if not fault_found:
18
            result.append(0)
19
    20
    return result
21
22
# Process the input
23
t = int(input())  # Number of test cases
24
25
for _ in range(t):
26
    n, k = map(int, input().split())  # Array size and batch size
27
    arr = list(map(int, input().split()))  # Array elements
28
    29
    result = earliest_fault(arr, k)
30
    print(*result)  # Print the result",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054076
1390054077,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }
19
20
      21
        auto check = [&](int k) {
22
            int l = 0;
23
         24
            for (int r = 0; r < n; r++) {
25
              26
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
27
                    l++;
28
                }
29
                // wtf ,  check number of 1's decommissioned
30
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
31
                    return true;
32
                }
33
            }
34
      35
            if (prefix_1[n] <= k) {
36
                return true;
37
            }
38
            return false;
39
        };
40
41
        // Binary search for minimum cost
42
        int low = 0, high = n;
43
        while (low < high) {
44
            int mid = (low + high) / 2;
45
            if (check(mid)) {
46
                high = mid;
47
            } else {
48
                low = mid + 1;
49
            }
50
        }
51
        cout << low << endl;
52
    }
53
    return 0;
54
}",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054077
1390054074,unknown,unknown,unknown,"1
import java.util.*;
2
public class Main {
3
    public static void main(String[] args) {
4
        Scanner sc = new Scanner(System.in);
5
        int t = sc.nextInt();
6
        7
        while (t-- > 0) {
8
            int n = sc.nextInt(), k = sc.nextInt();
9
            int[] arr = new int[n];
10
            11
            for (int i = 0; i < n; i++) {
12
                arr[i] = sc.nextInt();
13
            }
14
            15
            System.out.println(minEffort(n, k, arr));
16
        }
17
        sc.close();
18
    }
19
    20
    static int minEffort(int n, int k, int[] arr) {
21
        int[][] dp = new int[n + 1][k + 1];
22
        23
        for (int i = n - 1; i >= 0; i--) {
24
            for (int skip = 0; skip <= k; skip++) {
25
                int take = arr[i] + skip;
26
                if (i + 1 < n) take += dp[i + 1][skip];
27
                28
                int leave = Integer.MAX_VALUE;
29
                if (skip < k && i + 1 <= n) leave = dp[i + 1][skip + 1];
30
                31
                dp[i][skip] = Math.min(take, leave);
32
            }
33
        }
34
        35
        return dp[0][0];
36
    }
37
}",101,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054074
1390054061,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
 3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    5
    for j in range(k + 1):
6
        dp[0][j] = 0
7
    8
    for i in range(1, n + 1):
9
        for j in range(k + 1):
10
            if j > 0:
11
                dp[i][j] = dp[i-1][j-1]
12
13
            current_strength = strengths[i-1] + j  
14
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
15
    16
17
    return min(dp[n])
18
19
def solve():
20
    t = int(input())
21
    results = []
22
    23
    for _ in range(t):
24
        n, k = map(int, input().split())
25
        strengths = list(map(int, input().split()))
26
        results.append(min_effort_to_breach(n, k, strengths))
27
    28
    for result in results:
29
        print(result)
30
31
solve()",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054061
1390054066,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
5
    int n = arr.size();
6
    vector<int> result;
7
    deque<int> dq;  // Stores indices of negative numbers
8
9
    // Process first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) dq.push_back(i);
12
    }
13
14
    // Process the sliding window
15
    for (int i = k; i <= n; i++) {
16
        // Append first negative number in the window
17
        if (!dq.empty()) 
18
            result.push_back(arr[dq.front()]);  // First negative in the deque
19
        else 
20
            result.push_back(0);  // No negative number
21
22
        // Remove elements that are out of the current window
23
        while (!dq.empty() && dq.front() < i - k + 1) {
24
            dq.pop_front();
25
        }
26
27
        // Add the next element if negative
28
        if (i < n && arr[i] < 0) {
29
            dq.push_back(i);
30
        }
31
    }
32
33
    return result;
34
}
35
36
int main() {
37
    int t;
38
    cin >> t;  // Number of test cases
39
    while (t--) {
40
        int n, k;
41
        cin >> n >> k;  // Size of array and batch size
42
        vector<int> arr(n);
43
        for (int i = 0; i < n; i++) {
44
            cin >> arr[i];
45
        }
46
        47
        vector<int> result = earliest_faulty_readings(arr, k);
48
        for (int num : result) {
49
            cout << num << "" "";
50
        }
51
        cout << endl;
52
    }
53
    return 0;
54
}
55",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054066
1390054071,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    """"""
3
    Calculate minimum effort to breach n firewalls with optimal strategy.
4
    5
    Args:
6
        n: Number of firewalls
7
        k: Maximum number of firewalls that can be skipped
8
        firewalls: List of firewall strengths
9
        10
    Returns:
11
        Minimum effort required
12
    """"""
13
    # If we can skip all firewalls, return 0
14
    if k >= n:
15
        return 0
16
    17
    # We'll use a more memory-efficient approach that avoids potential
18
    # runtime errors with large inputs
19
    20
    # For each firewall, calculate the ""gain"" from skipping it
21
    # Gain = firewall strength - penalty to subsequent firewalls
22
    gains = []
23
    for i in range(n):
24
        # Original cost of the firewall
25
        original_cost = firewalls[i]
26
        27
        # Penalty to subsequent firewalls if we skip this one
28
        penalty = n - i - 1
29
        30
        # Gain = what we save by skipping this firewall
31
        gain = original_cost - penalty
32
        33
        gains.append((gain, i))
34
    35
    # Sort by gain in descending order
36
    gains.sort(reverse=True)
37
    38
    # Mark the firewalls to skip (the k firewalls with highest gain)
39
    to_skip = set()
40
    for i in range(min(k, n)):
41
        if i < len(gains) and gains[i][0] > 0:  # Only skip if gain is positive
42
            to_skip.add(gains[i][1])
43
    44
    # Calculate the total effort
45
    skipped_so_far = 0
46
    total_effort = 0
47
    48
    for i in range(n):
49
        if i in to_skip:
50
            # Skip this firewall
51
            skipped_so_far += 1
52
        else:
53
            # Pay the cost of this firewall (including penalties)
54
            total_effort += firewalls[i] + skipped_so_far
55
    56
    return total_effort
57
58
def main():
59
    t = int(input())  # Number of test cases
60
    61
    for _ in range(t):
62
        n, k = map(int, input().split())
63
        firewalls = list(map(int, input().split()))
64
        65
        min_effort = min_effort_to_breach(n, k, firewalls)
66
        print(min_effort)
67
68
if __name__ == ""__main__"":
69
    main()",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054071
1390054054,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054054
1390054055,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
           18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
         24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
            30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k);
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
               36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                   41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054055
1390054058,unknown,unknown,unknown,"1
def min_decommission_cost(server_rack):
2
    n = len(server_rack)
3
    4
    5
    total_active = server_rack.count('1')
6
    7
    min_cost = float('inf')
8
    9
    10
    for prefix in range(n + 1):  
11
        for suffix in range(n + 1 - prefix):  # Servers to remove from end
12
            13
            remaining = server_rack[prefix:n-suffix]
14
            15
            if not remaining:  
16
                continue
17
            18
            19
            active_remaining = remaining.count('1')
20
            21
            22
            idle_remaining = len(remaining) - active_remaining
23
            24
            25
            active_removed = total_active - active_remaining
26
            27
            28
            cost = max(idle_remaining, active_removed)
29
            30
            31
            min_cost = min(min_cost, cost)
32
    33
    return min_cost
34
35
def solve_test_cases():
36
    t = int(input())  
37
    38
    for _ in range(t):
39
        server_rack = input().strip()
40
        print(min_decommission_cost(server_rack))
41
42
43
if __name__ == ""__main__"":
44
    test_cases = [
45
        ""101110110"",
46
        ""1001001001001"",
47
        ""0000111111""
48
    ]
49
    50
    for rack in test_cases:
51
        cost = min_decommission_cost(rack)
52
        print(cost)",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054058
1390054052,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
    5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    dp[0][0] = 0
7
    8
    for i in range(1, n + 1):
9
        for j in range(min(i, k) + 1):
10
            if j > 0:
11
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
12
            13
            if dp[i-1][j] != float('inf'):
14
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
15
    16
    return min(dp[n])
17
18
def solve():
19
    t = int(input().strip())
20
    results = []
21
    22
    for _ in range(t):
23
        n, k = map(int, input().strip().split())
24
        strengths = list(map(int, input().strip().split()))
25
        results.append(str(min_effort_to_breach(n, k, strengths)))
26
    27
    print(""\n"".join(results))
28
29
solve()",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054052
1390054053,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    s = input().strip()
4
    n = len(s)
5
6
    l, r = 0, n - 1
7
    while l < n and s[l] == ""0"":
8
        l += 1
9
    while r >= 0 and s[r] == ""0"":
10
        r -= 1
11
12
    if l > r:
13
        print(0)
14
        continue
15
16
    s = s[l:r + 1]
17
    n = len(s)
18
19
    ones = s.count(""1"")
20
    zeros = s.count(""0"")
21
    c = min(ones, zeros)
22
23
    x = 0
24
    for i in s:
25
        if i == ""1"":
26
            x += 1
27
        else:
28
            zeros -= 1
29
        c = min(c, max(x, zeros))
30
31
    print(c)
32",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054053
1390054051,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054051
1390054050,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
    total_effort = sum(strengths)
3
    4
    if k == n:
5
        return 0
6
    7
    min_effort = total_effort
8
    9
    for i in range(n):
10
        skipped = min(k, i + 1) 
11
        effort = sum(strengths[:i]) + sum(strengths[i + 1:]) + (n - i - 1) * skipped
12
        min_effort = min(min_effort, effort)
13
    14
    return min_effort
15
16
T = int(input())
17
for _ in range(T):
18
    n, k = map(int, input().split())
19
    strengths = list(map(int, input().split()))
20
    print(min_effort(n, k, strengths))",102,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054050
1390054045,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        # Identify the first and last active server (1)
6
        first_active = servers.find('1')
7
        last_active = servers.rfind('1')
8
        9
        # If there are no active servers, the cost is 0
10
        if first_active == -1:
11
            results.append(0)
12
            continue
13
        14
        # Extract the relevant segment of servers
15
        trimmed_servers = servers[first_active:last_active + 1]
16
        17
        # Count idle servers (0's) that remain
18
        idle_remaining = trimmed_servers.count('0')
19
        20
        # Count active servers (1's) that need to be removed
21
        active_removed = servers[:first_active].count('1') + servers[last_active + 1:].count('1')
22
        23
        # Compute the cost
24
        cost = max(idle_remaining, active_removed)
25
        results.append(cost)
26
    27
    return results
28
29
# Read input
30
T = int(input())
31
test_cases = [input().strip() for _ in range(T)]
32
33
# Compute and print results
34
for result in min_decommissioning_cost(test_cases):
35
    print(result)",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054045
1390054047,unknown,unknown,unknown,"1
def solve():
2
3
    s = input()
4
5
    n = len(s)
6
7
    min_cost = float('inf')
8
9
    for i in range(n + 1):
10
11
        remaining = s[i:]
12
13
        idle_count = remaining.count('0')
14
15
        active_removed = s[:i].count('1')
16
17
        min_cost = min(min_cost, max(idle_count, active_removed))
18
19
    for j in range(n + 1):
20
21
        remaining = s[:n-j]
22
23
        idle_count = remaining.count('0')
24
25
        active_removed = s[n-j:].count('1')
26
27
        min_cost = min(min_cost, max(idle_count, active_removed))
28
29
    for i in range(n+1):
30
31
        for j in range(n-i+1):
32
33
            remaining = s[i:n-j]
34
35
            idle_count = remaining.count('0')
36
37
            active_removed = s[:i].count('1') + s[n-j:].count('1')
38
39
            min_cost = min(min_cost, max(idle_count, active_removed))
40
41
    print(min_cost)
42
43
t = int(input())
44
45
for _ in range(t):
46
47
    solve()
48
49",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054047
1390054048,unknown,unknown,unknown,"1
cases = int(input())
2
for t in range(cases):
3
    n,k = [int(i) for i in input().split()]
4
    array = [int(i) for i in input().split()]
5
    if n == k:
6
        print(0)
7
        continue
8
    batch_sum = [0]*n
9
    for i in range(n):
10
        batch_sum[i] = sum(array[i:i+k])
11
    total = sum(array)
12
    best = total
13
    for i in range(n):
14
        best = min(best, total -batch_sum[i] + n-i-k)
15
    print(best)
16
        17
        18
    19
    20
    21
    22
    ",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054048
1390054039,unknown,unknown,unknown,"1
def min_cost_to_decommission(rack):
2
    length = len(rack)
3
    min_cost = float('inf')
4
    5
    for prefix in range(length + 1):
6
        for suffix in range(length + 1 - prefix):
7
            remaining = rack[prefix:length - suffix]
8
            9
            if not remaining:
10
                continue
11
            12
            idle_count = remaining.count('0')
13
            active_removed = rack[:prefix].count('1') + rack[length - suffix:].count('1')
14
            15
            cost = max(idle_count, active_removed)
16
            min_cost = min(min_cost, cost)
17
    18
    return min_cost
19
20
cases = int(input().strip())
21
results = []
22
23
for _ in range(cases):
24
    rack = input().strip()
25
    results.append(min_cost_to_decommission(rack))
26
27
print(""\n"".join(map(str, results)))
28",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054039
1390054042,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
7
        Scanner sc = new Scanner(System.in);
8
9
        int T = sc.nextInt();
10
11
        while (T-- > 0) {
12
13
            int n = sc.nextInt();
14
15
            int k = sc.nextInt();
16
17
            int[] a = new int[n];
18
19
            long sum_a = 0;
20
21
            for (int i = 0; i < n; i++) {
22
23
                a[i] = sc.nextInt();
24
25
                sum_a += a[i];
26
27
            }
28
29
            List<Long> values = new ArrayList<>();
30
31
            for (int i = 0; i < n; i++) {
32
33
                long val = a[i] - (n - i - 1L);
34
35
                values.add(val);
36
37
            }
38
39
            values.sort((x, y) -> Long.compare(y, x));
40
41
            long[] prefixSum = new long[n + 1];
42
43
            prefixSum[0] = 0;
44
45
            for (int i = 1; i <= n; i++) {
46
47
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
48
49
            }
50
51
            int max_m = Math.min(k, n);
52
53
            long maxTotal = Long.MIN_VALUE;
54
55
            for (int m = 0; m <= max_m; m++) {
56
57
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
58
59
                if (current > maxTotal) {
60
61
                    maxTotal = current;
62
63
                }
64
65
            }
66
67
            long minEffort = sum_a - maxTotal;
68
69
            System.out.println(minEffort);
70
71
        }
72
73
        sc.close();
74
75
    }
76
77
}",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054042
1390054044,unknown,unknown,unknown,"1
def minimum_pruning_cost(rack):
2
    n = len(rack)
3
    4
    prefix_active = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_active[i+1] = prefix_active[i] + (1 if rack[i] == '1' else 0)
7
    8
    min_cost = float('inf')
9
    10
    for left in range(n): 
11
        for right in range(n):  
12
            if left + right >= n:
13
                continue
14
            15
            if left == 0 and right == 0:
16
                continue
17
            18
            active_left = prefix_active[left]
19
            active_right = prefix_active[n] - prefix_active[n-right]
20
            active_decommissioned = active_left + active_right
21
            22
            remaining_start = left
23
            remaining_end = n - right
24
            25
            remaining_total = remaining_end - remaining_start
26
            remaining_active = prefix_active[remaining_end] - prefix_active[remaining_start]
27
            remaining_idle = remaining_total - remaining_active
28
            29
            cost = max(remaining_idle, active_decommissioned)
30
            min_cost = min(min_cost, cost)
31
    32
    return min_cost
33
34
def solve():
35
    t = int(input().strip())
36
    37
    for _ in range(t):
38
        server_rack = input().strip()
39
        print(minimum_pruning_cost(server_rack))
40
41
if __name__ == ""__main__"":
42
    solve()",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054044
1390054035,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <bits/stdc++.h>
7
using namespace std;
8
9
int solve(vector<int>&arr, int i, int skip, int inc) {
10
    int n = arr.size();
11
    if(i==n){
12
        return 0;
13
    }
14
    //skip
15
    int ans = INT_MAX;
16
    if(skip) {
17
        ans = min(ans,solve(arr,i+1,skip-1,inc+1));
18
    }
19
    //no skip
20
    ans = min(ans,arr[i]+inc + solve(arr,i+1,skip,inc));
21
    return ans;
22
}
23
24
25
int main() {
26
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
27
    int t;
28
    cin>>t;
29
    while(t--) {
30
        int n,skip;
31
        cin>>n>>skip;
32
        vector<int>arr;
33
        while(n--) {
34
            int a;
35
            cin>>a;
36
            arr.push_back(a);
37
        }
38
        cout<<solve(arr,0,skip,0)<<endl;
39
    }
40
    return 0;
41
}
42",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054035
1390054036,unknown,unknown,unknown,"1
def main():
2
3
    import sys
4
5
    input = sys.stdin.read
6
7
    data = input().split(""\n"")
8
9
    10
11
    t = int(data[0])
12
13
    index = 1
14
15
    results = []
16
17
    for _ in range(t):
18
19
        n, k = map(int, data[index].split())
20
21
        strengths = list(map(int, data[index + 1].split()))
22
23
        index += 2
24
25
        26
27
        if k >= n:
28
29
            results.append(""0"")
30
31
            continue
32
33
        34
35
        # Calculate the impact of each firewall: strength + index
36
37
        impact = [(strengths[i] + i, i) for i in range(n)]
38
39
        40
41
        # Sort firewalls by impact (higher impact should be skipped)
42
43
        impact.sort(reverse=True)
44
45
        46
47
        # Select the top k firewalls to skip
48
49
        to_skip = set(idx for _, idx in impact[:k])
50
51
        52
53
        # Compute the minimal effort
54
55
        effort = 0
56
57
        skipped = 0
58
59
        60
61
        for i in range(n):
62
63
            if i in to_skip:
64
65
                skipped += 1
66
67
            else:
68
69
                effort += strengths[i] + skipped
70
71
        72
73
        results.append(str(effort))
74
75
    76
77
    # Print all results at once (faster output handling)
78
79
    sys.stdout.write(""\n"".join(results) + ""\n"")
80
81
if __name__ == ""__main__"":
82
83
    main()",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054036
1390054038,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054038
1390054034,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner input = new Scanner(System.in);
6
        int t = input.nextInt();  // Number of test cases
7
        8
        while (t-- > 0) {
9
            int N = input.nextInt();  // Array size
10
            int K = input.nextInt();  // Batch size
11
            int[] arr = new int[N];
12
            13
            for (int i = 0; i < N; i++) {
14
                arr[i] = input.nextInt();
15
            }
16
            17
            List<Integer> result = findEarliestFaults(arr, K);
18
            19
            // Print the result for this test case
20
            for (int num : result) {
21
                System.out.print(num + "" "");
22
            }
23
            System.out.println();
24
        }
25
        26
        input.close();
27
    }
28
29
    public static List<Integer> findEarliestFaults(int[] arr, int K) {
30
        List<Integer> result = new ArrayList<>();
31
        Deque<Integer> deque = new LinkedList<>();  // Stores indices of negative numbers
32
        33
        int n = arr.length;
34
35
        // Process first window of size K
36
        for (int i = 0; i < K; i++) {
37
            if (arr[i] < 0) {
38
                deque.addLast(i);
39
            }
40
        }
41
        42
        // Process remaining elements
43
        for (int i = K; i <= n; i++) {
44
            // If deque is not empty, the first element is the earliest fault
45
            if (!deque.isEmpty()) {
46
                result.add(arr[deque.peekFirst()]);
47
            } else {
48
                result.add(0);
49
            }
50
51
            // Remove elements that are out of the current window
52
            if (!deque.isEmpty() && deque.peekFirst() <= i - K) {
53
                deque.pollFirst();
54
            }
55
56
            // Add next element (if negative)
57
            if (i < n && arr[i] < 0) {
58
                deque.addLast(i);
59
            }
60
        }
61
        62
        return result;
63
    }
64
}
65",103,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054034
1390054029,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerPruning {
4
    public static int minPruningCost(String serverRack) {
5
        int n = serverRack.length();
6
        int minCost = n + 1; // Initialize with a value larger than any possible cost
7
8
        for (int leftRemoveCount = 0; leftRemoveCount <= n; ++leftRemoveCount) {
9
            for (int rightRemoveCount = 0; rightRemoveCount <= n - leftRemoveCount; ++rightRemoveCount) {
10
                int idleRemaining = 0;
11
                int activeRemoved = 0;
12
13
                // Calculate active_removed
14
                for (int i = 0; i < leftRemoveCount; ++i) {
15
                    if (serverRack.charAt(i) == '1') {
16
                        activeRemoved++;
17
                    }
18
                }
19
                for (int i = n - rightRemoveCount; i < n; ++i) {
20
                    if (serverRack.charAt(i) == '1') {
21
                        activeRemoved++;
22
                    }
23
                }
24
25
                // Calculate idle_remaining
26
                for (int i = leftRemoveCount; i < n - rightRemoveCount; ++i) {
27
                    if (serverRack.charAt(i) == '0') {
28
                        idleRemaining++;
29
                    }
30
                }
31
32
                int cost = Math.max(idleRemaining, activeRemoved);
33
                minCost = Math.min(minCost, cost);
34
            }
35
        }
36
        return minCost;
37
    }
38
39
    public static void main(String[] args) {
40
        Scanner sc = new Scanner(System.in);
41
        int T = Integer.parseInt(sc.nextLine().trim());
42
43
        while (T-- > 0) {
44
            String serverRack = sc.nextLine().trim();
45
            System.out.println(minPruningCost(serverRack));
46
        }
47
        sc.close();
48
    }
49
}",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054029
1390054031,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054031
1390054032,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <algorithm>
4
#include <climits>
5
6
using namespace std;
7
8
int minEffortToBreach(int n, int k, vector<int>& strengths) {
9
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX));
10
    11
    // Base case: No firewalls, no effort
12
    for (int j = 0; j <= k; ++j) {
13
        dp[0][j] = 0;
14
    }
15
    16
    for (int i = 1; i <= n; ++i) {
17
        for (int j = 0; j <= k; ++j) {
18
            // Option 1: Skip current firewall (if skips are available)
19
            if (j > 0) {
20
                dp[i][j] = dp[i - 1][j - 1];
21
            }
22
            23
            // Option 2: Don't skip current firewall
24
            int currentStrength = strengths[i - 1] + j; // Strength increases due to previous skips
25
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + currentStrength);
26
        }
27
    }
28
    29
    // Return minimum effort among all possible ways to use up to k skips
30
    return *min_element(dp[n].begin(), dp[n].end());
31
}
32
33
void solve() {
34
    int t;
35
    cin >> t;
36
    while (t--) {
37
        int n, k;
38
        cin >> n >> k;
39
        vector<int> strengths(n);
40
        for (int i = 0; i < n; ++i) {
41
            cin >> strengths[i];
42
        }
43
        cout << minEffortToBreach(n, k, strengths) << endl;
44
    }
45
}
46
47
int main() {
48
    solve();
49
    return 0;
50
}
51",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054032
1390054018,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054018
1390054020,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054020
1390054022,unknown,unknown,unknown,"1
def min_decommission_cost(server_rack):
2
    n = len(server_rack)
3
    total_ones = server_rack.count('1')
4
    min_cost = float('inf')
5
    6
    prefix_ones = [0] * (n + 1)
7
    prefix_zeros = [0] * (n + 1)
8
    9
    for i in range(n):
10
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_rack[i] == '1' else 0)
11
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_rack[i] == '0' else 0)
12
    13
    for left in range(n + 1):
14
        for right in range(left, n + 1):
15
            ones_in_substring = prefix_ones[right] - prefix_ones[left]
16
            zeros_in_substring = prefix_zeros[right] - prefix_zeros[left]
17
            ones_removed = total_ones - ones_in_substring
18
            cost = max(zeros_in_substring, ones_removed)
19
            if cost < min_cost:
20
                min_cost = cost
21
    22
    return min_cost
23
T = int(input())
24
for _ in range(T):
25
    server_rack = input().strip()
26
    print(min_decommission_cost(server_rack))",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054022
1390054014,unknown,unknown,unknown,"1
def min_cost_server_optimization(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    5
    for i in range(n + 1):
6
        for j in range(n + 1 - i): 
7
            if i + j > n:
8
                continue
9
                10
            remaining = server_rack[i:n-j]
11
            12
            if not remaining:  
13
                continue
14
                15
            idle_remaining = remaining.count('0')
16
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
17
            18
            cost = max(idle_remaining, active_removed)
19
            min_cost = min(min_cost, cost)
20
    21
    return min_cost
22
23
def main():
24
    t = int(input().strip())
25
    results = []
26
    27
    for _ in range(t):
28
        server_rack = input().strip()
29
        results.append(min_cost_server_optimization(server_rack))
30
    31
    for result in results:
32
        print(result)
33
34
if __name__ == ""__main__"":
35
    main()",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054014
1390054016,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
5
    results = []
6
7
    for n, k, arr in test_cases:
8
9
        dq = deque()
10
11
        res = []
12
13
        for i in range(n):
14
15
            while dq and dq[0] < i - k + 1:
16
17
                dq.popleft()
18
19
            if arr[i] < 0:
20
21
                dq.append(i)
22
23
            if i >= k - 1:
24
25
                res.append(arr[dq[0]] if dq else 0)
26
27
        results.append(res)
28
29
    return results
30
31
# Reading input
32
33
t = int(input())
34
35
test_cases = []
36
37
for _ in range(t):
38
39
    n, k = map(int, input().split())
40
41
    arr = list(map(int, input().split()))
42
43
    test_cases.append((n, k, arr))
44
45
# Processing and output
46
47
for result in earliest_faulty_readings(test_cases):
48
49
    print(*result)",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054016
1390054013,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        first_one = s.find('1')
5
        last_one = s.rfind('1')
6
7
        if first_one == -1:  # If there are no '1's, return 0
8
            results.append(0)
9
            continue
10
11
        # Trim the string to only consider the section between the first and last '1'
12
        trimmed = s[first_one:last_one + 1]
13
14
        # Count the number of idle servers ('0's) remaining in the trimmed section
15
        idle_servers_remaining = trimmed.count('0')
16
17
        # Count the number of active servers ('1's) removed from the start and end
18
        active_servers_removed = first_one + (len(s) - 1 - last_one)
19
20
        # The cost is the maximum of these two values
21
        results.append(max(idle_servers_remaining, active_servers_removed))
22
23
    return results
24
25
# Read input
26
T = int(input().strip())
27
test_cases = [input().strip() for _ in range(T)]
28
29
# Get results and print them
30
for res in min_decommissioning_cost(test_cases):
31
    print(res)",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054013
1390054012,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class ServerDecommissioning {
4
    public static int minDecommissionCost(String servers) {
5
        int firstActive = servers.indexOf('1');
6
        int lastActive = servers.lastIndexOf('1');
7
        8
        if (firstActive == -1) return 0; // No active servers
9
        10
        String relevantPart = servers.substring(firstActive, lastActive + 1);
11
        int idleCount = 0, activeRemoved = 0;
12
        13
        for (char c : relevantPart.toCharArray()) {
14
            if (c == '0') idleCount++;
15
            else activeRemoved++;
16
        }
17
        18
        return Math.min(activeRemoved, idleCount);
19
    }
20
    21
    public static void main(String[] args) {
22
        Scanner scanner = new Scanner(System.in);
23
        int t = scanner.nextInt();
24
        scanner.nextLine(); // Consume newline
25
        26
        while (t-- > 0) {
27
            String servers = scanner.nextLine();
28
            System.out.println(minDecommissionCost(servers));
29
        }
30
        31
        scanner.close();
32
    }
33
}
34",104,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054012
1390054010,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    if k == n:
3
        return 0
4
    if k == 0:
5
        return sum(firewalls)
6
7
    min_effort = float('inf')
8
    for i in range(n):
9
        skipped = 0
10
        effort = 0
11
12
        for j in range(n):
13
            if skipped < k and j >= i:
14
                skipped += 1
15
            else:
16
                effort += firewalls[j] + skipped
17
        min_effort = min(min_effort, effort)
18
19
    return min_effort
20
21
T = int(input().strip())
22
results = []
23
24
for _ in range(T):
25
    n, k = map(int, input().split())
26
    firewalls = list(map(int, input().split()))
27
    results.append(min_effort(n, k, firewalls))
28
29
for res in results:
30
    print(res)",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390054010
1390054011,unknown,unknown,unknown,"1
def earliest_faulty_readings(t, testcases):
2
    results = []
3
    for case in testcases:
4
        n, k, arr = case
5
        faults = []
6
        7
        for i in range(n - k + 1):  # Iterate over all possible batches
8
            batch = arr[i:i + k]  # Extract the current batch
9
            earliest_fault = 0  # Default to 0 if no faulty component is found
10
            11
            for num in batch:  # Check each number in the batch
12
                if num < 0:  # If it's faulty, take it as the earliest
13
                    earliest_fault = num
14
                    break  # Exit the loop as we found the earliest fault
15
            16
            faults.append(earliest_fault)  # Add result for this batch
17
        18
        results.append(faults)  # Collect results for this test case
19
    return results
20
21
# Read input
22
t = int(input())
23
testcases = []
24
for _ in range(t):
25
    n, k = map(int, input().split())
26
    arr = list(map(int, input().split()))
27
    testcases.append((n, k, arr))
28
29
# Solve and print the results
30
outputs = earliest_faulty_readings(t, testcases)
31
for output in outputs:
32
    print(' '.join(map(str, output)))
33",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054011
1390054008,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total active servers and total idle servers
5
    total_active = server_string.count('1')
6
    total_idle = n - total_active
7
    8
    # Precompute cumulative counts of active servers from left
9
    active_prefix_sum = [0] * (n + 1)
10
    for i in range(n):
11
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
12
    13
    min_cost = float('inf')
14
    15
    # Try all possible starting positions for the remaining servers
16
    for left in range(n + 1):
17
        # For each possible ending position
18
        for right in range(left, n + 1):
19
            # Active servers in the remaining segment
20
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
21
            idle_remaining = (right - left) - active_remaining
22
            23
            # Active servers removed
24
            active_removed = total_active - active_remaining
25
            26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
def faster_min_decommission_cost(server_string):
32
    n = len(server_string)
33
    34
    # Precompute prefix sums for active and idle servers
35
    active_prefix = [0] * (n + 1)
36
    idle_prefix = [0] * (n + 1)
37
    38
    for i in range(n):
39
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
40
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
41
    42
    min_cost = n  # Worst case cost
43
    44
    # For each possible remaining substring (from i to j-1)
45
    for i in range(n + 1):
46
        for j in range(i, n + 1):
47
            # Idle servers in remaining substring
48
            idle_remaining = idle_prefix[j] - idle_prefix[i]
49
            50
            # Active servers removed (from left and right)
51
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
52
            53
            cost = max(idle_remaining, active_removed)
54
            min_cost = min(min_cost, cost)
55
    56
    return min_cost
57
58
def main():
59
    t = int(input().strip())
60
    61
    for _ in range(t):
62
        server_string = input().strip()
63
        result = faster_min_decommission_cost(server_string)
64
        print(result)
65
66
if __name__ == ""__main__"":
67
    main()",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054008
1390054004,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first batch
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the earliest faulty reading of the first batch
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process the remaining batches
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the current batch
18
        while dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
        21
        # Add the current element if it's faulty
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the earliest faulty reading of the current batch
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Read input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    print("" "".join(map(str, earliest_faults(arr, k))))
36",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390054004
1390054003,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
        # get indices for active servers ('1')
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        # Precompute A: A[i] = positions[i] - i
18
        A = [positions[i] - i for i in range(m)]
19
        20
        # check(X) returns True if there exists a window in A
21
        # such that:
22
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
23
        # and A[j] - A[i] <= X.
24
        def check(X):
25
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                # slide j as far as possible while A[j]-A[i] <= X
33
                while j < m and A[j] - A[i] <= X:
34
                    j += 1
35
                # j now is one past the last index satisfying condition, so the window has length (j - i)
36
                if j - i >= m - X:
37
                    return True
38
            return False
39
40
        # Binary search for the minimum X
41
        lo, hi, ans = 0, n, n
42
        while lo <= hi:
43
            mid = (lo + hi) // 2
44
            if check(mid):
45
                ans = mid
46
                hi = mid - 1
47
            else:
48
                lo = mid + 1
49
        out_lines.append(str(ans))
50
    51
    sys.stdout.write(""\n"".join(out_lines))
52
    53
if __name__ == '__main__':
54
    solve()",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054003
1390054005,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054005
1390053998,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
8
    for _ in range(t):
9
        s = input_data[line].strip()
10
        line += 1
11
        n = len(s)
12
13
        # Get indices of active servers ('1')
14
        positions = [i for i, ch in enumerate(s) if ch == '1']
15
        m = len(positions)
16
17
        if m == 0:
18
            out_lines.append(""0"")
19
            continue
20
21
        # Precompute A: A[i] = positions[i] - i
22
        A = [positions[i] - i for i in range(m)]
23
24
        # Define the check function
25
        def check(X):
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                while j < m and A[j] - A[i] <= X:
33
                    j += 1
34
                if j - i >= m - X:
35
                    return True
36
            return False
37
38
        # Binary search for the minimum X
39
        lo, hi, ans = 0, n, n
40
        while lo <= hi:
41
            mid = (lo + hi) // 2
42
            if check(mid):
43
                ans = mid
44
                hi = mid - 1
45
            else:
46
                lo = mid + 1
47
48
        out_lines.append(str(ans))
49
50
    sys.stdout.write(""\n"".join(out_lines))
51
52
if __name__ == ""__main__"":
53
    solve()",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053998
1390053999,unknown,unknown,unknown,"1
def earliest_fault(arr,k):
2
    result=[]
3
    neg=[]
4
    5
    for i in range(len(arr)):
6
        while neg and neg[0]<i-k+1:
7
            neg.pop(0)
8
        9
        if arr[i]<0:
10
            neg.append(i)
11
            12
        if i>=k-1:
13
            result.append(arr[neg[0]] if neg else 0)
14
    15
    return result
16
17
t= int(input())
18
19
for _ in range(t):
20
    n,k=map(int, input().split())
21
    22
    arr= list(map(int,input().split()))
23
    24
    print("" "".join(map(str,earliest_fault(arr,k))))",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053999
1390054001,unknown,unknown,unknown,"1
def min_decommission_cost(s):
2
    total_ones = s.count('1')
3
    4
    if total_ones == 0:
5
        return 0  # No active servers, cost is 0
6
    7
    # Find first and last '1' in the string
8
    first_one = s.find('1')
9
    last_one = s.rfind('1')
10
    11
    # Consider the segment between first_one and last_one
12
    min_cost = total_ones  # Worst case: remove all ones
13
    14
    for start in range(first_one, last_one + 1):
15
        for end in range(start, last_one + 1):
16
            segment = s[start:end+1]
17
            ones_in_segment = segment.count('1')
18
            zeros_in_segment = segment.count('0')
19
            removed_ones = total_ones - ones_in_segment
20
            21
            cost = max(zeros_in_segment, removed_ones)
22
            min_cost = min(min_cost, cost)
23
    24
    return min_cost
25
26
# Read input
27
t = int(input().strip())
28
for _ in range(t):
29
    s = input().strip()
30
    print(min_decommission_cost(s))
31",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390054001
1390053997,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()",105,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053997
1390053994,unknown,unknown,unknown,"1
# Read number of test cases
2
t = int(input().strip())
3
4
for _ in range(t):
5
    servers = input().strip()
6
    n = len(servers)
7
    8
    # Track active and idle counts with 1D arrays
9
    active_prefix = [0] * (n + 1)
10
    idle_prefix = [0] * (n + 1)
11
    12
    for i in range(n):
13
        active_prefix[i + 1] = active_prefix[i] + (1 if servers[i] == '1' else 0)
14
        idle_prefix[i + 1] = idle_prefix[i] + (1 if servers[i] == '0' else 0)
15
    16
    total_active = active_prefix[n]
17
    total_idle = idle_prefix[n]
18
    19
    min_cost = n  # Start with worst possible cost
20
    21
    # For each possible middle segment [left, right)
22
    for left in range(n + 1):
23
        # Instead of trying all rights, use two pointers technique
24
        right = left
25
        while right <= n:
26
            # Calculate metrics
27
            active_removed = active_prefix[left] + (total_active - active_prefix[right])
28
            idle_remaining = idle_prefix[right] - idle_prefix[left]
29
            30
            cost = max(idle_remaining, active_removed)
31
            min_cost = min(min_cost, cost)
32
            33
            # If active_removed > idle_remaining, increasing right might help
34
            # If active_removed < idle_remaining, we need to increase left
35
            if active_removed > idle_remaining and right < n:
36
                right += 1
37
            else:
38
                break
39
    40
    print(min_cost)",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053994
1390053995,unknown,unknown,unknown,"1
def min_effort_to_breach(t, test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        # Sort firewalls in ascending order
6
        firewalls.sort()
7
        8
        # Increase the strength of the remaining firewalls
9
        total_effort = 0
10
        for i in range(k, n):
11
            total_effort += firewalls[i] + k  # Since we skipped k firewalls, each gets +k
12
        13
        results.append(total_effort)
14
    15
    return results
16
17
# Read input
18
t = int(input().strip())
19
test_cases = []
20
21
for _ in range(t):
22
    n, k = map(int, input().split())
23
    firewalls = list(map(int, input().split()))
24
    test_cases.append((n, k, firewalls))
25
26
# Get results
27
output = min_effort_to_breach(t, test_cases)
28
29
# Print results
30
for res in output:
31
    print(res)",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053995
1390053997,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053997
1390053990,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36
37
38",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053990
1390053992,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
typedef long long ll;
5
6
void solve() {
7
    int n, k;
8
    cin >> n >> k;
9
    vector<ll> arr(n);
10
    ll total = 0;
11
    12
    13
    for (int i = 0; i < n; i++) {
14
        cin >> arr[i];
15
        total += arr[i];
16
    }
17
    18
    vector<ll> benefits(n);
19
    for (int j = 0; j < n; j++){
20
        benefits[j] = arr[j] - (n - 1 - j);
21
    }
22
    23
    sort(benefits.begin(), benefits.end(), greater<ll>());
24
25
    ll best = total;
26
    ll sumb = 0;
27
    int m = min(k, n);
28
    for (int i = 0; i < m; i++){
29
        if (benefits[i] < 0) {
30
        }
31
        sumb += benefits[i];
32
        int skips = i + 1;
33
        ll candidate = total - sumb - (skips * (skips - 1LL)) / 2LL;
34
        best = min(best, candidate);
35
    }
36
    cout << best << ""\n"";
37
}
38
39
int main() {
40
    int t; cin >> t;
41
    while (t--) {
42
        solve();
43
    }
44
    return 0;
45
}
46",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053992
1390053993,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053993
1390053987,unknown,unknown,unknown,"1
import sys
2
import threading
3
4
def main():
5
    T = int(sys.stdin.readline())
6
    7
    for _ in range(T):
8
        n, k = map(int, sys.stdin.readline().split())
9
        a = list(map(int, sys.stdin.readline().split()))
10
11
        # We calculate the ""gain"" of skipping a firewall:
12
        # Skipping it saves a[i], but increases the cost of subsequent firewalls by 1.
13
        # So we rank the firewalls by how beneficial it is to skip them.
14
        # We sort by a[i] - (n - i - 1), because skipping early firewalls increases cost of more firewalls.
15
        # The higher this value, the better it is to skip.
16
17
        benefits = []
18
        for i in range(n):
19
            benefit = a[i] - (n - i - 1)
20
            benefits.append((benefit, i))
21
        22
        # Sort by benefit descending
23
        benefits.sort(reverse=True)
24
25
        skipped = [False] * n
26
27
        # Mark the top k firewalls to skip
28
        for i in range(k):
29
            _, idx = benefits[i]
30
            skipped[idx] = True
31
32
        # Calculate total effort
33
        total_effort = 0
34
        penalty = 0  # number of skipped firewalls so far
35
        for i in range(n):
36
            if skipped[i]:
37
                penalty += 1
38
            else:
39
                total_effort += a[i] + penalty
40
41
        print(total_effort)
42
43
# Run main() inside a separate thread to avoid recursion limit issues in large input
44
threading.Thread(target=main).start()",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053987
1390053988,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    skipped_indices = set()
6
    current_effort = 0
7
    for i in range(n):
8
        current_effort += a[i]
9
10
    min_effort = current_effort
11
12
    for _ in range(k):
13
        best_reduction = 0
14
        best_skip_index = -1
15
16
        for i in range(n):
17
            if i not in skipped_indices:
18
                reduction = a[i]
19
                increase = 0
20
                for j in range(i + 1, n):
21
                    if j not in skipped_indices:
22
                        increase += 1
23
                current_reduction = reduction - increase
24
                if current_reduction > best_reduction:
25
                    best_reduction = current_reduction
26
                    best_skip_index = i
27
28
        if best_skip_index != -1 and best_reduction > 0:
29
            skipped_indices.add(best_skip_index)
30
            current_effort -= best_reduction
31
            min_effort = min(min_effort, current_effort)
32
        else:
33
            break
34
35
    final_effort = 0
36
    for i in range(n):
37
        if i not in skipped_indices:
38
            strength_increase = 0
39
            for skipped_index in skipped_indices:
40
                if skipped_index < i:
41
                    strength_increase += 1
42
            final_effort += a[i] + strength_increase
43
    min_effort = min(min_effort, final_effort)
44
45
46
    print(min_effort)
47
48
49
t = int(input())
50
for _ in range(t):
51
    solve()",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053988
1390053989,unknown,unknown,unknown,"1
import bisect
2
3
t = int(input())
4
for _ in range(t):
5
    s = input().strip()
6
    n = len(s)
7
    8
    if n == 0:
9
        print(0)
10
        continue
11
    if n == 1:
12
        print(0)
13
        continue
14
    if n == 2:
15
        print(1 if s[0] == s[1] else 0)
16
        continue
17
    18
    prefix_0 = [0] * (n + 1)
19
    prefix_1 = [0] * (n + 1)
20
    for i in range(n):
21
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
22
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
23
    total_1 = prefix_1[n]
24
    25
    low, high = 0, n
26
    while low < high:
27
        m = (low + high) // 2
28
        possible = False
29
        for j in range(n + 1):
30
            target = prefix_0[j] - m
31
            i = bisect.bisect_left(prefix_0, target)
32
            if i <= j:
33
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
34
                if ones_removed <= m:
35
                    possible = True
36
                    break
37
        if possible:
38
            high = m
39
        else:
40
            low = m + 1
41
    print(low)",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053989
1390053985,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
5
    n = len(arr)
6
7
    result = []
8
9
    dq = deque()  # To store indices of negative numbers
10
11
    # Process first k elements (first window)
12
13
    for i in range(k):
14
15
        if arr[i] < 0:
16
17
            dq.append(i)
18
19
    20
21
    # Process rest of the array
22
23
    for i in range(n - k + 1):
24
25
        # Add earliest faulty reading or 0 if none
26
27
        result.append(arr[dq[0]] if dq else 0)
28
29
        # Remove elements out of the window
30
31
        if dq and dq[0] == i:
32
33
            dq.popleft()
34
35
        # Add new element to the window
36
37
        if i + k < n and arr[i + k] < 0:
38
39
            dq.append(i + k)
40
41
    return result
42
43
# Read input
44
45
t = int(input().strip())  # Number of test cases
46
47
for _ in range(t):
48
49
    n, k = map(int, input().split())  # Size of array and batch size
50
51
    arr = list(map(int, input().split()))
52
53
    print(*earliest_faulty_readings(arr, k))",106,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053985
1390053977,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053977
1390053983,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
        # get indices for active servers ('1')
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        # Precompute A: A[i] = positions[i] - i
18
        A = [positions[i] - i for i in range(m)]
19
        20
        # check(X) returns True if there exists a window in A
21
        # such that:
22
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
23
        # and A[j] - A[i] <= X.
24
        def check(X):
25
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                # slide j as far as possible while A[j]-A[i] <= X
33
                while j < m and A[j] - A[i] <= X:
34
                    j += 1
35
                # j now is one past the last index satisfying condition, so the window has length (j - i)
36
                if j - i >= m - X:
37
                    return True
38
            return False
39
40
        # Binary search for the minimum X
41
        lo, hi, ans = 0, n, n
42
        while lo <= hi:
43
            mid = (lo + hi) // 2
44
            if check(mid):
45
                ans = mid
46
                hi = mid - 1
47
            else:
48
                lo = mid + 1
49
        out_lines.append(str(ans))
50
    51
    sys.stdout.write(""\n"".join(out_lines))
52
    53
if _name_ == '_main_':
54
    solve()",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053983
1390053984,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    s = input().strip()
4
    n = len(s)
5
6
    a = [0] * (n + 1)
7
    for i in range(n):
8
        a[i + 1] = a[i] + (1 if s[i] == ""1"" else 0)
9
10
    c = float(""inf"")
11
12
    for i in range(n + 1):
13
        b = a[i]
14
        l, r = 0, n - i
15
16
        while l <= r:
17
            j = (l + r) // 2
18
            x = n - i - j
19
            y = a[n] - a[i] - (a[n] - a[n - j])
20
            z = x - y
21
            d = b + (a[n] - a[n - j])
22
            e = max(z, d)
23
            c = min(c, e)
24
25
            if z > d:
26
                l = j + 1
27
            else:
28
                r = j - 1
29
30
    print(c)
31",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053984
1390053972,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
11
        12
        13
        Scanner sc=new Scanner(System.in);
14
        15
        int t=sc.nextInt();
16
        17
        while(t-->0){
18
            int n=sc.nextInt();
19
            int k=sc.nextInt();
20
            21
            int arr[]=new int[n];
22
            23
            for(int i=0;i<n;i++){
24
                arr[i]=sc.nextInt();
25
            }
26
            27
            ArrayList<Integer> ans=new ArrayList<>();
28
            for(int i=0;i<=n-k;i++){
29
                30
                boolean flag=false;
31
                for(int j=i;j<i+k;j++){
32
                    if(arr[j]<0){
33
                        flag=true;
34
                        ans.add(arr[j]);
35
                        break;
36
                    }
37
                }
38
                if(flag==false){
39
                    ans.add(0);
40
                }
41
                42
            }
43
            44
            45
            int ans1[]=new int[ans.size()];
46
            int j=0;
47
            for(int i=0;i<ans.size();i++){
48
                ans1[j++]=ans.get(i);
49
            }
50
            51
            52
            for(int i=0;i<ans.size();i++){
53
                System.out.print(ans.get(i)+"" "");
54
            }
55
            System.out.println();
56
        }
57
    }
58
}",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053972
1390053975,unknown,unknown,unknown,"1
def minimum_decommission_cost(server_rack):
2
    n = len(server_rack)
3
    total_ones = server_rack.count('1')
4
    minimum_cost = float('inf')
5
    6
    prefix_ones = [0] * (n + 1)
7
    prefix_zeros = [0] * (n + 1)
8
    9
    for i in range(n):
10
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_rack[i] == '1' else 0)
11
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_rack[i] == '0' else 0)
12
    13
   14
    for left in range(n + 1):
15
        for right in range(left, n + 1):
16
            ones_in_substring = prefix_ones[right] - prefix_ones[left]
17
            zeros_in_substring = prefix_zeros[right] - prefix_zeros[left]
18
            ones_removed = total_ones - ones_in_substring
19
            cost = max(zeros_in_substring, ones_removed)
20
            if cost < minimum_cost:
21
                minimum_cost = cost
22
    23
    return minimum_cost
24
25
T = int(input())
26
for _ in range(T):
27
    server_rack = input().strip()
28
    print(minimum_decommission_cost(server_rack))",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053975
1390053971,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053971
1390053968,unknown,unknown,unknown,"1
def minimize_effort(n, k, a):
2
    if k == n:  # If we can skip all firewalls, the total effort is 0.
3
        return 0
4
5
    total_effort = sum(a)  # Initial total effort without skipping
6
    min_effort = total_effort  # Start with the worst case
7
8
    # Try skipping each subset of `k` firewalls and find the minimum effort
9
    for i in range(n):
10
        if i + k > n:  # If skipping `k` firewalls goes out of bounds, stop.
11
            break
12
13
        # Calculate new effort after skipping a[i:i+k]
14
        effort = sum(a[:i]) + sum(a[i + k:])  # Remove the skipped firewalls
15
16
        # Apply penalty for skipping `k` firewalls
17
        penalty = sum(range(1, k + 1))
18
        effort += penalty
19
20
        # Track the minimum effort found
21
        min_effort = min(min_effort, effort)
22
23
    return min_effort
24
25
26
# Driver code to handle multiple test cases
27
T = int(input().strip())
28
for _ in range(T):
29
    n, k = map(int, input().split())
30
    a = list(map(int, input().split()))
31
32
    result = minimize_effort(n, k, a)
33
    print(result)
34",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053968
1390053969,unknown,unknown,unknown,"1
def solve():
2
3
    s = input()
4
5
    n = len(s)
6
7
    min_cost = float('inf')
8
9
    for i in range(n + 1):
10
11
        for j in range(n - i + 1):
12
13
            remaining = s[i:n - j]
14
15
            idle_count = remaining.count('0')
16
17
            active_removed = s[:i].count('1') + s[n - j:].count('1')
18
19
            min_cost = min(min_cost, max(idle_count, active_removed))
20
21
    print(min_cost)
22
23
t = int(input())
24
25
for _ in range(t):
26
27
    solve()",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053969
1390053970,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); 
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            for (char c : s.toCharArray()) {
17
                if (c == '1') {
18
                    currentConsecutiveOnes++;
19
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
20
                    totalOnes++;
21
                } else {
22
                    currentConsecutiveOnes = 0;
23
                }
24
            }
25
            26
            if (totalOnes == 0) {
27
                System.out.println(0);
28
                continue;
29
            }
30
            if (maxConsecutiveOnes == totalOnes) {
31
                System.out.println(0);
32
                continue;
33
            }
34
            35
            int totalZeros = n - totalOnes;
36
            int low = 0;
37
            int high = Math.max(totalOnes, totalZeros);
38
            int answer = high;
39
            40
            while (low <= high) {
41
                int mid = (low + high) / 2;
42
                int requiredOnes = Math.max(0, totalOnes - mid);
43
                44
                if (requiredOnes == 0) {
45
                    answer = mid;
46
                    high = mid - 1;
47
                    continue;
48
                }
49
                50
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
51
                if (maxOnes >= requiredOnes) {
52
                    answer = mid;
53
                    high = mid - 1;
54
                } else {
55
                    low = mid + 1;
56
                }
57
            }
58
            59
            System.out.println(answer);
60
        }
61
        sc.close();
62
    }
63
    64
    private static int maxOnesWithAtMostKZeros(String s, int k) {
65
        int left = 0;
66
        int zeros = 0;
67
        int maxOnes = 0;
68
        int n = s.length();
69
        70
        for (int right = 0; right < n; right++) {
71
            if (s.charAt(right) == '0') {
72
                zeros++;
73
            }
74
            while (zeros > k) {
75
                if (s.charAt(left) == '0') {
76
                    zeros--;
77
                }
78
                left++;
79
            }
80
            int currentOnes = (right - left + 1) - zeros;
81
            maxOnes = Math.max(maxOnes, currentOnes);
82
        }
83
        84
        return maxOnes;
85
    }
86
}",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053970
1390053966,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",107,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053966
1390053963,unknown,unknown,unknown,"1
# Read number of test cases
2
t = int(input().strip())
3
4
for _ in range(t):
5
    servers = input().strip()
6
    n = len(servers)
7
    8
    # Precompute prefix sums
9
    active_prefix = [0] * (n + 1)
10
    idle_prefix = [0] * (n + 1)
11
    12
    for i in range(n):
13
        active_prefix[i + 1] = active_prefix[i] + (1 if servers[i] == '1' else 0)
14
        idle_prefix[i + 1] = idle_prefix[i] + (1 if servers[i] == '0' else 0)
15
    16
    total_active = active_prefix[n]
17
    18
    min_cost = n  # Initialize with worst case
19
    20
    # Try all possible combinations of left and right cuts
21
    # But do it efficiently by only computing each value once
22
    for left in range(n + 1):
23
        for right in range(left, n + 1):
24
            # Active servers removed
25
            active_removed = active_prefix[left] + (total_active - active_prefix[right])
26
            27
            # Idle servers remaining
28
            idle_remaining = idle_prefix[right] - idle_prefix[left]
29
            30
            # Calculate cost
31
            cost = max(idle_remaining, active_removed)
32
            min_cost = min(min_cost, cost)
33
    34
    print(min_cost)",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053963
1390053964,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
5
    public static List<Integer> earliestFaults(int[] arr, int k) {
6
7
        List<Integer> result = new ArrayList<>();
8
9
        Deque<Integer> deque = new LinkedList<>();
10
11
        for (int i = 0; i < arr.length; i++) {
12
13
            // Remove out-of-window elements
14
15
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
16
17
                deque.poll();
18
19
            }
20
21
            // Add new faulty readings
22
23
            if (arr[i] < 0) {
24
25
                deque.offer(i);
26
27
            }
28
29
            // Collect results for valid windows
30
31
            if (i >= k - 1) {
32
33
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
34
35
            }
36
37
        }
38
39
        return result;
40
41
    }
42
43
    public static void main(String[] args) {
44
45
        Scanner scanner = new Scanner(System.in);
46
47
        int t = scanner.nextInt(); // Number of test cases
48
49
        while (t-- > 0) {
50
51
            int n = scanner.nextInt(); // Array size
52
53
            int k = scanner.nextInt(); // Batch size
54
55
            int[] arr = new int[n];
56
57
            for (int i = 0; i < n; i++) {
58
59
                arr[i] = scanner.nextInt();
60
61
            }
62
63
            // Compute and print results
64
65
            List<Integer> faults = earliestFaults(arr, k);
66
67
            for (int val : faults) {
68
69
                System.out.print(val + "" "");
70
71
            }
72
73
            System.out.println();
74
75
        }
76
77
        scanner.close();
78
79
    }
80
81
}",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053964
1390053965,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); // Consume the newline after T
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            // Calculate totalOnes and maxConsecutiveOnes
17
            for (char c : s.toCharArray()) {
18
                if (c == '1') {
19
                    currentConsecutiveOnes++;
20
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
21
                    totalOnes++;
22
                } else {
23
                    currentConsecutiveOnes = 0;
24
                }
25
            }
26
            27
            // Handle cases where the cost is trivially 0
28
            if (totalOnes == 0) {
29
                System.out.println(0);
30
                continue;
31
            }
32
            if (maxConsecutiveOnes == totalOnes) {
33
                System.out.println(0);
34
                continue;
35
            }
36
            37
            int totalZeros = n - totalOnes;
38
            int low = 0;
39
            int high = Math.max(totalOnes, totalZeros);
40
            int answer = high;
41
            42
            // Binary search for the minimal possible cost
43
            while (low <= high) {
44
                int mid = (low + high) / 2;
45
                int requiredOnes = Math.max(0, totalOnes - mid);
46
                47
                if (requiredOnes == 0) {
48
                    answer = mid;
49
                    high = mid - 1;
50
                    continue;
51
                }
52
                53
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
54
                if (maxOnes >= requiredOnes) {
55
                    answer = mid;
56
                    high = mid - 1;
57
                } else {
58
                    low = mid + 1;
59
                }
60
            }
61
            62
            System.out.println(answer);
63
        }
64
        sc.close();
65
    }
66
    67
    // Helper function to calculate maximum ones in any window with at most k zeros
68
    private static int maxOnesWithAtMostKZeros(String s, int k) {
69
        int left = 0;
70
        int zeros = 0;
71
        int maxOnes = 0;
72
        int n = s.length();
73
        74
        for (int right = 0; right < n; right++) {
75
            if (s.charAt(right) == '0') {
76
                zeros++;
77
            }
78
            // Shrink the window if zeros exceed k
79
            while (zeros > k) {
80
                if (s.charAt(left) == '0') {
81
                    zeros--;
82
                }
83
                left++;
84
            }
85
            // Calculate current number of ones in the window
86
            int currentOnes = (right - left + 1) - zeros;
87
            maxOnes = Math.max(maxOnes, currentOnes);
88
        }
89
        90
        return maxOnes;
91
    }
92
}",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053965
1390053957,unknown,unknown,unknown,"1
t = int(input())  
2
while t > 0:
3
    n, k = map(int, input().split())  
4
    arr = list(map(int, input().split()))  
5
    neg = []
6
    7
    for i in range(n - k + 1):  
8
        found = 0  
9
        for j in range(i, i + k):  
10
            if arr[j] < 0:
11
                neg.append(arr[j])  
12
                found = 1
13
                break
14
        if not found:
15
            neg.append(0) 
16
    17
    print(*neg)  
18
    t -= 1 
19
20
        ",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053957
1390053958,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    ans = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            10
            decommissioned_ones = 0
11
            remaining_zeros = 0
12
            13
            # Decommission from the beginning
14
            decommissioned_ones += s[:i].count('1')
15
            16
            # Decommission from the end
17
            decommissioned_ones += s[n - j:].count('1')
18
            19
            # Remaining string after decommissioning
20
            remaining_string = s[i:n - j]
21
            remaining_zeros = remaining_string.count('0')
22
            23
            ans = min(ans, max(decommissioned_ones, remaining_zeros))
24
            25
    print(ans)
26
27
t = int(input())
28
for _ in range(t):
29
    solve()",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053958
1390053959,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int t = sc.nextInt();
8
        sc.nextLine(); 
9
        while (t-- > 0) {
10
            String s = sc.nextLine();
11
            System.out.println(minCost(s));
12
        }
13
    }
14
15
    public static int minCost(String s) {
16
        int n = s.length();
17
        int[] prefixOnes = new int[n + 1];
18
        int[] suffixZeros = new int[n + 1];
19
20
 21
        for (int i = 0; i < n; i++) {
22
            prefixOnes[i + 1] = prefixOnes[i] + (s.charAt(i) == '1' ? 1 : 0);
23
        }
24
25
      26
        for (int i = n - 1; i >= 0; i--) {
27
            suffixZeros[i] = suffixZeros[i + 1] + (s.charAt(i) == '0' ? 1 : 0);
28
        }
29
30
        int minCost = Integer.MAX_VALUE;
31
        for (int left = 0; left <= n; left++) {
32
            for (int right = 0; right <= n - left; right++) {
33
           34
                int onesRemoved = prefixOnes[left] + (prefixOnes[n] - prefixOnes[n - right]);
35
            36
                int zerosLeft = suffixZeros[left] - suffixZeros[n - right];
37
             38
                int cost = Math.max(zerosLeft, onesRemoved);
39
                minCost = Math.min(minCost, cost);
40
            }
41
        }
42
43
        return minCost;
44
    }
45
}",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053959
1390053948,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
8
    for _ in range(t):
9
        s = input_data[line].strip()
10
        line += 1
11
        n = len(s)
12
13
        # Get indices of active servers ('1')
14
        positions = [i for i, ch in enumerate(s) if ch == '1']
15
        m = len(positions)
16
17
        if m == 0:
18
            out_lines.append(""0"")
19
            continue
20
21
        # Precompute A: A[i] = positions[i] - i
22
        A = [positions[i] - i for i in range(m)]
23
24
        # Define the check function
25
        def check(X):
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                while j < m and A[j] - A[i] <= X:
33
                    j += 1
34
                if j - i >= m - X:
35
                    return True
36
            return False
37
38
        # Binary search for the minimum X
39
        lo, hi, ans = 0, n, n
40
        while lo <= hi:
41
            mid = (lo + hi) // 2
42
            if check(mid):
43
                ans = mid
44
                hi = mid - 1
45
            else:
46
                lo = mid + 1
47
48
        out_lines.append(str(ans))
49
50
    sys.stdout.write(""\n"".join(out_lines))
51
52
if __name__ == ""__main__"":
53
    solve()",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053948
1390053950,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int t = sc.nextInt();
8
        9
        while (t-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            13
            int[] strengths = new int[n];
14
            for (int i = 0; i < n; i++) {
15
                strengths[i] = sc.nextInt();
16
            }
17
18
            long totalEffort = 0;
19
            for (int i = 0; i < n; i++) {
20
                totalEffort += strengths[i];
21
            }
22
    23
            if (k == 0 || k >= n) {
24
                System.out.println(k >= n ? 0 : totalEffort);
25
                continue;
26
            }
27
28
            long[] prefixSum = new long[n - k + 1];
29
            for (int i = 0; i < k; i++) {
30
                prefixSum[0] += strengths[i];
31
            }
32
   33
            for (int i = 1; i <= n - k; i++) {
34
                prefixSum[i] = prefixSum[i-1] - strengths[i-1] + strengths[i+k-1];
35
            }
36
 37
            long maxSkipSum = 0;
38
            int bestSkipIndex = 0;
39
            40
            for (int i = 0; i <= n - k; i++) {
41
 42
                long benefitOfSkipping = prefixSum[i] - (long)(n - i - k) * k;
43
                44
                if (benefitOfSkipping > maxSkipSum) {
45
                    maxSkipSum = benefitOfSkipping;
46
                    bestSkipIndex = i;
47
                }
48
            }
49
            50
51
            long minEffort = totalEffort - maxSkipSum;
52
            System.out.println(minEffort);
53
        }
54
        55
        sc.close();
56
    }
57
}",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053950
1390053949,unknown,unknown,unknown,"1
def min_effort_to_breach(n, firewalls):
2
    total_effort = sum(firewalls)  
3
    min_effort = total_effort  
4
    for i in range(n):
5
        skipped_effort = total_effort - firewalls[i]
6
        min_effort = min(min_effort, skipped_effort)  
7
    return min_effort
8
9",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053949
1390053947,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
   4
    for j in range(k + 1):
5
        dp[0][j] = 0
6
    7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            10
            if j > 0:
11
                dp[i][j] = dp[i-1][j-1]
12
            13
           14
            current_strength = strengths[i-1] + j 
15
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
16
    17
    return min(dp[n])
18
19
def solve():
20
    t = int(input())
21
    results = []
22
    23
    for _ in range(t): 
24
        n, k = map(int, input().split())
25
        strengths = list(map(int, input().split()))
26
        results.append(min_effort_to_breach(n, k, strengths))
27
    28
    for result in results:
29
        print(result)
30
31
solve()
32",108,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053947
1390053943,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FirewallBreach {
4
    public static void main(String[] args) {
5
        Scanner scanner = new Scanner(System.in);
6
        int testCases = scanner.nextInt();
7
8
        while (testCases-- > 0) {
9
            int n = scanner.nextInt();
10
            int k = scanner.nextInt(); 
11
            int[] firewalls = new int[n];
12
13
            long totalEffort = 0; 
14
            for (int i = 0; i < n; i++) {
15
                firewalls[i] = scanner.nextInt();
16
                totalEffort += firewalls[i];
17
            }
18
19
            if (k >= n) {
20
                System.out.println(0);
21
                continue;
22
            }
23
24
            long[] reductionValues = new long[n];
25
26
            for (int i = 0; i < n; i++) {
27
                reductionValues[i] = firewalls[i] - (n - i - 1);
28
            }
29
30
            Arrays.sort(reductionValues);
31
32
            long maxReduction = 0;
33
            for (int i = 0; i < k; i++) {
34
                maxReduction += reductionValues[n - 1 - i];
35
            }
36
37
            System.out.println(totalEffort - maxReduction);
38
        }
39
40
        scanner.close();
41
    }
42
}
43",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053943
1390053944,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    // Optimized function to compute the minimum decommission cost for a test case
6
    public static int minDecommissionCostOptimized(String testCase) {
7
        int n = testCase.length();
8
        int[] prefix0 = new int[n + 1];
9
        int[] prefix1 = new int[n + 1];
10
        11
        // Build prefix sum arrays for '0's and '1's
12
        for (int i = 0; i < n; i++) {
13
            char ch = testCase.charAt(i);
14
            prefix0[i + 1] = prefix0[i] + (ch == '0' ? 1 : 0);
15
            prefix1[i + 1] = prefix1[i] + (ch == '1' ? 1 : 0);
16
        }
17
        18
        int totalOnes = prefix1[n];
19
        int minCost = Integer.MAX_VALUE;
20
        21
        // For each possible starting index i for the remaining segment
22
        for (int i = 0; i <= n; i++) {
23
            // Compute the ideal candidate j using the derived formula
24
            int candidate = i + totalOnes;
25
            if (candidate > n) {
26
                candidate = n;
27
            }
28
            29
            // Check candidate j as well as neighboring indices to ensure optimal cost
30
            for (int j : new int[]{candidate, candidate - 1, candidate + 1}) {
31
                if (j < i || j > n) continue;
32
                int zerosKept = prefix0[j] - prefix0[i];
33
                int onesRemoved = prefix1[i] + (totalOnes - prefix1[j]);
34
                int cost = Math.max(zerosKept, onesRemoved);
35
                if (cost < minCost) {
36
                    minCost = cost;
37
                }
38
            }
39
        }
40
        return minCost;
41
    }
42
43
    public static void main(String[] args) {
44
        Scanner scanner = new Scanner(System.in);
45
        int T = scanner.nextInt();
46
        scanner.nextLine(); // Consume the newline
47
        48
        // Process each test case
49
        for (int t = 0; t < T; t++) {
50
            String testCase = scanner.nextLine().trim();
51
            int result = minDecommissionCostOptimized(testCase);
52
            System.out.println(result);
53
        }
54
        scanner.close();
55
    }
56
}",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053944
1390053945,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053945
1390053938,unknown,unknown,unknown,1,109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053938
1390053941,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053941
1390053937,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053937
1390053934,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(t, test_cases):
4
    results = []
5
    for n, k, arr in test_cases:
6
        result = []
7
        dq = deque()
8
        9
        for i in range(n):
10
            if arr[i] < 0:
11
                dq.append(i)
12
            13
            if i >= k - 1:
14
                while dq and dq[0] < i - k + 1:
15
                    dq.popleft()
16
                17
                result.append(arr[dq[0]] if dq else 0)
18
        19
        results.append("" "".join(map(str, result)))
20
    21
    return results
22
23
# Read input
24
t = int(input().strip())
25
test_cases = []
26
for _ in range(t):
27
    n, k = map(int, input().split())
28
    arr = list(map(int, input().split()))
29
    test_cases.append((n, k, arr))
30
31
# Compute and print results
32
for res in earliest_faulty_readings(t, test_cases):
33
    print(res)
34",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053934
1390053935,unknown,unknown,unknown,"1
def min_effort(arr, k):
2
    n = len(arr)
3
    if k >= n:
4
        return 0
5
    dp = [0] + [float('inf')] * k
6
    for i in range(n):
7
        for j in range(min(k, i), -1, -1):
8
            cost_if_used = dp[j] + arr[i] + j
9
            if j < k:
10
                dp[j+1] = min(dp[j+1], dp[j])
11
            dp[j] = cost_if_used
12
    return min(dp)
13
14
def solve():
15
    import sys
16
    data = sys.stdin.read().strip().split()
17
    if not data:
18
        return
19
    t = int(data[0])
20
    index = 1
21
    res = []
22
    for _ in range(t):
23
        n = int(data[index])
24
        index += 1
25
        k = int(data[index])
26
        index += 1
27
        arr = list(map(int, data[index:index+n]))
28
        index += n
29
        res.append(str(min_effort(arr, k)))
30
    sys.stdout.write(""\n"".join(res))
31
32
if __name__ == ""__main__"":
33
    solve()
34",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053935
1390053936,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053936
1390053933,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",109,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053933
1390053931,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
            19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input().strip())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)
42",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053931
1390053930,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    s = input().strip()
4
    n = len(s)
5
6
    a = [0] * (n + 1)
7
    for i in range(n):
8
        a[i + 1] = a[i] + (1 if s[i] == ""1"" else 0)
9
10
    c = float(""inf"")
11
    b = a[n]
12
13
    for i in range(n + 1):
14
        d = a[i]
15
16
        for j in range(n + 1 - i):
17
            e = b - a[n - j]
18
            f = d + e
19
            g = n - i - j
20
            h = b - f
21
            k = g - h
22
            c = min(c, max(k, f))
23
24
    print(c)
25",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053930
1390053932,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <deque>
4
using namespace std;
5
6
void findeqfault(vector<int>& arr, int k) {
7
    deque<int> dq;
8
    int n = arr.size();
9
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0)
12
            dq.push_back(i);
13
    }
14
15
    for (int i = k; i <= n; i++) {
16
        if (!dq.empty())
17
            cout << arr[dq.front()] << "" "";
18
        else
19
            cout << ""0 "";
20
21
        while (!dq.empty() && dq.front() <= i - k)
22
            dq.pop_front();
23
24
        if (i < n && arr[i] < 0)
25
            dq.push_back(i);
26
    }
27
    cout << endl;
28
}
29
30
int main() {
31
    int t;
32
    cin >> t;
33
    while (t--) {
34
        int n, k;
35
        cin >> n >> k;
36
        vector<int> arr(n);
37
        for (int i = 0; i < n; i++) {
38
            cin >> arr[i];
39
        }
40
        findeqfault(arr, k);
41
    }
42
    return 0;
43
}
44",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053932
1390053919,unknown,unknown,unknown,"1
def min_cost_to_decommission(rack):
2
    length = len(rack)
3
    min_cost = float('inf')
4
    5
    for prefix in range(length + 1):
6
        for suffix in range(length + 1 - prefix):
7
            if prefix + suffix > length:
8
                continue
9
            10
            remaining = rack[prefix:length - suffix]
11
            12
            if not remaining:
13
                continue
14
            15
            idle_count = remaining.count('0')
16
            active_removed = rack[:prefix].count('1') + rack[length - suffix:].count('1')
17
            18
            cost = max(idle_count, active_removed)
19
            min_cost = min(min_cost, cost)
20
    21
    return min_cost
22
23
cases = int(input())
24
results = []
25
26
for _ in range(cases):
27
    rack = input().strip()
28
    results.append(min_cost_to_decommission(rack))
29
30
for res in results:
31
    print(res)",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053919
1390053925,unknown,unknown,unknown,"1
t = int(input())
2
3
for _ in range(t):
4
    n, k = map(int, input().split())
5
    firewalls = list(map(int, input().split()))
6
7
    if k >= n:  
8
        print(0)
9
        continue
10
11
    min_effort = sum(firewalls)  
12
13
    for i in range(n - k + 1):  
14
        effort = 0
15
        skipped = 0
16
17
        for j in range(n):
18
            if i <= j < i + k: 
19
                skipped += 1
20
                continue
21
22
            effort += firewalls[j] + skipped  
23
24
        min_effort = min(min_effort, effort)  
25
26
    print(min_effort)
27",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053925
1390053926,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053926
1390053912,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <iostream>
7
#include <vector>
8
#include <algorithm>
9
#include <climits>
10
11
using namespace std;
12
13
int minEffortToBreach(int n, int k, vector<int>& strengths) {
14
    vector<vector<int>> dp(n + 1, vector<int>(k + 1, INT_MAX));
15
    16
    // Base case: No firewalls, no effort
17
    for (int j = 0; j <= k; ++j) {
18
        dp[0][j] = 0;
19
    }
20
    21
    for (int i = 1; i <= n; ++i) {
22
        for (int j = 0; j <= k; ++j) {
23
            // Option 1: Skip current firewall (if skips are available)
24
            if (j > 0) {
25
                dp[i][j] = dp[i - 1][j - 1];
26
            }
27
            28
            // Option 2: Don't skip current firewall
29
            int currentStrength = strengths[i - 1] + j; // Strength increases due to previous skips
30
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + currentStrength);
31
        }
32
    }
33
    34
    // Return minimum effort among all possible ways to use up to k skips
35
    return *min_element(dp[n].begin(), dp[n].end());
36
}
37
38
void solve() {
39
    int t;
40
    cin >> t;
41
    while (t--) {
42
        int n, k;
43
        cin >> n >> k;
44
        vector<int> strengths(n);
45
        for (int i = 0; i < n; ++i) {
46
            cin >> strengths[i];
47
        }
48
        cout << minEffortToBreach(n, k, strengths) << endl;
49
    }
50
}
51
52
53
int main() {
54
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
55
    solve();
56
    return 0;
57
}
58",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053912
1390053914,unknown,unknown,unknown,"1
def min_effort(T, test_cases):
2
    results = []
3
    for n, k, strengths in test_cases:
4
        if k == n:
5
            results.append(""0"")
6
            continue
7
8
        total_effort = sum(strengths)  
9
        min_effort = total_effort 
10
11
        for i in range(n):  
12
            skipped_effort = total_effort - strengths[i] + 1  
13
            min_effort = min(min_effort, skipped_effort)
14
15
        results.append(str(min_effort))
16
17
    print(""\n"".join(results))
18
19
20
T = int(input().strip())
21
test_cases = []
22
for _ in range(T):
23
    n, k = map(int, input().split())
24
    strengths = list(map(int, input().split()))
25
    test_cases.append((n, k, strengths))
26
27
28
min_effort(T, test_cases)
29",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053914
1390053913,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    for case in test_cases:
6
        n, k, arr = case
7
        queue = deque()
8
        result = []
9
        10
        for i in range(n):
11
            # Add current element to the queue if it's faulty
12
            if arr[i] < 0:
13
                queue.append(arr[i])
14
            15
            # Remove elements out of the current batch from the queue
16
            if i >= k and arr[i - k] < 0:
17
                queue.popleft()
18
            19
            # Add the earliest fault in the current batch to the result
20
            if i >= k - 1:
21
                if queue:
22
                    result.append(queue[0])
23
                else:
24
                    result.append(0)
25
        26
        results.append(result)
27
    return results
28
29
# Input Reading
30
t = int(input())  # Number of test cases
31
test_cases = []
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    test_cases.append((n, k, arr))
36
37
# Output
38
output = earliest_faulty_readings(test_cases)
39
for res in output:
40
    print(*res)
41",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053913
1390053910,unknown,unknown,unknown,"1
# Read number of test cases
2
t = int(input().strip())
3
4
for _ in range(t):
5
    servers = input().strip()
6
    n = len(servers)
7
    8
    # Count total active and idle
9
    total_active = servers.count('1')
10
    total_idle = servers.count('0')
11
    12
    min_cost = min(total_active, total_idle)  # Initialize with removing all active or all idle
13
    14
    # Calculate prefix arrays
15
    active_prefix = [0]
16
    idle_prefix = [0]
17
    18
    for server in servers:
19
        active_prefix.append(active_prefix[-1] + (1 if server == '1' else 0))
20
        idle_prefix.append(idle_prefix[-1] + (1 if server == '0' else 0))
21
    22
    # Try all possible middle segments efficiently
23
    for left in range(n + 1):
24
        for right in range(left, n + 1):
25
            # Calculate active servers removed
26
            active_removed = active_prefix[left] + (total_active - active_prefix[right])
27
            28
            # Calculate idle servers remaining
29
            idle_remaining = idle_prefix[right] - idle_prefix[left]
30
            31
            # Update minimum cost
32
            cost = max(idle_remaining, active_removed)
33
            min_cost = min(min_cost, cost)
34
    35
    print(min_cost)",110,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053910
1390053907,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Process rest of the array
13
    for i in range(k, len(arr) + 1):
14
        # Append the earliest faulty reading
15
        if dq:
16
            result.append(arr[dq[0]])
17
        else:
18
            result.append(0)
19
        20
        # Remove elements not in the window
21
        if dq and dq[0] == i - k:
22
            dq.popleft()
23
        24
        # Add the next element if it is faulty
25
        if i < len(arr) and arr[i] < 0:
26
            dq.append(i)
27
    28
    return result
29
30
def process_test_cases(test_cases):
31
    results = []
32
    for n, k, arr in test_cases:
33
        results.append("" "".join(map(str, earliest_faults(arr, k))))
34
    return ""\n"".join(results)
35
36
# Example test cases for debugging
37
test_cases = [
38
    (5, 2, [-8, 2, 3, -6, 10]),
39
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
40
]
41
42
# Running test cases
43
print(process_test_cases(test_cases))",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053907
1390053908,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053908
1390053909,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    min_cost = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            remaining = s[i:n-j]
10
            11
            idle_count = 0
12
            for char in remaining:
13
                if char == '0':
14
                    idle_count += 1
15
                    16
            removed_count = 0
17
            for char in s[:i]:
18
                if char == '1':
19
                    removed_count += 1
20
            for char in s[n-j:]:
21
                if char == '1':
22
                    removed_count += 1
23
            24
            cost = max(idle_count, removed_count)
25
            min_cost = min(min_cost, cost)
26
            27
    print(min_cost)
28
29
t = int(input())
30
for _ in range(t):
31
    solve()",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053909
1390053901,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
   public class Solution {
8
    public static void main(String[] args) {
9
        Scanner scanner = new Scanner(System.in);
10
        int t = scanner.nextInt(); // Number of test cases
11
        12
        for (int tc = 0; tc < t; tc++) {
13
            int n = scanner.nextInt(); // Size of array
14
            int k = scanner.nextInt(); // Batch size
15
            16
            int[] arr = new int[n];
17
            for (int i = 0; i < n; i++) {
18
                arr[i] = scanner.nextInt();
19
            }
20
            21
            List<Integer> result = findEarliestFaults(arr, k);
22
            23
            for (int fault : result) {
24
                System.out.print(fault + "" "");
25
            }
26
            System.out.println();
27
        }
28
        scanner.close();
29
    }
30
    31
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
32
        List<Integer> result = new ArrayList<>();
33
        34
        for (int i = 0; i <= arr.length - k; i++) {
35
            int earliestFault = 0; // when no faults
36
            37
    38
            for (int j = i; j < i + k; j++) {
39
                if (arr[j] < 0) {
40
                    earliestFault = arr[j];
41
                    break; 
42
                }
43
            }
44
            45
            result.add(earliestFault);
46
        }
47
        48
        return result;
49
    }
50
}
51",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053901
1390053902,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    min_eff= float('inf')
6
7
    for i in range(1 << n):
8
        skip = []
9
        effort = 0
10
        current_a = a[:] 
11
        skip_count = 0
12
13
        for j in range(n):
14
            if (i >> j) & 1:
15
                skip.append(j)
16
                skip_count += 1
17
18
        if skip_count <= k:
19
            skip.sort()
20
            skip_index = 0
21
22
            for j in range(n):
23
                if skip_index < len(skip) and skip[skip_index] == j:
24
                  for index in range(j+1,n):
25
                    current_a[index] +=1
26
                  skip_index += 1
27
                else:
28
                    effort += current_a[j]
29
30
            min_eff = min(min_eff, effort)
31
32
    print(min_eff)
33
34
t = int(input())
35
for _ in range(t):
36
    solve()",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053902
1390053904,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first k elements
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the result for the first window
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process the remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the current window
18
        while dq and dq[0] <= i - k:
19
            dq.popleft()
20
        21
        # Add the current element if it is negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the result for the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Read input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    36
    # Compute and print results
37
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053904
1390053897,unknown,unknown,unknown,"1
def min_decommission_cost(server_rack):
2
    total_active = server_rack.count('1')
3
    total_idle = server_rack.count('0')
4
5
    min_cost = min(total_active, total_idle)  # Worst case: remove all active or all idle
6
7
    left, right = 0, len(server_rack) - 1
8
    removed_active = 0
9
    removed_idle = 0
10
11
    # Try decommissioning from both ends
12
    while left <= right:
13
        if server_rack[left] == '0':
14
            removed_idle += 1
15
            left += 1
16
        elif server_rack[right] == '0':
17
            removed_idle += 1
18
            right -= 1
19
        elif server_rack[left] == '1':
20
            removed_active += 1
21
            left += 1
22
        elif server_rack[right] == '1':
23
            removed_active += 1
24
            right -= 1
25
        26
        remaining_idle = total_idle - removed_idle
27
        min_cost = min(min_cost, max(remaining_idle, removed_active))
28
29
    return min_cost
30
31
32
# Read input
33
T = int(input())  # Number of test cases
34
results = []
35
36
for _ in range(T):
37
    server_rack = input().strip()
38
    results.append(min_decommission_cost(server_rack))
39
40
# Print results
41
for res in results:
42
    print(res)",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053897
1390053899,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt(); 
8
        9
        while(T-- > 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            int[] a = new int[n];
13
            for (int i = 0; i < n; i++){
14
                a[i] = sc.nextInt();
15
            }
16
            17
            18
            if(k >= n) {
19
                System.out.println(0);
20
                continue;
21
            }
22
            23
           24
            long INF = Long.MAX_VALUE / 2;
25
            long[] dp = new long[k+1];
26
            Arrays.fill(dp, INF);
27
            dp[0] = 0;
28
            29
          30
            for (int i = 0; i < n; i++) {
31
                int lim = Math.min(i+1, k); 
32
                long[] newdp = new long[k+1];
33
                Arrays.fill(newdp, INF);
34
                35
                .
36
                for (int j = lim; j >= 0; j--) {
37
                   38
                    newdp[j] = Math.min(newdp[j], dp[j] + a[i] + j);
39
                    40
                    41
                    if(j < k) {
42
                        newdp[j+1] = Math.min(newdp[j+1], dp[j]);
43
                    }
44
                }
45
                dp = newdp;
46
            }
47
            48
           49
            long ans = INF;
50
            for (int j = 0; j <= k; j++) {
51
                ans = Math.min(ans, dp[j]);
52
            }
53
            System.out.println(ans);
54
        }
55
        sc.close();
56
    }
57
}
58",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053899
1390053898,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    # Special case: If we can skip all firewalls, the effort is 0
3
    if k >= n:
4
        return 0
5
    6
    # Try all possible combinations of skipping 0 to k firewalls
7
    firewalls_sorted = sorted(firewalls)  # Sort to prioritize skipping stronger firewalls
8
    9
    min_effort = float('inf')
10
    11
    # Try skipping 0 to k firewalls
12
    for skipped in range(k + 1):
13
        # Skip the strongest firewalls
14
        remaining = firewalls_sorted[:n-skipped]
15
        16
        # Calculate the total effort with penalty
17
        effort = sum(remaining) + skipped
18
        min_effort = min(min_effort, effort)
19
    20
    return min_effort
21
22
# Read input
23
t = int(input().strip())  # Number of test cases
24
for _ in range(t):
25
    n, k = map(int, input().split())
26
    firewalls = list(map(int, input().split()))
27
    print(min_effort_to_breach(n, k, firewalls))",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053898
1390053896,unknown,unknown,unknown,"1
def minimum_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        if k >= n:
6
            results.append(0)
7
            continue
8
        9
        total = sum(a)
10
        11
        # Create list of (a[i] + i, i, a[i])
12
        candidates = [(a[i] + i, i, a[i]) for i in range(n)]
13
        # Sort candidates in descending order of (a[i] + i)
14
        candidates.sort(reverse=True, key=lambda x: x[0])
15
        # Select top k candidates
16
        selected = candidates[:k]
17
        # Sort selected by their i in ascending order
18
        selected.sort(key=lambda x: x[1])
19
        20
        sum_skipped = sum(x[2] for x in selected)
21
        added = 0
22
        for j in range(k):
23
            i = selected[j][1]
24
            # Number of non-skipped firewalls after i
25
            non_skipped_after = (n - i - 1) - (k - j - 1)
26
            added += non_skipped_after
27
        28
        min_effort = total - sum_skipped + added
29
        results.append(min_effort)
30
    31
    return results
32
33
def main():
34
    import sys
35
    input = sys.stdin.read().split()
36
    idx = 0
37
    T = int(input[idx])
38
    idx += 1
39
    test_cases = []
40
    for _ in range(T):
41
        n = int(input[idx])
42
        k = int(input[idx+1])
43
        idx += 2
44
        a = list(map(int, input[idx:idx+n]))
45
        idx += n
46
        test_cases.append((n, k, a))
47
    res = minimum_effort(test_cases)
48
    for r in res:
49
        print(r)
50
51
if __name__ == ""__main__"":
52
    main()",111,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053896
1390053889,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053889
1390053893,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
    total_effort = sum(strengths)
3
    4
    if k == n:
5
        return 0  # If we can skip all firewalls, minimum effort is 0
6
7
    # Finding the minimum effort by skipping one firewall
8
    min_effort = min(total_effort - strength for strength in strengths)
9
10
    return min_effort
11
12
# Read input
13
T = int(input())  
14
for _ in range(T):
15
    n, k = map(int, input().split())
16
    strengths = list(map(int, input().split()))
17
    print(min_effort(n, k, strengths))
18",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053893
1390053888,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053888
1390053883,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053883
1390053885,unknown,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n,k=list(map(int,input().split()))
4
    arr=list(map(int,input().split()))
5
    dp=[[float('inf')]*(k+1) for _ in range(n+1)]
6
    for j in range(k+1):dp[0][j]=0
7
    for i in range(1,n+1):
8
        for j in range(k+1):
9
            if j:dp[i][j]=min(dp[i][j],dp[i-1][j-1])
10
            dp[i][j]=min(dp[i][j],dp[i-1][j]+arr[i-1]+(j*1))
11
    print(min(dp[n]))",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053885
1390053887,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults_in_batches(test_cases):
4
    results = []
5
    for n, k, arr in test_cases:
6
        faults = []
7
        dq = deque()
8
        9
       10
        for i in range(k):
11
            if arr[i] < 0:
12
                dq.append(i)
13
        14
        15
        faults.append(arr[dq[0]] if dq else 0)
16
        17
        18
        for i in range(k, n):
19
          20
            if dq and dq[0] <= i - k:
21
                dq.popleft()
22
            23
           24
            if arr[i] < 0:
25
                dq.append(i)
26
            27
           28
            faults.append(arr[dq[0]] if dq else 0)
29
        30
        results.append(faults)
31
    32
    return results
33
34
35
t = int(input())
36
test_cases = []
37
for _ in range(t):
38
    n, k = map(int, input().split())
39
    arr = list(map(int, input().split()))
40
    test_cases.append((n, k, arr))
41
42
43
for result in earliest_faults_in_batches(test_cases):
44
    print(*result)",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053887
1390053881,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FirewallMinEffort {
4
    5
    public static long minimizeEffort(int n, int k, int[] firewalls) {
6
        long totalEffort = 0;
7
        8
        // Create a list of pairs (value + index, index)
9
        List<int[]> skipValue = new ArrayList<>();
10
        for (int i = 0; i < n; i++) {
11
            skipValue.add(new int[]{firewalls[i] + i, i});
12
        }
13
14
        // Sort by descending benefit to skip
15
        skipValue.sort((a, b) -> Integer.compare(b[0], a[0]));
16
17
        // Mark which firewalls to skip
18
        boolean[] skipped = new boolean[n];
19
        for (int i = 0; i < k; i++) {
20
            skipped[skipValue.get(i)[1]] = true;
21
        }
22
23
        // Calculate final effort
24
        long effort = 0;
25
        int penalty = 0;
26
        for (int i = 0; i < n; i++) {
27
            if (skipped[i]) {
28
                penalty++;
29
            } else {
30
                effort += firewalls[i] + penalty;
31
            }
32
        }
33
34
        return effort;
35
    }
36
37
    public static void main(String[] args) {
38
        Scanner sc = new Scanner(System.in);
39
        40
        int T = sc.nextInt();
41
        while (T-- > 0) {
42
            int n = sc.nextInt();
43
            int k = sc.nextInt();
44
            int[] firewalls = new int[n];
45
46
            for (int i = 0; i < n; i++) {
47
                firewalls[i] = sc.nextInt();
48
            }
49
50
            System.out.println(minimizeEffort(n, k, firewalls));
51
        }
52
        53
        sc.close();
54
    }
55
}",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053881
1390053880,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053880
1390053882,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053882
1390053879,unknown,unknown,unknown,"1
import itertools
2
3
def solve():
4
    n, k = map(int, input().split())
5
    a = list(map(int, input().split()))
6
7
    min_effort = float('inf')
8
9
    for num_skips in range(k + 1):
10
        indices_to_skip_combinations = itertools.combinations(range(n), num_skips)
11
        for skip_indices_tuple in indices_to_skip_combinations:
12
            skip_indices = set(skip_indices_tuple)
13
            current_effort = 0
14
            for i in range(n):
15
                if i not in skip_indices:
16
                    strength_increase = 0
17
                    for skipped_index in skip_indices:
18
                        if skipped_index < i:
19
                            strength_increase += 1
20
                    current_effort += a[i] + strength_increase
21
            min_effort = min(min_effort, current_effort)
22
23
    print(min_effort)
24
25
26
t = int(input())
27
for _ in range(t):
28
    solve()
29
30",112,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053879
1390053874,unknown,unknown,unknown,"1
def solve():
2
3
    n, k = map(int, input().split())
4
5
    a = list(map(int, input().split()))
6
7
    min_effort = float('inf')
8
9
    for i in range(1 << n):
10
11
        skipped = []
12
13
        efforts = []
14
15
        for j in range(n):
16
17
            if (i >> j) & 1:
18
19
                skipped.append(j)
20
21
            else:
22
23
                efforts.append(j)
24
25
        if len(skipped) <= k:
26
27
            current_effort = 0
28
29
            skipped_count = 0
30
31
            for j in range(n):
32
33
                if j in skipped:
34
35
                    skipped_count += 1
36
37
                else:
38
39
                    current_effort += a[j] + skipped_count
40
41
            min_effort = min(min_effort, current_effort)
42
43
    print(min_effort)
44
45
t = int(input())
46
47
for _ in range(t):
48
49
    solve()
50
51",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053874
1390053875,unknown,unknown,unknown,"1
import bisect
2
3
t = int(input())
4
for _ in range(t):
5
    s = input().strip()
6
    n = len(s)
7
    8
    if n == 0:
9
        print(0)
10
        continue
11
    12
    if s == ""0"" or s == ""1"":
13
        print(0)
14
        continue
15
    16
    if s == ""00"" or s == ""11"":
17
        print(1)
18
        continue
19
    20
    prefix_0 = [0] * (n + 1)
21
    prefix_1 = [0] * (n + 1)
22
    for i in range(n):
23
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
24
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
25
    total_1 = prefix_1[n]
26
    27
    low, high = 0, n
28
    while low < high:
29
        m = (low + high) // 2
30
        possible = False
31
        for j in range(n + 1):
32
            target = prefix_0[j] - m
33
            i = bisect.bisect_left(prefix_0, target)
34
            if i <= j:
35
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
36
                if ones_removed <= m:
37
                    possible = True
38
                    break
39
        if possible:
40
            high = m
41
        else:
42
            low = m + 1
43
    print(low)",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053875
1390053877,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner sc = new Scanner(System.in);
8
        int T = sc.nextInt();
9
        while (T-- > 0) {
10
            String s = sc.next(); 
11
            System.out.println(minDecommissionCost(s));
12
        }
13
        sc.close();
14
    }
15
16
    private static int minDecommissionCost(String s) {
17
        int n = s.length();
18
        19
        int totalOnes = 0;
20
        for (int i = 0; i < n; i++) {
21
            if (s.charAt(i) == '1') totalOnes++;
22
        }
23
        24
        int minCost = Integer.MAX_VALUE;
25
        26
        for (int i = 0; i <= n; i++) {
27
            int prefixOnes = 0;
28
            for (int j = 0; j < i; j++) {
29
                if (s.charAt(j) == '1') prefixOnes++;
30
            }
31
            32
            for (int j = 0; j <= n - i; j++) {
33
                int suffixOnes = 0;
34
                for (int k = n - j; k < n; k++) {
35
                    if (s.charAt(k) == '1') suffixOnes++;
36
                }
37
                38
                int keptOnes = totalOnes - prefixOnes - suffixOnes;
39
                int keptLength = n - i - j;
40
                int keptZeros = keptLength - keptOnes;
41
                42
                int removedOnes = prefixOnes + suffixOnes;
43
                int cost = Math.max(keptZeros, removedOnes);
44
                45
                minCost = Math.min(minCost, cost);
46
            }
47
        }
48
        49
        return minCost;
50
    }
51
}",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053877
1390053867,unknown,unknown,unknown,"1
def minimize_effort():
2
    n, k = map(int, input().split())
3
    strengths = list(map(int, input().split()))
4
    5
    # Calculate the initial total effort
6
    total_effort = sum(strengths)
7
    8
    # Compute the penalty for skipping each firewall
9
    skip_penalty = [strengths[i] - (n - i - 1) for i in range(n)]
10
    11
    # Sort in descending order to prioritize the most beneficial skips
12
    skip_penalty.sort(reverse=True)
13
    14
    # Reduce effort by skipping up to k firewalls
15
    total_effort -= sum(skip_penalty[:k])
16
    17
    # Account for the incremental difficulty of later firewalls
18
    total_effort -= k * (k - 1) // 2
19
    20
    # Print the minimized effort
21
    print(total_effort)
22
23
if __name__ == ""__main__"":
24
    test_cases = int(input())
25
    for _ in range(test_cases):
26
        minimize_effort()
27",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053867
1390053872,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
8
    for _ in range(t):
9
        s = input_data[line].strip()
10
        line += 1
11
        n = len(s)
12
13
        # Get indices of active servers ('1')
14
        positions = [i for i, ch in enumerate(s) if ch == '1']
15
        m = len(positions)
16
17
        if m == 0:
18
            out_lines.append(""0"")
19
            continue
20
21
        # Precompute A: A[i] = positions[i] - i
22
        A = [positions[i] - i for i in range(m)]
23
24
        # Define the check function
25
        def check(X):
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                while j < m and A[j] - A[i] <= X:
33
                    j += 1
34
                if j - i >= m - X:
35
                    return True
36
            return False
37
38
        # Binary search for the minimum X
39
        lo, hi, ans = 0, n, n
40
        while lo <= hi:
41
            mid = (lo + hi) // 2
42
            if check(mid):
43
                ans = mid
44
                hi = mid - 1
45
            else:
46
                lo = mid + 1
47
48
        out_lines.append(str(ans))
49
50
    sys.stdout.write(""\n"".join(out_lines))
51
52
if __name__ == ""__main__"":
53
    solve()",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053872
1390053870,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerPruning {
4
    public static int minPruningCost(String serverRack) {
5
        int n = serverRack.length();
6
        int left = 0, right = n - 1;
7
8
        // Remove leading idle servers (0s)
9
        while (left <= right && serverRack.charAt(left) == '0') {
10
            left++;
11
        }
12
13
        // Remove trailing idle servers (0s)
14
        while (right >= left && serverRack.charAt(right) == '0') {
15
            right--;
16
        }
17
18
        // If no active servers remain
19
        if (left > right) return 0;
20
21
        // Count remaining idle servers
22
        int idleCount = 0;
23
        for (int i = left; i <= right; i++) {
24
            if (serverRack.charAt(i) == '0') {
25
                idleCount++;
26
            }
27
        }
28
29
        // Active servers removed
30
        int activeRemoved = left + (n - 1 - right);
31
32
        return Math.max(idleCount, activeRemoved);
33
    }
34
35
    public static void main(String[] args) {
36
        Scanner sc = new Scanner(System.in);
37
        int T = Integer.parseInt(sc.nextLine().trim());
38
39
        while (T-- > 0) {
40
            String serverRack = sc.nextLine().trim();
41
            System.out.println(minPruningCost(serverRack));
42
        }
43
        sc.close();
44
    }
45
}
46",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053870
1390053860,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int T = sc.nextInt();
8
        sc.nextLine(); 
9
        while (T-- > 0) {
10
            String s = sc.nextLine().trim();
11
            int n = s.length();
12
            int totalOnes = 0;
13
            int maxConsecutiveOnes = 0;
14
            int currentConsecutiveOnes = 0;
15
            16
            for (char c : s.toCharArray()) {
17
                if (c == '1') {
18
                    currentConsecutiveOnes++;
19
                    maxConsecutiveOnes = Math.max(maxConsecutiveOnes, currentConsecutiveOnes);
20
                    totalOnes++;
21
                } else {
22
                    currentConsecutiveOnes = 0;
23
                }
24
            }
25
            26
            if (totalOnes == 0) {
27
                System.out.println(0);
28
                continue;
29
            }
30
            if (maxConsecutiveOnes == totalOnes) {
31
                System.out.println(0);
32
                continue;
33
            }
34
            35
            int totalZeros = n - totalOnes;
36
            int low = 0;
37
            int high = Math.max(totalOnes, totalZeros);
38
            int answer = high;
39
            40
            while (low <= high) {
41
                int mid = (low + high) / 2;
42
                int requiredOnes = Math.max(0, totalOnes - mid);
43
                44
                if (requiredOnes == 0) {
45
                    answer = mid;
46
                    high = mid - 1;
47
                    continue;
48
                }
49
                50
                int maxOnes = maxOnesWithAtMostKZeros(s, mid);
51
                if (maxOnes >= requiredOnes) {
52
                    answer = mid;
53
                    high = mid - 1;
54
                } else {
55
                    low = mid + 1;
56
                }
57
            }
58
            59
            System.out.println(answer);
60
        }
61
        sc.close();
62
    }
63
    64
    private static int maxOnesWithAtMostKZeros(String s, int k) {
65
        int left = 0;
66
        int zeros = 0;
67
        int maxOnes = 0;
68
        int n = s.length();
69
        70
        for (int right = 0; right < n; right++) {
71
            if (s.charAt(right) == '0') {
72
                zeros++;
73
            }
74
           75
            while (zeros > k) {
76
                if (s.charAt(left) == '0') {
77
                    zeros--;
78
                }
79
                left++;
80
            }
81
           82
            int currentOnes = (right - left + 1) - zeros;
83
            maxOnes = Math.max(maxOnes, currentOnes);
84
        }
85
        86
        return maxOnes;
87
    }
88
}
89",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053860
1390053861,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    if k >= n:
3
        return 0
4
    return min(sum(firewalls[:i] + firewalls[i + k:]) + sum(range(1, k + 1)) * (n - i - k) for i in range(n - k + 1))
5
6
# Test cases
7
for _ in range(int(input())):
8
    n, k = map(int, input().split())
9
    firewalls = list(map(int, input().split()))
10
    print(min_effort_to_breach(n, k, firewalls))",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053861
1390053866,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053866
1390053859,unknown,unknown,unknown,"1
def optimize_server_decommissioning(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    5
    for start in range(n + 1):
6
        for end in range(n + 1):
7
            if start + end <= n:
8
                remaining = server_rack[start:n-end]
9
                10
                idle_remaining = remaining.count('0')
11
                12
                active_removed = 0
13
                for i in range(start):
14
                    if server_rack[i] == '1':
15
                        active_removed += 1
16
                for i in range(n-end, n):
17
                    if server_rack[i] == '1':
18
                        active_removed += 1
19
                20
                cost = max(idle_remaining, active_removed)
21
                min_cost = min(min_cost, cost)
22
    23
    return min_cost
24
25
def main():
26
    t = int(input())
27
    28
    for _ in range(t):
29
        server_rack = input().strip()
30
        result = optimize_server_decommissioning(server_rack)
31
        print(result)
32
33
if __name__ == ""__main__"":
34
    main()",113,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053859
1390053857,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053857
1390053858,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053858
1390053856,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053856
1390053849,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    ans = float('inf')
5
6
    # Precompute cumulative counts of '1's from the beginning
7
    cumulative_ones = [0] * (n + 1)
8
    for i in range(n):
9
        cumulative_ones[i + 1] = cumulative_ones[i] + (1 if s[i] == '1' else 0)
10
11
    for i in range(n + 1):
12
        for j in range(i, n + 1):
13
            zeros_remaining = 0
14
            for k in range(i, j):
15
                if s[k] == '0':
16
                    zeros_remaining += 1
17
            18
            ones_removed = cumulative_ones[i] + (cumulative_ones[n] - cumulative_ones[j])
19
            ans = min(ans, max(zeros_remaining, ones_removed))
20
21
    print(ans)
22
23
t = int(input())
24
for _ in range(t):
25
    solve()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053849
1390053850,unknown,unknown,unknown,"1
def minimize_effort(n, k, a):
2
    total_effort = sum(a)  # initial total effort without skipping
3
    benefits = []
4
5
    # Calculate the benefit of skipping each firewall:
6
    # benefit = a[i] - (n - i - 1)
7
    for i in range(n):
8
        benefit = a[i] - (n - i - 1)
9
        benefits.append(benefit)
10
11
    # Sort benefits in descending order to pick best k skips
12
    benefits.sort(reverse=True)
13
14
    # Reduce the effort by skipping the firewalls with highest benefits
15
    for i in range(k):
16
        total_effort -= benefits[i]
17
18
    # Add the penalty: skipping k firewalls increases strength of remaining by 1, 2, ..., k
19
    # The total penalty is the sum of first k natural numbers: k * (k - 1) // 2
20
    penalty = k * (k - 1) // 2
21
    total_effort += penalty
22
23
    return total_effort
24
25
26
# Driver code to handle multiple test cases
27
T = int(input())
28
for _ in range(T):
29
    n, k = map(int, input().split())
30
    a = list(map(int, input().split()))
31
    32
    result = minimize_effort(n, k, a)
33
    print(result)
34
35",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053850
1390053852,unknown,unknown,unknown,"1
def solve():
2
3
    import sys
4
5
    input_data = sys.stdin.read().splitlines()
6
7
    t = int(input_data[0].strip())
8
9
    line = 1
10
11
    out_lines = []
12
13
    for _ in range(t):
14
15
        s = input_data[line].strip()
16
17
        line += 1
18
19
        n = len(s)
20
21
        # get indices for active servers ('1')
22
23
        positions = [i for i, ch in enumerate(s) if ch == '1']
24
25
        m = len(positions)
26
27
        if m == 0:
28
29
            out_lines.append(""0"")
30
31
            continue
32
33
        # Precompute A: A[i] = positions[i] - i
34
35
        A = [positions[i] - i for i in range(m)]
36
37
        38
39
        # check(X) returns True if there exists a window in A
40
41
        # such that:
42
43
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
44
45
        # and A[j] - A[i] <= X.
46
47
        def check(X):
48
49
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
50
51
            if m - X <= 0:
52
53
                return True
54
55
            j = 0
56
57
            for i in range(m):
58
59
                if j < i:
60
61
                    j = i
62
63
                # slide j as far as possible while A[j]-A[i] <= X
64
65
                while j < m and A[j] - A[i] <= X:
66
67
                    j += 1
68
69
                # j now is one past the last index satisfying condition, so the window has length (j - i)
70
71
                if j - i >= m - X:
72
73
                    return True
74
75
            return False
76
77
        # Binary search for the minimum X
78
79
        lo, hi, ans = 0, n, n
80
81
        while lo <= hi:
82
83
            mid = (lo + hi) // 2
84
85
            if check(mid):
86
87
                ans = mid
88
89
                hi = mid - 1
90
91
            else:
92
93
                lo = mid + 1
94
95
        out_lines.append(str(ans))
96
97
    98
99
    sys.stdout.write(""\n"".join(out_lines))
100
101
    102
103
if __name__ == '__main__':
104
105
    solve()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053852
1390053846,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053846
1390053847,unknown,unknown,unknown,"1
# Read number of test cases
2
t = int(input().strip())
3
4
for _ in range(t):
5
    # Read server string
6
    servers = input().strip()
7
    n = len(servers)
8
    9
    # Precompute prefix and suffix sums
10
    prefix_active = [0] * (n + 1)  # active[0:i]
11
    prefix_idle = [0] * (n + 1)    # idle[0:i]
12
    13
    for i in range(n):
14
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
15
        prefix_idle[i + 1] = prefix_idle[i] + (1 if servers[i] == '0' else 0)
16
    17
    total_active = prefix_active[n]
18
    total_idle = prefix_idle[n]
19
    20
    min_cost = n  # Initialize with worst case
21
    22
    # For each possible left cut point
23
    for left in range(n + 1):
24
        # Calculate active servers removed from left
25
        active_removed_left = prefix_active[left]
26
        27
        # Find the optimal right cut point for this left cut
28
        # Key insight: As we move the right boundary left, we:
29
        # 1. Remove more active servers from the right
30
        # 2. Reduce the number of idle servers remaining
31
        32
        # Binary search to find optimal right point would be ideal,
33
        # but we can solve this in O(n) by checking each right point
34
        35
        for right in range(n, left - 1, -1):
36
            active_removed_right = total_active - prefix_active[right]
37
            active_removed_total = active_removed_left + active_removed_right
38
            idle_remaining = prefix_idle[right] - prefix_idle[left]
39
            40
            cost = max(idle_remaining, active_removed_total)
41
            min_cost = min(min_cost, cost)
42
            43
            # Important optimization: If removing more from right increases cost,
44
            # no need to continue checking more right cuts for this left cut
45
            if active_removed_right >= idle_remaining:
46
                break
47
    48
    print(min_cost)",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053847
1390053848,unknown,unknown,unknown,"1
2
import sys
3
4
def main():
5
    input = sys.stdin.read().split()
6
    idx = 0
7
    T = int(input[idx])
8
    idx += 1
9
    for _ in range(T):
10
        n, k = int(input[idx]), int(input[idx + 1])
11
        idx += 2
12
        a = list(map(int, input[idx:idx + n]))
13
        idx += n
14
        15
        sum_S = sum(a)
16
        # Compute a[i] + i (0-based)
17
        values = [a[i] + i for i in range(n)]
18
        # Sort in descending order
19
        values.sort(reverse=True)
20
        sum_aj_plus_j = sum(values[:k])
21
        # Compute the result
22
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
23
        print(res)
24
25
main()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053848
1390053843,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    skipped = [False] * n
6
    7
    temp_a = a[:]
8
    for _ in range(k):
9
        max_val = -1
10
        max_idx = -1
11
        for i in range(n):
12
            if not skipped[i] and temp_a[i] > max_val:
13
                max_val = temp_a[i]
14
                max_idx = i
15
        if max_idx != -1:
16
            skipped[max_idx] = True
17
            temp_a[max_idx] = -1
18
19
    if k == n:
20
        print(0)
21
        return
22
23
    effort = 0
24
    skipped_count = 0
25
    26
    for i in range(n):
27
        if skipped[i]:
28
            skipped_count += 1
29
        else:
30
            effort += a[i] + skipped_count
31
32
    print(effort)
33
34
t = int(input())
35
for _ in range(t):
36
    solve()",114,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053843
1390053837,unknown,unknown,unknown,"1
import java.io.BufferedReader;
2
import java.io.IOException;
3
import java.io.InputStreamReader;
4
import java.io.PrintWriter;
5
6
class Solution {
7
    public static void main(String[] args) throws IOException {
8
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
9
        PrintWriter pw = new PrintWriter(System.out);
10
11
        int t = Integer.parseInt(br.readLine());
12
        while (t-- > 0) {
13
            String serverRack = br.readLine().trim();
14
            pw.println(minPruningCost(serverRack));
15
        }
16
17
        pw.close();
18
        br.close();
19
    }
20
21
    public static int minPruningCost(String serverRack) {
22
        int n = serverRack.length();
23
        int minCost = n + 1; // Initialize with a value larger than any possible cost
24
25
        for (int leftRemoveCount = 0; leftRemoveCount <= n; ++leftRemoveCount) {
26
            for (int rightRemoveCount = 0; rightRemoveCount <= n - leftRemoveCount; ++rightRemoveCount) {
27
                int idleRemaining = 0;
28
                int activeRemoved = 0;
29
30
                // Calculate activeRemoved servers
31
                for (int i = 0; i < leftRemoveCount; ++i) {
32
                    if (serverRack.charAt(i) == '1') {
33
                        activeRemoved++;
34
                    }
35
                }
36
                for (int i = n - rightRemoveCount; i < n; ++i) {
37
                    if (serverRack.charAt(i) == '1') {
38
                        activeRemoved++;
39
                    }
40
                }
41
42
                // Calculate idleRemaining servers
43
                for (int i = leftRemoveCount; i < n - rightRemoveCount; ++i) {
44
                    if (serverRack.charAt(i) == '0') {
45
                        idleRemaining++;
46
                    }
47
                }
48
49
                int cost = Math.max(idleRemaining, activeRemoved);
50
                minCost = Math.min(minCost, cost);
51
            }
52
        }
53
        return minCost;
54
    }
55
}",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053837
1390053839,unknown,unknown,unknown,"1
def bf(arr, k):
2
    if k==0:
3
        return sum(arr)
4
    elif k >= len(arr):
5
        return 0
6
    else:
7
        arr.sort(reverse=True)
8
        return sum(arr[k:])+1
9
10
t = int(input())
11
for _ in range(t):
12
    n, k = map(int, input().split())
13
    arr = list(map(int, input().split()))
14
    print(bf(arr, k))
15",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053839
1390053842,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
     public static void main(String[] args) {
7
        Scanner input = new Scanner(System.in);
8
        int testCases = input.nextInt();
9
10
        while (testCases-- > 0) {
11
            int size = input.nextInt();
12
            int limit = input.nextInt();
13
            int[] elements = new int[size];
14
            long totalSum = 0;
15
16
            for (int i = 0; i < size; i++) {
17
                elements[i] = input.nextInt();
18
                totalSum += elements[i];
19
            }
20
21
            List<Long> adjustedValues = new ArrayList<>();
22
            for (int i = 0; i < size; i++) {
23
                long value = elements[i] - (size - i - 1L);
24
                adjustedValues.add(value);
25
            }
26
27
            adjustedValues.sort((a, b) -> Long.compare(b, a));
28
29
            long[] prefixSum = new long[size + 1];
30
            for (int i = 1; i <= size; i++) {
31
                prefixSum[i] = prefixSum[i - 1] + adjustedValues.get(i - 1);
32
            }
33
34
            int maxOperations = Math.min(limit, size);
35
            long highestSum = Long.MIN_VALUE;
36
37
            for (int ops = 0; ops <= maxOperations; ops++) {
38
                long currentSum = prefixSum[ops] + ((long) ops * (ops - 1)) / 2;
39
                if (currentSum > highestSum) {
40
                    highestSum = currentSum;
41
                }
42
            }
43
44
            long minEffort = totalSum - highestSum;
45
            System.out.println(minEffort);
46
        }
47
48
        input.close();
49
    }
50
}",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053842
1390053833,unknown,unknown,unknown,"1
def min_decommissioning_cost(t, test_cases):
2
    results = []
3
    for s in test_cases:
4
        # Find the first and last occurrence of '1'
5
        first_one = s.find('1')
6
        last_one = s.rfind('1')
7
        8
        # If there are no '1's, we can remove everything
9
        if first_one == -1:
10
            results.append(0)
11
            continue
12
        13
        # Extract the relevant portion of the string
14
        trimmed = s[first_one:last_one+1]
15
        16
        # Count remaining idle (0's) and removed active (1's)
17
        idle_remaining = trimmed.count('0')
18
        active_removed = first_one + (len(s) - 1 - last_one)
19
        20
        # Compute minimum cost
21
        results.append(max(idle_remaining, active_removed))
22
    23
    return results
24
25
# Read input
26
t = int(input().strip())
27
test_cases = [input().strip() for _ in range(t)]
28
29
# Compute and print results
30
for res in min_decommissioning_cost(t, test_cases):
31
    print(res)",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053833
1390053835,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36
37",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053835
1390053834,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    min_cost = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            remaining = s[i:n-j]
10
            11
            idle_count = remaining.count('0')
12
            removed_count = s[:i].count('1') + s[n-j:].count('1')
13
            14
            cost = max(idle_count, removed_count)
15
            min_cost = min(min_cost, cost)
16
            17
    print(min_cost)
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053834
1390053827,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053827
1390053829,unknown,unknown,unknown,"1
def minimize_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
4
    skip_value = []
5
    for i in range(n):
6
        skip_value.append((firewalls[i] + i, i))
7
8
    skip_value.sort(reverse=True)
9
    skipped = [0] * n
10
    for i in range(k):
11
        _, idx = skip_value[i]
12
        skipped[idx] = 1
13
14
    effort = 0
15
    penalty = 0
16
    for i in range(n):
17
        if skipped[i]:
18
            penalty += 1
19
        else:
20
            effort += firewalls[i] + penalty
21
22
    return effort
23
24
T = int(input())
25
for _ in range(T):
26
    n, k = map(int, input().split())
27
    firewalls = list(map(int, input().split()))
28
    print(minimize_effort(n, k, firewalls))",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053829
1390053832,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
        # get indices for active servers ('1')
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        # Precompute A: A[i] = positions[i] - i
18
        A = [positions[i] - i for i in range(m)]
19
        20
        # check(X) returns True if there exists a window in A
21
        # such that:
22
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
23
        # and A[j] - A[i] <= X.
24
        def check(X):
25
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                # slide j as far as possible while A[j]-A[i] <= X
33
                while j < m and A[j] - A[i] <= X:
34
                    j += 1
35
                # j now is one past the last index satisfying condition, so the window has length (j - i)
36
                if j - i >= m - X:
37
                    return True
38
            return False
39
40
        # Binary search for the minimum X
41
        lo, hi, ans = 0, n, n
42
        while lo <= hi:
43
            mid = (lo + hi) // 2
44
            if check(mid):
45
                ans = mid
46
                hi = mid - 1
47
            else:
48
                lo = mid + 1
49
        out_lines.append(str(ans))
50
    51
    sys.stdout.write(""\n"".join(out_lines))
52
    53
if __name__ == '__main__':
54
    solve()",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053832
1390053826,unknown,unknown,unknown,"1
def min_decommission_cost(T, test_cases):
2
    results = []
3
4
    for binary_string in test_cases:
5
        # Find the first and last occurrence of '1'
6
        first_one = binary_string.find('1')
7
        last_one = binary_string.rfind('1')
8
9
        if first_one == -1:  # No '1's in the string (only idle servers)
10
            results.append(""0"")
11
            continue
12
13
        # Extract the core section between the first and last '1'
14
        trimmed_section = binary_string[first_one:last_one + 1]
15
16
        # Count idle servers (0s) left inside the active range
17
        idle_servers_left = trimmed_section.count('0')
18
19
        # Count active servers (1s) removed before first and after last '1'
20
        active_servers_removed = binary_string[:first_one].count('1') + binary_string[last_one + 1:].count('1')
21
22
        # The final cost is max(idle servers left, active servers removed)
23
        results.append(str(max(idle_servers_left, active_servers_removed)))
24
25
    print(""\n"".join(results))
26
27
28
# Read input
29
T = int(input().strip())  # Number of test cases
30
test_cases = [input().strip() for _ in range(T)]  # Read all test cases
31
32
# Run the function
33
min_decommission_cost(T, test_cases)
34
35
36
37
38",115,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053826
1390053822,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053822
1390053824,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053824
1390053825,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053825
1390053814,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FirewallMinEffort {
4
    5
    public static long minimizeEffort(int n, int k, int[] firewalls) {
6
        long totalEffort = 0;
7
        8
        // Create a list of pairs (value + index, index)
9
        List<int[]> skipValue = new ArrayList<>();
10
        for (int i = 0; i < n; i++) {
11
            skipValue.add(new int[]{firewalls[i] + i, i});
12
        }
13
14
        // Sort by descending benefit to skip
15
        skipValue.sort((a, b) -> Integer.compare(b[0], a[0]));
16
17
        // Mark which firewalls to skip
18
        boolean[] skipped = new boolean[n];
19
        for (int i = 0; i < k; i++) {
20
            skipped[skipValue.get(i)[1]] = true;
21
        }
22
23
        // Calculate final effort
24
        long effort = 0;
25
        int penalty = 0;
26
        for (int i = 0; i < n; i++) {
27
            if (skipped[i]) {
28
                penalty++;
29
            } else {
30
                effort += firewalls[i] + penalty;
31
            }
32
        }
33
34
        return effort;
35
    }
36
37
    public static void main(String[] args) {
38
        Scanner sc = new Scanner(System.in);
39
        40
        int T = sc.nextInt();
41
        while (T-- > 0) {
42
            int n = sc.nextInt();
43
            int k = sc.nextInt();
44
            int[] firewalls = new int[n];
45
46
            for (int i = 0; i < n; i++) {
47
                firewalls[i] = sc.nextInt();
48
            }
49
50
            System.out.println(minimizeEffort(n, k, firewalls));
51
        }
52
        53
        sc.close();
54
    }
55
}",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053814
1390053816,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
        # get indices for active servers ('1')
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        # Precompute A: A[i] = positions[i] - i
18
        A = [positions[i] - i for i in range(m)]
19
        20
        # check(X) returns True if there exists a window in A
21
        # such that:
22
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
23
        # and A[j] - A[i] <= X.
24
        def check(X):
25
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                # slide j as far as possible while A[j]-A[i] <= X
33
                while j < m and A[j] - A[i] <= X:
34
                    j += 1
35
                # j now is one past the last index satisfying condition, so the window has length (j - i)
36
                if j - i >= m - X:
37
                    return True
38
            return False
39
40
        # Binary search for the minimum X
41
        lo, hi, ans = 0, n, n
42
        while lo <= hi:
43
            mid = (lo + hi) // 2
44
            if check(mid):
45
                ans = mid
46
                hi = mid - 1
47
            else:
48
                lo = mid + 1
49
        out_lines.append(str(ans))
50
    51
    sys.stdout.write(""\n"".join(out_lines))
52
    53
if _name_ == '_main_':
54
    solve()",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053816
1390053815,unknown,unknown,unknown,"1
def min_decommission_cost(s):
2
    n = len(s)
3
    4
    start, end = 0, n - 1
5
    while start < n and s[start] == '0':
6
        start += 1
7
    while end >= 0 and s[end] == '0':
8
        end -= 1
9
    10
    if start > end:
11
        return 0
12
    13
    trimmed = s[start:end+1]
14
    remaining_idle = trimmed.count('0')
15
16
    min_cost = remaining_idle
17
    ones_removed = 0
18
19
    for i in range(start, end + 1):
20
        if s[i] == '1':
21
            ones_removed += 1
22
        else:
23
            remaining_idle -= 1
24
    25
        cost = max(remaining_idle, ones_removed)
26
        min_cost = min(min_cost, cost)
27
28
    return min_cost
29
30
T = int(input())
31
for _ in range(T):
32
    s = input().strip()
33
    print(min_decommission_cost(s))
34",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053815
1390053810,unknown,unknown,unknown,"1
def minimum_decommission_cost(server_rack):
2
    n = len(server_rack)
3
    total_ones = server_rack.count('1')
4
    minimum_cost = float('inf')
5
    6
    prefix_ones = [0] * (n + 1)
7
    prefix_zeros = [0] * (n + 1)
8
    9
    for i in range(n):
10
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_rack[i] == '1' else 0)
11
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_rack[i] == '0' else 0)
12
    13
    for left in range(n + 1):
14
        for right in range(left, n + 1):
15
            ones_in_substring = prefix_ones[right] - prefix_ones[left]
16
            zeros_in_substring = prefix_zeros[right] - prefix_zeros[left]
17
            ones_removed = total_ones - ones_in_substring
18
            cost = max(zeros_in_substring, ones_removed)
19
            if cost < minimum_cost:
20
                minimum_cost = cost
21
    22
    return minimum_cost
23
24
T = int(input())
25
for _ in range(T):
26
    server_rack = input().strip()
27
    print(minimum_decommission_cost(server_rack))",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053810
1390053811,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
4
using namespace std;
5
6
vector<int> findEarliestFaultyReadings(const vector<int>& arr, int k) {
7
    vector<int> result;
8
    int n = arr.size();
9
    for (int i = 0; i <= n - k; ++i) {
10
        bool foundFault = false;
11
        for (int j = i; j < i + k; ++j) {
12
            if (arr[j] < 0) {
13
                result.push_back(arr[j]);
14
                foundFault = true;
15
                break;
16
            }
17
        }
18
        if (!foundFault) {
19
            result.push_back(0);
20
        }
21
    }
22
    return result;
23
}
24
25
int main() {
26
    int t;
27
    cin >> t;
28
    while (t--) {
29
        int n, k;
30
        cin >> n >> k;
31
        vector<int> arr(n);
32
        for (int i = 0; i < n; ++i) {
33
            cin >> arr[i];
34
        }
35
        vector<int> result = findEarliestFaultyReadings(arr, k);
36
        for (int val : result) {
37
            cout << val << "" "";
38
        }
39
        cout << endl;
40
    }
41
    return 0;
42
}",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053811
1390053813,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    s = input().strip()
4
    n = len(s)
5
6
    a = [0] * (n + 1)
7
    for i in range(n):
8
        a[i + 1] = a[i] + (1 if s[i] == ""1"" else 0)
9
10
    c = float(""inf"")
11
12
    for i in range(n + 1):
13
        b = a[i]
14
        l, r = 0, n - i
15
16
        while l <= r:
17
            j = (l + r) // 2
18
            x = n - i - j
19
            y = a[n] - a[i] - (a[n] - a[n - j])
20
            z = x - y
21
            d = b + (a[n] - a[n - j])
22
            e = max(z, d)
23
            c = min(c, e)
24
25
            if z > d:
26
                l = j + 1
27
            else:
28
                r = j - 1
29
30
    print(c)
31",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053813
1390053809,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(len(arr)):
8
        if dq and dq[0] < i - k + 1:
9
            dq.popleft()
10
        11
        if arr[i] < 0:
12
            dq.append(i)
13
        14
        if i >= k - 1:
15
            result.append(arr[dq[0]] if dq else 0)
16
    17
    return result
18
19
def main():
20
    t = int(input()) 
21
    22
    for _ in range(t):
23
        n, k = map(int, input().split())  
24
        arr = list(map(int, input().split()))
25
        26
        output = earliest_faulty_readings(arr, k)
27
        print("" "".join(map(str, output)))
28
29
if __name__ == ""__main__"":
30
    main()",116,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053809
1390053801,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    if k >= n:
3
        return 0
4
5
    min_effort = sum(firewalls)
6
    7
    for i in range(n):
8
        temp_firewalls = firewalls[:]
9
        temp_firewalls[i] = 0
10
        11
        for j in range(i + 1, n):
12
            temp_firewalls[j] += 1
13
        14
        min_effort = min(min_effort, sum(temp_firewalls))
15
16
    return min_effort
17
18
T = int(input())
19
for _ in range(T):
20
    n, k = map(int, input().split())
21
    firewalls = list(map(int, input().split()))
22
    print(min_effort_to_breach(n, k, firewalls))
23",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053801
1390053806,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()
74",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053806
1390053808,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FirewallEffort {
4
    public static int findMinimumEffort(int[] arr, int k) {
5
        int totalEffort = Arrays.stream(arr).sum();
6
        int minEffort = totalEffort;
7
        8
        int windowSum = 0;
9
        for (int i = 0; i < k; i++) {
10
            windowSum += arr[i];
11
        }
12
        minEffort = Math.min(minEffort, totalEffort - windowSum);
13
        14
        for (int i = k; i < arr.length; i++) {
15
            windowSum += arr[i] - arr[i - k];
16
            minEffort = Math.min(minEffort, totalEffort - windowSum);
17
        }
18
        19
        return minEffort;
20
    }
21
22
    public static void main(String[] args) {
23
        Scanner scanner = new Scanner(System.in);
24
        int t = scanner.nextInt();
25
        26
        while (t-- > 0) {
27
            int n = scanner.nextInt();
28
            int k = scanner.nextInt();
29
            int[] arr = new int[n];
30
            31
            for (int i = 0; i < n; i++) {
32
                arr[i] = scanner.nextInt();
33
            }
34
            35
            System.out.println(findMinimumEffort(arr, k));
36
        }
37
        38
        scanner.close();
39
    }
40
}
41",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053808
1390053800,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        Scanner scanner = new Scanner(System.in);
11
        int t = scanner.nextInt(); 
12
13
        while (t-- > 0) {
14
            int n = scanner.nextInt(); 
15
            int k = scanner.nextInt(); 
16
            int[] arr = new int[n];
17
18
            for (int i = 0; i < n; i++) {
19
                arr[i] = scanner.nextInt();
20
            }
21
22
            List<Integer> ans = findResult(arr, k);
23
24
            for (int num : ans) {
25
                System.out.print(num + "" "");
26
            }
27
            System.out.println();
28
        }
29
        scanner.close();
30
     31
    }
32
    public static List<Integer> findResult(int []arr, int k){
33
        List<Integer> ans = new ArrayList<Integer>();
34
        Deque<Integer> deque = new LinkedList<>();
35
        36
        for(int i =0;i<k;i++){
37
            if(arr[i]<0){
38
            deque.addLast(i);
39
            }
40
        }
41
        if(!deque.isEmpty()){
42
            ans.add(arr[deque.peekFirst()]);
43
        }else{
44
            ans.add(0);
45
        }
46
        for(int i=k;i<arr.length;i++){
47
            if(!deque.isEmpty()&&deque.peekFirst()<=i-k){
48
                deque.pollFirst();
49
            }
50
            if(arr[i]<0){
51
            deque.addLast(i);
52
            }
53
            if(!deque.isEmpty()){
54
                ans.add(arr[deque.peekFirst()]);
55
            }else{
56
                ans.add(0);
57
            }
58
        }
59
        60
        61
        return ans;
62
     63
    }
64
}",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053800
1390053790,unknown,unknown,unknown,"1
def f(a, k):
2
3
    r = []
4
5
    n = len(a)
6
7
    for i in range(n - k + 1):
8
9
        b = a[i:i + k]
10
11
        f = next((x for x in b if x < 0), 0)  # Pick first negative, else 0
12
13
        r.append(f)
14
15
    return r
16
17
18
t = int(input())
19
20
for _ in range(t):
21
22
    n, k = map(int, input().split())
23
24
    a = list(map(int, input().split()))
25
26
    print(*f(a, k))",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053790
1390053791,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053791
1390053794,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
    public static List<Integer> earliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>();
7
8
        for (int i = 0; i < arr.length; i++) {
9
            // Remove out-of-window elements
10
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
11
                deque.poll();
12
            }
13
14
            // Add new faulty readings
15
            if (arr[i] < 0) {
16
                deque.offer(i);
17
            }
18
19
            // Collect results for valid windows
20
            if (i >= k - 1) {
21
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
22
            }
23
        }
24
        return result;
25
    }
26
27
    public static void main(String[] args) {
28
        Scanner scanner = new Scanner(System.in);
29
        int t = scanner.nextInt(); // Number of test cases
30
31
        while (t-- > 0) {
32
            int n = scanner.nextInt(); // Array size
33
            int k = scanner.nextInt(); // Batch size
34
            int[] arr = new int[n];
35
36
            for (int i = 0; i < n; i++) {
37
                arr[i] = scanner.nextInt();
38
            }
39
40
            // Compute and print results
41
            List<Integer> faults = earliestFaults(arr, k);
42
            for (int val : faults) {
43
                System.out.print(val + "" "");
44
            }
45
            System.out.println();
46
        }
47
        scanner.close();
48
    }
49
}",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053794
1390053789,unknown,unknown,unknown,"1
import bisect
2
3
t = int(input())
4
for _ in range(t):
5
    s = input().strip()
6
    n = len(s)
7
    8
    prefix_0 = [0] * (n + 1)  
9
    prefix_1 = [0] * (n + 1)  
10
    for i in range(n):
11
        prefix_0[i + 1] = prefix_0[i] + (1 if s[i] == '0' else 0)
12
        prefix_1[i + 1] = prefix_1[i] + (1 if s[i] == '1' else 0)
13
    total_1 = prefix_1[n]  
14
    15
    low, high = 0, n
16
    while low < high:
17
        m = (low + high) // 2  
18
        possible = False
19
        for j in range(n + 1):
20
            target = prefix_0[j] - m
21
            i = bisect.bisect_left(prefix_0, target)
22
            if i <= j:
23
                ones_removed = prefix_1[i] + (total_1 - prefix_1[j])
24
                if ones_removed <= m:
25
                    possible = True
26
                    break
27
        if possible:
28
            high = m  
29
        else:
30
            low = m + 1 
31
    print(low)",117,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053789
1390053779,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls using exactly j skips
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    # Calculate strength increments for each position based on previous skips
11
    for i in range(1, n + 1):
12
        for j in range(k + 1):
13
            # If we can skip this firewall
14
            if j > 0:
15
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
16
            17
            # If we don't skip this firewall
18
            if j <= k:  # We've used j skips so far
19
                # The strength increases by the number of previous skips
20
                current_strength = strengths[i-1]
21
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
22
    23
    # Find minimum effort among all possible numbers of skips
24
    return min(dp[n])
25
26
t = int(input())
27
for _ in range(t):
28
    n, k = map(int, input().split())
29
    strengths = list(map(int, input().split()))
30
    print(min_effort_to_breach(n, k, strengths))",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053779
1390053784,unknown,unknown,unknown,"1
cases = int(input())
2
for t in range(cases):
3
    n,k = [int(i) for i in input().split()]
4
    array = [int(i) for i in input().split()]
5
    if n == k:
6
        print(0)
7
        continue
8
    batch_sum = [0]*n
9
    for i in range(n):
10
        batch_sum[i] = sum(array[i:i+k])
11
    total = sum(array)
12
    best = total
13
    for i in range(n):
14
        best = min(best, total -batch_sum[i] + n-i-1)
15
    print(best)
16
        17
        18
    19
    20
    21
    22
    ",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053784
1390053780,unknown,unknown,unknown,"1
def min_server_decommission_cost(binary_str):
2
    # Step 1: Trim leading and trailing '0's
3
    trimmed_str = binary_str.strip('0')
4
5
    # If there are no '1's left after trimming, cost is 0
6
    if '1' not in trimmed_str:
7
        return 0
8
9
    # Step 2: Count remaining '0's in between
10
    idle_servers_left = trimmed_str.count('0')
11
12
    # Step 3: Try removing active servers ('1's) optimally
13
    active_servers_removed = binary_str.count('1') - trimmed_str.count('1')
14
15
    # Step 4: Compute minimum possible cost
16
    return max(idle_servers_left, active_servers_removed)
17
18
# Read input
19
t = int(input().strip())  # Number of test cases
20
for _ in range(t):
21
    binary_str = input().strip()
22
    print(min_server_decommission_cost(binary_str))
23",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053780
1390053775,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
8
    for i in range(n):
9
        if dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
12
        if arr[i] < 0:
13
            dq.append(i)
14
15
        if i >= k - 1:
16
            result.append(arr[dq[0]] if dq else 0)
17
18
    return result
19
20
t = int(input())
21
for _ in range(t):
22
    n, k = map(int, input().split())
23
    arr = list(map(int, input().split()))
24
    print(*earliest_faulty_readings(arr, k))
25",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053775
1390053777,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053777
1390053778,unknown,unknown,unknown,"1
def minimum_effort(test_cases, data):
2
    results = []
3
    for case in range(test_cases):
4
        n, k = data[case][0]
5
        firewalls = data[case][1]
6
        total_effort = sum(firewalls)
7
        8
        if k == n:
9
            results.append(""0"")
10
            continue
11
        12
        min_effort = total_effort
13
        for i in range(n):
14
            skipped_effort = total_effort - firewalls[i] + (n - 1) * 1
15
            min_effort = min(min_effort, skipped_effort)
16
        17
        results.append(str(min_effort))
18
    19
    return ""\n"".join(results)
20
21
# Reading input
22
t = int(input())
23
data = []
24
for _ in range(t):
25
    n, k = map(int, input().split())
26
    firewalls = list(map(int, input().split()))
27
    data.append(((n, k), firewalls))
28
29
# Processing and printing output
30
print(minimum_effort(t, data))
31",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053778
1390053767,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
5
    dp = [float('inf')] * (k + 1)
6
    dp[0] = 0
7
8
    for i in range(1, n + 1):
9
        for j in range(min(k, i), -1, -1):
10
            if j <= i - 1:
11
                dp[j] = min(dp[j], dp[j] + strengths[i - 1] + j)
12
            if j > 0:
13
                dp[j] = min(dp[j], dp[j - 1])
14
15
    return dp[k]
16
17
def solve():
18
    t = int(input())
19
    for _ in range(t):
20
        n, k = map(int, input().split())
21
        strengths = list(map(int, input().split()))
22
        if k >= n:
23
            print(0)
24
        else:
25
            print(min_effort_to_breach(n, k, strengths))
26
27
solve()",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053767
1390053772,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n, k = test_cases[t][0]  # Read n and k
6
        firewalls = test_cases[t][1]  # Read firewall strengths
7
        8
        # Sort firewalls based on strength, keeping track of original indices
9
        sorted_indices = sorted(range(n), key=lambda i: -firewalls[i])
10
11
        # Mark `k` strongest firewalls as skipped
12
        skipped = set(sorted_indices[:k])
13
14
        total_effort = 0
15
        increment = 0  # Tracks how many times subsequent firewalls increase
16
17
        for i in range(n):
18
            if i in skipped:
19
                increment += 1  # Since we skipped this firewall, increase effect on next
20
            else:
21
                total_effort += firewalls[i] + increment  # Add effort with increments
22
23
        results.append(total_effort)
24
    25
    return results
26
27
28
# Reading input
29
T = int(input().strip())  
30
test_cases = []
31
32
for _ in range(T):
33
    n, k = map(int, input().strip().split())  
34
    firewalls = list(map(int, input().strip().split()))  
35
    test_cases.append(((n, k), firewalls))
36
37
# Get results
38
output = min_effort_to_breach(T, test_cases)
39
40
# Print results
41
for res in output:
42
    print(res)
43",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053772
1390053774,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt(); 
7
        8
        while (T-- > 0) {
9
            String rack = sc.next();  // Binary string representing server rack
10
            11
            int n = rack.length();
12
            int[] servers = new int[n];
13
            for (int i = 0; i < n; i++) {
14
                servers[i] = rack.charAt(i) - '0';  // Convert string to int array
15
            }
16
            17
            int minCost = n;  // Maximum possible cost is n (if no decommissioning)
18
            19
            // Try all possible left and right cuts
20
            for (int left = 0; left <= n; left++) {
21
                for (int right = 0; left + right <= n; right++) {
22
                    int remainingIdle = 0;
23
                    int decommissionedActive = 0;
24
                    25
                    // Count remaining idle servers and decommissioned active servers
26
                    for (int i = left; i < n - right; i++) {
27
                        if (servers[i] == 0) remainingIdle++;
28
                    }
29
                    for (int i = 0; i < left; i++) {
30
                        if (servers[i] == 1) decommissionedActive++;
31
                    }
32
                    for (int i = n - right; i < n; i++) {
33
                        if (servers[i] == 1) decommissionedActive++;
34
                    }
35
                    36
                    // Cost is maximum of remaining idle and decommissioned active
37
                    int cost = Math.max(remainingIdle, decommissionedActive);
38
                    minCost = Math.min(minCost, cost);
39
                }
40
            }
41
            42
            System.out.println(minCost);
43
        }
44
        45
        sc.close();
46
    }
47
}",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053774
1390053766,unknown,unknown,unknown,"1
def solve():
2
    import sys
3
    input_data = sys.stdin.read().splitlines()
4
    t = int(input_data[0].strip())
5
    line = 1
6
    out_lines = []
7
    for _ in range(t):
8
        s = input_data[line].strip()
9
        line += 1
10
        n = len(s)
11
        # get indices for active servers ('1')
12
        positions = [i for i, ch in enumerate(s) if ch == '1']
13
        m = len(positions)
14
        if m == 0:
15
            out_lines.append(""0"")
16
            continue
17
        # Precompute A: A[i] = positions[i] - i
18
        A = [positions[i] - i for i in range(m)]
19
        20
        # check(X) returns True if there exists a window in A
21
        # such that:
22
        #    window length >= m - X   (i.e. j - i + 1 >= m - X)
23
        # and A[j] - A[i] <= X.
24
        def check(X):
25
            # if m - X <= 0, we can keep fewer than 1 one (so automatically ok)
26
            if m - X <= 0:
27
                return True
28
            j = 0
29
            for i in range(m):
30
                if j < i:
31
                    j = i
32
                # slide j as far as possible while A[j]-A[i] <= X
33
                while j < m and A[j] - A[i] <= X:
34
                    j += 1
35
                # j now is one past the last index satisfying condition, so the window has length (j - i)
36
                if j - i >= m - X:
37
                    return True
38
            return False
39
40
        # Binary search for the minimum X
41
        lo, hi, ans = 0, n, n
42
        while lo <= hi:
43
            mid = (lo + hi) // 2
44
            if check(mid):
45
                ans = mid
46
                hi = mid - 1
47
            else:
48
                lo = mid + 1
49
        out_lines.append(str(ans))
50
    51
    sys.stdout.write(""\n"".join(out_lines))
52
    53
if __name__ == '__main__':
54
    solve()
55",118,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053766
1390053762,unknown,unknown,unknown,"1
def minimize_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    4
    # Create list of (value + index) for each firewall
5
    skip_value = []
6
    for i in range(n):
7
        skip_value.append((firewalls[i] + i, i))
8
9
    # Sort by descending benefit to skip
10
    skip_value.sort(reverse=True)
11
12
    # Mark which firewalls to skip
13
    skipped = [0] * n
14
    for i in range(k):
15
        _, idx = skip_value[i]
16
        skipped[idx] = 1
17
18
    # Now calculate final effort
19
    effort = 0
20
    penalty = 0
21
    for i in range(n):
22
        if skipped[i]:
23
            penalty += 1
24
        else:
25
            effort += firewalls[i] + penalty
26
27
    return effort
28
29
# Main driver
30
T = int(input())
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    firewalls = list(map(int, input().split()))
34
    print(minimize_effort(n, k, firewalls))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053762
1390053763,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        min_cost = float('inf')
7
        8
        # Iterate over all possible prefixes to remove
9
        for i in range(n + 1):
10
            # Iterate over all possible suffixes to remove
11
            for j in range(n + 1):
12
                # Calculate the remaining servers after removing i from the start and j from the end
13
                remaining_servers = servers[i:n-j] if i + j <= n else """"
14
                15
                # Count remaining idle servers (0's) and decommissioned active servers (1's)
16
                remaining_idle = remaining_servers.count('0')
17
                decommissioned_active = (servers[:i].count('1') + servers[n-j:].count('1'))
18
                19
                # Calculate the cost
20
                cost = max(remaining_idle, decommissioned_active)
21
                22
                # Update the minimum cost
23
                min_cost = min(min_cost, cost)
24
        25
        results.append(min_cost)
26
    27
    return results
28
29
# Input reading
30
T = int(input())
31
test_cases = [input().strip() for _ in range(T)]
32
33
# Get results
34
results = min_decommissioning_cost(test_cases)
35
36
# Output results
37
for result in results:
38
    print(result)
39
40",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053763
1390053764,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053764
1390053755,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(n, k, arr):
4
5
    dq = deque()  # Stores indices of negative numbers
6
7
    res = []
8
9
    # Process first batch
10
11
    for i in range(k):
12
13
        if arr[i] < 0:
14
15
            dq.append(i)
16
17
    # Store result for the first batch
18
19
    res.append(arr[dq[0]] if dq else 0)
20
21
    # Process remaining batches
22
23
    for i in range(k, n):
24
25
        # Remove elements that are out of the window
26
27
        while dq and dq[0] < i - k + 1:
28
29
            dq.popleft()
30
31
        # Add the new element if it's negative
32
33
        if arr[i] < 0:
34
35
            dq.append(i)
36
37
        # Store result for the current batch
38
39
        res.append(arr[dq[0]] if dq else 0)
40
41
    return res
42
43
# Read input
44
45
t = int(input())  # Number of test cases
46
47
for _ in range(t):
48
49
    n, k = map(int, input().split())  # Size of array and batch size
50
51
    arr = list(map(int, input().split()))  # Array elements
52
53
    # Process and print output
54
55
    print("" "".join(map(str, earliest_faulty_readings(n, k, arr))))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053755
1390053759,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053759
1390053761,unknown,unknown,unknown,"1
def min_decommissioning_cost(s):
2
    n = len(s)
3
    4
    prefix_active = [0] * (n + 1)
5
    for i in range(n):
6
        prefix_active[i+1] = prefix_active[i] + (1 if s[i] == '1' else 0)
7
    8
    total_active = prefix_active[n]
9
    10
    min_cost = float('inf')
11
    12
    for start in range(n + 1):
13
        prefix_removed = prefix_active[start]
14
        15
        for end in range(start, n + 1):
16
            if start == end:
17
                min_cost = min(min_cost, total_active)
18
                continue
19
            20
            active_remaining = prefix_active[end] - prefix_active[start]
21
            22
            active_removed = prefix_removed + (total_active - prefix_active[end])
23
            24
            idle_remaining = (end - start) - active_remaining
25
            26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
import sys
32
input = sys.stdin.readline
33
34
t = int(input())
35
for _ in range(t):
36
    server_rack = input().strip()
37
    print(min_decommissioning_cost(server_rack))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053761
1390053748,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053748
1390053751,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        8
        while (T-- > 0) {
9
            int n = sc.nextInt();
10
            int k = sc.nextInt();
11
            12
            long[] arr = new long[n];
13
            for (int i = 0; i < n; i++) {
14
                arr[i] = sc.nextLong();
15
            }
16
            17
            long totalSum = 0;
18
            for (long val : arr) {
19
                totalSum += val;
20
            }
21
            22
            long currentWindowSum = 0;
23
            for (int i = 0; i < k; i++) {
24
                currentWindowSum += arr[i];
25
            }
26
            27
            long maxWindowSum = currentWindowSum;
28
            29
            for (int i = k; i < n; i++) {
30
                currentWindowSum = currentWindowSum + arr[i] - arr[i - k];
31
                maxWindowSum = Math.max(maxWindowSum, currentWindowSum);
32
            }
33
            34
            System.out.println(totalSum - maxWindowSum );
35
        }
36
        37
        sc.close();
38
    }
39
}
40",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053751
1390053754,unknown,unknown,unknown,"1
import sys
2
3
def min_effort(n, k, firewalls):
4
    if k >= n:
5
        return 0  # If we can skip all firewalls, effort is 0.
6
7
    total_effort = sum(firewalls)  # Base case: no firewalls skipped
8
    min_effort = total_effort  # Track the minimum possible effort
9
10
    # Precompute prefix sum for efficient range calculations
11
    prefix_sum = [0] * (n + 1)
12
    for i in range(n):
13
        prefix_sum[i + 1] = prefix_sum[i] + firewalls[i]
14
15
    # Try skipping every contiguous k firewalls using a sliding window
16
    for i in range(n - k + 1):  
17
        skipped_sum = prefix_sum[i + k] - prefix_sum[i]  # Sum of skipped firewalls
18
        increased_security = (n - (i + k)) * k  # Strength increase for remaining firewalls
19
        remaining_effort = total_effort - skipped_sum + increased_security
20
21
        min_effort = min(min_effort, remaining_effort)
22
23
    return min_effort
24
25
# Read input
26
t = int(sys.stdin.readline().strip())  
27
output = []
28
29
for _ in range(t):
30
    n, k = map(int, sys.stdin.readline().split())
31
    firewalls = list(map(int, sys.stdin.readline().split()))
32
    output.append(str(min_effort(n, k, firewalls)))
33
34
# Print final output
35
sys.stdout.write(""\n"".join(output) + ""\n"")
36",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053754
1390053747,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    ans = float('inf')
5
6
    for i in range(n + 1):  # Iterate through all possible start positions
7
        for j in range(i, n + 1):  # Iterate through all possible end positions
8
            remaining = s[i:j]
9
            zeros_remaining = remaining.count('0')
10
            ones_removed = s[:i].count('1') + s[j:].count('1')
11
            ans = min(ans, max(zeros_remaining, ones_removed))
12
13
    print(ans)
14
15
t = int(input())
16
for _ in range(t):
17
    solve()",119,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053747
1390053744,unknown,unknown,unknown,"1
from collections import deque
2
3
def first_negative_in_windows(arr, k):
4
    dq = deque()
5
    result = []
6
    7
    # Process the first window of size k
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Append result for first window
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove indices that are out of the current window
18
        while dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
            21
        # If current element is negative, add its index
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Append the earliest negative reading for current window if exists, else 0
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
def main():
31
    import sys
32
    input_data = sys.stdin.read().strip().split()
33
    if not input_data:
34
        return
35
36
    t = int(input_data[0])
37
    index = 1
38
    outputs = []
39
    40
    for _ in range(t):
41
        n = int(input_data[index])
42
        k = int(input_data[index + 1])
43
        index += 2
44
        45
        arr = list(map(int, input_data[index:index+n]))
46
        index += n
47
        48
        res = first_negative_in_windows(arr, k)
49
        outputs.append("" "".join(map(str, res)))
50
    51
    # Print each test case result on a new line
52
    print(""\n"".join(outputs))
53
54
if __name__ == '__main__':
55
    main()
56",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053744
1390053737,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    for _ in range(test_cases):
4
        n, k = map(int, input().split())
5
        arr = list(map(int, input().split()))
6
        result = []
7
        for i in range(n - k + 1):
8
            batch = arr[i:i+k]
9
            faulty = 0
10
            for num in batch:
11
                if num < 0:
12
                    faulty = num
13
                    break
14
            result.append(faulty)
15
        results.append(result)
16
    return results
17
18
# Read the number of test cases
19
test_cases = int(input())
20
results = earliest_faulty_readings(test_cases)
21
22
# Print the results
23
for result in results:
24
    print(' '.join(map(str, result)) + ' ')
25
26",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053737
1390053738,unknown,unknown,unknown,"1
def min_cost_optimization(servers):
2
    n = len(servers)
3
    min_cost = float('inf')
4
    5
    for prefix in range(n + 1):
6
        for suffix in range(n + 1 - prefix):
7
            remaining = servers[prefix:n-suffix]
8
            9
            idle_servers = remaining.count('0')
10
            active_servers_removed = servers[:prefix].count('1') + servers[n-suffix:].count('1')
11
            12
            cost = max(idle_servers, active_servers_removed)
13
            min_cost = min(min_cost, cost)
14
    15
    return min_cost
16
17
def solve():
18
    t = int(input())
19
    20
    for _ in range(t):
21
        servers = input().strip()
22
        result = min_cost_optimization(servers)
23
        print(result)
24
25
if __name__ == ""__main__"":
26
    solve()",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053738
1390053739,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()
38",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053739
1390053734,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    min_cost = float('inf')
5
6
    for i in range(n + 1):
7
        for j in range(n - i + 1):
8
            remaining_s = s[i:n - j]
9
            10
            idle_count = 0
11
            for char in remaining_s:
12
                if char == '0':
13
                    idle_count += 1
14
            15
            active_removed = 0
16
            for k in range(i):
17
                if s[k] == '1':
18
                    active_removed += 1
19
            for k in range(n - j, n):
20
                if s[k] == '1':
21
                    active_removed += 1
22
23
            cost = max(idle_count, active_removed)
24
            min_cost = min(min_cost, cost)
25
            26
    print(min_cost)
27
28
t = int(input())
29
for _ in range(t):
30
    solve()",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053734
1390053735,unknown,unknown,unknown,"1
def min_effort_to_breach_firewalls(test_cases):
2
    results = []
3
    4
    for n, k, strengths in test_cases:
5
        # Sort the strengths to consider the weakest firewalls first
6
        strengths.sort()
7
        8
        # Initialize the minimum effort to a large number
9
        min_effort = float('inf')
10
        11
        # Iterate over the number of skips
12
        for skips in range(min(k, n) + 1):
13
            # Calculate the effort if we skip 'skips' firewalls
14
            current_effort = 0
15
            16
            # Calculate the effort for the remaining firewalls after skipping
17
            for i in range(skips, n):
18
                current_effort += strengths[i] + skips
19
            20
            # Update the minimum effort
21
            min_effort = min(min_effort, current_effort)
22
        23
        results.append(min_effort)
24
    25
    return results
26
27
# Input reading
28
T = int(input())
29
test_cases = []
30
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    strengths = list(map(int, input().split()))
34
    test_cases.append((n, k, strengths))
35
36
# Get results
37
results = min_effort_to_breach_firewalls(test_cases)
38
39
# Output results
40
for result in results:
41
    print(result)
42
43
44",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053735
1390053736,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    5
    6
    for j in range(k + 1):
7
        dp[0][j] = 0
8
    9
    for i in range(1, n + 1):
10
        for j in range(k + 1):
11
            12
            if j > 0:
13
                14
                dp[i][j] = dp[i-1][j-1]
15
            16
           17
            current_strength = strengths[i-1] + j  
18
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
19
    20
 21
    return min(dp[n])
22
23
def solve():
24
    t = int(input())
25
    results = []
26
    27
    for _ in range(t):
28
        n, k = map(int, input().split())
29
        strengths = list(map(int, input().split()))
30
        results.append(min_effort_to_breach(n, k, strengths))
31
    32
    for result in results:
33
        print(result)
34
35
solve()",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053736
1390053732,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <cmath>
4
using namespace std;
5
6
void findFaulty(int n, int k, vector<int>& arr) {
7
    vector<int>reports;
8
    int i = 0;
9
    int j = k-1;
10
    while(i<j && j<n){
11
        bool neg = false;
12
        int val = 0;
13
        for(int x = i; x <= j; x++){
14
            if(arr[x]<0){
15
                val = arr[x];
16
                neg = true;
17
                break;
18
            }
19
        }
20
        reports.push_back(neg ? val: 0 );
21
        i++;
22
        j++;
23
    }
24
    for(auto report : reports){
25
        cout<<report<<"" "";
26
    }
27
    cout<<endl;
28
    29
}
30
31
int main() {
32
    int t;
33
    cin >> t;
34
    while (t--) {
35
        int n, k;
36
        cin >> n >> k;
37
        vector<int> arr(n);
38
        for (int i = 0; i < n; i++) {
39
            cin >> arr[i];
40
        }
41
        findFaulty(n, k, arr);
42
    }
43
    return 0;
44
}
45",120,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053732
1390053729,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053729
1390053731,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    n, k = map(int, input().split())
4
    arr = list(map(int, input().split()))
5
    res = []
6
    7
    L, R = 0, k - 1
8
    while R < n:
9
        batch = arr[L:R+1]
10
        isFaulty, value = False, 0
11
        for i in range(len(batch)):
12
            if batch[i] < 0:
13
                isFaulty = True
14
                value = batch[i]
15
                break
16
        if not isFaulty:
17
            res.append(0)
18
        else:
19
            res.append(value)
20
        L += 1
21
        R += 1
22
    23
    print(*res)",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053731
1390053730,unknown,unknown,unknown,"1
def minimum_effort(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n, k = test_cases[t][0]
6
        arr = test_cases[t][1][:]  # Create a copy of the input array
7
        8
        if k >= n:
9
            results.append(0)
10
            continue
11
        12
        min_effort = float('inf')
13
        14
        for i in range(1 << n):
15
            skipped_indices = []
16
            17
            for j in range(n):
18
                if (i >> j) & 1:
19
                    skipped_indices.append(j)
20
                    21
            if len(skipped_indices) <= k:
22
                effort = 0
23
                temp_arr = arr[:]  # Create a copy of the original array for each combination
24
                25
                skip_count = 0
26
                for j in range(n):
27
                    if (i >> j) & 1:
28
                        skip_count += 1
29
                        for l in range(j + 1, n):
30
                            if not (i >> l) & 1:
31
                                temp_arr[l] += 1
32
                    else:
33
                        effort += temp_arr[j]
34
                35
                min_effort = min(min_effort, effort)
36
        37
        results.append(min_effort)
38
        39
    return results
40
41
# Input reading
42
T = int(input())
43
test_cases = []
44
45
# Read all test cases
46
for _ in range(T):
47
    n, k = map(int, input().split())
48
    arr = list(map(int, input().split()))
49
    test_cases.append([(n, k), arr])
50
51
# Get the results and print them
52
results = minimum_effort(T, test_cases)
53
54
for result in results:
55
    print(result)",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053730
1390053722,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class DataCenterOptimization {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = Integer.parseInt(sc.nextLine());
7
        while (T-- > 0) {
8
            String s = sc.nextLine();
9
            int n = s.length();
10
11
            int totalActive = 0, totalIdle = 0;
12
            for (char c : s.toCharArray()) {
13
                if (c == '1') totalActive++;
14
                else totalIdle++;
15
            }
16
17
            int[] prefixActive = new int[n + 1];
18
            int[] prefixIdle = new int[n + 1];
19
            for (int i = 0; i < n; i++) {
20
                prefixActive[i + 1] = prefixActive[i] + (s.charAt(i) == '1' ? 1 : 0);
21
                prefixIdle[i + 1] = prefixIdle[i] + (s.charAt(i) == '0' ? 1 : 0);
22
            }
23
24
            int minCost = Integer.MAX_VALUE;
25
26
            // Try all possible (l, r) subarrays to keep
27
            for (int l = 0; l <= n; l++) {
28
                for (int r = l; r <= n; r++) {
29
                    int idleLeft = prefixIdle[r] - prefixIdle[l];
30
                    int activeRemoved = prefixActive[l] + (totalActive - prefixActive[r]);
31
                    int cost = Math.max(idleLeft, activeRemoved);
32
                    minCost = Math.min(minCost, cost);
33
                }
34
            }
35
36
            System.out.println(minCost);
37
        }
38
        sc.close();
39
    }
40
}
41",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053722
1390053723,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        Scanner scanner = new Scanner(System.in);
11
        int t = scanner.nextInt(); 
12
13
        while (t-- > 0) {
14
            int n = scanner.nextInt(); 
15
            int k = scanner.nextInt(); 
16
            int[] arr = new int[n];
17
18
            for (int i = 0; i < n; i++) {
19
                arr[i] = scanner.nextInt();
20
            }
21
22
            List<Integer> ans = findResult(arr, k);
23
24
            for (int num : ans) {
25
                System.out.print(num + "" "");
26
            }
27
            System.out.println();
28
        }
29
        scanner.close();
30
     31
    }
32
    public static List<Integer> findResult(int []arr, int k){
33
        List<Integer> ans = new ArrayList<Integer>();
34
        Deque<Integer> deque = new LinkedList<>();
35
        36
        for(int i =0;i<k;i++){
37
            if(arr[i]<0){
38
            deque.addLast(i);
39
            }
40
        }
41
        if(!deque.isEmpty()){
42
            ans.add(arr[deque.peekFirst()]);
43
        }
44
        for(int i=k;i<arr.length;i++){
45
            if(!deque.isEmpty()&&deque.peekFirst()<=i-k){
46
                deque.pollFirst();
47
            }
48
            if(arr[i]<0){
49
            deque.addLast(i);
50
            }
51
            if(!deque.isEmpty()){
52
                ans.add(arr[deque.peekFirst()]);
53
            }else{
54
                ans.add(0);
55
            }
56
        }
57
        58
        59
        return ans;
60
     61
    }
62
}",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053723
1390053728,unknown,unknown,unknown,"1
#include <stdio.h>
2
3
int main() {
4
    int t;
5
    scanf(""%d"", &t);
6
    7
    while (t--) {
8
        int n, k;
9
        scanf(""%d %d"", &n, &k);
10
        11
        int arr[n];
12
        for (int i = 0; i < n; i++) {
13
            scanf(""%d"", &arr[i]);
14
        }
15
16
        // Process each window
17
        for (int i = 0; i <= n - k; i++) {
18
            int found = 0;
19
            for (int j = i; j < i + k; j++) {
20
                if (arr[j] < 0) {
21
                    printf(""%d "", arr[j]);
22
                    found = 1;
23
                    break;
24
                }
25
            }
26
            if (!found) {
27
                printf(""0 "");
28
            }
29
        }
30
        printf(""\n"");
31
    }
32
33
    return 0;
34
}
35",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053728
1390053719,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053719
1390053721,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
            25
            # Calculate the remaining '0's in the middle
26
            # Total '0's minus the '0's removed from the left and right
27
            # Since we are iterating over left, we need to find the right decommissioning point
28
            # that minimizes the cost
29
            # We can use binary search to find the optimal right decommissioning point
30
            low = 0
31
            high = n - left
32
            best_right = 0
33
            best_cost = float('inf')
34
            35
            while low <= high:
36
                mid = (low + high) // 2
37
                right = mid
38
                ones_removed_right = suffix_ones[n - right]
39
                total_ones_removed = ones_removed_left + ones_removed_right
40
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
41
                current_cost = max(zeros_remaining, total_ones_removed)
42
                43
                if current_cost < best_cost:
44
                    best_cost = current_cost
45
                    best_right = right
46
                47
                if zeros_remaining > total_ones_removed:
48
                    low = mid + 1
49
                else:
50
                    high = mid - 1
51
            52
            if best_cost < min_cost_val:
53
                min_cost_val = best_cost
54
        55
        results.append(min_cost_val)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = [input().strip() for _ in range(T)]
61
62
# Compute results
63
results = min_cost(test_cases)
64
65
# Output results
66
for res in results:
67
    print(res)",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053721
1390053718,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
7
        # Precompute prefix sums for 1's
8
        prefix_1 = [0] * (n + 1)
9
        for i in range(n):
10
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
11
12
        # Iterate through all possible splits
13
        for i in range(n + 1):
14
            for j in range(i, n + 1):
15
                # Remaining segment is from i to j-1
16
                remaining_0s = (j - i) - (prefix_1[j] - prefix_1[i])  # Optimized calculation of 0s
17
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
18
                cost = max(remaining_0s, removed_1s)
19
                min_cost = min(min_cost, cost)
20
        results.append(min_cost)
21
    return results
22
23
# Read input
24
T = int(input())
25
test_cases = [input().strip() for _ in range(T)]
26
27
# Compute results
28
results = min_decommission_cost(test_cases)
29
30
# Print output
31
for result in results:
32
    print(result)",121,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053718
1390053712,unknown,unknown,unknown,"1
from collection import deque 
2
def early_fault(arr , n , k):
3
    queue = deque()
4
    output = []
5
#Process first k element    
6
    for i in range (k):
7
        if arr[i] < 0:
8
            queue.append(i)
9
    10
#Iteration
11
    for i in range(n -k +1):
12
        #add first faulty
13
        output.append(arr[queue[0]] if queue else 0)
14
        15
        if queue and queue[0] ==i:
16
            queue.popleft()
17
#add new falut
18
        if i+k < n and arr[i + k] < 0:
19
            queue.append(i+k)
20
    return output
21
#read test cases
22
test_cases = int(input().strip())
23
for _ in range(test_cases):
24
    size , batch = map(int , input(). strip().split()) #reading n and k 
25
    reading = list(map(int,input().strip().split()))
26
    27
    #getting result
28
    res = early_fault(readings , size , batch)
29
    print(*res)",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053712
1390053711,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class ServerDecommissioning {
4
    public static List<Integer> minDecommissionCost(List<String> testCases) {
5
        List<Integer> results = new ArrayList<>();
6
        7
        for (String servers : testCases) {
8
            int n = servers.length();
9
            int minCost = Integer.MAX_VALUE;
10
            11
            int[] prefix0 = new int[n + 1];
12
            int[] prefix1 = new int[n + 1];
13
            14
            for (int i = 0; i < n; i++) {
15
                prefix0[i + 1] = prefix0[i] + (servers.charAt(i) == '0' ? 1 : 0);
16
                prefix1[i + 1] = prefix1[i] + (servers.charAt(i) == '1' ? 1 : 0);
17
            }
18
            19
            for (int i = 0; i <= n; i++) {
20
                for (int j = i; j <= n; j++) {
21
                    int remaining0s = prefix0[j] - prefix0[i]; 
22
                    int removed1s = prefix1[i] + (prefix1[n] - prefix1[j]);
23
                    24
                    int cost = Math.max(remaining0s, removed1s);
25
                    minCost = Math.min(minCost, cost);
26
                }
27
            }
28
            results.add(minCost);
29
        }
30
        31
        return results;
32
    }
33
34
    public static void main(String[] args) {
35
        Scanner scanner = new Scanner(System.in);
36
        int t = scanner.nextInt();
37
        scanner.nextLine();
38
        39
        List<String> testCases = new ArrayList<>();
40
        for (int i = 0; i < t; i++) {
41
            testCases.add(scanner.nextLine().trim());
42
        }
43
        44
        List<Integer> results = minDecommissionCost(testCases);
45
        for (int result : results) {
46
            System.out.println(result);
47
        }
48
        49
        scanner.close();
50
    }
51
}
52",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053711
1390053715,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
5
    dp = [float('inf')] * (k + 1)
6
    dp[0] = 0
7
8
    for i in range(1, n + 1):
9
        new_dp = dp[:]  # Create a copy to avoid overwriting during iteration
10
        for j in range(min(k, i), -1, -1):
11
            if j <= i - 1:
12
                new_dp[j] = min(new_dp[j], dp[j] + strengths[i - 1] + j)
13
            if j > 0:
14
                new_dp[j] = min(new_dp[j], dp[j - 1])
15
        dp = new_dp
16
17
    return dp[k]
18
19
def solve():
20
    t = int(input())
21
    for _ in range(t):
22
        n, k = map(int, input().split())
23
        strengths = list(map(int, input().split()))
24
        if k >= n:
25
            print(0)
26
        else:
27
            print(min_effort_to_breach(n, k, strengths))
28
29
solve()",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053715
1390053704,unknown,unknown,unknown,"1
def min_decommission_cost(server_rack):
2
    total_active = server_rack.count('1')
3
    total_idle = server_rack.count('0')
4
5
    min_cost = min(total_active, total_idle)  # Worst case: remove all active or all idle
6
7
    left, right = 0, len(server_rack) - 1
8
    removed_active = 0
9
    removed_idle = 0
10
11
    while left <= right:
12
        while left <= right and server_rack[left] == '0':  # Remove idle from the left
13
            removed_idle += 1
14
            left += 1
15
        while left <= right and server_rack[right] == '0':  # Remove idle from the right
16
            removed_idle += 1
17
            right -= 1
18
        19
        remaining_idle = total_idle - removed_idle
20
        min_cost = min(min_cost, max(remaining_idle, removed_active))
21
22
        if left <= right:
23
            removed_active += 1  # Remove an active server
24
            left += 1
25
            min_cost = min(min_cost, max(total_idle - removed_idle, removed_active))
26
27
    return min_cost
28
29
30
# Read input
31
T = int(input())  # Number of test cases
32
results = []
33
34
for _ in range(T):
35
    server_rack = input().strip()
36
    results.append(min_decommission_cost(server_rack))
37
38
# Print results
39
for res in results:
40
    print(res)",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053704
1390053705,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    // Optimized function to compute the minimum decommission cost for a test case
6
    public static int minDecommissionCostOptimized(String testCase) {
7
        int n = testCase.length();
8
        int[] prefix0 = new int[n + 1];
9
        int[] prefix1 = new int[n + 1];
10
        11
        // Build prefix sum arrays for '0's and '1's
12
        for (int i = 0; i < n; i++) {
13
            char ch = testCase.charAt(i);
14
            prefix0[i + 1] = prefix0[i] + (ch == '0' ? 1 : 0);
15
            prefix1[i + 1] = prefix1[i] + (ch == '1' ? 1 : 0);
16
        }
17
        18
        int totalOnes = prefix1[n];
19
        int minCost = Integer.MAX_VALUE;
20
        21
        // For each possible starting index i for the remaining segment
22
        for (int i = 0; i <= n; i++) {
23
            // Compute the ideal candidate j using the derived formula
24
            int candidate = i + totalOnes;
25
            if (candidate > n) {
26
                candidate = n;
27
            }
28
            29
            // Check candidate j as well as neighboring indices to ensure optimal cost
30
            for (int j : new int[]{candidate, candidate - 1, candidate + 1}) {
31
                if (j < i || j > n) continue;
32
                int zerosKept = prefix0[j] - prefix0[i];
33
                int onesRemoved = prefix1[i] + (totalOnes - prefix1[j]);
34
                int cost = Math.max(zerosKept, onesRemoved);
35
                if (cost < minCost) {
36
                    minCost = cost;
37
                }
38
            }
39
        }
40
        return minCost;
41
    }
42
43
    public static void main(String[] args) {
44
        Scanner scanner = new Scanner(System.in);
45
        int T = scanner.nextInt();
46
        scanner.nextLine(); // Consume the newline
47
        48
        // Process each test case
49
        for (int t = 0; t < T; t++) {
50
            String testCase = scanner.nextLine().trim();
51
            int result = minDecommissionCostOptimized(testCase);
52
            System.out.println(result);
53
        }
54
        scanner.close();
55
    }
56
}
57",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053705
1390053709,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36
37
38",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053709
1390053699,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053699
1390053702,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053702
1390053697,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Precompute prefix sums for active and idle servers
5
    prefix_active = [0] * (n + 1)
6
    prefix_idle = [0] * (n + 1)
7
    8
    for i in range(n):
9
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
10
        prefix_idle[i + 1] = prefix_idle[i] + (1 if servers[i] == '0' else 0)
11
    12
    total_active = prefix_active[n]
13
    total_idle = prefix_idle[n]
14
    15
    min_cost = n  # Initialize with worst case (all servers)
16
    17
    # Try all possible left and right cuts
18
    for left in range(n + 1):  # Remove servers[0:left]
19
        for right in range(left, n + 1):  # Keep servers[left:right]
20
            # Active servers removed = those removed from left + those removed from right
21
            active_removed_left = prefix_active[left]
22
            active_removed_right = total_active - prefix_active[right]
23
            active_removed = active_removed_left + active_removed_right
24
            25
            # Idle servers remaining = those in the middle section we keep
26
            idle_remaining = prefix_idle[right] - prefix_idle[left]
27
            28
            cost = max(idle_remaining, active_removed)
29
            min_cost = min(min_cost, cost)
30
    31
    return min_cost
32
33
def main():
34
    try:
35
        t = int(input().strip())
36
        results = []
37
        38
        for _ in range(t):
39
            servers = input().strip()
40
            results.append(str(min_decommissioning_cost(servers)))
41
        42
        print(""\n"".join(results))
43
    except Exception as e:
44
        print(f""Error: {e}"")
45
46
if __name__ == ""__main__"":
47
    main()",122,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053697
1390053689,unknown,unknown,unknown,"1
def find_faulty(data_sets):
2
    3
    results = []
4
    5
    for data,w_size, s_readings in data_sets:
6
        output = []
7
        faulty = [] 
8
9
        for i in range(data):
10
            11
            while faulty and faulty[0] < i - w_size + 1:
12
                faulty.pop(0)
13
14
            15
            if s_readings[i] < 0:
16
                faulty.append(i)
17
18
            19
            if i >= w_size - 1:
20
                if faulty:
21
                    output.append(s_readings[faulty[0]])
22
                else:
23
                    output.append(0)
24
25
        results.append("" "".join(map(str, output)))
26
27
    print(""\n"".join(results))
28
29
30
n = int(input())
31
test_data = []
32
33
for _ in range(n):
34
    35
    36
    length, win = map(int, input().split())
37
    readings = list(map(int, input().split()))
38
    39
    test_data.append((length, win, readings))
40
41
find_faulty(test_data)",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053689
1390053691,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053691
1390053694,unknown,unknown,unknown,"1
def minimum_pruning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    active_count = server_rack.count('1')
5
    total_count = len(server_rack)
6
    idle_count = total_count - active_count
7
    8
    active_prefix = [0] * (n + 1)
9
    for i in range(n):
10
        active_prefix[i + 1] = active_prefix[i] + (1 if server_rack[i] == '1' else 0)
11
    12
    min_cost = float('inf')
13
    14
    for left in range(n + 1):  
15
        for right in range(n + 1 - left):  
16
            if left + right == 0:
17
                continue
18
                19
            if left + right == n:
20
                continue
21
                22
            active_decommissioned = active_prefix[left] + (active_prefix[n] - active_prefix[n - right])
23
            24
            idle_remaining = (n - left - right) - (active_prefix[n - right] - active_prefix[left])
25
            26
            cost = max(idle_remaining, active_decommissioned)
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
def solve():
32
    t = int(input().strip())
33
    34
    for _ in range(t):
35
        server_rack = input().strip()
36
        print(minimum_pruning_cost(server_rack))
37
38
if __name__ == ""__main__"":
39
    solve()",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053694
1390053684,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt();
7
        8
        while (t-- > 0) {
9
            int n = sc.nextInt(), k = sc.nextInt();
10
            int[] arr = new int[n];
11
            12
            for (int i = 0; i < n; i++) {
13
                arr[i] = sc.nextInt();
14
            }
15
            16
            System.out.println(minEffort(n, k, arr));
17
        }
18
        sc.close();
19
    }
20
    21
    static int minEffort(int n, int k, int[] arr) {
22
        Integer[][] dp = new Integer[n][k + 1];
23
        return calc(0, 0, n, k, arr, dp);
24
    }
25
    26
    static int calc(int i, int skip, int n, int k, int[] arr, Integer[][] dp) {
27
        if (i == n) return 0;
28
        if (dp[i][skip] != null) return dp[i][skip];
29
        30
        int take = arr[i] + skip + calc(i + 1, skip, n, k, arr, dp);
31
        int leave = (skip < k) ? calc(i + 1, skip + 1, n, k, arr, dp) : Integer.MAX_VALUE;
32
        33
        return dp[i][skip] = Math.min(take, leave);
34
    }
35
}
36",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053684
1390053687,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053687
1390053688,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) throws IOException {
6
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
7
        int t = Integer.parseInt(br.readLine().trim());
8
9
        while (t-- > 0) {
10
            StringTokenizer st = new StringTokenizer(br.readLine());
11
            int n = Integer.parseInt(st.nextToken()), k = Integer.parseInt(st.nextToken());
12
            int[] strengths = Arrays.stream(br.readLine().split("" "")).mapToInt(Integer::parseInt).toArray();
13
14
            System.out.println(minEffort(n, k, strengths));
15
        }
16
    }
17
    private static long minEffort(int n, int k, int[] strengths) {
18
        if (k >= n) return 0; 
19
20
        long[] dp = new long[k + 1];
21
        Arrays.fill(dp, Long.MAX_VALUE / 2);
22
        dp[0] = 0;
23
24
        for (int strength : strengths) {
25
            for (int skips = k; skips >= 0; skips--) {
26
                dp[skips] = Math.min(dp[skips] + strength + skips, skips > 0 ? dp[skips - 1] : Long.MAX_VALUE);
27
            }
28
        }
29
30
        return Arrays.stream(dp).min().getAsLong();
31
    }
32
}",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053688
1390053681,unknown,unknown,unknown,"1
import sys
2
3
def min_effort(n, k, firewalls):
4
    if k >= n:
5
        return 0  # If we can skip all firewalls, effort is 0.
6
7
    total_effort = sum(firewalls)  # Baseline effort without skipping
8
    min_effort = float('inf')  # Start with a very large number
9
10
    # Try every possible `k`-firewall skip combination
11
    for i in range(n - k + 1):  # Sliding window to choose which firewalls to skip
12
        skipped_sum = sum(firewalls[i:i + k])  # Sum of skipped firewalls
13
        remaining = firewalls[:i] + firewalls[i + k:]  # Remaining firewalls
14
15
        # Increase security for remaining firewalls
16
        increased_security = sum(remaining[j] + (k if j >= i else 0) for j in range(len(remaining)))
17
18
        total_after_skip = increased_security
19
        min_effort = min(min_effort, total_after_skip)
20
21
    return min_effort
22
23
# Read input
24
t = int(sys.stdin.readline())  # Number of test cases
25
output = []
26
27
for _ in range(t):
28
    n, k = map(int, sys.stdin.readline().split())
29
    firewalls = list(map(int, sys.stdin.readline().split()))
30
    output.append(str(min_effort(n, k, firewalls)))
31
32
# Print the final output
33
sys.stdout.write(""\n"".join(output) + ""\n"")
34",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053681
1390053682,unknown,unknown,unknown,"1
def f(a):
2
    b = len(a)
3
    c = a.count(""1"")
4
    d = b - c
5
    e = float(""inf"")
6
7
    for i in range(b + 1):
8
        for j in range(b + 1 - i):
9
            x = a[:i]
10
            y = a[b - j:] if j > 0 else """"
11
            z = a[i:b - j]
12
13
            p = x.count(""1"") + y.count(""1"")
14
            q = z.count(""0"")
15
16
            e = min(e, max(q, p))
17
18
    return e
19
20
t = int(input())
21
for _ in range(t):
22
    a = input().strip()
23
    print(f(a))
24",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053682
1390053683,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    dp[0][0] = 0  
4
5
    for i in range(1, n + 1):
6
        for j in range(k + 1):
7
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
8
9
            if j > 0:
10
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
11
12
    return min(dp[n])
13
14
T = int(input())  
15
for _ in range(T):
16
    n, k = map(int, input().split()) 
17
    firewalls = list(map(int, input().split()))  
18
19
    print(min_effort(n, k, firewalls))",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053683
1390053680,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
class Solution {
5
    public static int min_pruning_cost(String serverRack) {
6
        int n = serverRack.length();
7
        int minCost = n + 1;
8
9
        for (int leftRemoveCount = 0; leftRemoveCount <= n; ++leftRemoveCount) {
10
            for (int rightRemoveCount = 0; rightRemoveCount <= n - leftRemoveCount; ++rightRemoveCount) {
11
                int idleRemaining = 0;
12
                int activeRemoved = 0;
13
14
                // Calculate active_removed
15
                for (int i = 0; i < leftRemoveCount; ++i) {
16
                    if (serverRack.charAt(i) == '1') {
17
                        activeRemoved++;
18
                    }
19
                }
20
                for (int i = n - rightRemoveCount; i < n; ++i) {
21
                    if (serverRack.charAt(i) == '1') {
22
                        activeRemoved++;
23
                    }
24
                }
25
26
                // Calculate idle_remaining
27
                for (int i = leftRemoveCount; i < n - rightRemoveCount; ++i) {
28
                    if (serverRack.charAt(i) == '0') {
29
                        idleRemaining++;
30
                    }
31
                }
32
33
                int cost = Math.max(idleRemaining, activeRemoved);
34
                minCost = Math.min(minCost, cost);
35
            }
36
        }
37
        return minCost;
38
    }
39
40
    public static void main(String[] args) {
41
        Scanner scanner = new Scanner(System.in);
42
        int t = scanner.nextInt();
43
        scanner.nextLine(); // consume newline
44
        while (t-- > 0) {
45
            String serverRack = scanner.nextLine();
46
            System.out.println(min_pruning_cost(serverRack));
47
        }
48
    }
49
}",123,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053680
1390053671,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static int minEffort(int[] firewalls, int k) {
7
        int n = firewalls.length;
8
        if (k >= n) return 0;
9
10
        int[][] dp = new int[n + 1][k + 1];
11
        12
        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);
13
        for (int j = 0; j <= k; j++) dp[n][j] = 0;
14
15
        for (int i = n - 1; i >= 0; i--) {
16
            for (int j = 0; j <= k; j++) {
17
                if (j < k) dp[i][j] = dp[i + 1][j + 1];
18
                if (dp[i + 1][j] != Integer.MAX_VALUE) {
19
                    dp[i][j] = Math.min(dp[i][j], firewalls[i] + dp[i + 1][j]);
20
                }
21
            }
22
        }
23
24
        return dp[0][0];
25
    }
26
27
    public static void main(String[] args) {
28
        Scanner sc = new Scanner(System.in);
29
        int t = sc.nextInt();
30
31
        while (t-- > 0) {
32
            int n = sc.nextInt();
33
            int k = sc.nextInt();
34
            int[] firewalls = new int[n];
35
36
            for (int i = 0; i < n; i++) {
37
                firewalls[i] = sc.nextInt();
38
            }
39
40
            System.out.println(minEffort(firewalls, k));
41
        }
42
43
        sc.close();
44
    }
45
}
46",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053671
1390053677,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        prefix_0 = [0] * (n + 1)
7
        prefix_1 = [0] * (n + 1)
8
        for i in range(n):
9
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
10
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
11
        for i in range(n + 1):
12
            for j in range(i, n + 1):
13
                remaining_0s = prefix_0[j] - prefix_0[i]
14
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
15
                cost = max(remaining_0s, removed_1s)
16
                if cost < min_cost:
17
                    min_cost = cost
18
        results.append(min_cost)
19
    return results
20
T = int(input())
21
test_cases = [input().strip() for _ in range(T)]
22
results = min_decommission_cost(test_cases)
23
for result in results:
24
    print(result)",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053677
1390053678,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    skipped = [False] * n  # Track skipped firewalls
6
    7
    # Greedy selection of k highest firewalls to skip
8
    temp_a = a[:]
9
    for _ in range(k):
10
        max_val = -1
11
        max_idx = -1
12
        for i in range(n):
13
            if not skipped[i] and temp_a[i] > max_val:
14
                max_val = temp_a[i]
15
                max_idx = i
16
        if max_idx != -1:
17
            skipped[max_idx] = True
18
            temp_a[max_idx] = -1
19
20
    effort = 0
21
    skipped_count = 0
22
    23
    for i in range(n):
24
        if skipped[i]:
25
            skipped_count += 1
26
        else:
27
            effort += a[i] + skipped_count
28
29
    print(effort)
30
31
t = int(input())
32
for _ in range(t):
33
    solve()",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053678
1390053668,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx+1])
10
        idx +=2
11
        a = list(map(int, input[idx:idx+n]))
12
        idx +=n
13
        sum_a = sum(a)
14
        v = []
15
        for i in range(n):
16
            val = a[i] - (n - i -1)
17
            v.append(val)
18
        v.sort(reverse=True)
19
        prefix = [0] * (n+1)
20
        for i in range(n):
21
            prefix[i+1] = prefix[i] + v[i]
22
        max_sum = 0
23
        max_t = min(k, n)
24
        for t in range(0, max_t+1):
25
            current = prefix[t] + t*(t-1)//2
26
            if current > max_sum:
27
                max_sum = current
28
        print(sum_a - max_sum)
29
30
if __name__ == ""__main__"":
31
    main()",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053668
1390053670,unknown,unknown,unknown,"1
def min_cost(server_str):
2
    n = len(server_str)
3
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
4
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
5
6
    for i in range(n):
7
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
8
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
9
10
    total_1 = prefix_1[n]
11
    total_0 = prefix_0[n]
12
13
    min_cost = float('inf')
14
15
    # Try removing l elements from the front
16
    for l in range(n + 1):
17
        # Try removing r elements from the back
18
        for r in range(n - l + 1):
19
            left = l
20
            right = n - r
21
            remaining_0 = prefix_0[right] - prefix_0[left]
22
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
23
            cost = max(remaining_0, removed_1)
24
            min_cost = min(min_cost, cost)
25
26
    return min_cost
27
28
# Main driver
29
T = int(input())
30
for _ in range(T):
31
    server_str = input().strip()
32
    print(min_cost(server_str))",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053670
1390053658,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053658
1390053664,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053664
1390053656,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] arr = new int[n];
11
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
12
            13
            long[][] dp = new long[n + 1][k + 1];
14
            for (int i = 0; i <= n; i++) Arrays.fill(dp[i], Long.MAX_VALUE / 2);
15
            dp[0][0] = 0;
16
            17
            for (int i = 1; i <= n; i++) {
18
                for (int j = 0; j <= k; j++) {
19
                    // Don't skip
20
                    dp[i][j] = dp[i - 1][j] + arr[i - 1] + j;
21
                    // Skip
22
                    if (j > 0) dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
23
                }
24
            }
25
            26
            long minEffort = Long.MAX_VALUE;
27
            for (int j = 0; j <= k; j++) {
28
                minEffort = Math.min(minEffort, dp[n][j]);
29
            }
30
            31
            System.out.println(minEffort);
32
        }
33
        sc.close();
34
    }
35
}
36",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053656
1390053654,unknown,unknown,unknown,"1
def earliest_faulty_reading(test_cases, data):
2
    results = []
3
    for case in range(test_cases):
4
        n, k = data[case][0]
5
        arr = data[case][1]
6
        res = []
7
        8
        for i in range(n - k + 1):
9
            batch = arr[i:i + k]
10
            found = next((num for num in batch if num < 0), 0)
11
            res.append(found)
12
        13
        results.append("" "".join(map(str, res)))
14
    15
    return ""\n"".join(results)
16
17
# Reading input
18
t = int(input())
19
data = []
20
for _ in range(t):
21
    n, k = map(int, input().split())
22
    arr = list(map(int, input().split()))
23
    data.append(((n, k), arr))
24
25
# Processing and printing output
26
print(earliest_faulty_reading(t, data))",124,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053654
1390053649,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053649
1390053651,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static int minEffort(int[] firewalls, int k) {
7
        int n = firewalls.length;
8
        if (k >= n) return 0;
9
10
        int[][] dp = new int[n + 1][k + 1];
11
        12
        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);
13
        for (int j = 0; j <= k; j++) dp[n][j] = 0;
14
15
        for (int i = n - 1; i >= 0; i--) {
16
            for (int j = 0; j <= k; j++) {
17
                if (j < k) dp[i][j] = dp[i + 1][j + 1];
18
                if (dp[i + 1][j] != Integer.MAX_VALUE) {
19
                    dp[i][j] = Math.min(dp[i][j], firewalls[i] + dp[i + 1][j]);
20
                }
21
            }
22
        }
23
24
        return dp[0][0];
25
    }
26
27
    public static void main(String[] args) {
28
        Scanner sc = new Scanner(System.in);
29
        int t = sc.nextInt();
30
31
        while (t-- > 0) {
32
            int n = sc.nextInt();
33
            int k = sc.nextInt();
34
            int[] firewalls = new int[n];
35
36
            for (int i = 0; i < n; i++) {
37
                firewalls[i] = sc.nextInt();
38
            }
39
40
            System.out.println(minEffort(firewalls, k));
41
        }
42
43
        sc.close();
44
    }
45
}
46",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053651
1390053652,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    ans = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            10
            decommissioned_ones = 0
11
            remaining_zeros = 0
12
            13
            # Decommission from the beginning
14
            decommissioned_ones += s[:i].count('1')
15
            16
            # Decommission from the end
17
            decommissioned_ones += s[n - j:].count('1')
18
            19
            # Remaining string after decommissioning
20
            remaining_string = s[i:n - j]
21
            remaining_zeros = remaining_string.count('0')
22
            23
            ans = min(ans, max(decommissioned_ones, remaining_zeros))
24
            25
    print(ans)
26
27
t = int(input())
28
for _ in range(t):
29
    solve()",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053652
1390053641,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053641
1390053643,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    ans = float('inf')
5
    6
    for i in range(n + 1):
7
        prefix = s[:i]
8
        for j in range(n - i + 1):
9
            suffix = s[n-j:]
10
            remaining = s[i:n-j]
11
            12
            zeros_remaining = remaining.count('0')
13
            ones_removed = prefix.count('1') + suffix.count('1')
14
            15
            ans = min(ans, max(zeros_remaining, ones_removed))
16
    17
    print(ans)
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053643
1390053648,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <bits/stdc++.h>
7
using namespace std;
8
9
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
10
    int n = arr.size();
11
    vector<int> result;
12
    deque<int> dq;  // Stores indices of negative numbers
13
14
    // Process first window
15
    for (int i = 0; i < k; i++) {
16
        if (arr[i] < 0) dq.push_back(i);
17
    }
18
19
    // Process the sliding window
20
    for (int i = k; i <= n; i++) {
21
        // Append first negative number in the window
22
        if (!dq.empty()) 
23
            result.push_back(arr[dq.front()]);  // First negative in the deque
24
        else 
25
            result.push_back(0);  // No negative number
26
27
        // Remove elements that are out of the current window
28
        while (!dq.empty() && dq.front() < i - k + 1) {
29
            dq.pop_front();
30
        }
31
32
        // Add the next element if negative
33
        if (i < n && arr[i] < 0) {
34
            dq.push_back(i);
35
        }
36
    }
37
38
    return result;
39
}
40
41
42
int main() {
43
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
44
    int t;
45
    cin >> t;  // Number of test cases
46
    while (t--) {
47
        int n, k;
48
        cin >> n >> k;  // Size of array and batch size
49
        vector<int> arr(n);
50
        for (int i = 0; i < n; i++) {
51
            cin >> arr[i];
52
        }
53
        54
        vector<int> result = earliest_faulty_readings(arr, k);
55
        for (int num : result) {
56
            cout << num << "" "";
57
        }
58
        cout << endl;
59
    }
60
    return 0;
61
}",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053648
1390053639,unknown,unknown,unknown,"1
2
def faulty_reading(arr, k):
3
    result = []
4
    for i in range(0,len(arr) - k + 1):
5
        for j in range(i,i+k):
6
            if arr[j] < 0:
7
                result.append(arr[j])
8
                break
9
            if j == i+k-1:
10
                result.append(0)
11
    return result
12
13
14
15
t = int(input())
16
17
for _ in range(t):
18
    n,k = map(int,input().split())
19
    arr = list(map(int,input().split()))
20
    print(*faulty_reading(arr,k))",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053639
1390053640,unknown,unknown,unknown,"1
def minimize_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    4
    # Create list of (value + index) for each firewall
5
    skip_value = []
6
    for i in range(n):
7
        skip_value.append((firewalls[i] + i, i))
8
9
    # Sort by descending benefit to skip
10
    skip_value.sort(reverse=True)
11
12
    # Mark which firewalls to skip
13
    skipped = [0] * n
14
    for i in range(k):
15
        _, idx = skip_value[i]
16
        skipped[idx] = 1
17
18
    # Now calculate final effort
19
    effort = 0
20
    penalty = 0
21
    for i in range(n):
22
        if skipped[i]:
23
            penalty += 1
24
        else:
25
            effort += firewalls[i] + penalty
26
27
    return effort
28
29
# Main driver
30
T = int(input())
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    firewalls = list(map(int, input().split()))
34
    print(minimize_effort(n, k, firewalls))",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053640
1390053637,unknown,unknown,unknown,"1
def minimize_effort(test_cases):
2
    results = []
3
    4
    for n, k, strengths in test_cases:
5
        # Sort the strengths array to prioritize skipping the most costly firewalls
6
        strengths.sort()
7
        8
        # Skip up to k strongest firewalls, which are now the last k elements in the sorted list
9
        total_effort = sum(strengths[:-k]) if k < n else 0
10
        11
        results.append(total_effort)
12
    13
    return results
14
15
# Input reading
16
T = int(input())
17
test_cases = []
18
19
for _ in range(T):
20
    n, k = map(int, input().split())
21
    strengths = list(map(int, input().split()))
22
    test_cases.append((n, k, strengths))
23
24
# Get results
25
results = minimize_effort(test_cases)
26
27
# Output results
28
for res in results:
29
    print(res)",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053637
1390053636,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",125,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053636
1390053632,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        prefix_0 = [0] * (n + 1)
7
        prefix_1 = [0] * (n + 1)
8
        for i in range(n):
9
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
10
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
11
        for i in range(n + 1):
12
            for j in range(i, n + 1):
13
                remaining_0s = prefix_0[j] - prefix_0[i]
14
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
15
                cost = max(remaining_0s, removed_1s)
16
                if cost < min_cost:
17
                    min_cost = cost
18
        results.append(min_cost)
19
    return results
20
T = int(input())
21
test_cases = [input().strip() for _ in range(T)]
22
results = min_decommission_cost(test_cases)
23
for result in results:
24
    print(result)",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053632
1390053634,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053634
1390053635,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # If we can skip all firewalls, return 0 effort
3
    if k >= n:
4
        return 0
5
6
    # Initialize DP array: dp[j] = min effort using at most j skips
7
    dp = [float('inf')] * (k + 1)
8
    dp[0] = 0  # Base case: No firewalls, no effort
9
10
    for i in range(1, n + 1):
11
        # Process in **reverse order** to avoid overwriting dp[j-1]
12
        for j in range(min(k, i), -1, -1):  
13
            # Case 1: Don't skip this firewall
14
            if j <= i - 1:
15
                dp[j] = dp[j] + strengths[i-1] + j
16
17
            # Case 2: Skip this firewall (if we have skips left)
18
            if j > 0:
19
                dp[j] = min(dp[j], dp[j-1])
20
21
    return dp[k]
22
23
def solve():
24
    t = int(input())  # Read number of test cases
25
    26
    for _ in range(t):
27
        n, k = map(int, input().split())  # Read n (firewalls) and k (max skips)
28
        strengths = list(map(int, input().split()))  # Read firewall strengths
29
        30
        # Special case: If we can skip all firewalls
31
        if k >= n:
32
            print(0)
33
        else:
34
            print(min_effort_to_breach(n, k, strengths))
35
36
# Run the solution
37
solve()
38",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053635
1390053626,unknown,unknown,unknown,"1
def calculate_minimum_effort(test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        # Calculate the total effort
6
        total_effort = sum(firewalls)
7
        8
        # If k is equal to n, we can skip all firewalls
9
        if k == n:
10
            min_effort = 0
11
        else:
12
            # Sort the firewalls to find the k largest easily
13
            firewalls.sort()
14
            # Sum of the k largest firewalls
15
            sum_of_k_largest = sum(firewalls[-k:])
16
            # Minimum effort is total effort minus the sum of the k largest firewalls
17
            min_effort = total_effort - sum_of_k_largest
18
        19
        results.append(min_effort)
20
    21
    return results
22
23
def main():
24
    import sys
25
    input = sys.stdin.read
26
    data = input().splitlines()
27
    28
    index = 0
29
    T = int(data[index])
30
    index += 1
31
    test_cases = []
32
    33
    for _ in range(T):
34
        n, k = map(int, data[index].split())
35
        index += 1
36
        firewalls = list(map(int, data[index].split()))
37
        index += 1
38
        test_cases.append((n, k, firewalls))
39
    40
    results = calculate_minimum_effort(test_cases)
41
    42
    for result in results:
43
        print(result)
44
45
if __name__ == ""__main__"":
46
    main()",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053626
1390053627,unknown,unknown,unknown,"1
t = int(input())
2
3
for _ in range(t):
4
    n, k = map(int, input().split())
5
    arr = list(map(int, input().split()))
6
    result = []
7
8
    for i in range(n - k + 1):
9
        batch = arr[i:i + k]
10
        for num in batch:
11
            if num < 0:
12
                result.append(num)
13
                break
14
        else:
15
            result.append(0)  
16
    print(*result)
17
                18
            19
            ",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053627
1390053631,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Precompute prefix and suffix sums for active and idle servers
5
    prefix_active = [0] * (n + 1)  # prefix_active[i] = # of active servers in servers[0:i]
6
    prefix_idle = [0] * (n + 1)    # prefix_idle[i] = # of idle servers in servers[0:i]
7
    8
    for i in range(n):
9
        prefix_active[i + 1] = prefix_active[i] + (1 if servers[i] == '1' else 0)
10
        prefix_idle[i + 1] = prefix_idle[i] + (1 if servers[i] == '0' else 0)
11
    12
    total_active = prefix_active[n]
13
    total_idle = prefix_idle[n]
14
    15
    min_cost = float('inf')
16
    17
    # Try all possible left and right cuts
18
    for left in range(n + 1):  # Remove servers[0:left]
19
        for right in range(left, n + 1):  # Keep servers[left:right]
20
            # Active servers removed = those removed from left + those removed from right
21
            active_removed_left = prefix_active[left]
22
            active_removed_right = total_active - prefix_active[right]
23
            active_removed = active_removed_left + active_removed_right
24
            25
            # Idle servers remaining = those in the middle section we keep
26
            idle_remaining = prefix_idle[right] - prefix_idle[left]
27
            28
            cost = max(idle_remaining, active_removed)
29
            min_cost = min(min_cost, cost)
30
    31
    return min_cost
32
33
def main():
34
    t = int(input().strip())
35
    for _ in range(t):
36
        servers = input().strip()
37
        print(min_decommissioning_cost(servers))
38
39
if __name__ == ""__main__"":
40
    main()",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053631
1390053623,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053623
1390053624,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053624
1390053625,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int t = sc.nextInt(); // Number of test cases
8
9
        while (t-- > 0) {
10
            int n = sc.nextInt(); // Size of array
11
            int k = sc.nextInt(); // Batch size
12
            int[] arr = new int[n];
13
14
            // Read array elements
15
            for (int i = 0; i < n; i++) {
16
                arr[i] = sc.nextInt();
17
            }
18
19
            // Process each batch
20
            for (int i = 0; i <= n - k; i++) { 
21
                int found = 0; // Flag to check if negative found
22
                for (int j = i; j < i + k; j++) { 
23
                    if (arr[j] < 0) { 
24
                        System.out.print(arr[j] + "" ""); // Print first negative
25
                        found = 1;
26
                        break; // Stop checking this batch
27
                    }
28
                }
29
                if (found == 0) System.out.print(""0 ""); // No negative found
30
            }
31
            System.out.println(); // New line for next test case
32
        }
33
    }
34
}
35",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053625
1390053622,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    prefix_active = [0] * (n + 1)
5
    prefix_idle = [0] * (n + 1)
6
    7
    for i in range(n):
8
        prefix_active[i + 1] = prefix_active[i] + (1 if server_rack[i] == '1' else 0)
9
        prefix_idle[i + 1] = prefix_idle[i] + (1 if server_rack[i] == '0' else 0)
10
    11
    total_active = prefix_active[n]
12
    total_idle = prefix_idle[n]
13
    14
    min_cost = n
15
    16
    for prefix in range(n + 1):
17
        for suffix in range(n + 1 - prefix):
18
            if prefix + suffix == n:
19
                cost = total_active
20
            else:
21
                active_removed = prefix_active[prefix] + (prefix_active[n] - prefix_active[n - suffix])
22
                idle_remaining = total_idle - (prefix_idle[prefix] + (prefix_idle[n] - prefix_idle[n - suffix]))
23
                cost = max(idle_remaining, active_removed)
24
            25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
t = int(input().strip())
30
for _ in range(t):
31
    server_rack = input().strip()
32
    print(min_decommissioning_cost(server_rack))",126,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053622
1390053619,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053619
1390053620,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053620
1390053621,unknown,unknown,unknown,"1
def minimum_effort(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n, k = test_cases[t][0]
6
        arr = test_cases[t][1][:]
7
        8
        if k >= n:
9
            results.append(0)
10
            continue
11
        12
        min_effort = float('inf')
13
        14
        for i in range(1 << n):
15
            skipped_indices = []
16
            17
            for j in range(n):
18
                if (i >> j) & 1:
19
                    skipped_indices.append(j)
20
                    21
            if len(skipped_indices) <= k:
22
                effort = 0
23
                temp_arr = arr[:]
24
                25
                for j in range(n):
26
                    if not (i >> j) & 1:
27
                        effort += temp_arr[j]
28
                        for l in range(j + 1, n):
29
                            if (i >> l) & 1:
30
                                continue
31
                            temp_arr[l] += 1
32
                33
                min_effort = min(min_effort, effort)
34
        35
        results.append(min_effort)
36
        37
    return results
38
39
# Input reading
40
T = int(input())
41
test_cases = []
42
43
# Read all test cases
44
for _ in range(T):
45
    n, k = map(int, input().split())
46
    arr = list(map(int, input().split()))
47
    test_cases.append([(n, k), arr])
48
49
# Get the results and print them
50
results = minimum_effort(T, test_cases)
51
52
for result in results:
53
    print(result)",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053621
1390053615,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    ans = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            10
            decommissioned_ones = 0
11
            remaining_zeros = 0
12
            13
            # Decommission from the beginning
14
            decommissioned_ones += s[:i].count('1')
15
            16
            # Decommission from the end
17
            decommissioned_ones += s[n - j:].count('1')
18
            19
            # Remaining string after decommissioning
20
            remaining_string = s[i:n - j]
21
            remaining_zeros = remaining_string.count('0')
22
            23
            ans = min(ans, max(decommissioned_ones, remaining_zeros))
24
            25
    print(ans)
26
27
t = int(input())
28
for _ in range(t):
29
    solve()",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053615
1390053618,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total active servers and total idle servers
5
    total_active = server_string.count('1')
6
    total_idle = n - total_active
7
    8
    # Precompute cumulative counts of active servers from left
9
    active_prefix_sum = [0] * (n + 1)
10
    for i in range(n):
11
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
12
    13
    min_cost = float('inf')
14
    15
    # Try all possible starting positions for the remaining servers
16
    for left in range(n + 1):
17
        # For each possible ending position
18
        for right in range(left, n + 1):
19
            # Active servers in the remaining segment
20
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
21
            idle_remaining = (right - left) - active_remaining
22
            23
            # Active servers removed
24
            active_removed = total_active - active_remaining
25
            26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
def faster_min_decommission_cost(server_string):
32
    n = len(server_string)
33
    34
    # Precompute prefix sums for active and idle servers
35
    active_prefix = [0] * (n + 1)
36
    idle_prefix = [0] * (n + 1)
37
    38
    for i in range(n):
39
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
40
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
41
    42
    min_cost = n  # Worst case cost
43
    44
    # For each possible remaining substring (from i to j-1)
45
    for i in range(n + 1):
46
        for j in range(i, n + 1):
47
            # Idle servers in remaining substring
48
            idle_remaining = idle_prefix[j] - idle_prefix[i]
49
            50
            # Active servers removed (from left and right)
51
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
52
            53
            cost = max(idle_remaining, active_removed)
54
            min_cost = min(min_cost, cost)
55
    56
    return min_cost
57
58
def main():
59
    t = int(input().strip())
60
    61
    for _ in range(t):
62
        server_string = input().strip()
63
        result = faster_min_decommission_cost(server_string)
64
        print(result)
65
66
if __name__ == ""__main__"":
67
    main()",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053618
1390053614,unknown,unknown,unknown,"1
def min_decommission_cost(server_rack):
2
    total_active = server_rack.count('1')
3
    total_idle = server_rack.count('0')
4
5
    min_cost = min(total_active, total_idle)  # Worst case: remove all active or all idle
6
7
    left, right = 0, len(server_rack) - 1
8
    removed_active = 0
9
    removed_idle = 0
10
11
    # Try decommissioning from both ends
12
    while left <= right:
13
        if server_rack[left] == '0':
14
            removed_idle += 1
15
            left += 1
16
        elif server_rack[right] == '0':
17
            removed_idle += 1
18
            right -= 1
19
        elif server_rack[left] == '1':
20
            removed_active += 1
21
            left += 1
22
        elif server_rack[right] == '1':
23
            removed_active += 1
24
            right -= 1
25
        26
        remaining_idle = total_idle - removed_idle
27
        min_cost = min(min_cost, max(remaining_idle, removed_active))
28
29
    return min_cost
30
31
32
# Read input
33
T = int(input())  # Number of test cases
34
results = []
35
36
for _ in range(T):
37
    server_rack = input().strip()
38
    results.append(min_decommission_cost(server_rack))
39
40
# Print results
41
for res in results:
42
    print(res)",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053614
1390053607,unknown,unknown,unknown,"1
import java.util.*;
2
import java.io.*;
3
4
public class FaultyComponents {
5
6
    public static void main(String[] args) throws IOException {
7
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
8
        9
        // Read number of test cases
10
        int t = Integer.parseInt(reader.readLine().trim());
11
        12
        StringBuilder output = new StringBuilder();
13
        14
        for (int testCase = 0; testCase < t; testCase++) {
15
            // Read n and k
16
            String[] nk = reader.readLine().trim().split("" "");
17
            int n = Integer.parseInt(nk[0]);
18
            int k = Integer.parseInt(nk[1]);
19
            20
            // Read the array of sensor readings
21
            String[] arrStr = reader.readLine().trim().split("" "");
22
            int[] arr = new int[n];
23
            for (int i = 0; i < n; i++) {
24
                arr[i] = Integer.parseInt(arrStr[i]);
25
            }
26
            27
            ArrayList<Integer> results = findEarliestFaults(n, k, arr);
28
            29
            // Convert results to a single string line
30
            for (int i = 0; i < results.size(); i++) {
31
                if (i > 0) output.append("" "");
32
                output.append(results.get(i));
33
            }
34
            output.append(""\n"");
35
        }
36
        37
        System.out.println(output.toString());
38
    }
39
40
    public static ArrayList<Integer> findEarliestFaults(int n, int k, int[] arr) {
41
        ArrayList<Integer> result = new ArrayList<>();
42
        Deque<Integer> dq = new ArrayDeque<>();
43
        44
        // Process the first window
45
        for (int i = 0; i < k; i++) {
46
            if (arr[i] < 0) {
47
                dq.addLast(i);
48
            }
49
        }
50
        51
        // Store result for the first window
52
        if (!dq.isEmpty()) {
53
            result.add(arr[dq.peek()]);
54
        } else {
55
            result.add(0);
56
        }
57
        58
        // Process the rest of the array
59
        for (int i = k; i < n; i++) {
60
            // Remove elements not within the sliding window
61
            while (!dq.isEmpty() && dq.peek() <= i - k) {
62
                dq.poll();
63
            }
64
            65
            // Add the current element if it's negative
66
            if (arr[i] < 0) {
67
                dq.addLast(i);
68
            }
69
            70
            // Append result for the current window
71
            if (!dq.isEmpty()) {
72
                result.add(arr[dq.peek()]);
73
            } else {
74
                result.add(0);
75
            }
76
        }
77
        78
        return result;
79
    }
80
}",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053607
1390053605,unknown,unknown,unknown,"1
def generate_skip_options(n, k, start=0, current_skips=[], all_skips=[]):
2
    if len(current_skips) == k:
3
        all_skips.append(current_skips[:]) 
4
        return
5
    6
    for i in range(start, n):
7
        current_skips.append(i)
8
        generate_skip_options(n, k, i + 1, current_skips, all_skips)
9
        current_skips.pop() 
10
11
def min_effort_to_breach(n, k, firewalls):
12
    min_effort = float('inf')
13
    all_skip_options = []
14
    15
    generate_skip_options(n, k, 0, [], all_skip_options)
16
    17
    for skip_indices in all_skip_options:
18
        effort = 0
19
        skipped = set(skip_indices)
20
        21
        security_increase = 0 
22
        for i in range(n):
23
            if i in skipped:
24
                security_increase += 1  
25
            else:
26
                effort += firewalls[i] + security_increase  
27
28
        min_effort = min(min_effort, effort)
29
30
    return min_effort
31
32
T = int(input()) 
33
34
for _ in range(T):
35
    n, k = map(int, input().split())
36
    firewalls = list(map(int, input().split()))
37
    print(min_effort_to_breach(n, k, firewalls))
38",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053605
1390053613,unknown,unknown,unknown,"1
def earliest_faulty_readings(arr, k):
2
    n = len(arr)
3
    result = []
4
    5
    for i in range(n - k + 1):
6
        batch = arr[i:i + k]  # Extract batch of size k
7
        found = 0
8
        for num in batch:
9
            if num < 0:
10
                found = num  # First faulty component
11
                break
12
        result.append(found)
13
    14
    return result
15
16
# Input handling
17
t = int(input())  # Number of test cases
18
for _ in range(t):
19
    n, k = map(int, input().split())  # Array size and batch size
20
    arr = list(map(int, input().split()))  # Sensor readings
21
    print(*earliest_faulty_readings(arr, k))  # Print results space-separated
22",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053613
1390053604,unknown,unknown,unknown,"1
import bisect
2
3
4
T = int(input())
5
6
for _ in range(T):
7
    8
    s = input().strip()
9
    n = len(s)
10
    11
    12
    prefix_0= [0]* (n+1)
13
    prefix_1 = [0] *(n+1)
14
    15
    #assign
16
    17
    18
    for i in range(n):
19
        prefix_0[i+ 1] =prefix_0[i] +(1 if s[i]== '0' else 0)
20
        prefix_1[i+ 1] = prefix_1[i]+ (1 if s[i] == '1' else 0)
21
    total_1 = prefix_1[n]
22
    23
   24
    def check(m):
25
        26
        #check
27
        28
        29
        for j in range(n + 1):
30
            target = prefix_0[j] - m
31
            l_j = bisect.bisect_left(prefix_0, target)
32
            if l_j<=j and prefix_1[l_j]<=m -(total_1-prefix_1[j]):
33
                return True
34
        return False
35
    36
    37
    low,high =0, n
38
    39
    while low<high:
40
        mid=(low+high)//2
41
        if check(mid):
42
            high=mid
43
        else:
44
            low=mid + 1
45
            46
            47
    print(low)",127,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053604
1390053601,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    4
    for n, k, arr in test_cases:
5
        total_effort = sum(arr)  # Compute total effort without skipping
6
7
        if k >= n:  
8
            results.append(""0"")  # If k >= n, we can skip all firewalls.
9
            continue
10
11
        # Compute the minimum effort after skipping one firewall
12
        min_effort = float('inf')
13
14
        for i in range(n):
15
            effort_with_skip = (total_effort - arr[i]) + k
16
            min_effort = min(min_effort, effort_with_skip)
17
18
        results.append(str(min_effort))
19
20
    return ""\n"".join(results)
21
22
23
# Reading input
24
t = int(input())  # Number of test cases
25
test_cases = []
26
27
for _ in range(t):
28
    n, k = map(int, input().split())  # Number of firewalls and penalty
29
    arr = list(map(int, input().split()))  # Firewall strengths
30
    test_cases.append((n, k, arr))
31
32
# Output results
33
print(min_effort(test_cases))
34",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053601
1390053602,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <algorithm>
4
#include <vector>
5
6
using namespace std;
7
8
int min_pruning_cost(const string& server_rack) {
9
    int n = server_rack.length();
10
    int min_cost = n + 1;
11
12
    for (int left_remove_count = 0; left_remove_count <= n; ++left_remove_count) {
13
        for (int right_remove_count = 0; right_remove_count <= n - left_remove_count; ++right_remove_count) {
14
            int idle_remaining = 0;
15
            int active_removed = 0;
16
17
            // Calculate active_removed
18
            for (int i = 0; i < left_remove_count; ++i) {
19
                if (server_rack[i] == '1') {
20
                    active_removed++;
21
                }
22
            }
23
            for (int i = n - right_remove_count; i < n; ++i) {
24
                if (server_rack[i] == '1') {
25
                    active_removed++;
26
                }
27
            }
28
29
            // Calculate idle_remaining
30
            for (int i = left_remove_count; i < n - right_remove_count; ++i) {
31
                if (server_rack[i] == '0') {
32
                    idle_remaining++;
33
                }
34
            }
35
36
            int cost = max(idle_remaining, active_removed);
37
            min_cost = min(min_cost, cost);
38
        }
39
    }
40
    return min_cost;
41
}
42
43
int main() {
44
    ios_base::sync_with_stdio(false);
45
    cin.tie(NULL);
46
47
    int t;
48
    cin >> t;
49
    while (t--) {
50
        string server_rack;
51
        cin >> server_rack;
52
        cout << min_pruning_cost(server_rack) << endl;
53
    }
54
    return 0;
55
}",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053602
1390053603,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static int minEffort(int[] firewalls, int k) {
7
        int n = firewalls.length;
8
        if (k >= n) return 0;
9
10
        int[] dp = new int[k + 1];
11
        Arrays.fill(dp, Integer.MAX_VALUE);
12
        dp[0] = 0;
13
14
        for (int i = 0; i < n; i++) {
15
            for (int j = k; j >= 0; j--) {
16
                if (dp[j] != Integer.MAX_VALUE) {
17
                    dp[j] += firewalls[i] + j;
18
                }
19
                if (j > 0) {
20
                    dp[j] = Math.min(dp[j], dp[j - 1]);
21
                }
22
            }
23
        }
24
25
        return dp[k];
26
    }
27
28
    public static void main(String[] args) {
29
        Scanner sc = new Scanner(System.in);
30
        int t = sc.nextInt();
31
32
        while (t-- > 0) {
33
            int n = sc.nextInt();
34
            int k = sc.nextInt();
35
            int[] firewalls = new int[n];
36
37
            for (int i = 0; i < n; i++) {
38
                firewalls[i] = sc.nextInt();
39
            }
40
41
            System.out.println(minEffort(firewalls, k));
42
        }
43
44
        sc.close();
45
    }
46
}
47",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053603
1390053596,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total active ('1') and idle ('0') servers
5
    total_active = server_string.count('1')
6
    total_idle = n - total_active
7
8
    # Precompute cumulative count of active servers from the left
9
    active_prefix_sum = [0] * (n + 1)
10
    for i in range(n):
11
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
12
    13
    min_cost = float('inf')
14
15
    # Try all possible segments
16
    for left in range(n + 1):
17
        for right in range(left, n + 1):
18
            # Active servers in the selected range
19
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
20
            idle_remaining = (right - left) - active_remaining
21
22
            # Active servers removed (total active - active in range)
23
            active_removed = total_active - active_remaining
24
25
            # Cost is max of idle servers in range or removed active servers
26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
def faster_min_decommission_cost(server_string):
32
    n = len(server_string)
33
34
    # Precompute prefix sums for active ('1') and idle ('0') servers
35
    active_prefix = [0] * (n + 1)
36
    idle_prefix = [0] * (n + 1)
37
38
    for i in range(n):
39
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
40
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
41
42
    min_cost = n  # Worst case scenario
43
44
    # Iterate through all possible substrings efficiently
45
    for i in range(n + 1):
46
        for j in range(i, n + 1):
47
            # Idle servers in the selected range
48
            idle_remaining = idle_prefix[j] - idle_prefix[i]
49
50
            # Active servers removed (total active - active in selected range)
51
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
52
53
            # Compute cost and update minimum
54
            cost = max(idle_remaining, active_removed)
55
            min_cost = min(min_cost, cost)
56
57
    return min_cost
58
59
def main():
60
    t = int(input().strip())
61
62
    for _ in range(t):
63
        server_string = input().strip()
64
        result = faster_min_decommission_cost(server_string)
65
        print(result)
66
67
if __name__ == ""__main__"":
68
    main()
69",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053596
1390053597,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Compute the initial total effort if we do NOT skip any firewall
3
    effort = sum(strengths[i] + i for i in range(n))
4
5
    # Create a list of (contribution, index)
6
    contributions = [(strengths[i] + i, i) for i in range(n)]
7
8
    # Sort by contribution (ascending) to skip the weakest k firewalls
9
    contributions.sort()
10
11
    # Remove k weakest firewalls from effort
12
    for i in range(k):
13
        effort -= contributions[i][0]
14
15
    return effort
16
17
def solve():
18
    t = int(input())  # Read number of test cases
19
    20
    for _ in range(t):
21
        n, k = map(int, input().split())  # Read n (firewalls) and k (max skips)
22
        strengths = list(map(int, input().split()))  # Read firewall strengths
23
24
        print(min_effort_to_breach(n, k, strengths))
25
26
# Run the solution
27
solve()
28",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053597
1390053600,unknown,unknown,unknown,"1
def min_effort_to_breach(firewalls, n, k):
2
    total_effort = sum(firewalls)  # Total effort without skipping any firewall
3
    4
    # If we can skip all firewalls, return 0
5
    if k == n:
6
        return 0
7
8
    # Sliding window approach to find the minimum effort when skipping up to k firewalls
9
    min_effort = total_effort
10
    skipped_effort = sum(firewalls[:k])  # Initial sum of the first k firewalls
11
12
    # Try different positions for skipping
13
    for i in range(k, n):
14
        min_effort = min(min_effort, total_effort - skipped_effort)
15
        skipped_effort += firewalls[i] - firewalls[i - k]
16
17
    # Final check for the last possible skip window
18
    min_effort = min(min_effort, total_effort - skipped_effort)
19
20
    return min_effort
21
22
# Read input
23
T = int(input())  # Number of test cases
24
for _ in range(T):
25
    n, k = map(int, input().split())  # Number of firewalls and max skips
26
    firewalls = list(map(int, input().split()))  # Strength of firewalls
27
    print(min_effort_to_breach(firewalls, n, k))
28",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053600
1390053591,unknown,unknown,unknown,"1
def find_earliest_faults(arr, k):
2
    result = []
3
    for i in range(len(arr) - k + 1):
4
        batch = arr[i:i + k]
5
        fault = 0
6
        for j, val in enumerate(batch):
7
            if val < 0:
8
                fault = val
9
                break
10
        result.append(fault)
11
    return result
12
13
def solve():
14
    n, k = map(int, input().split())
15
    arr = list(map(int, input().split()))
16
    result = find_earliest_faults(arr, k)
17
    print(*result)
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053591
1390053595,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static int minEffort(int n, int k, int[] firewalls) {
6
        int[][] dp = new int[n + 1][k + 1];
7
        8
        // Initialize DP array with large values
9
        for (int i = 0; i <= n; i++) {
10
            Arrays.fill(dp[i], Integer.MAX_VALUE);
11
        }
12
        dp[0][0] = 0;
13
14
        // DP Computation
15
        for (int i = 1; i <= n; i++) {
16
            for (int j = 0; j <= k; j++) {
17
                // Case 1: Don't skip the firewall
18
                if (dp[i - 1][j] != Integer.MAX_VALUE) {
19
                    dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j;
20
                }
21
22
                // Case 2: Skip the firewall (if skips available)
23
                if (j > 0 && dp[i - 1][j - 1] != Integer.MAX_VALUE) {
24
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
25
                }
26
            }
27
        }
28
29
        // Answer is the minimum effort across all skip possibilities
30
        int minEffort = Integer.MAX_VALUE;
31
        for (int j = 0; j <= k; j++) {
32
            minEffort = Math.min(minEffort, dp[n][j]);
33
        }
34
35
        return minEffort;
36
    }
37
38
    public static void main(String[] args) throws IOException {
39
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
40
        int T = Integer.parseInt(br.readLine().trim()); // Number of test cases
41
        StringBuilder result = new StringBuilder();
42
43
        for (int t = 0; t < T; t++) {
44
            String[] nk = br.readLine().trim().split("" "");
45
            int n = Integer.parseInt(nk[0]);
46
            int k = Integer.parseInt(nk[1]);
47
            int[] firewalls = new int[n];
48
49
            String[] firewallValues = br.readLine().trim().split("" "");
50
            for (int i = 0; i < n; i++) {
51
                firewalls[i] = Integer.parseInt(firewallValues[i]);
52
            }
53
54
            result.append(minEffort(n, k, firewalls)).append(""\n"");
55
        }
56
57
        // Print all results in one go (faster output)
58
        System.out.print(result.toString());
59
    }
60
}
61",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053595
1390053593,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Use dynamic programming to find optimal solution
3
    # dp[i][j] = min effort to breach first i firewalls by skipping exactly j firewalls
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Skip current firewall (if we still have skips left)
13
            if j > 0:
14
                # If we skip this firewall, all subsequent firewalls increase by 1
15
                dp[i][j] = dp[i-1][j-1]
16
            17
            # Option 2: Don't skip current firewall
18
            # Current firewall strength may have increased due to previous skips
19
            current_strength = strengths[i-1] + j  # j = number of firewalls skipped so far
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
    22
    # Return minimum effort among all possible ways to use up to k skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    results = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().split())
31
        strengths = list(map(int, input().split()))
32
        results.append(min_effort_to_breach(n, k, strengths))
33
    34
    for result in results:
35
        print(result)
36
37
solve()",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053593
1390053589,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)",128,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053589
1390053581,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053581
1390053582,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36
37",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053582
1390053586,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    """"""
3
    Calculate minimum effort to breach n firewalls with optimal strategy.
4
    5
    Args:
6
        n: Number of firewalls
7
        k: Maximum number of firewalls that can be skipped
8
        firewalls: List of firewall strengths
9
        10
    Returns:
11
        Minimum effort required
12
    """"""
13
    # If we can skip all firewalls, return 0
14
    if k >= n:
15
        return 0
16
    17
    # Initialize dp array with infinity
18
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
19
    20
    # Base case: no firewalls, no effort
21
    dp[0][0] = 0
22
    23
    for i in range(1, n + 1):
24
        firewall_idx = i - 1  # Convert to 0-indexed
25
        26
        for j in range(k + 1):
27
            # Option 1: Don't skip the current firewall
28
            if j <= i - 1:  # Ensure we have processed enough firewalls
29
                dp[i][j] = min(dp[i][j], dp[i-1][j] + firewalls[firewall_idx] + j)
30
            31
            # Option 2: Skip the current firewall
32
            if j > 0:  # We must have at least one skip available
33
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
34
    35
    # Return the minimum effort after processing all firewalls
36
    return dp[n][k]
37
38
def main():
39
    t = int(input())  # Number of test cases
40
    41
    for _ in range(t):
42
        n, k = map(int, input().split())
43
        firewalls = list(map(int, input().split()))
44
        45
        min_effort = min_effort_to_breach(n, k, firewalls)
46
        print(min_effort)
47
48
if __name__ == ""__main__"":
49
    main()",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053586
1390053578,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class FirewallBreach {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
9
        while (t-- > 0) {
10
            int n = scanner.nextInt();
11
            int k = scanner.nextInt();
12
            int[] a = new int[n];
13
14
            for (int i = 0; i < n; i++) {
15
                a[i] = scanner.nextInt();
16
            }
17
18
            int minEffort = Integer.MAX_VALUE;
19
20
            for (int i = 0; i < (1 << n); i++) {
21
                int skippedCount = 0;
22
                int effort = 0;
23
                int currentSkipCount = 0;
24
25
                for (int j = 0; j < n; j++) {
26
                    if ((i & (1 << j)) != 0) {
27
                        skippedCount++;
28
                    }
29
                }
30
31
                if (skippedCount <= k) {
32
                    for (int j = 0; j < n; j++) {
33
                        if ((i & (1 << j)) != 0) {
34
                            currentSkipCount++;
35
                        } else {
36
                            effort += a[j] + currentSkipCount;
37
                        }
38
                    }
39
                    minEffort = Math.min(minEffort, effort);
40
                }
41
            }
42
43
            System.out.println(minEffort);
44
        }
45
        scanner.close();
46
    }
47
}",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053578
1390053580,unknown,unknown,unknown,"1
def earliest_faulty_readings(arr, n, k):
2
    result = []
3
    for i in range(n - k + 1):
4
        batch = arr[i:i + k]
5
        first_faulty = next((x for x in batch if x < 0), 0)
6
        result.append(first_faulty)
7
    return result
8
9
# Read input
10
t = int(input())
11
for _ in range(t):
12
    n, k = map(int, input().split())
13
    arr = list(map(int, input().split()))
14
    print(*earliest_faulty_readings(arr, n, k))
15",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053580
1390053577,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    n = len(arr)
5
    result, dq = [], deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
11
    for i in range(n - k + 1):
12
        result.append(arr[dq[0]] if dq else 0)
13
        if dq and dq[0] == i:
14
            dq.popleft()
15
        if i + k < n and arr[i + k] < 0:
16
            dq.append(i + k)
17
    18
    return result
19
20
t = int(input())
21
for _ in range(t):
22
    n, k = map(int, input().split())
23
    arr = list(map(int, input().split()))
24
    print(*earliest_faults(arr, k))
25",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053577
1390053571,unknown,unknown,unknown,"1
def minimum_pruning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    active_prefix_sum = [0] * (n + 1)
5
    for i in range(n):
6
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_rack[i] == '1' else 0)
7
    8
    active_suffix_sum = [0] * (n + 1)
9
    for i in range(n - 1, -1, -1):
10
        active_suffix_sum[n - 1 - i] = active_suffix_sum[n - i - 2] if n - i - 2 >= 0 else 0
11
        active_suffix_sum[n - 1 - i] += (1 if server_rack[i] == '1' else 0)
12
    13
    min_cost = float('inf')
14
    15
    for left in range(n + 1):
16
        for right in range(n + 1 - left):
17
            if left == 0 and right == 0:
18
                continue
19
            20
            active_decommissioned = active_prefix_sum[left] + active_suffix_sum[right]
21
            22
            remaining_length = n - left - right
23
            remaining_active = active_prefix_sum[left + remaining_length] - active_prefix_sum[left]
24
            remaining_idle = remaining_length - remaining_active
25
            26
            cost = max(remaining_idle, active_decommissioned)
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
def main():
32
    t = int(input().strip())
33
    34
    results = []
35
    for _ in range(t):
36
        server_rack = input().strip()
37
        results.append(minimum_pruning_cost(server_rack))
38
    39
    for result in results:
40
        print(result)
41
42
if __name__ == ""__main__"":
43
    main()",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053571
1390053572,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Main {
4
5
    // Function to compute the minimum decommission cost for a given test case string
6
    public static int minDecommissionCost(String testCase) {
7
        int n = testCase.length();
8
        int minCost = Integer.MAX_VALUE;
9
10
        // Create prefix sum arrays for '0's and '1's of length n+1
11
        int[] prefix0 = new int[n + 1];
12
        int[] prefix1 = new int[n + 1];
13
14
        // Precompute prefix sums for 0's and 1's
15
        for (int i = 0; i < n; i++) {
16
            char ch = testCase.charAt(i);
17
            prefix0[i + 1] = prefix0[i] + (ch == '0' ? 1 : 0);
18
            prefix1[i + 1] = prefix1[i] + (ch == '1' ? 1 : 0);
19
        }
20
21
        // Iterate through all possible splits using indices i and j
22
        // i represents the start index for the ""removed"" section at the beginning,
23
        // and j represents the end index (exclusive) for the remaining segment.
24
        for (int i = 0; i <= n; i++) {
25
            for (int j = i; j <= n; j++) {
26
                // Count of '0's in the remaining segment [i, j-1]
27
                int remaining0s = prefix0[j] - prefix0[i];
28
                // Count of '1's that have been removed: those before i and after j-1
29
                int removed1s = prefix1[i] + (prefix1[n] - prefix1[j]);
30
                // The cost for this split is the maximum of the two counts
31
                int cost = Math.max(remaining0s, removed1s);
32
                if (cost < minCost) {
33
                    minCost = cost;
34
                }
35
            }
36
        }
37
        return minCost;
38
    }
39
40
    public static void main(String[] args) {
41
        Scanner scanner = new Scanner(System.in);
42
        43
        // Read the number of test cases
44
        int T = scanner.nextInt();
45
        scanner.nextLine();  // Consume the newline
46
        47
        // Process each test case
48
        for (int t = 0; t < T; t++) {
49
            String testCase = scanner.nextLine().trim();
50
            int result = minDecommissionCost(testCase);
51
            System.out.println(result);
52
        }
53
        54
        scanner.close();
55
    }
56
}
57",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053572
1390053576,unknown,unknown,unknown,"1
def main():
2
3
    import sys
4
5
    input = sys.stdin.read
6
7
    data = input().split(""\n"")
8
9
    10
11
    t = int(data[0])
12
13
    index = 1
14
15
    results = []
16
17
    for _ in range(t):
18
19
        n, k = map(int, data[index].split())
20
21
        strengths = list(map(int, data[index + 1].split()))
22
23
        index += 2
24
25
        26
27
        if k >= n:
28
29
            results.append(""0"")
30
31
            continue
32
33
        34
35
        # Calculate the impact of each firewall: strength + index
36
37
        impact = [(strengths[i] + i, i) for i in range(n)]
38
39
        40
41
        # Sort firewalls by impact (higher impact should be skipped)
42
43
        impact.sort(reverse=True)
44
45
        46
47
        # Select the top k firewalls to skip
48
49
        to_skip = set(idx for _, idx in impact[:k])
50
51
        52
53
        # Compute the minimal effort
54
55
        effort = 0
56
57
        skipped = 0
58
59
        60
61
        for i in range(n):
62
63
            if i in to_skip:
64
65
                skipped += 1
66
67
            else:
68
69
                effort += strengths[i] + skipped
70
71
        72
73
        results.append(str(effort))
74
75
    76
77
    # Print all results at once (faster output handling)
78
79
    sys.stdout.write(""\n"".join(results) + ""\n"")
80
81
if __name__ == ""__main__"":
82
83
    main()",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053576
1390053567,unknown,unknown,unknown,"1
def min_decommission_cost(server_rack):
2
    total_active = server_rack.count('1')
3
    total_idle = server_rack.count('0')
4
5
    min_cost = min(total_active, total_idle)  # Worst case: remove all active or all idle
6
7
    left, right = 0, len(server_rack) - 1
8
    removed_active = 0
9
    removed_idle = 0
10
11
    # Try decommissioning from both ends
12
    while left <= right:
13
        if server_rack[left] == '0':
14
            removed_idle += 1
15
            left += 1
16
        elif server_rack[right] == '0':
17
            removed_idle += 1
18
            right -= 1
19
        elif server_rack[left] == '1':
20
            removed_active += 1
21
            left += 1
22
        elif server_rack[right] == '1':
23
            removed_active += 1
24
            right -= 1
25
        26
        remaining_idle = total_idle - removed_idle
27
        min_cost = min(min_cost, max(remaining_idle, removed_active))
28
29
    return min_cost
30
31
32
# Read input
33
T = int(input())  # Number of test cases
34
results = []
35
36
for _ in range(T):
37
    server_rack = input().strip()
38
    results.append(min_decommission_cost(server_rack))
39
40
# Print results
41
for res in results:
42
    print(res)",129,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053567
1390053563,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, arr = case
5
        result = []
6
        for i in range(n - k + 1):  # Sliding window
7
            window = arr[i:i + k]
8
            earliest_fault = 0
9
            for num in window:
10
                if num < 0:
11
                    earliest_fault = num
12
                    break
13
            result.append(earliest_fault)
14
        results.append(result)
15
    return results
16
17
# Input Parsing
18
def main():
19
    import sys
20
    input = sys.stdin.read
21
    data = input().split()
22
    idx = 0
23
    T = int(data[idx])  # Number of test cases
24
    idx += 1
25
    test_cases = []
26
    for _ in range(T):
27
        n = int(data[idx])
28
        k = int(data[idx + 1])
29
        idx += 2
30
        arr = list(map(int, data[idx:idx + n]))
31
        idx += n
32
        test_cases.append((n, k, arr))
33
    34
    # Process and Output
35
    results = earliest_faulty_readings(test_cases)
36
    for result in results:
37
        print("" "".join(map(str, result)) + "" "")
38
39
if __name__ == ""__main__"":
40
    main()",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053563
1390053565,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total active servers and total idle servers
5
    total_active = server_string.count('1')
6
    total_idle = n - total_active
7
    8
    # Precompute cumulative counts of active servers from left
9
    active_prefix_sum = [0] * (n + 1)
10
    for i in range(n):
11
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
12
    13
    min_cost = float('inf')
14
    15
    # Try all possible starting positions for the remaining servers
16
    for left in range(n + 1):
17
        # For each possible ending position
18
        for right in range(left, n + 1):
19
            # Active servers in the remaining segment
20
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
21
            idle_remaining = (right - left) - active_remaining
22
            23
            # Active servers removed
24
            active_removed = total_active - active_remaining
25
            26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
def faster_min_decommission_cost(server_string):
32
    n = len(server_string)
33
    34
    # Precompute prefix sums for active and idle servers
35
    active_prefix = [0] * (n + 1)
36
    idle_prefix = [0] * (n + 1)
37
    38
    for i in range(n):
39
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
40
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
41
    42
    min_cost = n  # Worst case cost
43
    44
    # For each possible remaining substring (from i to j-1)
45
    for i in range(n + 1):
46
        for j in range(i, n + 1):
47
            # Idle servers in remaining substring
48
            idle_remaining = idle_prefix[j] - idle_prefix[i]
49
            50
            # Active servers removed (from left and right)
51
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
52
            53
            cost = max(idle_remaining, active_removed)
54
            min_cost = min(min_cost, cost)
55
    56
    return min_cost
57
58
def main():
59
    t = int(input().strip())
60
    61
    for _ in range(t):
62
        server_string = input().strip()
63
        result = faster_min_decommission_cost(server_string)
64
        print(result)
65
66
if __name__ == ""__main__"":
67
    main()",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053565
1390053566,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053566
1390053560,unknown,unknown,unknown,"1
def minimize_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    4
    # Create list of (value + index) for each firewall
5
    skip_value = []
6
    for i in range(n):
7
        skip_value.append((firewalls[i] + i, i))
8
9
    # Sort by descending benefit to skip
10
    skip_value.sort(reverse=True)
11
12
    # Mark which firewalls to skip
13
    skipped = [0] * n
14
    for i in range(k):
15
        _, idx = skip_value[i]
16
        skipped[idx] = 1
17
18
    # Now calculate final effort
19
    effort = 0
20
    penalty = 0
21
    for i in range(n):
22
        if skipped[i]:
23
            penalty += 1
24
        else:
25
            effort += firewalls[i] + penalty
26
27
    return effort
28
29
# Main driver
30
T = int(input())
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    firewalls = list(map(int, input().split()))
34
    print(minimize_effort(n, k, firewalls))",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053560
1390053561,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
int main() {
5
    int T;
6
    cin >> T; 
7
    for (int t = 0; t < T; t++) {
8
        string s;
9
        cin >> s; 
10
        int n = s.length();
11
12
    13
        vector<int> prefix_0(n + 1, 0);
14
        vector<int> prefix_1(n + 1, 0);
15
        for (int i = 1; i <= n; i++) {
16
            prefix_0[i] = prefix_0[i - 1] + (s[i - 1] == '0' ? 1 : 0);
17
            prefix_1[i] = prefix_1[i - 1] + (s[i - 1] == '1' ? 1 : 0);
18
        }
19
20
      21
        auto check = [&](int k) {
22
            int l = 0;
23
         24
            for (int r = 0; r < n; r++) {
25
              26
                while (l <= r && prefix_0[r + 1] - prefix_0[l] > k) {
27
                    l++;
28
                }
29
                // If subarray is valid, check number of 1's decommissioned
30
                if (l <= r && prefix_1[l] + (prefix_1[n] - prefix_1[r + 1]) <= k) {
31
                    return true;
32
                }
33
            }
34
      35
            if (prefix_1[n] <= k) {
36
                return true;
37
            }
38
            return false;
39
        };
40
41
        // Binary search for minimum cost
42
        int low = 0, high = n;
43
        while (low < high) {
44
            int mid = (low + high) / 2;
45
            if (check(mid)) {
46
                high = mid;
47
            } else {
48
                low = mid + 1;
49
            }
50
        }
51
        cout << low << endl;
52
    }
53
    return 0;
54
}",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053561
1390053559,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
5
    int n = arr.size();
6
    vector<int> result;
7
    deque<int> dq;  // Stores indices of negative numbers
8
9
    // Process first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) dq.push_back(i);
12
    }
13
14
    // Process the sliding window
15
    for (int i = k; i <= n; i++) {
16
        // Append first negative number in the window
17
        if (!dq.empty()) 
18
            result.push_back(arr[dq.front()]);  // First negative in the deque
19
        else 
20
            result.push_back(0);  // No negative number
21
22
        // Remove elements that are out of the current window
23
        while (!dq.empty() && dq.front() < i - k + 1) {
24
            dq.pop_front();
25
        }
26
27
        // Add the next element if negative
28
        if (i < n && arr[i] < 0) {
29
            dq.push_back(i);
30
        }
31
    }
32
33
    return result;
34
}
35
36
int main() {
37
    int t;
38
    cin >> t;  // Number of test cases
39
    while (t--) {
40
        int n, k;
41
        cin >> n >> k;  // Size of array and batch size
42
        vector<int> arr(n);
43
        for (int i = 0; i < n; i++) {
44
            cin >> arr[i];
45
        }
46
        47
        vector<int> result = earliest_faulty_readings(arr, k);
48
        for (int num : result) {
49
            cout << num << "" "";
50
        }
51
        cout << endl;
52
    }
53
    return 0;
54
}",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053559
1390053550,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
void solve(){
9
    int n,k;
10
    cin>>n>>k;
11
    12
    vector<int> v(n);
13
    for(int i=0; i<n; i++) cin>>v[i];
14
    15
    vector<int> ans;
16
    for(int i=0; i<=n-k; i++){
17
        bool flag = false;
18
        19
        for(int j=i; j<k+i; j++){
20
            if(v[j] < 0){
21
                ans.push_back(v[j]);
22
                flag = true;
23
                break;
24
            }
25
        }
26
        if(!flag) ans.push_back(0);
27
    }
28
    29
    for(int i=0; i<ans.size(); i++){
30
        cout<<ans[i]<<"" "";
31
    } cout<<""\n"";
32
    33
}
34
35
36
int main() {
37
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
38
    int t;
39
    cin>>t;
40
    41
    while(t--){
42
        solve();
43
    }
44
    return 0;
45
}",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053550
1390053549,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) throws IOException {
6
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
7
        int testCases = Integer.parseInt(reader.readLine().trim());
8
9
        StringBuilder output = new StringBuilder();
10
        11
        while (testCases-- > 0) {
12
            String[] input = reader.readLine().trim().split("" "");
13
            int arraySize = Integer.parseInt(input[0]);
14
            int batchSize = Integer.parseInt(input[1]);
15
16
            int[] readings = Arrays.stream(reader.readLine().trim().split("" ""))
17
                                   .mapToInt(Integer::parseInt)
18
                                   .toArray();
19
20
            List<Integer> earliestFaults = getFaultyReadings(readings, arraySize, batchSize);
21
22
            for (int fault : earliestFaults) {
23
                output.append(fault).append("" "");
24
            }
25
            output.append(""\n"");
26
        }
27
        28
        System.out.print(output);
29
    }
30
31
    public static List<Integer> getFaultyReadings(int[] readings, int size, int batchSize) {
32
        List<Integer> result = new ArrayList<>();
33
        Deque<Integer> faultIndices = new LinkedList<>(); 
34
35
        for (int i = 0; i < batchSize; i++) {
36
            if (readings[i] < 0) {
37
                faultIndices.addLast(i);
38
            }
39
        }
40
41
        for (int i = batchSize; i <= size; i++) {
42
            result.add(faultIndices.isEmpty() ? 0 : readings[faultIndices.peekFirst()]);
43
            while (!faultIndices.isEmpty() && faultIndices.peekFirst() < i - batchSize + 1) {
44
                faultIndices.pollFirst();
45
            }
46
            if (i < size && readings[i] < 0) {
47
                faultIndices.addLast(i);
48
            }
49
        }
50
51
        return result;
52
    }
53
}
54",130,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053549
1390053546,unknown,unknown,unknown,"1
def find_min_cost(server_rack):
2
 3
    total_idle_servers = server_rack.count('0')
4
    total_active_servers = server_rack.count('1')
5
6
    # Start scanning from both ends
7
    start = 0
8
    end = len(server_rack) - 1
9
10
    # Move 'start' forward while there are idle servers at the beginning
11
    while start < len(server_rack) and server_rack[start] == '0':
12
        start += 1
13
14
    # Move 'end' backward while there are idle servers at the end
15
    while end >= 0 and server_rack[end] == '0':
16
        end -= 1
17
18
    # After removing leading and trailing idle servers, count remaining idle servers
19
    if start <= end:
20
        remaining_idle_servers = server_rack[start:end+1].count('0')
21
        remaining_active_servers = server_rack[start:end+1].count('1')
22
    else:
23
        # If all servers are removed, then no remaining servers
24
        remaining_idle_servers = 0
25
        remaining_active_servers = 0
26
27
    # Active servers that were removed
28
    removed_active_servers = total_active_servers - remaining_active_servers
29
30
    # The cost is determined by the max of remaining idle servers and removed active servers
31
    return min(
32
        max(remaining_idle_servers, removed_active_servers),
33
        max(total_idle_servers, total_active_servers)
34
    )
35
36
# Read number of test cases
37
T = int(input(""Enter number of test cases: "").strip())
38
39
# Process each test case
40
for _ in range(T):
41
    server_rack = input(""Enter server rack binary string: "").strip()
42
    print(find_min_cost(server_rack))
43",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053546
1390053547,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053547
1390053548,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    """"""
3
    Calculate minimum effort to breach n firewalls with optimal strategy.
4
    5
    Args:
6
        n: Number of firewalls
7
        k: Maximum number of firewalls that can be skipped
8
        firewalls: List of firewall strengths
9
        10
    Returns:
11
        Minimum effort required
12
    """"""
13
    # If we can skip all firewalls, return 0
14
    if k >= n:
15
        return 0
16
    17
    # We'll use a more memory-efficient approach that avoids potential
18
    # runtime errors with large inputs
19
    20
    # For each firewall, calculate the ""gain"" from skipping it
21
    # Gain = firewall strength - penalty to subsequent firewalls
22
    gains = []
23
    for i in range(n):
24
        # Original cost of the firewall
25
        original_cost = firewalls[i]
26
        27
        # Penalty to subsequent firewalls if we skip this one
28
        penalty = n - i - 1
29
        30
        # Gain = what we save by skipping this firewall
31
        gain = original_cost - penalty
32
        33
        gains.append((gain, i))
34
    35
    # Sort by gain in descending order
36
    gains.sort(reverse=True)
37
    38
    # Mark the firewalls to skip (the k firewalls with highest gain)
39
    to_skip = set()
40
    for i in range(min(k, n)):
41
        if i < len(gains) and gains[i][0] > 0:  # Only skip if gain is positive
42
            to_skip.add(gains[i][1])
43
    44
    # Calculate the total effort
45
    skipped_so_far = 0
46
    total_effort = 0
47
    48
    for i in range(n):
49
        if i in to_skip:
50
            # Skip this firewall
51
            skipped_so_far += 1
52
        else:
53
            # Pay the cost of this firewall (including penalties)
54
            total_effort += firewalls[i] + skipped_so_far
55
    56
    return total_effort
57
58
def main():
59
    t = int(input())  # Number of test cases
60
    61
    for _ in range(t):
62
        n, k = map(int, input().split())
63
        firewalls = list(map(int, input().split()))
64
        65
        min_effort = min_effort_to_breach(n, k, firewalls)
66
        print(min_effort)
67
68
if __name__ == ""__main__"":
69
    main()",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053548
1390053542,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    min_effort = float('inf')
3
4
    def backtrack(start, chosen):
5
        nonlocal min_effort
6
        if len(chosen) == k:
7
            effort = 0
8
            skipped = set(chosen)
9
            security_increase = 0
10
11
            for i in range(n):
12
                if i in skipped:
13
                    security_increase += 1
14
                else:
15
                    effort += firewalls[i] + security_increase
16
17
            min_effort = min(min_effort, effort)
18
            return
19
20
        for i in range(start, n):
21
            backtrack(i + 1, chosen + [i])
22
23
    backtrack(0, [])
24
    return min_effort
25
26
T = int(input())
27
for _ in range(T):
28
    n, k = map(int, input().split())
29
    firewalls = list(map(int, input().split()))
30
    print(min_effort_to_breach(n, k, firewalls))
31",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053542
1390053543,unknown,unknown,unknown,"1
def min_server_pruning_cost(binary_string):
2
    # Count total idle (0s) and active (1s) servers
3
    total_zeros = binary_string.count('0')
4
    total_ones = binary_string.count('1')
5
6
    # Initialize cost to a large value
7
    min_cost = float('inf')
8
9
    # Left and right pointers to remove servers from both ends
10
    left_zeros = 0
11
    left_ones = 0
12
13
    # Iterate to remove servers from both ends and minimize cost
14
    for i in range(len(binary_string) + 1):
15
        # Remaining idle servers in the middle
16
        remaining_zeros = total_zeros - left_zeros
17
        # Removed active servers
18
        removed_ones = left_ones
19
20
        # Update minimum cost
21
        min_cost = min(min_cost, max(remaining_zeros, removed_ones))
22
23
        # Expand left boundary (remove one more character from the start)
24
        if i < len(binary_string):
25
            if binary_string[i] == '0':
26
                left_zeros += 1
27
            else:
28
                left_ones += 1
29
30
    return min_cost
31
32
# Read input
33
T = int(input())  # Number of test cases
34
for _ in range(T):
35
    binary_string = input().strip()
36
    print(min_server_pruning_cost(binary_string))
37",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053543
1390053545,unknown,unknown,unknown,"1
def find_earliest_faults(t, data):
2
3
    results = []
4
5
    6
7
    for case in range(t):
8
9
        n, k = data[case][0]
10
11
        arr = data[case][1]
12
13
        14
15
        result = []
16
17
        # Initialize the deque to store indices of negative numbers
18
19
        from collections import deque
20
21
        dq = deque()
22
23
        24
25
        # Process the first window
26
27
        for i in range(k):
28
29
            if arr[i] < 0:
30
31
                dq.append(i)
32
33
        34
35
        # For the first window, append the result
36
37
        if dq:
38
39
            result.append(arr[dq[0]])
40
41
        else:
42
43
            result.append(0)
44
45
        46
47
        # Process the rest of the windows
48
49
        for i in range(k, n):
50
51
            # Remove elements that are out of this window
52
53
            if dq and dq[0] < i - k + 1:
54
55
                dq.popleft()
56
57
            58
59
            # Add new element if it's negative
60
61
            if arr[i] < 0:
62
63
                dq.append(i)
64
65
            66
67
            # Append the result for the current window
68
69
            if dq:
70
71
                result.append(arr[dq[0]])
72
73
            else:
74
75
                result.append(0)
76
77
        78
79
        results.append(result)
80
81
    82
83
    return results
84
85
# Test cases as described in the input format
86
87
test_cases = [
88
89
    ((5, 2), [-8, 2, 3, -6, 10]),
90
91
    ((8, 3), [12, -1, -7, 8, -15, 30, 16, 28])
92
93
]
94
95
# Number of test cases
96
97
t = len(test_cases)
98
99
# Calling the function
100
101
outputs = find_earliest_faults(t, test_cases)
102
103
for output in outputs:
104
105
    print("" "".join(map(str, output)))",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053545
1390053537,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    min_effort = float('inf')
6
7
    for i in range(1 << n):
8
        skipped = 0
9
        effort = 0
10
        temp_a = a[:]
11
        12
        skip_indices = []
13
        for j in range(n):
14
          if (i >> j) & 1:
15
            skipped += 1
16
            skip_indices.append(j)
17
18
        if skipped <= k:
19
            skip_count = 0
20
            for j in range(n):
21
              if j in skip_indices:
22
                skip_count +=1
23
              else:
24
                effort += temp_a[j] + skip_count
25
                26
            min_effort = min(min_effort, effort)
27
28
    print(min_effort)
29
30
t = int(input())
31
for _ in range(t):
32
    solve()",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053537
1390053539,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
    5
    min_effort = float('inf')
6
    7
    for i in range(1 << n):
8
        skipped = 0
9
        effort = 0
10
        temp_a = a[:]
11
        12
        for j in range(n):
13
            if (i >> j) & 1:
14
                skipped += 1
15
                temp_a[j] = -1
16
        17
        if skipped <= k:
18
            skipped_count = 0
19
            for j in range(n):
20
                if temp_a[j] == -1:
21
                    skipped_count+=1
22
                else:
23
                    effort += temp_a[j] + skipped_count
24
            min_effort = min(min_effort, effort)
25
    26
    print(min_effort)
27
    28
t = int(input())
29
for _ in range(t):
30
    solve()",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053539
1390053540,unknown,unknown,unknown,"1
def minimum_effort(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n, k = test_cases[t][0]
6
        arr = test_cases[t][1][:]  # Create a copy of the input array
7
        8
        if k >= n:
9
            results.append(0)
10
            continue
11
        12
        min_effort = float('inf')
13
        14
        for i in range(1 << n):
15
            skipped_indices = []
16
            17
            for j in range(n):
18
                if (i >> j) & 1:
19
                    skipped_indices.append(j)
20
                    21
            if len(skipped_indices) <= k:
22
                effort = 0
23
                temp_arr = arr[:]  # Create a copy of the original array for each combination
24
                25
                skip_count = 0
26
                for j in range(n):
27
                    if (i >> j) & 1:
28
                        skip_count += 1
29
                        for l in range(j + 1, n):
30
                            if not (i >> l) & 1:
31
                                temp_arr[l] += 1
32
                    else:
33
                        effort += temp_arr[j]
34
                35
                min_effort = min(min_effort, effort)
36
        37
        results.append(min_effort)
38
        39
    return results
40
41
# Input reading
42
T = int(input())
43
test_cases = []
44
45
# Read all test cases
46
for _ in range(T):
47
    n, k = map(int, input().split())
48
    arr = list(map(int, input().split()))
49
    test_cases.append([(n, k), arr])
50
51
# Get the results and print them
52
results = minimum_effort(T, test_cases)
53
54
for result in results:
55
    print(result)",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053540
1390053536,unknown,unknown,unknown,"1
import sys
2
3
def min_effort(n, k, firewalls):
4
    # DP array, initialized with large values
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    dp[0][0] = 0  # Base case: No firewalls, no effort
7
8
    # DP Computation
9
    for i in range(1, n + 1):
10
        for j in range(k + 1):
11
            # Case 1: Don't skip this firewall
12
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
13
14
            # Case 2: Skip this firewall (if skips available)
15
            if j > 0:
16
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
17
18
    # Answer is the minimum effort across all skip possibilities
19
    return min(dp[n])
20
21
# Read input efficiently
22
input_data = sys.stdin.read().split()
23
24
if not input_data:  # Check if input is empty
25
    sys.exit(0)  # Exit gracefully
26
27
index = 0
28
T = int(input_data[index])  # Number of test cases
29
index += 1
30
31
results = []
32
for _ in range(T):
33
    if index >= len(input_data):  # Prevent index out of range
34
        break
35
36
    n, k = map(int, input_data[index:index+2])  # Read n and k
37
    index += 2
38
39
    if index + n > len(input_data):  # Check if enough data exists for firewalls
40
        break
41
42
    firewalls = list(map(int, input_data[index:index+n]))  # Firewall strengths
43
    index += n
44
45
    # Compute and store the minimum effort
46
    results.append(str(min_effort(n, k, firewalls)))
47
48
# Print all results at once for efficiency
49
if results:
50
    sys.stdout.write(""\n"".join(results) + ""\n"")
51",131,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053536
1390053533,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053533
1390053535,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
   5
    min_cost = float('inf')
6
    7
    8
    for i in range(n + 1):  
9
        for j in range(n + 1 - i):  
10
            if i + j > n:
11
                continue
12
                13
            14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue 
18
                19
            20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
           24
            cost = max(idle_remaining, active_removed)
25
            26
            27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
40
for result in results:
41
    print(result)",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053535
1390053532,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <algorithm>
4
#include <vector>
5
6
using namespace std;
7
8
int min_pruning_cost(const string& server_rack) {
9
    int n = server_rack.length();
10
    int min_cost = n + 1; // Initialize with a value larger than any possible cost
11
12
    for (int left_remove_count = 0; left_remove_count <= n; ++left_remove_count) {
13
        for (int right_remove_count = 0; right_remove_count <= n - left_remove_count; ++right_remove_count) {
14
            string removed_prefix = server_rack.substr(0, left_remove_count);
15
            string removed_suffix = server_rack.substr(n - right_remove_count);
16
            string remaining_rack = server_rack.substr(left_remove_count, n - left_remove_count - right_remove_count);
17
18
            int idle_remaining = 0;
19
            for (char c : remaining_rack) {
20
                if (c == '0') {
21
                    idle_remaining++;
22
                }
23
            }
24
25
            int active_removed = 0;
26
            for (char c : removed_prefix) {
27
                if (c == '1') {
28
                    active_removed++;
29
                }
30
            }
31
            for (char c : removed_suffix) {
32
                if (c == '1') {
33
                    active_removed++;
34
                }
35
            }
36
37
            int cost = max(idle_remaining, active_removed);
38
            min_cost = min(min_cost, cost);
39
        }
40
    }
41
    return min_cost;
42
}
43
44
int main() {
45
    int t;
46
    cin >> t;
47
    while (t--) {
48
        string server_rack;
49
        cin >> server_rack;
50
        cout << min_pruning_cost(server_rack) << endl;
51
    }
52
    return 0;
53
}",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053532
1390053530,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    for n, k, arr in test_cases:
6
        dq = deque()
7
        res = []
8
        9
        for i in range(k):
10
            if arr[i] < 0:
11
                dq.append(i)
12
        13
        for i in range(n - k + 1):
14
            if dq:
15
                res.append(arr[dq[0]])
16
            else:
17
                res.append(0)
18
            19
            if dq and dq[0] == i:
20
                dq.popleft()
21
            22
            if i + k < n and arr[i + k] < 0:
23
                dq.append(i + k)
24
        25
        results.append("" "".join(map(str, res)))
26
    27
    return ""\n"".join(results)
28
29
t = int(input())
30
test_cases = []
31
for _ in range(t):
32
    n, k = map(int, input().split())
33
    arr = list(map(int, input().split()))
34
    test_cases.append((n, k, arr))
35
36
print(earliest_faulty_readings(test_cases))
37",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053530
1390053526,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053526
1390053531,unknown,unknown,unknown,"1
from collections import deque
2
3
test_cases = int(input())
4
for _ in range(test_cases):
5
    n, k = map(int, input().split())
6
    arr = list(map(int, input().split()))
7
    8
    dq = deque()  
9
    res = []
10
11
    for i in range(k):
12
        if arr[i] < 0:
13
            dq.append(i)
14
15
    for i in range(n - k + 1):
16
        res.append(arr[dq[0]] if dq else 0)
17
18
        if dq and dq[0] == i:
19
            dq.popleft()
20
        21
        if i + k < n and arr[i + k] < 0:
22
            dq.append(i + k)
23
24
    for i in res:
25
        print(i,end="" "")
26
    print()
27",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053531
1390053520,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053520
1390053521,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
        5
    impacts = []
6
    7
    for i in range(n):
8
        impact = strengths[i] - (n - i - 1)
9
        impacts.append((impact, i))
10
    11
    impacts.sort(reverse=True)
12
    13
    to_skip = set(impacts[i][1] for i in range(k))
14
    15
    total_effort = 0
16
    penalty = 0
17
    18
    for i in range(n):
19
        if i in to_skip:
20
            penalty += 1
21
        else:
22
            total_effort += strengths[i] + penalty
23
    24
    return total_effort
25
26
def solve_test_cases():
27
    t = int(input())  
28
    results = []
29
    30
    for _ in range(t):
31
        n, k = map(int, input().split())
32
        strengths = list(map(int, input().split()))
33
        results.append(min_effort_to_breach(n, k, strengths))
34
    35
    return results
36
37
def main():
38
    results = solve_test_cases()
39
    40
    for result in results:
41
        print(result)
42
43
if __name__ == ""__main__"":
44
    main()
45",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053521
1390053524,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053524
1390053519,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()",132,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053519
1390053512,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <deque>
7
#include <bits/stdc++.h>
8
using namespace std;
9
10
vector<int>solve(vector<int>&arr, int k) {
11
    vector<int>res;
12
    int n = arr.size();
13
    deque<int>dq;
14
    for(int i=0; i<n; i++) {
15
        while(!dq.empty() && i-dq.front()>=k){
16
            dq.pop_front();
17
        }
18
        if(arr[i]<0)
19
            dq.push_back(i);
20
        if(i>=k-1) {
21
            if(!dq.empty()) {
22
                res.push_back(arr[dq.front()]);
23
            }
24
            else {
25
                res.push_back(0);
26
            }
27
        }
28
    }
29
    return res;
30
}
31
32
int main() {
33
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
34
    int t;
35
    cin>>t;
36
    while(t--) {
37
        int n,k;
38
        vector<int>arr;
39
        cin>>n>>k;
40
        while(n--) {
41
            int a;
42
            cin>>a;
43
            arr.push_back(a);
44
        }
45
        vector<int>res = solve(arr,k);
46
        for(int& i: res) {
47
            cout<<i<<"" "";
48
        }
49
        cout<<endl;
50
    }
51
    return 0;
52
}",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053512
1390053513,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    4
    for n, k, arr in test_cases:
5
        total_effort = sum(arr)
6
7
        if k >= n:  
8
            results.append(""0"")  # If k >= n, we can skip all firewalls.
9
            continue
10
11
        # Compute the minimum effort after skipping one firewall
12
        min_effort = min(total_effort - arr[i] + k for i in range(n))
13
14
        results.append(str(min_effort))
15
16
    return ""\n"".join(results)
17
18
19
# Reading input
20
t = int(input())  # Number of test cases
21
test_cases = []
22
23
for _ in range(t):
24
    n, k = map(int, input().split())  # Number of firewalls and penalty
25
    arr = list(map(int, input().split()))  # Firewall strengths
26
    test_cases.append((n, k, arr))
27
28
# Output results
29
print(min_effort(test_cases))
30",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053513
1390053517,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class SmartFactoryQualityControl {
4
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>(); // Stores indices of negative elements
7
8
        // Process first k elements
9
        for (int i = 0; i < k; i++) {
10
            if (arr[i] < 0) {
11
                deque.addLast(i);
12
            }
13
        }
14
        15
        // Iterate over the array in batches
16
        for (int i = k; i <= arr.length; i++) {
17
            // If deque is not empty, the first element is the earliest negative number
18
            result.add(deque.isEmpty() ? 0 : arr[deque.peekFirst()]);
19
            20
            // Remove elements that are out of this window
21
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
22
                deque.pollFirst();
23
            }
24
            25
            // Add the next element to the deque if it's negative
26
            if (i < arr.length && arr[i] < 0) {
27
                deque.addLast(i);
28
            }
29
        }
30
        31
        return result;
32
    }
33
34
    public static void main(String[] args) {
35
        Scanner scanner = new Scanner(System.in);
36
        int t = scanner.nextInt(); // Number of test cases
37
        38
        while (t-- > 0) {
39
            int n = scanner.nextInt(); // Size of array
40
            int k = scanner.nextInt(); // Batch size
41
            int[] arr = new int[n];
42
            43
            for (int i = 0; i < n; i++) {
44
                arr[i] = scanner.nextInt();
45
            }
46
            47
            List<Integer> result = findEarliestFaults(arr, k);
48
            for (int num : result) {
49
                System.out.print(num + "" "");
50
            }
51
            System.out.println();
52
        }
53
        54
        scanner.close();
55
    }
56
}",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053517
1390053509,unknown,unknown,unknown,"1
def earliest_faulty_reading(testcases):
2
    results = []
3
    4
    for case in testcases:
5
        n, k, arr = case
6
        result = []
7
        8
        # Process each batch of size k
9
        for i in range(n - k + 1):
10
            batch = arr[i:i+k]
11
            faulty = next((x for x in batch if x < 0), 0)
12
            result.append(faulty)
13
        14
        results.append(result)
15
    16
    return results
17
18
# Reading input
19
t = int(input())  # number of test cases
20
testcases = []
21
22
for _ in range(t):
23
    n, k = map(int, input().split())  # size of array and batch size
24
    arr = list(map(int, input().split()))  # the array of sensor readings
25
    testcases.append((n, k, arr))
26
27
# Get the result for each test case
28
results = earliest_faulty_reading(testcases)
29
30
# Output the result
31
for result in results:
32
    print("" "".join(map(str, result)))",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053509
1390053511,unknown,unknown,unknown,"1
def solve_NeelJain():
2
    3
    n_NeelJain, k_NeelJain = map(int, input().split())
4
    strengths_NeelJain = list(map(int, input().split()))
5
    total_NeelJain = sum(strengths_NeelJain)
6
    skip_NeelJain = [strengths_NeelJain[i] - (n_NeelJain - i - 1) for i in range(n_NeelJain)]
7
    skip_NeelJain.sort(reverse=True)
8
    total_NeelJain -= sum(skip_NeelJain[:k_NeelJain])
9
    total_NeelJain -= k_NeelJain * (k_NeelJain - 1) // 2
10
    print(total_NeelJain)
11
12
if __name__== ""__main__"":
13
    t_NeelJain = int(input())
14
    for _ in range(t_NeelJain):
15
        solve_NeelJain()",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053511
1390053510,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36
37
38",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053510
1390053503,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)
36",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053503
1390053501,unknown,unknown,unknown,"1
import sys
2
3
def min_effort(n, k, firewalls):
4
    if k >= n:
5
        return 0  # If we can skip all firewalls, effort is 0.
6
7
    total_effort = sum(firewalls)  # Total effort without skipping
8
9
    # Try removing k firewalls in different positions and find the minimum effort
10
    min_effort = total_effort
11
12
    for i in range(n - k + 1):  # Sliding window approach
13
        skipped_sum = sum(firewalls[i:i + k])  # Sum of k consecutive firewalls
14
        extra_security = k * (n - (i + k))  # Extra security added to remaining firewalls
15
        remaining_effort = total_effort - skipped_sum + extra_security  # Adjusted total effort
16
17
        min_effort = min(min_effort, remaining_effort)
18
19
    return min_effort
20
21
# Read input
22
t = int(sys.stdin.readline())  # Number of test cases
23
output = []
24
25
for _ in range(t):
26
    n, k = map(int, sys.stdin.readline().split())
27
    firewalls = list(map(int, sys.stdin.readline().split()))
28
    output.append(str(min_effort(n, k, firewalls)))
29
30
# Print the final output
31
sys.stdout.write(""\n"".join(output) + ""\n"")
32",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053501
1390053506,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053506
1390053500,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    int T;
10
    cin >> T;
11
    while (T--) {
12
        string s;
13
        cin >> s;
14
        int n = s.size();
15
16
        // Prefix sums
17
        vector<int> prefix_1(n + 1, 0);
18
        vector<int> prefix_0(n + 1, 0);
19
        for (int i = 0; i < n; i++) {
20
            prefix_1[i + 1] = prefix_1[i] + (s[i] == '1' ? 1 : 0);
21
            prefix_0[i + 1] = prefix_0[i] + (s[i] == '0' ? 1 : 0);
22
        }
23
24
        int total_1 = prefix_1[n];
25
        int min_cost = n;
26
27
        // Try all possible kept substrings [l, r)
28
        for (int l = 0; l <= n; l++) {
29
            // Instead of full nested loop, calculate cost directly
30
            // for r = n (maximum right end possible for fixed l)
31
            for (int r = l; r <= n; r++) {
32
                int kept_1 = prefix_1[r] - prefix_1[l];
33
                int kept_0 = prefix_0[r] - prefix_0[l];
34
                int removed_1 = total_1 - kept_1;
35
                int cost = max(removed_1, kept_0);
36
                if (cost < min_cost) min_cost = cost;
37
            }
38
        }
39
40
        cout << min_cost << endl;
41
    }
42
    return 0;
43
}
44",133,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053500
1390053497,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    min_total_effort = float('inf')
3
    4
    for mask in range(1 << n):
5
        skipped = bin(mask).count('1')
6
        7
        if skipped <= k:
8
            total_effort = 0
9
            for i in range(n):
10
                if mask & (1 << i):
11
                    continue
12
                else:
13
                    additional = 0
14
                    for j in range(i):
15
                        if mask & (1 << j):
16
                            additional += 1
17
                    total_effort += strengths[i] + additional
18
                    19
            min_total_effort = min(min_total_effort, total_effort)
20
    21
    return min_total_effort
22
23
def solve():
24
    t = int(input())
25
    26
    for _ in range(t):
27
        n, k = map(int, input().split())
28
        strengths = list(map(int, input().split()))
29
        30
        result = min_effort_to_breach(n, k, strengths)
31
        print(result)
32
33
if __name__ == ""__main__"":
34
    solve()",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053497
1390053499,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    min_effort = float('inf')
3
    for i in range(n - k + 1):
4
        effort = sum(firewalls[:i])
5
        increased_firewalls = [firewalls[j] + (j - i) for j in range(i, n)]
6
        effort += sum(sorted(increased_firewalls)[:n - i - k])
7
        min_effort = min(min_effort, effort)
8
    return min_effort
9
10
T = int(input())
11
for _ in range(T):
12
    n, k = map(int, input().split())
13
    firewalls = list(map(int, input().split()))
14
    print(min_effort(n, k, firewalls))",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053499
1390053496,unknown,unknown,unknown,"1
for _ in range(int(input())):
2
    x, y = map(int, input().split())
3
    arr = list(map(int, input().split()))
4
    res = []
5
6
    for i in range(x - y + 1):
7
        batch = arr[i:i + y]
8
        found_negative = False  
9
        10
        for a in batch:
11
            if a < 0:
12
                res.append(a)
13
                found_negative = True
14
                break  
15
        if not found_negative:  
16
            res.append(0)
17
18
    print(*res) 
19",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053496
1390053491,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
7
        Scanner sc = new Scanner(System.in);
8
9
        int T = sc.nextInt();
10
11
        while (T-- > 0) {
12
13
            int n = sc.nextInt();
14
15
            int k = sc.nextInt();
16
17
            int[] a = new int[n];
18
19
            long sum_a = 0;
20
21
            for (int i = 0; i < n; i++) {
22
23
                a[i] = sc.nextInt();
24
25
                sum_a += a[i];
26
27
            }
28
29
            List<Long> values = new ArrayList<>();
30
31
            for (int i = 0; i < n; i++) {
32
33
                long val = a[i] - (n - i - 1L);
34
35
                values.add(val);
36
37
            }
38
39
            values.sort((x, y) -> Long.compare(y, x));
40
41
            long[] prefixSum = new long[n + 1];
42
43
            prefixSum[0] = 0;
44
45
            for (int i = 1; i <= n; i++) {
46
47
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
48
49
            }
50
51
            int max_m = Math.min(k, n);
52
53
            long maxTotal = Long.MIN_VALUE;
54
55
            for (int m = 0; m <= max_m; m++) {
56
57
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
58
59
                if (current > maxTotal) {
60
61
                    maxTotal = current;
62
63
                }
64
65
            }
66
67
            long minEffort = sum_a - maxTotal;
68
69
            System.out.println(minEffort);
70
71
        }
72
73
        sc.close();
74
75
    }
76
77
}",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053491
1390053493,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  
7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    result.append(arr[dq[0]] if dq else 0)
12
    13
    for i in range(k, n):
14
        if dq and dq[0] < i - k + 1:
15
            dq.popleft()
16
        17
        if arr[i] < 0:
18
            dq.append(i)
19
20
        result.append(arr[dq[0]] if dq else 0)
21
    22
    return result
23
24
t = int(input())  # Number of test cases
25
for _ in range(t):
26
    n, k = map(int, input().split())
27
    arr = list(map(int, input().split()))
28
    print(*earliest_faulty_readings(arr, k))",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053493
1390053495,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    if k == n:
3
        return 0
4
    if k == 0:
5
        return sum(firewalls)
6
7
    min_effort = float('inf')
8
9
    for i in range(n):
10
        skipped = 0
11
        effort = 0
12
        for j in range(n):
13
            if skipped < k and j >= i:
14
                skipped += 1
15
            else:
16
                effort += firewalls[j] + skipped
17
        min_effort = min(min_effort, effort)
18
19
    return min_effort
20
T = int(input().strip())
21
results = []
22
23
for _ in range(T):
24
    n, k = map(int, input().split())
25
    firewalls = list(map(int, input().split()))
26
    results.append(min_effort(n, k, firewalls))
27
28
for res in results:
29
    print(res)",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053495
1390053487,unknown,unknown,unknown,"1
def find_earliest_faults(t, data):
2
    results = []
3
    4
    for case in range(t):
5
        n, k = data[case][0]
6
        arr = data[case][1]
7
        8
        result = []
9
        # Initialize the deque to store indices of negative numbers
10
        from collections import deque
11
        dq = deque()
12
        13
        # Process the first window
14
        for i in range(k):
15
            if arr[i] < 0:
16
                dq.append(i)
17
        18
        # For the first window, append the result
19
        if dq:
20
            result.append(arr[dq[0]])
21
        else:
22
            result.append(0)
23
        24
        # Process the rest of the windows
25
        for i in range(k, n):
26
            # Remove elements that are out of this window
27
            if dq and dq[0] < i - k + 1:
28
                dq.popleft()
29
            30
            # Add new element if it's negative
31
            if arr[i] < 0:
32
                dq.append(i)
33
            34
            # Append the result for the current window
35
            if dq:
36
                result.append(arr[dq[0]])
37
            else:
38
                result.append(0)
39
        40
        results.append(result)
41
    42
    return results
43
44
# Test cases as described in the input format
45
test_cases = [
46
    ((5, 2), [-8, 2, 3, -6, 10]),
47
    ((8, 3), [12, -1, -7, 8, -15, 30, 16, 28])
48
]
49
50
# Number of test cases
51
t = len(test_cases)
52
53
# Calling the function
54
outputs = find_earliest_faults(t, test_cases)
55
for output in outputs:
56
    print("" "".join(map(str, output)))
57",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053487
1390053489,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
    public static List<Integer> earliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>();
7
8
        for (int i = 0; i < arr.length; i++) {
9
            // Remove out-of-window elements
10
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
11
                deque.poll();
12
            }
13
14
            // Add new faulty readings
15
            if (arr[i] < 0) {
16
                deque.offer(i);
17
            }
18
19
            // Collect results for valid windows
20
            if (i >= k - 1) {
21
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
22
            }
23
        }
24
        return result;
25
    }
26
27
    public static void main(String[] args) {
28
        Scanner scanner = new Scanner(System.in);
29
        int t = scanner.nextInt(); // Number of test cases
30
31
        while (t-- > 0) {
32
            int n = scanner.nextInt(); // Array size
33
            int k = scanner.nextInt(); // Batch size
34
            int[] arr = new int[n];
35
36
            for (int i = 0; i < n; i++) {
37
                arr[i] = scanner.nextInt();
38
            }
39
40
            // Compute and print results
41
            List<Integer> faults = earliestFaults(arr, k);
42
            for (int val : faults) {
43
                System.out.print(val + "" "");
44
            }
45
            System.out.println();
46
        }
47
        scanner.close();
48
    }
49
}",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053489
1390053490,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)  # Effort without skipping any firewalls
3
    min_effort = total_effort  # Start with this as the baseline
4
5
    # Compute initial sum of first 'k' firewalls
6
    skip_sum = sum(firewalls[:k])
7
8
    # Try skipping each block of size k
9
    for i in range(n - k + 1):
10
        # Compute the new effort
11
        effort = total_effort - skip_sum + (n - k)  # Remaining firewalls get +1
12
13
        # Update minimum effort
14
        min_effort = min(min_effort, effort)
15
16
        # Slide the window forward (if possible)
17
        if i + k < n:
18
            skip_sum = skip_sum - firewalls[i] + firewalls[i + k]
19
20
    return min_effort
21
22
# Read input
23
t = int(input().strip())  # Number of test cases
24
for _ in range(t):
25
    n, k = map(int, input().split())  # Size of array and max firewalls to skip
26
    firewalls = list(map(int, input().split()))
27
    print(min_effort(n, k, firewalls))
28",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053490
1390053484,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # If we can skip all firewalls, return 0 effort
3
    if k >= n:
4
        return 0
5
6
    # Initialize DP array: dp[j] = min effort using at most j skips
7
    dp = [float('inf')] * (k + 1)
8
    dp[0] = 0  # Base case: No firewalls, no effort
9
10
    for i in range(1, n + 1):
11
        # Process in **reverse order** to avoid overwriting dp[j-1]
12
        for j in range(min(k, i), -1, -1):  
13
            # Case 1: Don't skip this firewall
14
            if j <= i - 1:
15
                dp[j] = dp[j] + strengths[i-1] + j
16
17
            # Case 2: Skip this firewall (if we have skips left)
18
            if j > 0:
19
                dp[j] = min(dp[j], dp[j-1])
20
21
    return dp[k]
22
23
def solve():
24
    t = int(input())  # Read number of test cases
25
    26
    for _ in range(t):
27
        n, k = map(int, input().split())  # Read n (firewalls) and k (max skips)
28
        strengths = list(map(int, input().split()))  # Read firewall strengths
29
        30
        # Special case: If we can skip all firewalls
31
        if k >= n:
32
            print(0)
33
        else:
34
            print(min_effort_to_breach(n, k, strengths))
35
36
# Run the solution
37
solve()
38",134,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053484
1390053478,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <string.h>
3
#include <math.h>
4
#include <stdlib.h>
5
void find_earliest_faulty(int arr[], int n, int k) {
6
    for (int i = 0; i <= n - k; i++) {
7
        int earliest_faulty = 0;
8
        for (int j = i; j < i + k; j++) {
9
            if (arr[j] < 0) {
10
                earliest_faulty = arr[j];
11
                break; // First faulty component found, exit loop
12
            }
13
        }
14
        printf(""%d "", earliest_faulty);
15
    }
16
    printf(""\n"");
17
}
18
19
int main() {
20
    int t;
21
    scanf(""%d"", &t);
22
    23
    while (t--) {
24
        int n, k;
25
        scanf(""%d %d"", &n, &k);
26
        int *arr = (int *)malloc(n * sizeof(int));
27
        28
        for (int i = 0; i < n; i++) {
29
            scanf(""%d"", &arr[i]);
30
        }
31
        32
        find_earliest_faulty(arr, n, k);
33
        free(arr);
34
    }
35
    36
    return 0;
37
}",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053478
1390053483,unknown,unknown,unknown,"1
def find_earliest_faults(arr, k):
2
    """"""
3
    Finds the earliest faulty reading for each consecutive batch of size k.
4
5
    Args:
6
        arr: A list of sensor readings (integers).
7
        k: The batch size.
8
9
    Returns:
10
        A list of earliest faulty readings for each batch.
11
    """"""
12
    result = []
13
    for i in range(len(arr) - k + 1):
14
        batch = arr[i:i + k]
15
        earliest_fault = 0
16
        for j, reading in enumerate(batch):
17
            if reading < 0:
18
                earliest_fault = reading
19
                break
20
        result.append(earliest_fault)
21
    return result
22
23
def solve():
24
    t = int(input())
25
    for _ in range(t):
26
        n, k = map(int, input().split())
27
        arr = list(map(int, input().split()))
28
        result = find_earliest_faults(arr, k)
29
        print(*result)
30
31
solve()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053483
1390053476,unknown,unknown,unknown,"1
def main():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().split(""\n"")
5
    6
    t = int(data[0])
7
    index = 1
8
9
    results = []
10
    for _ in range(t):
11
        n, k = map(int, data[index].split())
12
        strengths = list(map(int, data[index + 1].split()))
13
        index += 2
14
        15
        if k >= n:
16
            results.append(""0"")
17
            continue
18
        19
        # Calculate the impact of each firewall: strength + index
20
        impact = [(strengths[i] + i, i) for i in range(n)]
21
        22
        # Sort firewalls by impact (higher impact should be skipped)
23
        impact.sort(reverse=True)
24
        25
        # Select the top k firewalls to skip
26
        to_skip = set(idx for _, idx in impact[:k])
27
        28
        # Compute the minimal effort
29
        effort = 0
30
        skipped = 0
31
        32
        for i in range(n):
33
            if i in to_skip:
34
                skipped += 1
35
            else:
36
                effort += strengths[i] + skipped
37
        38
        results.append(str(effort))
39
    40
    # Print all results at once (faster output handling)
41
    sys.stdout.write(""\n"".join(results) + ""\n"")
42
43
if __name__ == ""__main__"":
44
    main()
45",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053476
1390053472,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    min_effort = float('inf')
6
7
    for i in range(1 << n):
8
        skipped_count = 0
9
        current_effort = 0
10
        current_a = a[:]
11
12
        skipped_indices = []
13
        for j in range(n):
14
            if (i >> j) & 1:
15
                skipped_count += 1
16
                skipped_indices.append(j)
17
18
        if skipped_count <= k:
19
            for j in range(n):
20
                if j in skipped_indices:
21
                    continue
22
                else:
23
                    offset = 0
24
                    for skipped_index in skipped_indices:
25
                        if skipped_index < j:
26
                            offset += 1
27
                    current_effort += current_a[j] + offset
28
29
            min_effort = min(min_effort, current_effort)
30
31
    print(min_effort)
32
33
t = int(input())
34
for _ in range(t):
35
    solve()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053472
1390053473,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx+1])
10
        idx +=2
11
        a = list(map(int, input[idx:idx+n]))
12
        idx +=n
13
        sum_a = sum(a)
14
        v = []
15
        for i in range(n):
16
            val = a[i] - (n - i -1)
17
            v.append(val)
18
        v.sort(reverse=True)
19
        prefix = [0] * (n+1)
20
        for i in range(n):
21
            prefix[i+1] = prefix[i] + v[i]
22
        max_sum = 0
23
        max_t = min(k, n)
24
        for t in range(0, max_t+1):
25
            current = prefix[t] + t*(t-1)//2
26
            if current > max_sum:
27
                max_sum = current
28
        print(sum_a - max_sum)
29
30
if __name__ == ""__main__"":
31
    main()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053473
1390053475,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, arr = case
5
        batch_results = []
6
        for i in range(n - k + 1):
7
            batch = arr[i:i + k]
8
            earliest_fault = 0
9
            for num in batch:
10
                if num < 0:
11
                    earliest_fault = num
12
                    break
13
            batch_results.append(earliest_fault)
14
        results.append(batch_results)
15
    return results
16
17
# Input reading
18
def main():
19
    import sys
20
    input = sys.stdin.read
21
    data = input().split()
22
    idx = 0
23
    t = int(data[idx])
24
    idx += 1
25
    test_cases = []
26
    for _ in range(t):
27
        n = int(data[idx])
28
        k = int(data[idx + 1])
29
        idx += 2
30
        arr = list(map(int, data[idx:idx + n]))
31
        idx += n
32
        test_cases.append((n, k, arr))
33
    34
    # Compute results
35
    results = earliest_faulty_readings(test_cases)
36
    37
    # Output results
38
    for result in results:
39
        print("" "".join(map(str, result)) + "" "", end="""")
40
    print()
41
42
if __name__ == ""__main__"":
43
    main()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053475
1390053466,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
3
    results = []
4
5
    for case in test_cases:
6
7
        n = len(case)
8
9
        min_cost = float('inf')
10
11
        12
13
        # Precompute prefix sums for 0's and 1's
14
15
        prefix_0 = [0] * (n + 1)
16
17
        prefix_1 = [0] * (n + 1)
18
19
        for i in range(n):
20
21
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
22
23
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
24
25
        26
27
        # Iterate through all possible splits
28
29
        for i in range(n + 1):
30
31
            for j in range(i, n + 1):
32
33
                # Remaining segment is from i to j-1
34
35
                remaining_0s = prefix_0[j] - prefix_0[i]
36
37
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
38
39
                cost = max(remaining_0s, removed_1s)
40
41
                if cost < min_cost:
42
43
                    min_cost = cost
44
45
        results.append(min_cost)
46
47
    return results
48
49
# Read input
50
51
T = int(input())
52
53
test_cases = [input().strip() for _ in range(T)]
54
55
# Compute results
56
57
results = min_decommission_cost(test_cases)
58
59
# Print output
60
61
for result in results:
62
63
    print(result)
64
65
66
67
68
69",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053466
1390053469,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    min_cost = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            remaining = s[i:n-j]
10
            11
            idle_remaining = 0
12
            for char in remaining:
13
                if char == '0':
14
                    idle_remaining += 1
15
            16
            active_removed = 0
17
            for char in s[:i]:
18
                if char == '1':
19
                    active_removed += 1
20
            for char in s[n-j:]:
21
                if char == '1':
22
                    active_removed += 1
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
            27
    print(min_cost)
28
29
t = int(input())
30
for _ in range(t):
31
    solve()",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053469
1390053467,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total active ('1') and idle ('0') servers
5
    total_active = server_string.count('1')
6
    total_idle = n - total_active
7
8
    # Precompute cumulative count of active servers from the left
9
    active_prefix_sum = [0] * (n + 1)
10
    for i in range(n):
11
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
12
    13
    min_cost = float('inf')
14
15
    # Try all possible segments
16
    for left in range(n + 1):
17
        for right in range(left, n + 1):
18
            # Active servers in the selected range
19
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
20
            idle_remaining = (right - left) - active_remaining
21
22
            # Active servers removed (total active - active in range)
23
            active_removed = total_active - active_remaining
24
25
            # Cost is max of idle servers in range or removed active servers
26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
def faster_min_decommission_cost(server_string):
32
    n = len(server_string)
33
34
    # Precompute prefix sums for active ('1') and idle ('0') servers
35
    active_prefix = [0] * (n + 1)
36
    idle_prefix = [0] * (n + 1)
37
38
    for i in range(n):
39
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
40
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
41
42
    min_cost = n  # Worst case scenario
43
44
    # Iterate through all possible substrings efficiently
45
    for i in range(n + 1):
46
        for j in range(i, n + 1):
47
            # Idle servers in the selected range
48
            idle_remaining = idle_prefix[j] - idle_prefix[i]
49
50
            # Active servers removed (total active - active in selected range)
51
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
52
53
            # Compute cost and update minimum
54
            cost = max(idle_remaining, active_removed)
55
            min_cost = min(min_cost, cost)
56
57
    return min_cost
58
59
def main():
60
    t = int(input().strip())
61
62
    for _ in range(t):
63
        server_string = input().strip()
64
        result = faster_min_decommission_cost(server_string)
65
        print(result)
66
67
if __name__ == ""__main__"":
68
    main()
69",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053467
1390053463,unknown,unknown,unknown,"1
def min_cost_to_balance(s):
2
    n = len(s)
3
4
    # Step 1: Build prefix sums
5
    prefix0 = [0] * (n + 1)
6
    prefix1 = [0] * (n + 1)
7
8
    for i in range(n):
9
        prefix0[i + 1] = prefix0[i] + (1 if s[i] == '0' else 0)
10
        prefix1[i + 1] = prefix1[i] + (1 if s[i] == '1' else 0)
11
12
    # Step 2: Initialize min_cost with the case of removing everything
13
    min_cost = prefix1[n]
14
15
    # Step 3: Iterate over all possible a and b
16
    for a in range(n + 1):
17
        for b in range(a - 1, n):
18
            # Number of '0's in s[a..b]
19
            zeros_remaining = prefix0[b + 1] - prefix0[a] if b >= a else 0
20
            # Number of '1's in prefix s[0..a-1] and suffix s[b+1..n-1]
21
            ones_removed = prefix1[a] + (prefix1[n] - prefix1[b + 1])
22
            # Cost for this substring
23
            cost = max(zeros_remaining, ones_removed)
24
            # Update minimum cost
25
            min_cost = min(min_cost, cost)
26
27
    return min_cost
28
29
# Input handling
30
T = int(input())
31
for _ in range(T):
32
    s = input().strip()
33
    print(min_cost_to_balance(s))
34",135,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053463
1390053459,unknown,unknown,unknown,"1
def minimum_decommission_cost(servers):
2
    n = len(servers)
3
    4
    # Convert the string to a list of integers (0 or 1)
5
    server_list = [1 if c == '1' else 0 for c in servers]
6
    7
    # Precompute prefix sums
8
    prefix_sum = [0] * (n + 1)
9
    for i in range(n):
10
        prefix_sum[i + 1] = prefix_sum[i] + server_list[i]
11
    12
    min_cost = n  # Initialize to worst case
13
    14
    # For each start index i
15
    for i in range(n + 1):
16
        # Total active servers removed from the left
17
        left_ones = prefix_sum[i]
18
        19
        # For each end index j (using binary search would be ideal, but direct is OK for now)
20
        for j in range(i, n + 1):
21
            # Calculate metrics for current segment [i,j)
22
            segment_length = j - i
23
            segment_ones = prefix_sum[j] - prefix_sum[i]
24
            segment_zeros = segment_length - segment_ones
25
            26
            # Total active servers removed from the right
27
            right_ones = prefix_sum[n] - prefix_sum[j]
28
            29
            # Total active servers removed
30
            total_ones_removed = left_ones + right_ones
31
            32
            cost = max(segment_zeros, total_ones_removed)
33
            min_cost = min(min_cost, cost)
34
    35
    return min_cost
36
37
def process_input():
38
    t = int(input().strip())
39
    results = []
40
    41
    for _ in range(t):
42
        servers = input().strip()
43
        results.append(minimum_decommission_cost(servers))
44
    45
    for result in results:
46
        print(result)
47
48
if __name__ == ""__main__"":
49
    process_input()",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053459
1390053461,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    5
    total_active = server_rack.count('1')
6
    7
    for prefix in range(n + 1):
8
        for suffix in range(n + 1 - prefix):
9
            if prefix + suffix > n:
10
                continue
11
                12
            remaining = server_rack[prefix:n-suffix]
13
            14
            if not remaining:
15
                cost = total_active
16
            else:
17
                idle_remaining = remaining.count('0')
18
                active_removed = total_active - remaining.count('1')
19
                cost = max(idle_remaining, active_removed)
20
                21
            min_cost = min(min_cost, cost)
22
    23
    return min_cost
24
25
def process_test_cases():
26
    t = int(input().strip())
27
    results = []
28
    29
    for _ in range(t):
30
        server_rack = input().strip()
31
        results.append(min_decommissioning_cost(server_rack))
32
    33
    return results
34
35
if __name__ == ""__main__"":
36
    results = process_test_cases()
37
    for result in results:
38
        print(result)",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053461
1390053462,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx + 1])
10
        idx += 2
11
        a = list(map(int, input[idx:idx + n]))
12
        idx += n
13
        14
        sum_S = sum(a)
15
        # Compute a[i] + i (0-based)
16
        values = [a[i] + i for i in range(n)]
17
        # Sort in descending order
18
        values.sort(reverse=True)
19
        sum_aj_plus_j = sum(values[:k])
20
        # Compute the result
21
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
22
        print(res)
23
24
if __name__ == ""__main__"":
25
    main()",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053462
1390053456,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    4
    for n, k, arr in test_cases:
5
        total_effort = sum(arr)
6
7
        if k == n:
8
            results.append(""0"")  # If k == n, we can skip all firewalls
9
            continue
10
11
        # Compute the minimum effort after skipping one firewall
12
        min_effort = float('inf')
13
14
        for i in range(n):
15
            effort_with_skip = total_effort - arr[i] + k  # Remove arr[i] and add k
16
            min_effort = min(min_effort, effort_with_skip)
17
18
        results.append(str(min_effort))
19
20
    return ""\n"".join(results)
21
22
23
# Reading input
24
t = int(input())  # Number of test cases
25
test_cases = []
26
27
for _ in range(t):
28
    n, k = map(int, input().split())  # Number of firewalls and penalty
29
    arr = list(map(int, input().split()))  # Firewall strengths
30
    test_cases.append((n, k, arr))
31
32
# Output results
33
print(min_effort(test_cases))
34",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053456
1390053457,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
    public static List<Integer> earliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>();
7
8
        for (int i = 0; i < arr.length; i++) {
9
            // Remove out-of-window elements
10
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
11
                deque.poll();
12
            }
13
14
            // Add new faulty readings
15
            if (arr[i] < 0) {
16
                deque.offer(i);
17
            }
18
19
            // Collect results for valid windows
20
            if (i >= k - 1) {
21
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
22
            }
23
        }
24
        return result;
25
    }
26
27
    public static void main(String[] args) {
28
        Scanner scanner = new Scanner(System.in);
29
        int t = scanner.nextInt(); // Number of test cases
30
31
        while (t-- > 0) {
32
            int n = scanner.nextInt(); // Array size
33
            int k = scanner.nextInt(); // Batch size
34
            int[] arr = new int[n];
35
36
            for (int i = 0; i < n; i++) {
37
                arr[i] = scanner.nextInt();
38
            }
39
40
            // Compute and print results
41
            List<Integer> faults = earliestFaults(arr, k);
42
            for (int val : faults) {
43
                System.out.print(val + "" "");
44
            }
45
            System.out.println();
46
        }
47
        scanner.close();
48
    }
49
}",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053457
1390053458,unknown,unknown,unknown,"1
def minimum_pruning_cost(server_rack):
2
    active_count = server_rack.count('1')
3
    idle_count = server_rack.count('0')
4
    5
    min_cost = float('inf')
6
    7
    for start_servers in range(len(server_rack) + 1):
8
        for end_servers in range(len(server_rack) + 1 - start_servers):
9
            if start_servers == 0 and end_servers == 0:
10
                continue
11
                12
            remaining = server_rack[start_servers:len(server_rack) - end_servers]
13
            14
            active_decommissioned = (server_rack[:start_servers].count('1') + 
15
                                    server_rack[len(server_rack) - end_servers:].count('1'))
16
            17
            remaining_idle = remaining.count('0')
18
            19
            cost = max(remaining_idle, active_decommissioned)
20
            21
            min_cost = min(min_cost, cost)
22
    23
    return min_cost
24
25
def main():
26
    t = int(input().strip())
27
    28
    results = []
29
    for _ in range(t):
30
        server_rack = input().strip()
31
        results.append(minimum_pruning_cost(server_rack))
32
    33
    for result in results:
34
        print(result)
35
36
if __name__ == ""__main__"":
37
    main()",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053458
1390053448,unknown,unknown,unknown,"1
def find_earliest_faults(arr, batch_size):
2
    results = []
3
    for i in range(len(arr) - batch_size + 1):
4
        batch = arr[i:i + batch_size]
5
        earliest_fault = next((x for x in batch if x < 0), 0)
6
        results.append(earliest_fault)
7
    return results
8
9
# Test cases
10
for _ in range(int(input())):
11
    n, k = map(int, input().split())
12
    arr = list(map(int, input().split()))
13
    print(*find_earliest_faults(arr, k))
14",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053448
1390053449,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053449
1390053454,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx + 1])
10
        idx += 2
11
        a = list(map(int, input[idx:idx + n]))
12
        idx += n
13
        14
        sum_S = sum(a)
15
        # Compute a[i] + i (0-based)
16
        values = [a[i] + i for i in range(n)]
17
        # Sort in descending order
18
        values.sort(reverse=True)
19
        sum_aj_plus_j = sum(values[:k])
20
        # Compute the result
21
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
22
        print(res)
23
24
25
main()",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053454
1390053446,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  
7
    8
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
   13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    16
    for i in range(k, n):
17
       18
        if dq and dq[0] <= i - k:
19
            dq.popleft()
20
        21
        22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
       26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
31
t = int(input())  
32
for _ in range(t):
33
    n, k = map(int, input().split())  
34
    arr = list(map(int, input().split()))  
35
    print(*earliest_faulty_readings(arr, k))
36",136,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053446
1390053438,unknown,unknown,unknown,"1
def main():
2
    import sys
3
    input = sys.stdin.read
4
    data = input().split()
5
    6
    # Read number of test cases
7
    T = int(data[0])
8
    index = 1
9
    10
    # Process each test case
11
    for _ in range(T):
12
        s = data[index]
13
        index += 1
14
        n = len(s)
15
        16
        # Compute prefix sums for '0's and '1's
17
        prefix0 = [0] * (n + 1)  # Number of '0's up to index i
18
        prefix1 = [0] * (n + 1)  # Number of '1's up to index i
19
        for i in range(n):
20
            prefix0[i + 1] = prefix0[i] + (1 if s[i] == '0' else 0)
21
            prefix1[i + 1] = prefix1[i] + (1 if s[i] == '1' else 0)
22
        23
        # Initial minimum cost: cost of removing entire string
24
        min_cost = prefix1[n]
25
        26
        # Iterate over all possible ending indices b
27
        for b in range(n):
28
            # '0's up to b, '1's from b+1 to end
29
            zeros_up_to_b = prefix0[b + 1]
30
            ones_after_b = prefix1[n] - prefix1[b + 1]
31
            32
            # Cost function for a given starting index a
33
            def cost(a):
34
                zeros_remaining = zeros_up_to_b - prefix0[a]
35
                ones_removed = prefix1[a] + ones_after_b
36
                return max(zeros_remaining, ones_removed)
37
            38
            # Ternary search to find optimal a for this b
39
            left, right = 0, b
40
            while right - left > 2:
41
                m1 = left + (right - left) // 3
42
                m2 = right - (right - left) // 3
43
                if cost(m1) < cost(m2):
44
                    right = m2
45
                else:
46
                    left = m1
47
            48
            # Check remaining points for minimum cost
49
            local_min = min(cost(a) for a in range(left, right + 1))
50
            min_cost = min(min_cost, local_min)
51
        52
        # Output the minimum cost for this test case
53
        print(min_cost)
54
55
if __name__ == ""__main__"":
56
    main()",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053438
1390053435,unknown,unknown,unknown,"1
def solve():
2
    server_rack = input().strip()
3
    n = len(server_rack)
4
    ones_prefix = [0] * (n + 1)
5
    for i in range(n):
6
        ones_prefix[i+1] = ones_prefix[i] + (1 if server_rack[i] == '1' else 0)
7
8
    min_cost = float('inf')
9
    for left_remove_count in range(n + 1):
10
        for right_remove_count in range(n - left_remove_count + 1):
11
            active_removed = ones_prefix[left_remove_count] + (ones_prefix[n] - ones_prefix[n - right_remove_count])
12
            remaining_rack = server_rack[left_remove_count:n - right_remove_count]
13
            idle_remaining = 0
14
            for char in remaining_rack:
15
                if char == '0':
16
                    idle_remaining += 1
17
            cost = max(idle_remaining, active_removed)
18
            min_cost = min(min_cost, cost)
19
    print(min_cost)
20
21
T = int(input())
22
for _ in range(T):
23
    solve()",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053435
1390053439,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int t = sc.nextInt();
8
        while (t-- > 0) {
9
            int n = sc.nextInt(), k = sc.nextInt();
10
            int[] s = new int[n];
11
            for (int i = 0; i < n; i++) s[i] = sc.nextInt();
12
            System.out.println(minEffort(s, n, k));
13
        }
14
        sc.close();
15
    }
16
17
    private static long minEffort(int[] s, int n, int k) {
18
        if (k >= n) return 0;
19
20
        long[][] dp = new long[n + 1][k + 1];
21
        for (long[] row : dp) Arrays.fill(row, Long.MAX_VALUE / 2);
22
        dp[0][0] = 0;
23
24
        for (int i = 0; i < n; i++) {
25
            for (int j = 0; j <= k; j++) {
26
                if (dp[i][j] == Long.MAX_VALUE / 2) continue;
27
                dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + s[i] + j);
28
                if (j < k) dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j]);
29
            }
30
        }
31
32
        long minEffort = Long.MAX_VALUE;
33
        for (int j = 0; j <= k; j++) minEffort = Math.min(minEffort, dp[n][j]);
34
35
        return minEffort;
36
    }
37
}
38",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053439
1390053431,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053431
1390053432,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053432
1390053424,unknown,unknown,unknown,"1
def min_effort(firewalls, n, k):
2
    if k >= n:
3
        return 0
4
    5
    indexed_firewalls = [(i, firewalls[i]) for i in range(n)]
6
    indexed_firewalls.sort(key=lambda x: x[1], reverse=True)
7
    8
    skip = [False] * n
9
    for i in range(k):
10
        skip[indexed_firewalls[i][0]] = True
11
    12
    total_effort = 0
13
    skipped_count = 0
14
    15
    for i in range(n):
16
        if skip[i]:
17
            skipped_count += 1
18
        else:
19
            total_effort += firewalls[i] + skipped_count
20
    21
    return total_effort
22
23
if __name__ == ""__main__"":
24
    import sys
25
    input = sys.stdin.read
26
    data = input().split('\n')
27
    28
    t = int(data[0])
29
    index = 1
30
    31
    results = []
32
    for _ in range(t):
33
        n, k = map(int, data[index].split())
34
        firewalls = list(map(int, data[index + 1].split()))
35
        results.append(str(min_effort(firewalls, n, k)))
36
        index += 2
37
    38
    print(""\n"".join(results))",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053424
1390053428,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
    public static List<Integer> earliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>();
7
8
        for (int i = 0; i < arr.length; i++) {
9
            // Remove out-of-window elements
10
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
11
                deque.poll();
12
            }
13
14
            // Add new faulty readings
15
            if (arr[i] < 0) {
16
                deque.offer(i);
17
            }
18
19
            // Collect results for valid windows
20
            if (i >= k - 1) {
21
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
22
            }
23
        }
24
        return result;
25
    }
26
27
    public static void main(String[] args) {
28
        Scanner scanner = new Scanner(System.in);
29
        int t = scanner.nextInt(); // Number of test cases
30
31
        while (t-- > 0) {
32
            int n = scanner.nextInt(); // Array size
33
            int k = scanner.nextInt(); // Batch size
34
            int[] arr = new int[n];
35
36
            for (int i = 0; i < n; i++) {
37
                arr[i] = scanner.nextInt();
38
            }
39
40
            // Compute and print results
41
            List<Integer> faults = earliestFaults(arr, k);
42
            for (int val : faults) {
43
                System.out.print(val + "" "");
44
            }
45
            System.out.println();
46
        }
47
        scanner.close();
48
    }
49
}",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053428
1390053427,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void findEarliestFaultyReadings(int *arr, int n, int k) {
5
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
6
    int front = 0, rear = 0;
7
    int queue[n];
8
    9
    // Process the first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) {
12
            queue[rear++] = i;
13
        }
14
    }
15
    16
    // Store result for the first batch
17
    result[0] = (front < rear) ? arr[queue[front]] : 0;
18
    19
    // Process the remaining windows
20
    for (int i = k; i < n; i++) {
21
        // Remove elements not within the window
22
        while (front < rear && queue[front] <= i - k) {
23
            front++;
24
        }
25
        26
        // Add new element if it's faulty
27
        if (arr[i] < 0) {
28
            queue[rear++] = i;
29
        }
30
        31
        // Store result for current batch
32
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
33
    }
34
    35
    // Print the result
36
    for (int i = 0; i < n - k + 1; i++) {
37
        printf(""%d "", result[i]);
38
    }
39
    printf(""\n"");
40
    41
    free(result);
42
}
43
44
int main() {
45
    int t;
46
    scanf(""%d"", &t);
47
    48
    while (t--) {
49
        int n, k;
50
        scanf(""%d %d"", &n, &k);
51
        int arr[n];
52
        53
        for (int i = 0; i < n; i++) {
54
            scanf(""%d"", &arr[i]);
55
        }
56
        57
        findEarliestFaultyReadings(arr, n, k);
58
    }
59
    60
    return 0;
61
}",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053427
1390053423,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    if k == n:
3
        return 0
4
    if k == 0:
5
        return sum(firewalls)
6
    min_effort = float('inf')
7
    for i in range(n):
8
   9
        skipped = 0
10
        effort = 0
11
        for j in range(n):
12
            if skipped < k and j >= i:
13
                skipped += 1
14
            else:
15
                effort += firewalls[j] + skipped
16
17
        min_effort = min(min_effort, effort)
18
19
    return min_effort
20
21
T = int(input().strip())
22
results = []
23
24
for _ in range(T):
25
    n, k = map(int, input().split())
26
    firewalls = list(map(int, input().split()))
27
    results.append(min_effort(n, k, firewalls))
28
29
for res in results:
30
    print(res)",137,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053423
1390053416,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n = len(case)
5
        min_cost = float('inf')
6
        7
        # Precompute prefix sums for 0's and 1's
8
        prefix_0 = [0] * (n + 1)
9
        prefix_1 = [0] * (n + 1)
10
        for i in range(n):
11
            prefix_0[i + 1] = prefix_0[i] + (1 if case[i] == '0' else 0)
12
            prefix_1[i + 1] = prefix_1[i] + (1 if case[i] == '1' else 0)
13
        14
        # Iterate through all possible splits
15
        for i in range(n + 1):
16
            for j in range(i, n + 1):
17
                # Remaining segment is from i to j-1
18
                remaining_0s = prefix_0[j] - prefix_0[i]
19
                removed_1s = prefix_1[i] + (prefix_1[n] - prefix_1[j])
20
                cost = max(remaining_0s, removed_1s)
21
                if cost < min_cost:
22
                    min_cost = cost
23
        results.append(min_cost)
24
    return results
25
26
# Read input
27
T = int(input())
28
test_cases = [input().strip() for _ in range(T)]
29
30
# Compute results
31
results = min_decommission_cost(test_cases)
32
33
# Print output
34
for result in results:
35
    print(result)",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053416
1390053422,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static int minEffort(int[] firewalls, int k) {
7
        int n = firewalls.length;
8
        if (k >= n) return 0;
9
10
        int[][] dp = new int[n + 1][k + 1];
11
12
        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);
13
        for (int j = 0; j <= k; j++) dp[n][j] = 0;
14
15
        for (int i = n - 1; i >= 0; i--) {
16
            for (int j = 0; j <= k; j++) {
17
                if (j < k) dp[i][j] = dp[i + 1][j + 1];
18
19
                if (dp[i + 1][j] != Integer.MAX_VALUE) {
20
                    dp[i][j] = Math.min(dp[i][j], firewalls[i] + j + dp[i + 1][j]);
21
                }
22
            }
23
        }
24
25
        return dp[0][0];
26
    }
27
28
    public static void main(String[] args) {
29
        Scanner sc = new Scanner(System.in);
30
        int t = sc.nextInt();
31
32
        while (t-- > 0) {
33
            int n = sc.nextInt();
34
            int k = sc.nextInt();
35
            int[] firewalls = new int[n];
36
37
            for (int i = 0; i < n; i++) {
38
                firewalls[i] = sc.nextInt();
39
            }
40
41
            System.out.println(minEffort(firewalls, k));
42
        }
43
44
        sc.close();
45
    }
46
}
47",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053422
1390053419,unknown,unknown,unknown,"1
def min_decommission_cost(binary_str):
2
    binary_str = binary_str.strip('0')
3
    4
    if not binary_str:
5
        return 0  
6
    7
    total_zeros = binary_str.count('0')
8
    min_cost = total_zeros  
9
    10
    removed_ones = 0
11
    for ch in binary_str:
12
        if ch == '1':
13
            removed_ones += 1
14
        else:
15
            total_zeros -= 1  
16
        17
        min_cost = min(min_cost, max(total_zeros, removed_ones))
18
    19
    return min_cost
20
21
22
T = int(input())
23
for _ in range(T):
24
    binary_str = input().strip()
25
    print(min_decommission_cost(binary_str))
26
27",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053419
1390053412,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total active ('1') and idle ('0') servers
5
    total_active = server_string.count('1')
6
    total_idle = n - total_active
7
8
    # Precompute cumulative count of active servers from the left
9
    active_prefix_sum = [0] * (n + 1)
10
    for i in range(n):
11
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
12
    13
    min_cost = float('inf')
14
15
    # Try all possible segments
16
    for left in range(n + 1):
17
        for right in range(left, n + 1):
18
            # Active servers in the selected range
19
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
20
            idle_remaining = (right - left) - active_remaining
21
22
            # Active servers removed (total active - active in range)
23
            active_removed = total_active - active_remaining
24
25
            # Cost is max of idle servers in range or removed active servers
26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
def faster_min_decommission_cost(server_string):
32
    n = len(server_string)
33
34
    # Precompute prefix sums for active ('1') and idle ('0') servers
35
    active_prefix = [0] * (n + 1)
36
    idle_prefix = [0] * (n + 1)
37
38
    for i in range(n):
39
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
40
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
41
42
    min_cost = n  # Worst case scenario
43
44
    # Iterate through all possible substrings efficiently
45
    for i in range(n + 1):
46
        for j in range(i, n + 1):
47
            # Idle servers in the selected range
48
            idle_remaining = idle_prefix[j] - idle_prefix[i]
49
50
            # Active servers removed (total active - active in selected range)
51
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
52
53
            # Compute cost and update minimum
54
            cost = max(idle_remaining, active_removed)
55
            min_cost = min(min_cost, cost)
56
57
    return min_cost
58
59
def main():
60
    t = int(input().strip())
61
62
    for _ in range(t):
63
        server_string = input().strip()
64
        result = faster_min_decommission_cost(server_string)
65
        print(result)
66
67
if __name__ == ""__main__"":
68
    main()
69",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053412
1390053411,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of faulty readings (negative values)
7
8
    for i in range(n):
9
        # Remove indices that are out of the current window
10
        if dq and dq[0] < i - k + 1:
11
            dq.popleft()
12
13
        # Add the current element's index if it's a negative value (faulty)
14
        if arr[i] < 0:
15
            dq.append(i)
16
17
        # If the window is large enough (i >= k - 1), we check the result
18
        if i >= k - 1:
19
            if dq:
20
                result.append(arr[dq[0]])  # The earliest faulty reading in the window
21
            else:
22
                result.append(0)  # No faulty reading in this window
23
24
    return result
25
26
def process_test_cases():
27
    t = int(input())  # number of test cases
28
    for _ in range(t):
29
        n, k = map(int, input().split())  # size of array and batch size
30
        arr = list(map(int, input().split()))  # the array of sensor readings
31
        result = earliest_faulty_reading(arr, k)
32
        print(' '.join(map(str, result)))
33
34
# Call the function to process test cases
35
process_test_cases()",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053411
1390053414,unknown,unknown,unknown,"1
def find_earliest_faults(arr, n, k):
2
    result = []
3
    4
    for i in range(n - k + 1):
5
        window = arr[i:i + k]
6
        fault = next((num for num in window if num < 0), 0)
7
        result.append(fault)
8
9
    print(*result)
10
11
for _ in range(int(input().strip())):
12
    n, k = map(int, input().strip().split())
13
    arr = list(map(int, input().strip().split()))
14
    find_earliest_faults(arr, n, k)
15",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053414
1390053404,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FirewallMinEffort {
4
    5
    public static long minEffort(int[] firewalls, int n, int k) {
6
        // If we can skip all firewalls, return 0
7
        if (k >= n) return 0;
8
        9
        // Create a list of pairs (index, strength)
10
        List<int[]> indexedFirewalls = new ArrayList<>();
11
        for (int i = 0; i < n; i++) {
12
            indexedFirewalls.add(new int[]{i, firewalls[i]});
13
        }
14
        15
        // Sort by strength to find the k strongest firewalls to skip
16
        indexedFirewalls.sort((a, b) -> Integer.compare(b[1], a[1]));
17
        18
        // Mark which firewalls to skip
19
        boolean[] skip = new boolean[n];
20
        for (int i = 0; i < k; i++) {
21
            skip[indexedFirewalls.get(i)[0]] = true;
22
        }
23
        24
        // Calculate the total effort
25
        long totalEffort = 0;
26
        int skippedCount = 0;
27
        28
        for (int i = 0; i < n; i++) {
29
            if (skip[i]) {
30
                skippedCount++;
31
            } else {
32
                totalEffort += firewalls[i] + skippedCount;
33
            }
34
        }
35
        36
        return totalEffort;
37
    }
38
39
    public static void main(String[] args) {
40
        Scanner sc = new Scanner(System.in);
41
        42
        int t = sc.nextInt(); // Number of test cases
43
        44
        while (t-- > 0) {
45
            int n = sc.nextInt(); // Number of firewalls
46
            int k = sc.nextInt(); // Firewalls to skip
47
            48
            int[] firewalls = new int[n];
49
            for (int i = 0; i < n; i++) {
50
                firewalls[i] = sc.nextInt();
51
            }
52
            53
            System.out.println(minEffort(firewalls, n, k));
54
        }
55
        56
        sc.close();
57
    }
58
}",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053404
1390053406,unknown,unknown,unknown,"1
def min_firewall_effort(n, k, firewalls):
2
    """"""
3
    Calculates the minimum effort needed to breach the network.
4
5
    Args:
6
        n: The number of firewalls.
7
        k: The maximum number of firewalls that can be skipped.
8
        firewalls: A list of firewall strengths.
9
10
    Returns:
11
        The minimum effort needed.
12
    """"""
13
    min_effort = float('inf')
14
15
    for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
16
        skipped_count = bin(i).count('1')
17
        if skipped_count <= k:
18
            current_effort = 0
19
            skipped = 0
20
            current_firewalls = firewalls[:]  # Create a copy to avoid modifying the original list
21
22
            skipped_indices = []
23
            for j in range(n):
24
                if (i >> j) & 1:
25
                    skipped_indices.append(j)
26
27
            skipped_indices.sort()
28
            29
            j = 0
30
            for index in skipped_indices:
31
                for l in range(index+1,n):
32
                    current_firewalls[l] +=1
33
34
            for j in range(n):
35
                if (i >> j) & 1:
36
                    continue
37
                else:
38
                    current_effort += current_firewalls[j]
39
40
            min_effort = min(min_effort, current_effort)
41
42
    return min_effort
43
44
if __name__ == ""__main__"":
45
    t = int(input())
46
    for _ in range(t):
47
        n, k = map(int, input().split())
48
        firewalls = list(map(int, input().split()))
49
        result = min_firewall_effort(n, k, firewalls)
50
        print(result)",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053406
1390053410,unknown,unknown,unknown,"1
from collections import deque
2
def first_negative_in_batches(a, b):
3
    c = []
4
    d = deque()
5
    for i in range(b):
6
        if a[i] < 0:
7
            d.append(i)
8
    for i in range(b, len(a) + 1):
9
        c.append(a[d[0]] if d else 0)
10
        while d and d[0] < i - b + 1:
11
            d.popleft()
12
        if i < len(a) and a[i] < 0:
13
            d.append(i)
14
    return c
15
16
a = int(input())
17
for _ in range(a):
18
    b, c = map(int, input().split())
19
    d = list(map(int, input().split()))
20
    print(*first_negative_in_batches(d, c))
21",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053410
1390053403,unknown,unknown,unknown,"1
     2
        3
for _ in range(int(input())):
4
    x,y = map(int,input().split())
5
    arr = list(map(int,input().split()))
6
    res = []
7
    for i in range(x-y+1):
8
        batch = arr[i:i+y]
9
        for a in batch:
10
            if a<0:
11
                res.append(a)
12
                break
13
            elif a>=0 and a == batch[-1]: 
14
                res.append(0)
15
                16
    for i in res:
17
        print(i, end = ' ')
18
    print()
19
20
21
    22
 23
            24
            ",138,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053403
1390053396,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first k elements
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the result for the first window
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process the remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the current window
18
        while dq and dq[0] <= i - k:
19
            dq.popleft()
20
        21
        # Add the current element if it is negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the result for the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Read input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    36
    # Compute and print results
37
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053396
1390053397,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
from collections import deque
3
4
def earliest_faulty_readings(arr, k):
5
6
    result = []
7
8
    dq = deque()
9
10
    11
12
    for i in range(len(arr)):
13
14
        # Remove elements not part of the current batch
15
16
        while dq and dq[0] < i - k + 1:
17
18
            dq.popleft()
19
20
        21
22
        # If current element is faulty, add its index to deque
23
24
        if arr[i] < 0:
25
26
            dq.append(i)
27
28
        29
30
        # Add the first faulty element of the batch to result
31
32
        if i >= k - 1:
33
34
            result.append(arr[dq[0]] if dq else 0)
35
36
    37
38
    return result
39
40
def main():
41
42
    t = int(input())
43
44
    for _ in range(t):
45
46
        n, k = map(int, input().split())
47
48
        arr = list(map(int, input().split()))
49
50
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))
51
52
if __name__ == ""__main__"":
53
54
    main()",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053397
1390053401,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <algorithm>
4
5
using namespace std;
6
7
long long minEffort(vector<int>& firewalls, int n, int k) {
8
    // If we can skip all firewalls, return 0
9
    if (k >= n) return 0;
10
    11
    // Create a vector of pairs (index, strength)
12
    vector<pair<int, int>> indexedFirewalls(n);
13
    for (int i = 0; i < n; i++) {
14
        indexedFirewalls[i] = {i, firewalls[i]};
15
    }
16
    17
    // Sort by strength to find the k strongest firewalls to skip
18
    sort(indexedFirewalls.begin(), indexedFirewalls.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
19
        return a.second > b.second;
20
    });
21
    22
    // Mark which firewalls to skip
23
    vector<bool> skip(n, false);
24
    for (int i = 0; i < k; i++) {
25
        skip[indexedFirewalls[i].first] = true;
26
    }
27
    28
    // Calculate the total effort
29
    long long totalEffort = 0;
30
    int skippedCount = 0;
31
    32
    for (int i = 0; i < n; i++) {
33
        if (skip[i]) {
34
            skippedCount++;
35
        } else {
36
            totalEffort += firewalls[i] + skippedCount;
37
        }
38
    }
39
    40
    return totalEffort;
41
}
42
43
int main() {
44
    ios_base::sync_with_stdio(false);
45
    cin.tie(NULL);
46
    47
    int t;
48
    cin >> t;
49
    50
    while (t--) {
51
        int n, k;
52
        cin >> n >> k;
53
        54
        vector<int> firewalls(n);
55
        for (int i = 0; i < n; i++) {
56
            cin >> firewalls[i];
57
        }
58
        59
        cout << minEffort(firewalls, n, k) << endl;
60
    }
61
    62
    return 0;
63
}",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053401
1390053391,unknown,unknown,unknown,"1
def earliest_faulty_in_batches(arr, n, k):
2
    result = []
3
4
    for i in range(n - k + 1):
5
        batch = arr[i:i + k]
6
        found_fault = False 
7
        for num in batch:
8
            if num < 0:
9
                result.append(num)
10
                found_fault = True
11
                break
12
        if not found_fault:
13
            result.append(0)
14
    15
    return result
16
17
t= int(input().strip())
18
outputs = []
19
20
for _ in range(t):
21
    n, k = map(int, input().strip().split())
22
    arr = list(map(int, input().strip().split()))
23
    outputs.append(earliest_faulty_in_batches(arr, n, k))
24
for output in outputs:
25
    print("" "".join(map(str, output)))",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053391
1390053392,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
5
    int n = arr.size();
6
    vector<int> result;
7
    deque<int> dq;  
8
9
    for (int i = 0; i < k; i++) {
10
        if (arr[i] < 0) dq.push_back(i);
11
    }
12
13
    for (int i = k; i <= n; i++) {
14
    15
        if (!dq.empty()) 
16
            result.push_back(arr[dq.front()]);  
17
        else 
18
            result.push_back(0);  
19
20
        while (!dq.empty() && dq.front() < i - k + 1) {
21
            dq.pop_front();
22
        }
23
24
        if (i < n && arr[i] < 0) {
25
            dq.push_back(i);
26
        }
27
    }
28
29
    return result;
30
}
31
32
int main() {
33
    int t;
34
    cin >> t;  
35
    while (t--) {
36
        int n, k;
37
        cin >> n >> k;  
38
        vector<int> arr(n);
39
        for (int i = 0; i < n; i++) {
40
            cin >> arr[i];
41
        }
42
        43
        vector<int> result = earliest_faulty_readings(arr, k);
44
        for (int num : result) {
45
            cout << num << "" "";
46
        }
47
        cout << endl;
48
    }
49
    return 0;
50
}",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053392
1390053394,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    4
    for _ in range(test_cases):
5
        n, k = map(int, input().split())  # Read n (firewalls) and k (skips)
6
        effort = list(map(int, input().split()))  # Read effort values
7
8
        if k == n:  # If we skip all firewalls, effort is 0
9
            results.append(""0"")
10
            continue
11
12
        total_effort = sum(effort)  # Sum of all firewall efforts
13
        min_effort_value = total_effort  # Initialize with the maximum possible effort
14
15
        # Try skipping each firewall one by one and compute the new effort
16
        for i in range(n):
17
            new_effort = total_effort - effort[i]  # Remove effort[i] from the sum
18
            if i > 0:
19
                new_effort += 1  # Increase effort for all remaining firewalls
20
21
            min_effort_value = min(min_effort_value, new_effort)  # Update minimum effort
22
        23
        results.append(str(min_effort_value))  # Store the result for this test case
24
    print(""\n"".join(results))  # Print results ef
25
26
T = int(input())  # Number of test cases
27
min_effort(T)",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053394
1390053387,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static long minDecommissionCost(String s) {
6
        int n = s.length();
7
        if (n == 0) return 0;
8
9
        long[] preOnes = new long[n + 1], preZeros = new long[n + 1];
10
        long[] sufOnes = new long[n + 1], sufZeros = new long[n + 1];
11
12
        for (int i = 0; i < n; i++) {
13
            preOnes[i + 1] = preOnes[i] + (s.charAt(i) == '1' ? 1 : 0);
14
            preZeros[i + 1] = preZeros[i] + (s.charAt(i) == '0' ? 1 : 0);
15
        }
16
17
        for (int i = n - 1; i >= 0; i--) {
18
            sufOnes[i] = sufOnes[i + 1] + (s.charAt(i) == '1' ? 1 : 0);
19
            sufZeros[i] = sufZeros[i + 1] + (s.charAt(i) == '0' ? 1 : 0);
20
        }
21
22
        long minCost = Long.MAX_VALUE;
23
24
        for (int l = 0; l <= n; l++) {
25
            for (int r = l - 1; r < n; r++) {
26
                long decomm1s = (r < l) ? preOnes[n] : preOnes[l] + sufOnes[r + 1];
27
                long rem0s = (r < l) ? 0 : preZeros[r + 1] - preZeros[l];
28
                minCost = Math.min(minCost, Math.max(rem0s, decomm1s));
29
            }
30
        }
31
32
        return minCost;
33
    }
34
35
    public static void main(String[] args) {
36
        Scanner sc = new Scanner(System.in);
37
        int t = sc.nextInt();
38
        sc.nextLine();
39
        while (t-- > 0) System.out.println(minDecommissionCost(sc.nextLine().trim()));
40
        sc.close();
41
    }
42
}
43",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053387
1390053388,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    int T;
10
    cin >> T;
11
    while (T--) {
12
        string s;
13
        cin >> s;
14
        int n = s.size();
15
16
        // Total 1s and 0s
17
        vector<int> prefix_1(n + 1, 0);
18
        vector<int> prefix_0(n + 1, 0);
19
        for (int i = 0; i < n; i++) {
20
            prefix_1[i + 1] = prefix_1[i] + (s[i] == '1' ? 1 : 0);
21
            prefix_0[i + 1] = prefix_0[i] + (s[i] == '0' ? 1 : 0);
22
        }
23
24
        int total_1 = prefix_1[n];
25
        int total_0 = prefix_0[n];
26
27
        int min_cost = n;
28
29
        // Try all possible pairs of (left_removal = l, right_removal = r)
30
        // Keep substring from index l to r-1 inclusive
31
        for (int l = 0; l <= n; l++) {
32
            // Binary search on r (right removal count), so that l + r <= n
33
            for (int r = 0; r <= n - l; r++) {
34
                int start = l;
35
                int end = n - r;
36
37
                int kept_1 = prefix_1[end] - prefix_1[start];
38
                int kept_0 = prefix_0[end] - prefix_0[start];
39
40
                int removed_1 = total_1 - kept_1;
41
                int remaining_0 = kept_0;
42
43
                int cost = max(removed_1, remaining_0);
44
                min_cost = min(min_cost, cost);
45
            }
46
        }
47
48
        cout << min_cost << endl;
49
    }
50
    return 0;
51
}
52",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053388
1390053389,unknown,unknown,unknown,"1
def min_effort(arr, k):
2
    n = len(arr)
3
    total = sum(arr)
4
    # Consider not skipping any firewall as an option
5
    min_cost = total  
6
    # Try skipping every contiguous block of size k
7
    for i in range(n - k + 1):
8
        skipped_sum = sum(arr[i:i+k])
9
        penalty = n - (i + k)  # extra cost for each firewall after the skipped block
10
        cost = total - skipped_sum + penalty
11
        min_cost = min(min_cost, cost)
12
    return min_cost
13
14
# Input handling
15
t = int(input())
16
for _ in range(t):
17
    n, k = map(int, input().split())
18
    arr = list(map(int, input().split()))
19
    print(min_effort(arr, k))
20",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053389
1390053379,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}
41",139,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053379
1390053374,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        # Precompute prefix counts of '1's
6
        prefix_ones = [0] * (n + 1)
7
        for i in range(n):
8
            prefix_ones[i + 1] = prefix_ones[i] + (1 if s[i] == '1' else 0)
9
        10
        # Precompute suffix counts of '1's
11
        suffix_ones = [0] * (n + 1)
12
        for i in range(n - 1, -1, -1):
13
            suffix_ones[i] = suffix_ones[i + 1] + (1 if s[i] == '1' else 0)
14
        15
        # Precompute the number of '0's in the entire string
16
        total_zeros = s.count('0')
17
        18
        min_cost_val = float('inf')
19
        20
        # Iterate over all possible left decommissioning points
21
        for left in range(n + 1):
22
            # Calculate the number of '1's removed from the left
23
            ones_removed_left = prefix_ones[left]
24
25
            low = 0
26
            high = n - left
27
            best_right = 0
28
            best_cost = float('inf')
29
            30
            while low <= high:
31
                mid = (low + high) // 2
32
                right = mid
33
                ones_removed_right = suffix_ones[n - right]
34
                total_ones_removed = ones_removed_left + ones_removed_right
35
                zeros_remaining = total_zeros - (left - prefix_ones[left]) - (right - suffix_ones[n - right])
36
                current_cost = max(zeros_remaining, total_ones_removed)
37
                38
                if current_cost < best_cost:
39
                    best_cost = current_cost
40
                    best_right = right
41
                42
                if zeros_remaining > total_ones_removed:
43
                    low = mid + 1
44
                else:
45
                    high = mid - 1
46
            47
            if best_cost < min_cost_val:
48
                min_cost_val = best_cost
49
        50
        results.append(min_cost_val)
51
    return results
52
53
# Read input
54
T = int(input())
55
test_cases = [input().strip() for _ in range(T)]
56
57
# Compute results
58
results = min_cost(test_cases)
59
60
# Output results
61
for res in results:
62
    print(res)",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053374
1390053376,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    min_cost = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            remaining = s[i:n-j]
10
            11
            idle_remaining = remaining.count('0')
12
            active_removed = s[:i].count('1') + s[n-j:].count('1')
13
            14
            cost = max(idle_remaining, active_removed)
15
            min_cost = min(min_cost, cost)
16
            17
    print(min_cost)
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053376
1390053377,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053377
1390053363,unknown,unknown,unknown,"1
def min_decommission_cost(server_rack):
2
    n = len(server_rack)
3
    min_cost = float('inf')
4
    5
    for i in range(n + 1):
6
        for j in range(i, n + 1):
7
            remaining = server_rack[i:j]
8
            cost = max(remaining.count('0'), server_rack[:i].count('1') + server_rack[j:].count('1'))
9
            min_cost = min(min_cost, cost)
10
    11
    return min_cost
12
13
def main():
14
    T = int(input().strip())
15
    for _ in range(T):
16
        server_rack = input().strip()
17
        print(min_decommission_cost(server_rack))
18
19
if __name__ == ""__main__"":
20
    main()",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053363
1390053366,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    4
    for n, k, arr in test_cases:
5
        res = []
6
        negatives = []
7
        8
        for i in range(k):
9
            if arr[i] < 0:
10
                negatives.append(i)
11
        12
        res.append(arr[negatives[0]] if negatives else 0)
13
        14
        for i in range(k, n):
15
            if negatives and negatives[0] < i - k + 1:
16
                negatives.pop(0)
17
            18
            if arr[i] < 0:
19
                negatives.append(i)
20
            21
            res.append(arr[negatives[0]] if negatives else 0)
22
        23
        results.append("" "".join(map(str, res)))
24
    25
    return ""\n"".join(results)
26
27
t = int(input())
28
test_cases = []
29
30
for _ in range(t):
31
    n, k = map(int, input().split())
32
    arr = list(map(int, input().split()))
33
    test_cases.append((n, k, arr))
34
35
print(earliest_faulty_readings(test_cases))
36",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053366
1390053365,unknown,unknown,unknown,"1
test_cases = int(input())
2
for t in range(test_cases):
3
    a,b = list(map(int,input().split("" "")))
4
    arr = list(map(int,input().split("" "")))
5
    l,r = 0,b-1
6
    res = []
7
    neg_index = 0
8
    while r<a:
9
        temp = None
10
        for i in range(l,r+1):
11
            if arr[i]<0:
12
                temp = arr[i]
13
                break
14
        if temp:
15
            res.append(temp)
16
        else:
17
            res.append(0)
18
        l+=1
19
        r+=1
20
    for i in res:
21
        print(i,end="" "")
22
    print()",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053365
1390053358,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommission {
4
5
    public static int minCostDecommissioning(String rack) {
6
        int n = rack.length();
7
        int totalOnes = 0;
8
9
        // Count total number of 1's in the rack
10
        for (char c : rack.toCharArray()) {
11
            if (c == '1') {
12
                totalOnes++;
13
            }
14
        }
15
16
        int minCost = Integer.MAX_VALUE;
17
18
        // Try all possible removals from left and right
19
        for (int left = 0; left <= n; left++) {
20
            for (int right = 0; right <= n - left; right++) {
21
                String remaining = rack.substring(left, n - right);
22
23
                int remainingZeros = 0, remainingOnes = 0;
24
                for (char c : remaining.toCharArray()) {
25
                    if (c == '0') {
26
                        remainingZeros++;
27
                    } else {
28
                        remainingOnes++;
29
                    }
30
                }
31
32
                int removedOnes = totalOnes - remainingOnes;
33
                int cost = Math.max(remainingZeros, removedOnes);
34
35
                minCost = Math.min(minCost, cost);
36
            }
37
        }
38
39
        return minCost;
40
    }
41
42
    public static void main(String[] args) {
43
        Scanner scanner = new Scanner(System.in);
44
        int T = scanner.nextInt();
45
        scanner.nextLine(); // Consume newline
46
47
        for (int i = 0; i < T; i++) {
48
            String rack = scanner.nextLine();
49
            System.out.println(minCostDecommissioning(rack));
50
        }
51
52
        scanner.close();
53
    }
54
}
55",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053358
1390053359,unknown,unknown,unknown,"1
def main():
2
    t = int(input())
3
    4
    for _ in range(t):
5
        n, k = map(int, input().split())
6
        strengths = list(map(int, input().split()))
7
        8
        # Edge case: if we can skip all firewalls
9
        if k >= n:
10
            print(0)
11
            continue
12
        13
        # For small test cases, use brute force
14
        if n <= 20:
15
            min_effort = float('inf')
16
            17
            # Try all possible combinations of firewalls to skip
18
            for mask in range(1 << n):
19
                if bin(mask).count('1') <= k:
20
                    effort = 0
21
                    skipped = 0
22
                    23
                    for i in range(n):
24
                        if (mask >> i) & 1:
25
                            skipped += 1
26
                        else:
27
                            effort += strengths[i] + skipped
28
                    29
                    min_effort = min(min_effort, effort)
30
            31
            print(min_effort)
32
            continue
33
        34
        # For larger test cases, use a more efficient approach
35
        # Calculate the benefit array
36
        benefits = []
37
        for i in range(n):
38
            benefits.append((strengths[i] - (n - i - 1), i))
39
        40
        # Sort by benefit
41
        benefits.sort(reverse=True)
42
        43
        # Try skipping different numbers of firewalls
44
        min_effort = float('inf')
45
        46
        for skips in range(k + 1):
47
            to_skip = set()
48
            49
            # Take the top 'skips' firewalls with highest benefit
50
            for i in range(skips):
51
                if i < len(benefits):
52
                    to_skip.add(benefits[i][1])
53
            54
            # Calculate the effort
55
            effort = 0
56
            skipped = 0
57
            58
            for i in range(n):
59
                if i in to_skip:
60
                    skipped += 1
61
                else:
62
                    effort += strengths[i] + skipped
63
            64
            min_effort = min(min_effort, effort)
65
        66
        print(min_effort)
67
68
if __name__ == ""__main__"":
69
    main()",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053359
1390053361,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053361
1390053356,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    """"""
3
    Calculate minimum effort to breach n firewalls with optimal strategy.
4
    5
    Args:
6
        n: Number of firewalls
7
        k: Maximum number of firewalls that can be skipped
8
        firewalls: List of firewall strengths
9
        10
    Returns:
11
        Minimum effort required
12
    """"""
13
    # If we can skip all firewalls, return 0
14
    if k >= n:
15
        return 0
16
    17
    # Initialize dp array with infinity
18
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
19
    20
    # Base case: no firewalls, no effort
21
    dp[0][0] = 0
22
    23
    for i in range(1, n + 1):
24
        firewall_idx = i - 1  # Convert to 0-indexed
25
        26
        for j in range(k + 1):
27
            # Option 1: Don't skip the current firewall
28
            if j <= i - 1:  # Ensure we have processed enough firewalls
29
                dp[i][j] = min(dp[i][j], dp[i-1][j] + firewalls[firewall_idx] + j)
30
            31
            # Option 2: Skip the current firewall
32
            if j > 0:  # We must have at least one skip available
33
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
34
    35
    # Return the minimum effort after processing all firewalls
36
    return dp[n][k]
37
38
def main():
39
    t = int(input())  # Number of test cases
40
    41
    for _ in range(t):
42
        n, k = map(int, input().split())
43
        firewalls = list(map(int, input().split()))
44
        45
        min_effort = min_effort_to_breach(n, k, firewalls)
46
        print(min_effort)
47
48
if __name__ == ""__main__"":
49
    main()",140,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053356
1390053351,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first window of size k
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process the remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the current window
18
        if dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
        21
        # Add the new element if it is negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the result for the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
def main():
31
    t = int(input().strip())  # Number of test cases
32
    for _ in range(t):
33
        n, k = map(int, input().split())  # Read n and k
34
        arr = list(map(int, input().split()))  # Read array elements
35
        36
        # Get the earliest faulty readings
37
        output = earliest_faulty_readings(arr, k)
38
        39
        # Print result as space-separated values
40
        print("" "".join(map(str, output)))
41
42
if __name__ == ""__main__"":
43
    main()
44",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053351
1390053353,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for n, k, arr in test_cases:
4
        total_effort = sum(arr)
5
        6
        if k == n:
7
            results.append(""0"")  
8
            continue
9
10
        min_effort = total_effort 
11
        12
        13
        for i in range(n):
14
            effort_with_skip = (total_effort - arr[i]) + k
15
            min_effort = min(min_effort, effort_with_skip)
16
        17
        results.append(str(min_effort))
18
    19
    return ""\n"".join(results)
20
21
22
t = int(input())  
23
test_cases = []
24
for _ in range(t):
25
    n, k = map(int, input().split())  
26
    arr = list(map(int, input().split()))  
27
    test_cases.append((n, k, arr))
28
29
30
print(min_effort(test_cases))
31",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053353
1390053354,unknown,unknown,unknown,"1
def min_effort(n, k, arr):
2
    total_effort = sum(arr)  # Compute the total effort without skipping any firewall
3
    min_effort = total_effort  # Initialize minimum effort
4
5
    if len(arr)==k:
6
        return 0
7
    # Try skipping each firewall
8
    for i in range(n):
9
        effort = total_effort - arr[i] + k  # Skip the i-th firewall and add k penalty
10
        min_effort = min(min_effort, effort)  # Keep track of the minimum
11
12
    return min_effort
13
14
# Read input
15
t = int(input())
16
for _ in range(t):
17
    n, k = map(int, input().split())
18
    arr = list(map(int, input().split()))
19
    print(min_effort(n, k, arr))
20",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053354
1390053339,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
5
    public static void main(String[] args) {
6
7
        Scanner sc = new Scanner(System.in);
8
9
        int T = sc.nextInt();
10
11
        while (T-- > 0) {
12
13
            int n = sc.nextInt();
14
15
            int k = sc.nextInt();
16
17
            int[] a = new int[n];
18
19
            long sum_a = 0;
20
21
            for (int i = 0; i < n; i++) {
22
23
                a[i] = sc.nextInt();
24
25
                sum_a += a[i];
26
27
            }
28
29
            List<Long> values = new ArrayList<>();
30
31
            for (int i = 0; i < n; i++) {
32
33
                long val = a[i] - (n - i - 1L);
34
35
                values.add(val);
36
37
            }
38
39
            values.sort((x, y) -> Long.compare(y, x));
40
41
            long[] prefixSum = new long[n + 1];
42
43
            prefixSum[0] = 0;
44
45
            for (int i = 1; i <= n; i++) {
46
47
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
48
49
            }
50
51
            int max_m = Math.min(k, n);
52
53
            long maxTotal = Long.MIN_VALUE;
54
55
            for (int m = 0; m <= max_m; m++) {
56
57
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
58
59
                if (current > maxTotal) {
60
61
                    maxTotal = current;
62
63
                }
64
65
            }
66
67
            long minEffort = sum_a - maxTotal;
68
69
            System.out.println(minEffort);
70
71
        }
72
73
        sc.close();
74
75
    }
76
77
}",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053339
1390053344,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <algorithm>
4
5
using namespace std;
6
7
long long minEffort(vector<int>& firewalls, int n, int k) {
8
    // If we can skip all firewalls, return 0
9
    if (k >= n) return 0;
10
    11
    // Create a vector of pairs (index, strength)
12
    vector<pair<int, int>> indexedFirewalls(n);
13
    for (int i = 0; i < n; i++) {
14
        indexedFirewalls[i] = {i, firewalls[i]};
15
    }
16
    17
    // Sort by strength to find the k strongest firewalls to skip
18
    sort(indexedFirewalls.begin(), indexedFirewalls.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
19
        return a.second > b.second;
20
    });
21
    22
    // Mark which firewalls to skip
23
    vector<bool> skip(n, false);
24
    for (int i = 0; i < k; i++) {
25
        skip[indexedFirewalls[i].first] = true;
26
    }
27
    28
    // Calculate the total effort
29
    long long totalEffort = 0;
30
    int skippedCount = 0;
31
    32
    for (int i = 0; i < n; i++) {
33
        if (skip[i]) {
34
            skippedCount++;
35
        } else {
36
            totalEffort += firewalls[i] + skippedCount;
37
        }
38
    }
39
    40
    return totalEffort;
41
}
42
43
int main() {
44
    ios_base::sync_with_stdio(false);
45
    cin.tie(NULL);
46
    47
    int t;
48
    cin >> t;
49
    50
    while (t--) {
51
        int n, k;
52
        cin >> n >> k;
53
        54
        vector<int> firewalls(n);
55
        for (int i = 0; i < n; i++) {
56
            cin >> firewalls[i];
57
        }
58
        59
        cout << minEffort(firewalls, n, k) << endl;
60
    }
61
    62
    return 0;
63
}
64",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053344
1390053349,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
5
    int n = arr.size();
6
    vector<int> result;
7
    deque<int> dq;  // Stores indices of negative numbers
8
9
    // Process first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) dq.push_back(i);
12
    }
13
14
    // Process the sliding window
15
    for (int i = k; i <= n; i++) {
16
        // Append first negative number in the window
17
        if (!dq.empty()) 
18
            result.push_back(arr[dq.front()]);  // First negative in the deque
19
        else 
20
            result.push_back(0);  // No negative number
21
22
        // Remove elements that are out of the current window
23
        while (!dq.empty() && dq.front() < i - k + 1) {
24
            dq.pop_front();
25
        }
26
27
        // Add the next element if negative
28
        if (i < n && arr[i] < 0) {
29
            dq.push_back(i);
30
        }
31
    }
32
33
    return result;
34
}
35
36
int main() {
37
    int t;
38
    cin >> t;  // Number of test cases
39
    while (t--) {
40
        int n, k;
41
        cin >> n >> k;  // Size of array and batch size
42
        vector<int> arr(n);
43
        for (int i = 0; i < n; i++) {
44
            cin >> arr[i];
45
        }
46
        47
        vector<int> result = earliest_faulty_readings(arr, k);
48
        for (int num : result) {
49
            cout << num << "" "";
50
        }
51
        cout << endl;
52
    }
53
    return 0;
54
}",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053349
1390053333,unknown,unknown,unknown,"1
t = int(input())
2
for _ in range(t):
3
    4
    5
    n, k = map(int, input().split())
6
    a = list(map(int, input().split()))
7
    8
    9
    dp = [float('inf')] * (k + 1)
10
    dp[0] = 0
11
    12
    13
    for i in range(n):
14
        new_dp = [float('inf')]*(k+1)
15
        16
        17
        for s in range(k+1):
18
            19
            if s>0:
20
                new_dp[s] = min(new_dp[s],dp[s - 1])
21
                22
                23
            new_dp[s] = min(new_dp[s], dp[s] + a[i] + s)
24
        dp = new_dp
25
    print(min(dp))",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053333
1390053334,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
        Scanner sc = new Scanner(System.in);
9
        int T = sc.nextInt();
10
        while (T-- > 0) {
11
            String rack = sc.next();
12
            int n = rack.length();
13
            int[] prefixZero = new int[n + 1];
14
            int[] prefixOne = new int[n + 1];
15
            16
            // Build prefix sums
17
            for (int i = 0; i < n; i++) {
18
                prefixZero[i + 1] = prefixZero[i] + (rack.charAt(i) == '0' ? 1 : 0);
19
                prefixOne[i + 1] = prefixOne[i] + (rack.charAt(i) == '1' ? 1 : 0);
20
            }
21
22
            int totalOnes = prefixOne[n];
23
            int totalZeros = prefixZero[n];
24
            int minCost = totalOnes; // If we remove nothing, A = 0, I = totalZeros
25
            26
            // If all are zeros, we can remove everything from the beginning
27
            if (totalOnes == 0) {
28
                System.out.println(0);
29
                continue;
30
            }
31
            32
            // Try all possible left starting points
33
            for (int i = 1; i <= n; i++) {
34
                int onesInPrefix = prefixOne[i];
35
                int zerosBefore = prefixZero[i];
36
                // Try all possible right ending points
37
                for (int j = 0; j <= n - i; j++) {
38
                    int onesInSuffix = prefixOne[n] - prefixOne[n - j];
39
                    int zerosInSuffix = prefixZero[n] - prefixZero[n - j];
40
                    int idleRemaining = totalZeros - zerosBefore - zerosInSuffix;
41
                    int activeDecommissioned = onesInPrefix + onesInSuffix;
42
                    int cost = Math.max(idleRemaining, activeDecommissioned);
43
                    minCost = Math.min(minCost, cost);
44
                    // Early termination: if activeDecommissioned >= minCost, no need to check larger suffixes
45
                    if (activeDecommissioned >= minCost) break;
46
                }
47
            }
48
            System.out.println(minCost);
49
        }
50
        sc.close();
51
    }
52
}",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053334
1390053337,unknown,unknown,unknown,"1
     2
        3
for _ in range(int(input())):
4
    x,y = map(int,input().split())
5
    arr = list(map(int,input().split()))
6
    res = []
7
    for i in range(x-y+1):
8
        batch = arr[i:i+y]
9
        for a in batch:
10
            if a<=0:
11
                res.append(a)
12
                break
13
            elif a>0 and a == batch[-1]: 
14
                res.append(0)
15
                16
    for i in res:
17
        print(i, end = ' ')
18
    print()
19
20
21
    22
 23
            24
            ",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053337
1390053332,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    min_cost = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            remaining = s[i:n-j]
10
            11
            idle_remaining = remaining.count('0')
12
            active_removed = s[:i].count('1') + s[n-j:].count('1')
13
            14
            cost = max(idle_remaining, active_removed)
15
            min_cost = min(min_cost, cost)
16
            17
    print(min_cost)
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",141,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053332
1390053322,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] arr = new int[n];
11
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
12
13
            long minEffort = Long.MAX_VALUE;
14
15
            // Case when skipping 0 to k firewalls
16
            if (k >= n) {
17
                // Skip all firewalls
18
                System.out.println(0);
19
                continue;
20
            }
21
22
            // Try all combinations where we skip up to k firewalls
23
            // For k=1, try skipping each firewall one by one
24
            // General approach:
25
            boolean[] skip = new boolean[n];
26
            // Priority Queue to skip k largest firewalls
27
            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);
28
29
            for (int i = 0; i < n; i++) {
30
                pq.add(new int[]{arr[i], i});
31
            }
32
33
            for (int s = 0; s <= k; s++) {
34
                Arrays.fill(skip, false);
35
                PriorityQueue<int[]> temp = new PriorityQueue<>(pq);
36
37
                // Skip 's' largest firewalls
38
                for (int j = 0; j < s; j++) {
39
                    int[] top = temp.poll();
40
                    skip[top[1]] = true;
41
                }
42
43
                long effort = 0;
44
                int skipped = 0;
45
                for (int i = 0; i < n; i++) {
46
                    if (skip[i]) {
47
                        skipped++;
48
                    } else {
49
                        effort += arr[i] + skipped;
50
                    }
51
                }
52
53
                minEffort = Math.min(minEffort, effort);
54
            }
55
56
            System.out.println(minEffort);
57
        }
58
        sc.close();
59
    }
60
}",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053322
1390053326,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    min_cost = float('inf')
5
6
    for i in range(n + 1):
7
        for j in range(n - i + 1):
8
            remaining_s = s[i:n - j]
9
            10
            idle_count = remaining_s.count('0')
11
            active_removed = s[:i].count('1') + s[n - j:].count('1')
12
            13
            cost = max(idle_count, active_removed)
14
            min_cost = min(min_cost, cost)
15
            16
    print(min_cost)
17
18
t = int(input())
19
for _ in range(t):
20
    solve()",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053326
1390053327,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_rack):
2
    n = len(server_rack)
3
    4
    # Initialize counters
5
    min_cost = float('inf')
6
    7
    # Try all possible combinations of removing prefix and suffix
8
    for i in range(n + 1):  # i = length of prefix to remove
9
        for j in range(n + 1 - i):  # j = length of suffix to remove
10
            if i + j > n:
11
                continue
12
                13
            # Calculate what's left after removing prefix and suffix
14
            remaining = server_rack[i:n-j]
15
            16
            if not remaining:
17
                continue  # Cannot remove all servers
18
                19
            # Count idle servers remaining and active servers removed
20
            idle_remaining = remaining.count('0')
21
            active_removed = server_rack[:i].count('1') + server_rack[n-j:].count('1')
22
            23
            # Cost is the maximum of these two
24
            cost = max(idle_remaining, active_removed)
25
            26
            # Update min_cost if this is better
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
# Process input
32
t = int(input())
33
results = []
34
35
for _ in range(t):
36
    server_rack = input().strip()
37
    results.append(min_decommissioning_cost(server_rack))
38
39
# Output results
40
for result in results:
41
    print(result)",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053327
1390053317,unknown,unknown,unknown,"1
def solve():
2
    server_rack = input().strip()
3
    n = len(server_rack)
4
    min_cost = float('inf')
5
6
    for left_remove_count in range(n + 1):
7
        for right_remove_count in range(n - left_remove_count + 1):
8
            removed_prefix = server_rack[:left_remove_count]
9
            removed_suffix = server_rack[n - right_remove_count:]
10
            remaining_rack = server_rack[left_remove_count:n - right_remove_count]
11
12
            idle_remaining = remaining_rack.count('0')
13
            active_removed = removed_prefix.count('1') + removed_suffix.count('1')
14
            cost = max(idle_remaining, active_removed)
15
            min_cost = min(min_cost, cost)
16
17
    print(min_cost)
18
19
T = int(input())
20
for _ in range(T):
21
    solve()",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053317
1390053320,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static int minEffort(int[] firewalls, int k) {
7
        int n = firewalls.length;
8
        if (k >= n) return 0;
9
10
        int[][] dp = new int[n + 1][k + 1];
11
        for (int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);
12
13
        for (int j = 0; j <= k; j++) dp[n][j] = 0;
14
15
        for (int i = n - 1; i >= 0; i--) {
16
            for (int j = 0; j <= k; j++) {
17
                if (j < k) dp[i][j] = dp[i + 1][j + 1];
18
                int effort = firewalls[i] + j;
19
                dp[i][j] = Math.min(dp[i][j], effort + dp[i + 1][j]);
20
            }
21
        }
22
23
        return dp[0][0];
24
    }
25
26
    public static void main(String[] args) {
27
        Scanner sc = new Scanner(System.in);
28
        int t = sc.nextInt();
29
30
        while (t-- > 0) {
31
            int n = sc.nextInt();
32
            int k = sc.nextInt();
33
            int[] firewalls = new int[n];
34
35
            for (int i = 0; i < n; i++) {
36
                firewalls[i] = sc.nextInt();
37
            }
38
39
            System.out.println(minEffort(firewalls, k));
40
        }
41
42
        sc.close();
43
    }
44
}
45",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053320
1390053318,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053318
1390053313,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053313
1390053314,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_earliest_faults(test_cases):
4
5
    results = []
6
7
    8
9
    for n, k, arr in test_cases:
10
11
        dq = deque()  # Store indices of negative elements
12
13
        res = []
14
15
        # Process first window
16
17
        for i in range(k):
18
19
            if arr[i] < 0:
20
21
                dq.append(i)
22
23
        # Store result for first window
24
25
        res.append(arr[dq[0]] if dq else 0)
26
27
        # Process remaining windows
28
29
        for i in range(k, n):
30
31
            # Remove elements not in the current window
32
33
            while dq and dq[0] < i - k + 1:
34
35
                dq.popleft()
36
37
            # Add new element if it's negative
38
39
            if arr[i] < 0:
40
41
                dq.append(i)
42
43
            # Store result for this batch
44
45
            res.append(arr[dq[0]] if dq else 0)
46
47
        results.append("" "".join(map(str, res)))
48
49
    return results
50
51
# Read input
52
53
t = int(input())  # Number of test cases
54
55
test_cases = []
56
57
for _ in range(t):
58
59
    n, k = map(int, input().split())  # Size of array and batch size
60
61
    arr = list(map(int, input().split()))  # Array elements
62
63
    test_cases.append((n, k, arr))
64
65
# Processing and printing output
66
67
for result in find_earliest_faults(test_cases):
68
69
    print(result)",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053314
1390053312,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    result = []
3
    for i in range(len(arr) - k + 1):
4
        for num in arr[i:i+k]:
5
            if num < 0:
6
                result.append(num)
7
                break
8
        else:
9
            result.append(0)
10
    return result
11
12
t = int(input())
13
for _ in range(t):
14
    n, k = map(int, input().split())
15
    arr = list(map(int, input().split()))
16
    print(*earliest_fault(arr, k))
17",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053312
1390053311,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",142,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053311
1390053308,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053308
1390053305,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <string>
4
#include <algorithm>
5
6
using namespace std;
7
8
int main() {
9
    int T;
10
    cin >> T;
11
    for (int t = 0; t < T; t++) {
12
        string s;
13
        cin >> s;
14
        int n = s.size();
15
16
        // Step 1: Build prefix sums
17
        vector<int> prefix0(n + 1, 0);
18
        vector<int> prefix1(n + 1, 0);
19
        for (int i = 0; i < n; i++) {
20
            prefix0[i + 1] = prefix0[i] + (s[i] == '0' ? 1 : 0);
21
            prefix1[i + 1] = prefix1[i] + (s[i] == '1' ? 1 : 0);
22
        }
23
24
        // Step 2: Initialize min_cost with the case of removing everything
25
        int min_cost = prefix1[n];
26
27
        // Step 3: Iterate over all possible a and b
28
        for (int a = 0; a <= n; a++) {
29
            for (int b = a - 1; b < n; b++) {
30
                // Number of '0's in s[a..b]
31
                int zeros_remaining = (b >= a) ? prefix0[b + 1] - prefix0[a] : 0;
32
                // Number of '1's in prefix s[0..a-1] and suffix s[b+1..n-1]
33
                int ones_removed = prefix1[a] + (prefix1[n] - prefix1[b + 1]);
34
                // Cost for this substring
35
                int cost = max(zeros_remaining, ones_removed);
36
                // Update minimum cost
37
                min_cost = min(min_cost, cost);
38
            }
39
        }
40
41
        cout << min_cost << endl;
42
    }
43
    return 0;
44
}",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053305
1390053310,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # If we can skip all firewalls, no effort is needed
3
    if k >= n:
4
        return 0
5
    6
    # Initialize DP array: dp[i][j] -> min effort to breach first i firewalls with j skips
7
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
8
9
    # Base case: No firewalls, no effort needed
10
    for j in range(k + 1):
11
        dp[0][j] = 0  # If no firewalls exist, effort is zero
12
    13
    for i in range(1, n + 1):
14
        for j in range(min(k, i) + 1):  # Ensure j never exceeds i
15
            # Case 1: Don't skip current firewall
16
            if j <= i - 1:
17
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
18
            19
            # Case 2: Skip current firewall (only if skips are available)
20
            if j > 0:
21
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
22
    23
    return dp[n][k]
24
25
def solve():
26
    t = int(input())  # Read number of test cases
27
    28
    for _ in range(t):
29
        n, k = map(int, input().split())  # Read n (firewalls) and k (max skips)
30
        strengths = list(map(int, input().split()))  # Read firewall strengths
31
        32
        # Special case: If we can skip all firewalls
33
        if k >= n:
34
            print(0)
35
        else:
36
            print(min_effort_to_breach(n, k, strengths))
37
38
# Run the solution
39
solve()
40",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053310
1390053300,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    min_effort = float('inf')
6
7
    # Iterate through all possible combinations of firewalls to skip
8
    for i in range(1 << n):
9
        skipped_count = bin(i).count('1')  # Count the number of set bits (skipped firewalls)
10
11
        if skipped_count <= k:
12
            effort = 0
13
            skip_count_so_far = 0
14
            15
            for j in range(n):
16
                if (i >> j) & 1:  # Check if the j-th firewall is skipped
17
                    skip_count_so_far += 1
18
                else:
19
                    effort += a[j] + skip_count_so_far  # Add the cost of the firewall + increased security
20
            21
            min_effort = min(min_effort, effort)
22
23
    print(min_effort)
24
25
26
t = int(input())
27
for _ in range(t):
28
    solve()",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053300
1390053302,unknown,unknown,unknown,"1
def solution():
2
    m = int(input())
3
    for _ in range(m):
4
        s = input() 
5
        n = len(s)
6
        ans = float('inf')
7
        for i in range(n+1):
8
            for j in range(n-i+1):
9
                temp = s[i:n-j]
10
                count = temp.count('0')
11
                removed = s[:i].count('1')+ s[n-j:].count('1')
12
                ans = min(ans,max(count,removed))
13
        print(ans)
14
solution()",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053302
1390053304,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    """"""
3
    Calculate minimum effort to breach n firewalls with optimal strategy.
4
    5
    Args:
6
        n: Number of firewalls
7
        k: Maximum number of firewalls that can be skipped
8
        firewalls: List of firewall strengths
9
        10
    Returns:
11
        Minimum effort required
12
    """"""
13
    # If we can skip all firewalls, return 0
14
    if k >= n:
15
        return 0
16
    17
    # Initialize dp array with infinity
18
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
19
    20
    # Base case: no firewalls, no effort
21
    dp[0][0] = 0
22
    23
    for i in range(1, n + 1):
24
        firewall_idx = i - 1  # Convert to 0-indexed
25
        26
        for j in range(k + 1):
27
            # Option 1: Don't skip the current firewall
28
            if j <= i - 1:  # Ensure we have processed enough firewalls
29
                dp[i][j] = min(dp[i][j], dp[i-1][j] + firewalls[firewall_idx] + j)
30
            31
            # Option 2: Skip the current firewall
32
            if j > 0:  # We must have at least one skip available
33
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
34
    35
    # Return the minimum effort after processing all firewalls
36
    return dp[n][k]
37
38
def main():
39
    t = int(input())  # Number of test cases
40
    41
    for _ in range(t):
42
        n, k = map(int, input().split())
43
        firewalls = list(map(int, input().split()))
44
        45
        min_effort = min_effort_to_breach(n, k, firewalls)
46
        print(min_effort)
47
48
if __name__ == ""__main__"":
49
    main()",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053304
1390053290,unknown,unknown,unknown,"1
from collections import deque
2
import sys
3
4
def faults(arr, n, k):
5
    result = []
6
    dq = deque()  
7
8
    for i in range(n):
9
        if dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
        12
        if arr[i] < 0:
13
            dq.append(i)
14
15
        if i >= k - 1:
16
            result.append(arr[dq[0]] if dq else 0)
17
18
    return result
19
20
def test_cases():
21
    t = int(sys.stdin.readline().strip())  
22
    results = []
23
    24
    for _ in range(t):
25
        n, k = map(int, sys.stdin.readline().strip().split())  
26
        arr = list(map(int, sys.stdin.readline().strip().split()))  
27
        28
        results.append("" "".join(map(str,faults(arr, n, k))))  
29
    30
    print(""\n"".join(results))  
31
32
33
if __name__ == ""__main__"":
34
    test_cases()
35",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053290
1390053291,unknown,unknown,unknown,"1
def minimum_decommission_cost(server_rack):
2
    n = len(server_rack)
3
    4
    min_cost = float('inf')
5
    6
    for prefix in range(n + 1):
7
        for suffix in range(n + 1 - prefix):
8
            if prefix + suffix > n:
9
                continue
10
                11
            prefix_active = server_rack[:prefix].count('1')
12
            suffix_active = server_rack[n-suffix:].count('1')
13
            total_active_removed = prefix_active + suffix_active
14
            15
            remaining_idle = server_rack[prefix:n-suffix].count('0')
16
            17
            cost = max(remaining_idle, total_active_removed)
18
            19
            min_cost = min(min_cost, cost)
20
    21
    return min_cost
22
23
def solve_test_cases():
24
    t = int(input().strip())
25
    results = []
26
    27
    for _ in range(t):
28
        server_rack = input().strip()
29
        results.append(minimum_decommission_cost(server_rack))
30
    31
    return results
32
results = solve_test_cases()
33
for result in results:
34
    print(result)",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053291
1390053298,unknown,unknown,unknown,"1
     2
        3
for _ in range(int(input())):
4
    x,y = map(int,input().split())
5
    arr = list(map(int,input().split()))
6
    res = []
7
    for i in range(x-y+1):
8
        batch = arr[i:i+y]
9
        for a in batch:
10
            if a<0:
11
                res.append(a)
12
                break
13
            elif a>=0 and a == batch[-1]: 
14
                res.append(0)
15
                16
    for i in res:
17
        print(i, end = ' ')
18
    print()
19
20
21
    22
 23
            24
            ",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053298
1390053286,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0 
5
6
    for i in range(1, n + 1):
7
        for j in range(k + 1):
8
            9
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
10
11
            12
            if j > 0:
13
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
14
15
    16
    return min(dp[n])
17
18
T = int(input())  # Number of test cases
19
for _ in range(T):
20
    n, k = map(int, input().split())  # Read n and k
21
    firewalls = list(map(int, input().split()))  # Firewall strengths
22
23
    # Compute and print the minimum effort
24
    print(min_effort(n, k, firewalls))",143,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053286
1390053280,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053280
1390053284,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <algorithm>
4
using namespace std;
5
6
int main() {
7
    int T;
8
    cin >> T;
9
10
    while (T--) {
11
        string servers;
12
        cin >> servers;
13
        14
        int n = servers.size();
15
        int total_1 = count(servers.begin(), servers.end(), '1');
16
        int total_0 = n - total_1;
17
18
        int min_cost = n;  // Initialize to the maximum possible value
19
20
        // Try all possible ways of removing from the front (i) and from the back (j)
21
        for (int i = 0; i <= n; ++i) {
22
            int count_1_removed = 0;
23
            int count_0_remaining = total_0;
24
25
            // Count the number of 1's and 0's removed from the front
26
            for (int k = 0; k < i; ++k) {
27
                if (servers[k] == '1') {
28
                    count_1_removed++;
29
                } else {
30
                    count_0_remaining--;
31
                }
32
            }
33
34
            for (int j = 0; j <= n - i; ++j) {
35
                // Count the number of 1's and 0's removed from the back
36
                int count_1_removed_after_back = count_1_removed;
37
                int count_0_remaining_after_back = count_0_remaining;
38
39
                if (j > 0) {
40
                    if (servers[n - j] == '1') {
41
                        count_1_removed_after_back++;
42
                    } else {
43
                        count_0_remaining_after_back--;
44
                    }
45
                }
46
47
                // Compute the cost as max of (1's removed) and (0's remaining)
48
                min_cost = min(min_cost, max(count_1_removed_after_back, count_0_remaining_after_back));
49
            }
50
        }
51
52
        cout << min_cost << endl;
53
    }
54
55
    return 0;
56
}",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053284
1390053285,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx + 1])
10
        idx += 2
11
        a = list(map(int, input[idx:idx + n]))
12
        idx += n
13
        14
        sum_S = sum(a)
15
        values = [a[i] + i for i in range(n)]
16
        values.sort(reverse=True)
17
        sum_aj_plus_j = sum(values[:k])
18
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
19
        print(res)
20
21
if _name_ == ""_main_"":
22
    main()",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053285
1390053268,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    ans = float('inf')
5
6
    for i in range(n + 1):
7
        for j in range(n - i + 1):
8
            temp = s[i:n - j]
9
            idle = temp.count('0')
10
            active = s[:i].count('1') + s[n - j:].count('1')
11
            ans = min(ans, max(idle, active))
12
            13
    print(ans)
14
15
t = int(input())
16
for _ in range(t):
17
    solve()",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053268
1390053272,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    4
    for _ in range(test_cases):
5
        n, k = map(int, input().split())  # Read n (firewalls) and k (skips)
6
        effort = list(map(int, input().split()))  # Read effort values
7
8
        if k == n:  # If we skip all firewalls, effort is 0
9
            results.append(""0"")
10
            continue
11
12
        total_effort = sum(effort)  # Sum of all firewall efforts
13
        min_effort_value = total_effort  # Initialize with the maximum possible effort
14
15
        # Try skipping each firewall one by one and compute the new effort
16
        for i in range(n):
17
            new_effort = total_effort - effort[i]  # Remove effort[i] from the sum
18
            if i > 0:
19
                new_effort += 1  # Increase effort for all remaining firewalls
20
21
            min_effort_value = min(min_effort_value, new_effort)  # Update minimum effort
22
        23
        results.append(str(min_effort_value))  # Store the result for this test case
24
25
    print(""\n"".join(results))  # Print results efficiently
26
27
# Driver Code
28
T = int(input())  # Number of test cases
29
min_effort(T)
30
31",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053272
1390053278,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] arr = new int[n];
11
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
12
            13
            long[] prev = new long[k + 2];
14
            Arrays.fill(prev, Long.MAX_VALUE);
15
            prev[0] = 0;
16
            17
            for (int i = 0; i < n; i++) {
18
                long[] curr = new long[k + 2];
19
                Arrays.fill(curr, Long.MAX_VALUE);
20
                for (int j = 0; j <= k; j++) {
21
                    if (prev[j] == Long.MAX_VALUE) continue;
22
                    23
                    // Option 1: Pay effort
24
                    curr[j] = Math.min(curr[j], prev[j] + arr[i] + j);
25
                    26
                    // Option 2: Skip (if skips left)
27
                    if (j + 1 <= k)
28
                        curr[j + 1] = Math.min(curr[j + 1], prev[j]);
29
                }
30
                prev = curr;
31
            }
32
            33
            long result = Long.MAX_VALUE;
34
            for (int j = 0; j <= k; j++) result = Math.min(result, prev[j]);
35
            System.out.println(result);
36
        }
37
        sc.close();
38
    }
39
}
40",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053278
1390053262,unknown,unknown,unknown,"1
2
3
4
5
6
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
7
8
import java.util.*;
9
10
public class Main {
11
12
    public static void main(String[] args) {
13
14
        Scanner sc = new Scanner(System.in);
15
16
        int T = sc.nextInt();
17
18
        while (T-- > 0) {
19
20
            int n = sc.nextInt();
21
22
            int k = sc.nextInt();
23
24
            int[] a = new int[n];
25
26
            long sum_a = 0;
27
28
            for (int i = 0; i < n; i++) {
29
30
                a[i] = sc.nextInt();
31
32
                sum_a += a[i];
33
34
            }
35
36
            List<Long> values = new ArrayList<>();
37
38
            for (int i = 0; i < n; i++) {
39
40
                long val = a[i] - (n - i - 1L);
41
42
                values.add(val);
43
44
            }
45
46
            values.sort((x, y) -> Long.compare(y, x));
47
48
            long[] prefixSum = new long[n + 1];
49
50
            prefixSum[0] = 0;
51
52
            for (int i = 1; i <= n; i++) {
53
54
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
55
56
            }
57
58
            int max_m = Math.min(k, n);
59
60
            long maxTotal = Long.MIN_VALUE;
61
62
            for (int m = 0; m <= max_m; m++) {
63
64
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
65
66
                if (current > maxTotal) {
67
68
                    maxTotal = current;
69
70
                }
71
72
            }
73
74
            long minEffort = sum_a - maxTotal;
75
76
            System.out.println(minEffort);
77
78
        }
79
80
        sc.close();
81
82
    }
83
84
}",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053262
1390053263,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
8
    # Process first k elements (first window)
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Process rest of the array
14
    for i in range(n - k + 1):
15
        # Add earliest faulty reading or 0 if none
16
        result.append(arr[dq[0]] if dq else 0)
17
18
        # Remove elements out of the window
19
        if dq and dq[0] == i:
20
            dq.popleft()
21
22
        # Add new element to the window
23
        if i + k < n and arr[i + k] < 0:
24
            dq.append(i + k)
25
26
    return result
27
28
# Read input
29
t = int(input().strip())  # Number of test cases
30
for _ in range(t):
31
    n, k = map(int, input().split())  # Size of array and batch size
32
    arr = list(map(int, input().split()))
33
    print(*earliest_faulty_readings(arr, k))
34",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053263
1390053265,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
17
    # Calculate the impact of skipping each firewall
18
    impacts = []
19
    for i in range(n):
20
        impact = strengths[i] - (n - i - 1)  # Firewall strength minus penalty
21
        impacts.append((impact, i))  # Store impact and index
22
23
    # Sort by impact in descending order
24
    impacts.sort(reverse=True, key=lambda x: x[0])
25
26
    # Select the k firewalls with the highest impact to skip
27
    to_skip = set(impacts[i][1] for i in range(k))
28
29
    # Calculate the total effort
30
    total_effort = 0
31
    penalty = 0
32
33
    for i in range(n):
34
        if i in to_skip:
35
            penalty += 1  # Skipping imposes a penalty
36
        else:
37
            total_effort += strengths[i] + penalty  # Apply penalty to effort
38
39
    return total_effort
40
41
42
def solve_test_cases():
43
    """"""
44
    Process all test cases and return the minimum effort for each.
45
    """"""
46
    t = int(input())  # Number of test cases
47
    results = []
48
49
    for _ in range(t):
50
        n, k = map(int, input().split())
51
        strengths = list(map(int, input().split()))
52
        results.append(min_effort_to_breach(n, k, strengths))
53
54
    return results
55
56
57
# Main function to run the solution
58
if __name__ == ""__main__"":  # Fixed Typo
59
    results = solve_test_cases()
60
    for result in results:
61
        print(result)
62",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053265
1390053261,unknown,unknown,unknown,"1
def find_earliest_faults(t, data):
2
    results = []
3
    4
    for case in range(t):
5
        n, k = data[case][0]
6
        arr = data[case][1]
7
        8
        result = []
9
        from collections import deque
10
        dq = deque()
11
12
        for i in range(k):
13
            if arr[i] < 0:
14
                dq.append(i)
15
16
        if dq:
17
            result.append(arr[dq[0]])
18
        else:
19
            result.append(0)
20
21
        for i in range(k, n):
22
23
            if dq and dq[0] < i - k + 1:
24
                dq.popleft()
25
26
            if arr[i] < 0:
27
                dq.append(i)
28
29
            if dq:
30
                result.append(arr[dq[0]])
31
            else:
32
                result.append(0)
33
        34
        results.append(result)
35
    36
    return results
37
38
test_cases = [
39
    ((5, 2), [-8, 2, 3, -6, 10]),
40
    ((8, 3), [12, -1, -7, 8, -15, 30, 16, 28])
41
]
42
43
t = len(test_cases)
44
45
outputs = find_earliest_faults(t, test_cases)
46
for output in outputs:
47
    print("" "".join(map(str, output)))
48",144,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053261
1390053252,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        dq = deque()
8
        output = []
9
        10
        # Process the first window
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
15
        # Check the first window
16
        output.append(arr[dq[0]] if dq else 0)
17
18
        # Process the rest of the array
19
        for i in range(k, n):
20
            # Remove elements not in the window
21
            while dq and dq[0] < i - k + 1:
22
                dq.popleft()
23
            24
            # Add the current element if it's negative
25
            if arr[i] < 0:
26
                dq.append(i)
27
28
            # Append the result for the current window
29
            output.append(arr[dq[0]] if dq else 0)
30
31
        results.append("" "".join(map(str, output)))
32
    33
    return results
34
35
# Read input
36
t = int(input().strip())
37
test_cases = []
38
39
for _ in range(t):
40
    n, k = map(int, input().split())
41
    arr = list(map(int, input().split()))
42
    test_cases.append((n, k, arr))
43
44
# Get the results
45
output = earliest_faulty_readings(test_cases)
46
47
# Print the output
48
for line in output:
49
    print(line)
50
    ",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053252
1390053259,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total active servers and total idle servers
5
    total_active = server_string.count('1')
6
    total_idle = n - total_active
7
    8
    # Precompute cumulative counts of active servers from left
9
    active_prefix_sum = [0] * (n + 1)
10
    for i in range(n):
11
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
12
    13
    min_cost = float('inf')
14
    15
    # Try all possible starting positions for the remaining servers
16
    for left in range(n + 1):
17
        # For each possible ending position
18
        for right in range(left, n + 1):
19
            # Active servers in the remaining segment
20
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
21
            idle_remaining = (right - left) - active_remaining
22
            23
            # Active servers removed
24
            active_removed = total_active - active_remaining
25
            26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
def faster_min_decommission_cost(server_string):
32
    n = len(server_string)
33
    34
    # Precompute prefix sums for active and idle servers
35
    active_prefix = [0] * (n + 1)
36
    idle_prefix = [0] * (n + 1)
37
    38
    for i in range(n):
39
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
40
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
41
    42
    min_cost = n  # Worst case cost
43
    44
    # For each possible remaining substring (from i to j-1)
45
    for i in range(n + 1):
46
        for j in range(i, n + 1):
47
            # Idle servers in remaining substring
48
            idle_remaining = idle_prefix[j] - idle_prefix[i]
49
            50
            # Active servers removed (from left and right)
51
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
52
            53
            cost = max(idle_remaining, active_removed)
54
            min_cost = min(min_cost, cost)
55
    56
    return min_cost
57
58
def main():
59
    t = int(input().strip())
60
    61
    for _ in range(t):
62
        server_string = input().strip()
63
        result = faster_min_decommission_cost(server_string)
64
        print(result)
65
66
if _name_ == ""_main_"":
67
    main()",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053259
1390053257,unknown,unknown,unknown,"1
def solve():
2
    n,k=map(int,input().split())
3
    a=list(map(int,input().split()))
4
    mineffort=float('inf')
5
    for i in range(1<<n):
6
        skipped=[]
7
        efforts=[]
8
        for j in range(n):
9
            if(i>>j)&1:
10
                skipped.append(j)
11
            else:
12
                efforts.append(j)
13
        if len(skipped)<=k:
14
            current_effort=0
15
            skippedcount=0
16
            for j in range(n):
17
                if j in skipped:
18
                    skippedcount+=1
19
                else:
20
                    current_effort+=a[j]+skippedcount
21
            mineffort=min(mineffort,current_effort)
22
    print(mineffort)
23
t = int(input())
24
for _ in range(t):
25
    solve()
26
    ",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053257
1390053249,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
3
    dp[0][0] = 0  
4
5
    for i in range(1, n + 1):
6
        for j in range(k + 1):
7
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
8
            if j > 0:
9
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
10
11
    return min(dp[n])
12
13
T = int(input())  
14
for _ in range(T):
15
    n, k = map(int, input().split())  
16
    firewalls = list(map(int, input().split()))  
17
    print(min_effort(n, k, firewalls))
18",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053249
1390053250,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053250
1390053251,unknown,unknown,unknown,"1
t = int(input())
2
3
4
for _ in range(t):
5
   6
    n, k = map(int, input().split())
7
    a = list(map(int, input().split()))
8
    9
    10
    #sort
11
    12
    value_idx = [(a[i], i) for i in range(n)]
13
14
    value_idx.sort(reverse=True)
15
    16
    17
    18
    #possible skips
19
    20
 21
    k = min(k, n)  
22
    candidates = value_idx[:k]  
23
    24
  25
    min_cost = float('inf')
26
    27
    for skips in range(k + 1):
28
       29
        skip_positions = set(c[1] for c in candidates[:skips])
30
        31
        32
        num_skips_so_far = 0
33
        current_cost = 0
34
        35
      36
        for i in range(n):
37
            38
            if i in skip_positions:
39
               40
                current_cost += 0
41
                num_skips_so_far += 1
42
                43
            else:
44
              45
                current_cost += a[i] + num_skips_so_far
46
        47
       48
        min_cost = min(min_cost, current_cost)
49
    50
  51
    print(min_cost)",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053251
1390053243,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
5
    public static int minEffort(int n, int k, int[] fw) {
6
        if (k >= n) return 0; 
7
        int total = 0;
8
        for (int x : fw) total += x; 
9
10
        Integer[] impact = new Integer[n];
11
        for (int i = 0; i < n; i++) {
12
            impact[i] = fw[i] - (n - i - 1); 
13
        }
14
15
        Arrays.sort(impact, Collections.reverseOrder()); 
16
17
        for (int i = 0; i < k; i++) {
18
            total -= Math.max(impact[i], 0); 
19
        }
20
21
        return total;
22
    }
23
24
    public static void main(String[] args) {
25
        Scanner sc = new Scanner(System.in);
26
        int t = sc.nextInt();
27
28
        while (t-- > 0) {
29
            int n = sc.nextInt(), k = sc.nextInt();
30
            int[] fw = new int[n];
31
32
            for (int i = 0; i < n; i++) fw[i] = sc.nextInt();
33
34
            System.out.println(minEffort(n, k, fw));
35
        }
36
        sc.close();
37
    }
38
}
39",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053243
1390053246,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        min_cost_val = float('inf')
6
        7
        # Iterate over possible decommissioning points
8
        for left in range(n + 1):
9
            for right in range(n + 1):
10
                if left + right > n:
11
                    continue
12
                remaining = s[left:n - right]
13
                idle_remaining = remaining.count('0')
14
                active_removed = s[:left].count('1') + s[n - right:].count('1')
15
                current_cost = max(idle_remaining, active_removed)
16
                if current_cost < min_cost_val:
17
                    min_cost_val = current_cost
18
        19
        results.append(min_cost_val)
20
    return results
21
22
# Read input
23
T = int(input())
24
test_cases = [input().strip() for _ in range(T)]
25
26
# Compute results
27
results = min_cost(test_cases)
28
29
# Output results
30
for res in results:
31
    print(res)",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053246
1390053248,unknown,unknown,unknown,"1
def minimize_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
4
    # Create list of (value + index) for each firewall
5
    skip_value = []
6
    for i in range(n):
7
        skip_value.append((firewalls[i] + i, i))
8
9
    # Sort by descending benefit to skip
10
    skip_value.sort(reverse=True)
11
12
    # Mark which firewalls to skip
13
    skipped = [0] * n
14
    for i in range(k):
15
        _, idx = skip_value[i]
16
        skipped[idx] = 1
17
18
    # Now calculate final effort
19
    effort = 0
20
    penalty = 0
21
    for i in range(n):
22
        if skipped[i]:
23
            penalty += 1
24
        else:
25
            effort += firewalls[i] + penalty
26
27
    return effort
28
29
# Main driver
30
T = int(input())
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    firewalls = list(map(int, input().split()))
34
    print(minimize_effort(n, k, firewalls))",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053248
1390053242,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <vector>
4
#include <algorithm>
5
#include <climits>  
6
7
using namespace std;
8
9
int minCost(const string& servers) {
10
    int n = servers.length();
11
    12
    // Edge case: empty rack
13
    if (n == 0) return 0;
14
    15
    // Precompute prefix sums for active and idle servers
16
    vector<int> activePrefixSum(n + 1, 0);
17
    vector<int> idlePrefixSum(n + 1, 0);
18
    19
    for (int i = 0; i < n; i++) {
20
        activePrefixSum[i + 1] = activePrefixSum[i] + (servers[i] == '1');
21
        idlePrefixSum[i + 1] = idlePrefixSum[i] + (servers[i] == '0');
22
    }
23
    24
    int minCost = INT_MAX;
25
    26
    // Try all possible combinations of removing servers from beginning and end
27
    for (int prefix = 0; prefix <= n; prefix++) {
28
        for (int suffix = 0; prefix + suffix <= n; suffix++) {
29
            // Skip if removing all servers
30
            if (prefix + suffix == n) continue;
31
            32
            // Calculate active servers removed
33
            int activeRemoved = activePrefixSum[prefix] + 
34
                               (activePrefixSum[n] - activePrefixSum[n - suffix]);
35
            36
            // Calculate idle servers remaining
37
            int idleRemaining = idlePrefixSum[n] - idlePrefixSum[prefix] - 
38
                               (idlePrefixSum[n] - idlePrefixSum[n - suffix]);
39
            40
            // Calculate cost as max of active removed and idle remaining
41
            int cost = max(activeRemoved, idleRemaining);
42
            minCost = min(minCost, cost);
43
        }
44
    }
45
    46
    return minCost;
47
}
48
49
int main() {
50
51
    int t;
52
    cin >> t;
53
    54
    while (t--) {
55
        string servers;
56
        cin >> servers;
57
        58
        cout << minCost(servers) << endl;
59
    }
60
    61
    return 0;
62
}",145,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053242
1390053237,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053237
1390053238,unknown,unknown,unknown,"1
def find_fault(arr,k):
2
    n=len(arr)
3
    result=[]
4
    5
    for i in range(n-k+1):
6
        batch=arr[i:i+k]
7
        faulty=0
8
        for x in batch:
9
            if x<0:
10
                faulty=x
11
                break
12
        result.append(faulty)
13
    return result
14
15
t=int(input())
16
for j in range(t):
17
    n,k=map(int,input().split())
18
    arr=list(map(int,input().split()))
19
    20
    faulty_readings=find_fault(arr,k)
21
    print(*faulty_readings)",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053238
1390053241,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053241
1390053231,unknown,unknown,unknown,"1
import sys
2
3
def main():
4
    input = sys.stdin.read().split()
5
    idx = 0
6
    T = int(input[idx])
7
    idx += 1
8
    for _ in range(T):
9
        n, k = int(input[idx]), int(input[idx + 1])
10
        idx += 2
11
        a = list(map(int, input[idx:idx + n]))
12
        idx += n
13
        14
        sum_S = sum(a)
15
        # Compute a[i] + i (0-based)
16
        values = [a[i] + i for i in range(n)]
17
        # Sort in descending order
18
        values.sort(reverse=True)
19
        sum_aj_plus_j = sum(values[:k])
20
        # Compute the result
21
        res = sum_S - sum_aj_plus_j - (k * (k + 1)) // 2 + k * n
22
        print(res)
23
24
if __name__ == ""__main__"":
25
    main()",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053231
1390053232,unknown,unknown,unknown,"1
def ans(x):
2
3
    n = len(x)
4
5
    total_idle = x.count('0')
6
7
    min_cost = float('inf')
8
9
    left = 0
10
11
    right = n - 1
12
13
    current_idle = 0
14
15
    current_active = 0
16
17
    18
19
    while left <= right:
20
21
        idle_remaining = total_idle - current_idle
22
23
        active_decommissioned = current_active
24
25
        cost = max(idle_remaining, active_decommissioned)
26
27
        28
29
        if cost < min_cost:
30
31
            min_cost = cost
32
33
        34
35
        if x[left] == '0':
36
37
            current_idle += 1
38
39
            left += 1
40
41
        elif x[right] == '0':
42
43
            current_idle += 1
44
45
            right -= 1
46
47
        else:
48
49
            current_active += 1
50
51
            left += 1
52
53
    54
55
    return min_cost
56
57
T = int(input())
58
59
for _ in range(T):
60
61
    x = input().strip()
62
63
    print(ans(x))",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053232
1390053233,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053233
1390053228,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # Stores indices of negative numbers in current window
7
8
    # Process first k elements
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
13
    # Process the remaining elements
14
    for i in range(n - k + 1):
15
        # If deque is not empty, add the first negative number; else, add 0
16
        result.append(arr[dq[0]] if dq else 0)
17
18
        # Remove elements that are out of this window
19
        if dq and dq[0] == i:
20
            dq.popleft()
21
22
        # Add next element to the window
23
        if i + k < n and arr[i + k] < 0:
24
            dq.append(i + k)
25
26
    return result
27
28
# Read input
29
t = int(input())
30
for _ in range(t):
31
    n, k = map(int, input().split())
32
    arr = list(map(int, input().split()))
33
    print(*earliest_faulty_reading(arr, k))
34",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053228
1390053229,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
5
    int n = arr.size();
6
    vector<int> result;
7
    deque<int> dq;  
8
9
    for (int i = 0; i < k; i++) {
10
        if (arr[i] < 0) dq.push_back(i);
11
    }
12
13
    for (int i = k; i <= n; i++) {
14
    15
        if (!dq.empty()) 
16
            result.push_back(arr[dq.front()]);  
17
        else 
18
            result.push_back(0);  
19
20
        while (!dq.empty() && dq.front() < i - k + 1) {
21
            dq.pop_front();
22
        }
23
24
        if (i < n && arr[i] < 0) {
25
            dq.push_back(i);
26
        }
27
    }
28
29
    return result;
30
}
31
32
int main() {
33
    int t;
34
    cin >> t;  
35
    while (t--) {
36
        int n, k;
37
        cin >> n >> k;  
38
        vector<int> arr(n);
39
        for (int i = 0; i < n; i++) {
40
            cin >> arr[i];
41
        }
42
        43
        vector<int> result = earliest_faulty_readings(arr, k);
44
        for (int num : result) {
45
            cout << num << "" "";
46
        }
47
        cout << endl;
48
    }
49
    return 0;
50
}",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053229
1390053230,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
4
    # Count total active servers and total idle servers
5
    total_active = server_string.count('1')
6
    total_idle = n - total_active
7
8
    # Precompute cumulative counts of active servers from left
9
    active_prefix_sum = [0] * (n + 1)
10
    for i in range(n):
11
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
12
13
    min_cost = float('inf')
14
15
    # Try all possible starting positions for the remaining servers
16
    for left in range(n + 1):
17
        # For each possible ending position
18
        for right in range(left, n + 1):
19
            # Active servers in the remaining segment
20
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
21
            idle_remaining = (right - left) - active_remaining
22
23
            # Active servers removed
24
            active_removed = total_active - active_remaining
25
26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
29
    return min_cost
30
31
def faster_min_decommission_cost(server_string):
32
    n = len(server_string)
33
34
    # Precompute prefix sums for active and idle servers
35
    active_prefix = [0] * (n + 1)
36
    idle_prefix = [0] * (n + 1)
37
38
    for i in range(n):
39
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
40
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
41
42
    min_cost = n  # Worst case cost
43
44
    # For each possible remaining substring (from i to j-1)
45
    for i in range(n + 1):
46
        for j in range(i, n + 1):
47
            # Idle servers in remaining substring
48
            idle_remaining = idle_prefix[j] - idle_prefix[i]
49
50
            # Active servers removed (from left and right)
51
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
52
53
            cost = max(idle_remaining, active_removed)
54
            min_cost = min(min_cost, cost)
55
56
    return min_cost
57
58
def main():
59
    t = int(input().strip())
60
61
    for _ in range(t):
62
        server_string = input().strip()
63
        result = faster_min_decommission_cost(server_string)
64
        print(result) # Corrected to print the result
65
66
if __name__ == ""__main__"": # Corrected if condition.
67
    main()",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053230
1390053227,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",146,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053227
1390053219,unknown,unknown,unknown,"1
def main():
2
    t = int(input())
3
    4
    for _ in range(t):
5
        n, k = map(int, input().split())
6
        strengths = list(map(int, input().split()))
7
        8
        if k >= n:
9
            print(0)
10
            continue
11
12
        dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
13
        dp[0][0] = 0
14
        15
        for i in range(1, n + 1):
16
            for j in range(k + 1):
17
                if j > 0:
18
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])
19
                20
                if dp[i-1][j] != float('inf'):
21
                    dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
22
        23
        print(min(dp[n]))
24
25
if __name__ == ""__main__"":
26
    main()",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053219
1390053223,unknown,unknown,unknown,"1
from collections import deque
2
def earliest_faulty_reading(arr, n, k):
3
    result = []
4
    dq = deque()
5
    6
    for i in range(n):
7
        if dq and dq[0] < i - k + 1:
8
            dq.popleft()
9
            10
        if arr[i] < 0:
11
            dq.append(i)
12
            13
        if i >= k - 1:
14
            result.append(arr[dq[0]] if dq else 0)
15
            16
    return result
17
18
t = int(input())
19
for _ in range(t):
20
    n, k = map(int, input().split())
21
    arr = list(map(int, input().split()))
22
    print("" "".join(map(str, earliest_faulty_reading(arr, n, k))))",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053223
1390053221,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # We need to handle the case where k >= n (can skip all firewalls)
3
    if k >= n:
4
        return 0
5
    6
    # Initialize DP array
7
    # dp[i][j] = min effort to breach first i firewalls using at most j skips
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: no firewalls, no effort
11
    for j in range(k + 1):
12
        dp[0][j] = 0
13
    14
    for i in range(1, n + 1):
15
        for j in range(k + 1):
16
            # Option 1: Don't skip current firewall
17
            # Current strength is increased by the number of skips used so far
18
            # But j could be larger than what's possible with i-1 firewalls
19
            # So we need to cap the number of skips considered
20
            if j <= i - 1:
21
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
22
            elif j == 0:  # Special case when no skips are used
23
                dp[i][j] = dp[i-1][j] + strengths[i-1]
24
            25
            # Option 2: Skip current firewall (if we have skips left)
26
            if j > 0:
27
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
28
    29
    return dp[n][k]
30
31
def solve():
32
    t = int(input())
33
    34
    for _ in range(t):
35
        n, k = map(int, input().split())
36
        strengths = list(map(int, input().split()))
37
        38
        # Special case: if we can skip all firewalls
39
        if k >= n:
40
            print(0)
41
        else:
42
            print(min_effort_to_breach(n, k, strengths))
43
44
# Run the solution
45
solve()",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053221
1390053215,unknown,unknown,unknown,"1
t = int(input())
2
3
4
for _ in range(t):
5
   6
    n, k = map(int, input().split())
7
    a = list(map(int, input().split()))
8
    9
    10
    #sort
11
    12
    value_idx = [(a[i], i) for i in range(n)]
13
14
    value_idx.sort(reverse=True)
15
    16
    17
    18
    #possible skips
19
    20
 21
    k = min(k, n)  
22
    candidates = value_idx[:k]  
23
    24
  25
    min_cost = float('inf')
26
    27
    for skips in range(k + 1):
28
       29
        skip_positions = set(c[1] for c in candidates[:skips])
30
        31
        32
        num_skips_so_far = 0
33
        current_cost = 0
34
        35
      36
        for i in range(n):
37
            38
            if i in skip_positions:
39
               40
                current_cost += 0
41
                num_skips_so_far += 1
42
                43
            else:
44
              45
                current_cost += a[i] + num_skips_so_far
46
        47
       48
        min_cost = min(min_cost, current_cost)
49
    50
  51
    print(min_cost)",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053215
1390053217,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <algorithm>
4
using namespace std;
5
6
int main() {
7
    int T;
8
    cin >> T;
9
10
    while (T--) {
11
        string servers;
12
        cin >> servers;
13
14
        int n = servers.size();
15
        int min_cost = n;
16
17
        int total_1 = count(servers.begin(), servers.end(), '1');
18
        int total_0 = n - total_1;
19
20
        int count_1_removed = 0;
21
        int count_0_remaining = total_0;
22
23
        for (int i = 0; i <= n; ++i) {
24
            if (i > 0) {
25
                if (servers[i - 1] == '1') {
26
                    count_1_removed++;
27
                } else {
28
                    count_0_remaining--;
29
                }
30
            }
31
32
            for (int j = 0; j <= n - i; ++j) {
33
                int count_0_remaining_after_back = count_0_remaining;
34
                int count_1_removed_after_back = count_1_removed;
35
36
                if (j > 0) {
37
                    if (servers[n - j] == '1') {
38
                        count_1_removed_after_back++;
39
                    } else {
40
                        count_0_remaining_after_back--;
41
                    }
42
                }
43
44
                min_cost = min(min_cost, max(count_1_removed_after_back, count_0_remaining_after_back));
45
            }
46
        }
47
48
        cout << min_cost << endl;
49
    }
50
51
    return 0;
52
}
53",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053217
1390053214,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int t = sc.nextInt();
8
        while (t-- > 0) {
9
            int n = sc.nextInt(), k = sc.nextInt();
10
            int[] s = new int[n];
11
            for (int i = 0; i < n; i++) s[i] = sc.nextInt();
12
            System.out.println(minEffort(s, n, k));
13
        }
14
        sc.close();
15
    }
16
17
    private static long minEffort(int[] s, int n, int k) {
18
        if (k >= n) return 0;
19
20
        int[] save = new int[n];
21
        for (int i = 0; i < n; i++) save[i] = s[i] - (n - i - 1);
22
23
        Integer[] idx = new Integer[n];
24
        for (int i = 0; i < n; i++) idx[i] = i;
25
        Arrays.sort(idx, (a, b) -> Integer.compare(save[b], save[a]));
26
27
        boolean[] skip = new boolean[n];
28
        int skipped = 0;
29
        for (int i = 0; i < n && skipped < k; i++) {
30
            if (save[idx[i]] > 0) skip[idx[i]] = true;
31
            else break;
32
            skipped++;
33
        }
34
35
        long effort = 0, skips = 0;
36
        for (int i = 0; i < n; i++) {
37
            if (skip[i]) skips++;
38
            else effort += s[i] + skips;
39
        }
40
41
        return effort;
42
    }
43
}
44",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053214
1390053212,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
11
        Scanner sc = new Scanner(System.in);
12
        int t = sc.nextInt();
13
        while(t >0){
14
            int n = sc.nextInt();
15
            int k = sc.nextInt();
16
            int arr[] = new int[n];
17
            for(int i = 0; i<n; i++){
18
                arr[i] = sc.nextInt();
19
            }
20
            for(int i = 0; i <= n-k; i++){
21
                int faulty = 0;
22
                for(int j = i; j < i+k; j++){
23
                    if(arr[j] < 0){
24
                        faulty = arr[j];
25
                        break;
26
                    }
27
                }
28
                System.out.print(faulty + "" "");
29
                30
            }
31
            System.out.println();
32
            t--;
33
        }
34
        sc.close();
35
    }
36
}",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053212
1390053211,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        Scanner scanner = new Scanner(System.in);
11
        int t = scanner.nextInt(); // Number of test cases
12
        13
        for (int testCase = 0; testCase < t; testCase++) {
14
            int n = scanner.nextInt(); // Number of firewalls
15
            int k = scanner.nextInt(); // Max firewalls we can skip
16
            17
            long[] firewalls = new long[n];
18
            for (int i = 0; i < n; i++) {
19
                firewalls[i] = scanner.nextLong(); // Firewall strengths
20
            }
21
            22
            System.out.println(findMinimumEffort(firewalls, n, k));
23
        }
24
        25
        scanner.close();
26
    }
27
    28
    private static long findMinimumEffort(long[] firewalls, int n, int k) {
29
        // If we can skip all firewalls, the minimum effort is 0
30
        if (k >= n) {
31
            return 0;
32
        }
33
        34
        // Calculate the total sum of all firewalls
35
        long totalSum = 0;
36
        for (int i = 0; i < n; i++) {
37
            totalSum += firewalls[i];
38
        }
39
        40
        // Try all possible combinations of skipping firewalls
41
        long minEffort = totalSum;
42
        43
        // Try not skipping any firewalls
44
        minEffort = Math.min(minEffort, totalSum);
45
        46
        // Try skipping each firewall individually
47
        for (int i = 0; i < n; i++) {
48
            // Calculate the effort if we skip this firewall
49
            long effort = totalSum - firewalls[i];
50
            51
            // Add the penalty for each firewall after the skipped one
52
            for (int j = i + 1; j < n; j++) {
53
                effort += 1; // Penalty for each subsequent firewall
54
            }
55
            56
            minEffort = Math.min(minEffort, effort);
57
        }
58
        59
        return minEffort;
60
    }
61
}",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053211
1390053213,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
public static List<Integer> earliestFault(int[] arr, int k) {
9
        List<Integer> results = new ArrayList<>();
10
11
        // Loop through each possible batch
12
        for (int i = 0; i <= arr.length - k; i++) {
13
            boolean faultFound = false;
14
15
            // Find earliest fault in current batch
16
            for (int j = i; j < i + k; j++) {
17
                if (arr[j] < 0) {
18
                    results.add(arr[j]);
19
                    faultFound = true;
20
                    break;
21
                }
22
            }
23
24
            // If no fault found in batch, append 0
25
            if (!faultFound) {
26
                results.add(0);
27
            }
28
        }
29
30
        return results;
31
    }
32
33
    public static void main(String[] args) {
34
        Scanner sc = new Scanner(System.in);
35
        36
        int t = sc.nextInt(); // Number of test cases
37
        38
        while (t-- > 0) {
39
            int n = sc.nextInt(); // Size of array
40
            int k = sc.nextInt(); // Batch size
41
            int[] arr = new int[n];
42
43
            for (int i = 0; i < n; i++) {
44
                arr[i] = sc.nextInt();
45
            }
46
47
            List<Integer> result = earliestFault(arr, k);
48
            49
            // Print results in the required format
50
            for (int num : result) {
51
                System.out.print(num + "" "");
52
            }
53
            System.out.println();
54
        }
55
56
        sc.close();
57
    }
58
}",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053213
1390053210,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        min_cost_val = float('inf')
6
        7
        # Iterate over possible decommissioning points
8
        for left in range(n + 1):
9
            for right in range(n + 1):
10
                if left + right > n:
11
                    continue
12
                remaining = s[left:n - right]
13
                idle_remaining = remaining.count('0')
14
                active_removed = s[:left].count('1') + s[n - right:].count('1')
15
                current_cost = max(idle_remaining, active_removed)
16
                if current_cost < min_cost_val:
17
                    min_cost_val = current_cost
18
        19
        results.append(min_cost_val)
20
    return results
21
22
# Read input
23
T = int(input())
24
test_cases = [input().strip() for _ in range(T)]
25
26
# Compute results
27
results = min_cost(test_cases)
28
29
# Output results
30
for res in results:
31
    print(res)",147,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053210
1390053203,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    for n, k, arr in test_cases:
6
        dq = deque()
7
        res = []
8
        9
        10
        for i in range(k):
11
            if arr[i] < 0:
12
                dq.append(i)
13
        14
        15
        res.append(arr[dq[0]] if dq else 0)
16
        17
        18
        for i in range(k, n):
19
            20
            if dq and dq[0] <= i - k:
21
                dq.popleft()
22
            23
           24
            if arr[i] < 0:
25
                dq.append(i)
26
            27
            28
            res.append(arr[dq[0]] if dq else 0)
29
        30
        results.append("" "".join(map(str, res)))
31
    32
    return ""\n"".join(results)
33
34
35
t = int(input())
36
test_cases = []
37
for _ in range(t):
38
    n, k = map(int, input().split())
39
    arr = list(map(int, input().split()))
40
    test_cases.append((n, k, arr))
41
42
43
print(earliest_faulty_readings(test_cases))
44",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053203
1390053204,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    for _ in range(test_cases):
4
        n, k = map(int, input().split())
5
        arr = list(map(int, input().split()))
6
        result = []
7
        for i in range(n - k + 1):
8
            batch = arr[i:i+k]
9
            faulty = 0
10
            for num in batch:
11
                if num < 0:
12
                    faulty = num
13
                    break
14
            result.append(faulty)
15
        results.append(result)
16
    return results
17
18
# Read the number of test cases
19
test_cases = int(input())
20
results = earliest_faulty_readings(test_cases)
21
22
# Print the results
23
for result in results:
24
    print(' '.join(map(str, result)) + ' ')",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053204
1390053208,unknown,unknown,unknown,"1
def find_faults(readings, batch_size):
2
    results = []
3
    for i in range(len(readings) - batch_size + 1):
4
        batch = readings[i:i + batch_size]
5
        fault = 0
6
        for r in batch:
7
            if r < 0:
8
                fault = r
9
                break
10
        results.append(fault)
11
    return results
12
13
def process_tests():
14
    tests = int(input())
15
    for _ in range(tests):
16
        n, k = map(int, input().split())
17
        sensor_data = list(map(int, input().split()))
18
        fault_results = find_faults(sensor_data, k)
19
        print(*fault_results)
20
21
process_tests()",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053208
1390053200,unknown,unknown,unknown,"1
def minimum_effort(n, k, arr):
2
    3
    if k == n:
4
        return 0
5
    6
    7
    total_effort = sum(arr)
8
    min_effort = total_effort  # Start with worst case
9
    10
    11
    for i in range(n - k + 1):
12
        current_effort = 0
13
        14
        current_effort += sum(arr[:i])
15
        16
        17
        for j in range(i + k, n):
18
            current_effort += arr[j] + 1
19
        20
        21
        min_effort = min(min_effort, current_effort)
22
    23
    return min_effort
24
25
26
T = int(input())
27
results = []
28
for _ in range(T):
29
    n, k = map(int, input().split())
30
    arr = list(map(int, input().split()))
31
    results.append(str(minimum_effort(n, k, arr)))
32
33
34
print('\n'.join(results))
35",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053200
1390053201,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # Base case: If we skip all firewalls, total effort = 0
3
    if k == n:
4
        return 0
5
6
    # If no skips are allowed, total effort is just the sum of all firewalls
7
    if k == 0:
8
        return sum(firewalls)
9
10
    min_effort = float('inf')
11
12
    # Try skipping up to 'k' firewalls
13
    for i in range(n):
14
        # Skip 'k' firewalls starting from index 'i'
15
        skipped = 0
16
        effort = 0
17
18
        # Count skips and apply penalties
19
        for j in range(n):
20
            if skipped < k and j >= i:
21
                skipped += 1
22
            else:
23
                effort += firewalls[j] + skipped
24
25
        # Track the minimum effort
26
        min_effort = min(min_effort, effort)
27
28
    return min_effort
29
30
31
# Reading input
32
T = int(input().strip())
33
results = []
34
35
for _ in range(T):
36
    n, k = map(int, input().split())
37
    firewalls = list(map(int, input().split()))
38
    results.append(min_effort(n, k, firewalls))
39
40
# Output the results for each test case
41
for res in results:
42
    print(res)
43",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053201
1390053202,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque() 
7
    8
   9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
  14
    result.append(arr[dq[0]] if dq else 0)
15
    16
   17
    for i in range(k, n):
18
        19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
  23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
       27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
32
t = int(input()) 
33
for _ in range(t):
34
    n, k = map(int, input().split())  
35
    arr = list(map(int, input().split()))  
36
    37
    print(*earliest_faulty_readings(arr, k))",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053202
1390053194,unknown,unknown,unknown,"1
import sys
2
3
def f(n, k, a):
4
    if k >= n:
5
        return 0
6
7
    b = sum(a)
8
    c = b
9
10
    for i in range(n):
11
        d = 0
12
        e = 0
13
14
        for j in range(n):
15
            if d < k and j == i:
16
                d += 1
17
                continue
18
            e += a[j] + d
19
20
        c = min(c, e)
21
22
    return c
23
24
t = int(sys.stdin.readline().strip())
25
26
for _ in range(t):
27
    n, k = map(int, sys.stdin.readline().split())
28
    a = list(map(int, sys.stdin.readline().split()))
29
    print(f(n, k, a))
30",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053194
1390053196,unknown,unknown,unknown,"1
import java.util.Arrays;
2
import java.util.Scanner;
3
4
public class FirewallBreachOptimized {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int t = scanner.nextInt();
9
10
        while (t-- > 0) {
11
            int n = scanner.nextInt();
12
            int k = scanner.nextInt();
13
            long[] a = new long[n];
14
            for (int i = 0; i < n; i++) {
15
                a[i] = scanner.nextLong();
16
            }
17
18
            long minEffort = solveOptimized(a, k);
19
            System.out.println(minEffort);
20
        }
21
        scanner.close();
22
    }
23
24
    private static long solveOptimized(long[] a, int k) {
25
        long minEffort = Long.MAX_VALUE;
26
        long[][] dp = new long[a.length + 1][k + 1];
27
28
        for (int i = 0; i <= a.length; i++) {
29
            Arrays.fill(dp[i], Long.MAX_VALUE);
30
        }
31
32
        dp[0][0] = 0;
33
34
        for (int i = 1; i <= a.length; i++) {
35
            for (int j = 0; j <= k; j++) {
36
                // Option 1: Don't skip the current firewall
37
                if (dp[i - 1][j] != Long.MAX_VALUE) {
38
                    long currentEffort = dp[i - 1][j];
39
                    long increasedStrength = a[i - 1];
40
                    for(int l = 0; l < j; l++){
41
                        increasedStrength++;
42
                    }
43
                    dp[i][j] = Math.min(dp[i][j], currentEffort + increasedStrength);
44
                }
45
46
                // Option 2: Skip the current firewall
47
                if (j > 0 && dp[i - 1][j - 1] != Long.MAX_VALUE) {
48
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
49
                }
50
            }
51
        }
52
53
        for (int j = 0; j <= k; j++) {
54
            minEffort = Math.min(minEffort, dp[a.length][j]);
55
        }
56
57
        return minEffort;
58
    }
59
}",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053196
1390053199,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips available
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j > 0:
19
                skip_option = dp[i + 1][j - 1]
20
                dp[i][j] = min(dp[i][j], skip_option)
21
            22
            # Option 2: Don't skip this firewall
23
            # The effort is the firewall value plus the number of skips used so far (k-j)
24
            effort_factor = k - j
25
            no_skip_option = firewalls[i] + effort_factor + dp[i + 1][j]
26
            dp[i][j] = min(dp[i][j], no_skip_option)
27
    28
    return dp[0][k]
29
30
# Handle automatic input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    firewalls = list(map(int, input().split()))
35
    result = min_effort(firewalls, k)
36
    print(result)",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053199
1390053193,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultyComponentDetector {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt(); // Number of test cases
7
8
        while (t-- > 0) {
9
            int n = sc.nextInt(); // Size of the array
10
            int k = sc.nextInt(); // Batch size
11
            int[] arr = new int[n];
12
13
            for (int i = 0; i < n; i++) {
14
                arr[i] = sc.nextInt();
15
            }
16
17
            List<Integer> result = findEarliestFaults(arr, k);
18
            for (int num : result) {
19
                System.out.print(num + "" "");
20
            }
21
            System.out.println();
22
        }
23
24
        sc.close();
25
    }
26
27
    private static List<Integer> findEarliestFaults(int[] arr, int k) {
28
        List<Integer> result = new ArrayList<>();
29
        Deque<Integer> deque = new LinkedList<>();
30
31
        for (int i = 0; i < arr.length; i++) {
32
            // Remove elements that are out of the current window
33
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
34
                deque.poll();
35
            }
36
37
            // Add new negative number index to the deque
38
            if (arr[i] < 0) {
39
                deque.offer(i);
40
            }
41
42
            // Start collecting results when we have a complete window
43
            if (i >= k - 1) {
44
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
45
            }
46
        }
47
48
        return result;
49
    }
50
}
51",148,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053193
1390053188,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
10
        List<Integer> result = new ArrayList<>();
11
        Deque<Integer> dq = new LinkedList<>();
12
        13
        for (int i = 0; i < k; i++) {
14
            if (arr[i] < 0) {
15
                dq.addLast(i);
16
            }
17
        }
18
        19
        if (!dq.isEmpty()) {
20
            result.add(arr[dq.peekFirst()]);
21
        } else {
22
            result.add(0);
23
        }
24
        25
        for (int i = k; i < arr.length; i++) {
26
            if (!dq.isEmpty() && dq.peekFirst() <= i - k) {
27
                dq.pollFirst();
28
            }
29
            30
            if (arr[i] < 0) {
31
                dq.addLast(i);
32
            }
33
            34
            if (!dq.isEmpty()) {
35
                result.add(arr[dq.peekFirst()]);
36
            } else {
37
                result.add(0);
38
            }
39
        }
40
        41
        return result;
42
    }
43
44
    public static void main(String[] args) {
45
        Scanner sc = new Scanner(System.in);
46
        int t = sc.nextInt();  
47
        48
        while (t-- > 0) {
49
            int n = sc.nextInt(); 
50
            int k = sc.nextInt(); 
51
            int[] arr = new int[n];
52
            53
            for (int i = 0; i < n; i++) {
54
                arr[i] = sc.nextInt();
55
            }
56
            57
            List<Integer> result = findEarliestFaults(arr, k);
58
            for (int num : result) {
59
                System.out.print(num + "" "");
60
            }
61
            System.out.println();
62
        }
63
        sc.close();
64
    }
65
}",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053188
1390053191,unknown,unknown,unknown,"1
def min_cost_decommission(server_rack):
2
3
    n = len(server_rack)
4
5
    min_cost = float('inf')
6
7
    8
9
    # Iterate over all possible ways to decommission servers from the beginning and the end
10
11
    for i in range(n + 1):
12
13
        for j in range(n + 1):
14
15
            if i + j > n:
16
17
                continue
18
19
            remaining_rack = server_rack[i:n - j]
20
21
            idle_remaining = remaining_rack.count('0')
22
23
            active_decommissioned = server_rack[:i].count('1') + server_rack[n - j:].count('1')
24
25
            cost = max(idle_remaining, active_decommissioned)
26
27
            if cost < min_cost:
28
29
                min_cost = cost
30
31
    32
33
    return min_cost
34
35
def main():
36
37
    # Predefined input for test cases
38
39
    test_cases = [
40
41
        ""101110110"",
42
43
        ""1001001001001"",
44
45
        ""0000111111""
46
47
    ]
48
49
    50
51
    # Process each test case
52
53
    for server_rack in test_cases:
54
55
        print(min_cost_decommission(server_rack))
56
57
if __name__ == ""__main__"":
58
59
    main()
60
    ",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053191
1390053192,unknown,unknown,unknown,"1
def min_effort(arr, k):
2
    n = len(arr)
3
    # Option: Do not skip any firewall
4
    min_cost = sum(arr)
5
    6
    # Try skipping every contiguous block of k firewalls
7
    for i in range(n - k + 1):
8
        cost_before = sum(arr[:i])
9
        cost_after = sum(arr[i+k:]) + (n - (i+k))  # extra 1 for each firewall after skipped block
10
        cost = cost_before + cost_after
11
        min_cost = min(min_cost, cost)
12
    13
    return min_cost
14
15
# Input handling
16
t = int(input())
17
for _ in range(t):
18
    n, k = map(int, input().split())
19
    arr = list(map(int, input().split()))
20
    print(min_effort(arr, k))
21",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053192
1390053179,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void earliest_faulty_readings(int arr[], int n, int k) {
5
    int i;
6
    int front = 0, rear = 0;  // Deque implemented using an array
7
    int deque[n]; // Stores indices of negative numbers
8
9
    // Process the first window
10
    for (i = 0; i < k; i++) {
11
        if (arr[i] < 0)
12
            deque[rear++] = i;
13
    }
14
15
    // Process rest of the windows
16
    for (i = k; i <= n; i++) {
17
        // Print the first negative number in the current window
18
        if (front < rear)
19
            printf(""%d "", arr[deque[front]]);
20
        else
21
            printf(""0 "");
22
23
        // Remove elements not in this window
24
        while (front < rear && deque[front] < i - k + 1)
25
            front++;
26
27
        // Add the new element if negative
28
        if (i < n && arr[i] < 0)
29
            deque[rear++] = i;
30
    }
31
32
    printf(""\n"");
33
}
34
35
int main() {
36
    int t;
37
    scanf(""%d"", &t);
38
39
    while (t--) {
40
        int n, k;
41
        scanf(""%d %d"", &n, &k);
42
        int arr[n];
43
44
        for (int i = 0; i < n; i++)
45
            scanf(""%d"", &arr[i]);
46
47
        earliest_faulty_readings(arr, n, k);
48
    }
49
50
    return 0;
51
}
52",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053179
1390053182,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(len(arr)):
8
        # Remove elements out of the current window
9
        if dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
        12
        # Add current element if it is faulty
13
        if arr[i] < 0:
14
            dq.append(i)
15
        16
        # Add result when we have a full window
17
        if i >= k - 1:
18
            result.append(arr[dq[0]] if dq else 0)
19
    20
    return result
21
22
# Read input
23
t = int(input())
24
for _ in range(t):
25
    n, k = map(int, input().split())
26
    arr = list(map(int, input().split()))
27
    print(*earliest_faulty_readings(arr, k))
28",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053182
1390053185,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}
41",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053185
1390053175,unknown,unknown,unknown,"1
def min_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        n = len(s)
5
        min_cost_val = float('inf')
6
        7
        # Iterate over possible decommissioning points
8
        for left in range(n + 1):
9
            for right in range(n + 1):
10
                if left + right > n:
11
                    continue
12
                remaining = s[left:n - right]
13
                idle_remaining = remaining.count('0')
14
                active_removed = s[:left].count('1') + s[n - right:].count('1')
15
                current_cost = max(idle_remaining, active_removed)
16
                if current_cost < min_cost_val:
17
                    min_cost_val = current_cost
18
        19
        results.append(min_cost_val)
20
    return results
21
22
# Read input
23
T = int(input())
24
test_cases = [input().strip() for _ in range(T)]
25
26
# Compute results
27
results = min_cost(test_cases)
28
29
# Output results
30
for res in results:
31
    print(res)",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053175
1390053178,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053178
1390053174,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053174
1390053172,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(len(arr)):
8
        9
        while dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
        12
        if arr[i] < 0:
13
            dq.append(i)
14
        15
        if i >= k - 1:
16
            result.append(arr[dq[0]] if dq else 0)
17
    18
    return result
19
20
def main():
21
    t = int(input())
22
    for _ in range(t):
23
        n, k = map(int, input().split())
24
        arr = list(map(int, input().split()))
25
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))
26
27
if __name__ == ""__main__"":
28
    main()",149,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053172
1390053169,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)  # Compute total effort without skipping
3
    if k == n:
4
        return 0  # If we can skip all, effort is 0
5
    6
    min_effort = float('inf')
7
    8
    for i in range(n):
9
        effort = total_effort - firewalls[i]  # Skip the i-th firewall
10
        penalty = 0
11
        12
        for j in range(i + 1, n):
13
            penalty += 1  # Each subsequent firewall increases by 1
14
            effort += penalty
15
        16
        if i < k:
17
            min_effort = min(min_effort, effort)
18
    19
    return min_effort
20
21
22
T = int(input())
23
for _ in range(T):
24
    n, k = map(int, input().split())
25
    firewalls = list(map(int, input().split()))
26
    print(min_effort(n, k, firewalls))
27",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053169
1390053170,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    ans = float('inf')
5
6
    for i in range(n + 1):
7
        for j in range(n - i + 1):
8
            remaining = s[i:n-j]
9
            10
            zeros = remaining.count('0')
11
            ones_removed = s[:i].count('1') + s[n-j:].count('1')
12
            13
            ans = min(ans, max(zeros, ones_removed))
14
            15
    print(ans)
16
17
t = int(input())
18
for _ in range(t):
19
    solve()",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053170
1390053171,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Initialize an array to track the minimum effort for using exactly j skips
3
    # We'll use a 2D DP array where dp[i][j] = min effort to breach first i firewalls using exactly j skips
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        # If we use 0 skips up to firewall i
12
        dp[i][0] = dp[i-1][0] + strengths[i-1]
13
        14
        for j in range(1, min(i, k) + 1):
15
            # Option 1: Skip the current firewall
16
            dp[i][j] = dp[i-1][j-1]
17
            18
            # Option 2: Don't skip the current firewall
19
            # If we've skipped j firewalls so far, strength increases by j
20
            dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
21
    22
    # Return the minimum across all possible numbers of skips for all n firewalls
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    28
    for _ in range(t):
29
        n, k = map(int, input().split())
30
        strengths = list(map(int, input().split()))
31
        print(min_effort_to_breach(n, k, strengths))
32
33
# Run the solution
34
solve()",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053171
1390053163,unknown,unknown,unknown,"1
def min_cost(server_str):
2
    n = len(server_str)
3
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
4
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
5
6
    for i in range(n):
7
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
8
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
9
10
    total_1 = prefix_1[n]
11
    total_0 = prefix_0[n]
12
13
    min_cost = float('inf')
14
15
    # Try removing l elements from the front
16
    for l in range(n + 1):
17
        # Try removing r elements from the back
18
        for r in range(n - l + 1):
19
            left = l
20
            right = n - r
21
            remaining_0 = prefix_0[right] - prefix_0[left]
22
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
23
            cost = max(remaining_0, removed_1)
24
            min_cost = min(min_cost, cost)
25
26
    return min_cost
27
28
# Main driver
29
T = int(input())
30
for _ in range(T):
31
    server_str = input().strip()
32
    print(min_cost(server_str))
33",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053163
1390053164,unknown,unknown,unknown,"1
def min_decommissioning_cost(server_string):
2
    n = len(server_string)
3
    4
    # Track total number of active servers in the original string
5
    total_active = server_string.count('1')
6
    7
    min_cost = float('inf')
8
    9
    # Try all possible prefixes and suffixes to remove
10
    for prefix_len in range(n + 1):
11
        for suffix_len in range(n + 1 - prefix_len):
12
            # The remaining substring after removing prefix and suffix
13
            remaining = server_string[prefix_len:n-suffix_len]
14
            15
            if not remaining:  # If we removed everything
16
                continue
17
                18
            # Count remaining idle servers and removed active servers
19
            remaining_idle = remaining.count('0')
20
            21
            # Active servers in prefix and suffix
22
            removed_active = 0
23
            if prefix_len > 0:
24
                removed_active += server_string[:prefix_len].count('1')
25
            if suffix_len > 0:
26
                removed_active += server_string[n-suffix_len:].count('1')
27
            28
            # Calculate cost
29
            cost = max(remaining_idle, removed_active)
30
            min_cost = min(min_cost, cost)
31
    32
    return min_cost
33
34
# Process test cases
35
t = int(input())
36
for _ in range(t):
37
    server_string = input().strip()
38
    print(min_decommissioning_cost(server_string))",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053164
1390053166,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053166
1390053160,unknown,unknown,unknown,"1
#include <iostream>
2
#include <deque>
3
#include <vector>
4
using namespace std;
5
6
void earliestFaultyReadings(int n, int k, vector<int>& arr) {
7
    deque<int> dq;
8
    vector<int> result;
9
    10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) {
12
            dq.push_back(i);
13
        }
14
    }
15
    result.push_back(dq.empty() ? 0 : arr[dq.front()]);
16
17
    for (int i = k; i < n; i++) {
18
        if (!dq.empty() && dq.front() <= i - k) {
19
            dq.pop_front();
20
        }
21
        if (arr[i] < 0) {
22
            dq.push_back(i);
23
        }
24
        result.push_back(dq.empty() ? 0 : arr[dq.front()]);
25
    }
26
    27
    for (int num : result) {
28
        cout << num << "" "";
29
    }
30
    cout << endl;
31
}
32
33
int main() {
34
    int t;
35
    cin >> t;
36
37
    while (t--) {
38
        int n, k;
39
        cin >> n >> k;
40
        vector<int> arr(n);
41
        for (int i = 0; i < n; i++) {
42
            cin >> arr[i];
43
        }
44
        earliestFaultyReadings(n, k, arr);
45
    }
46
47
    return 0;
48
}
49",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053160
1390053161,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
    public static List<Integer> earliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>();
7
8
        for (int i = 0; i < arr.length; i++) {
9
            10
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
11
                deque.poll();
12
            }
13
14
            15
            if (arr[i] < 0) {
16
                deque.offer(i);
17
            }
18
19
            if (i >= k - 1) {
20
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
21
            }
22
        }
23
        return result;
24
    }
25
26
    public static void main(String[] args) {
27
        Scanner scanner = new Scanner(System.in);
28
        int t = scanner.nextInt();
29
30
        while (t-- > 0) {
31
            int n = scanner.nextInt(); 
32
            int k = scanner.nextInt(); 
33
            int[] arr = new int[n];
34
35
            for (int i = 0; i < n; i++) {
36
                arr[i] = scanner.nextInt();
37
            }
38
39
            40
            List<Integer> faults = earliestFaults(arr, k);
41
            for (int val : faults) {
42
                System.out.print(val + "" "");
43
            }
44
            System.out.println();
45
        }
46
        scanner.close();
47
    }
48
}
49",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053161
1390053162,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total active servers and total idle servers
5
    total_active = server_string.count('1')
6
    total_idle = n - total_active
7
    8
    # Precompute cumulative counts of active servers from left
9
    active_prefix_sum = [0] * (n + 1)
10
    for i in range(n):
11
        active_prefix_sum[i + 1] = active_prefix_sum[i] + (1 if server_string[i] == '1' else 0)
12
    13
    min_cost = float('inf')
14
    15
    # Try all possible starting positions for the remaining servers
16
    for left in range(n + 1):
17
        # For each possible ending position
18
        for right in range(left, n + 1):
19
            # Active servers in the remaining segment
20
            active_remaining = active_prefix_sum[right] - active_prefix_sum[left]
21
            idle_remaining = (right - left) - active_remaining
22
            23
            # Active servers removed
24
            active_removed = total_active - active_remaining
25
            26
            cost = max(idle_remaining, active_removed)
27
            min_cost = min(min_cost, cost)
28
    29
    return min_cost
30
31
def faster_min_decommission_cost(server_string):
32
    n = len(server_string)
33
    34
    # Precompute prefix sums for active and idle servers
35
    active_prefix = [0] * (n + 1)
36
    idle_prefix = [0] * (n + 1)
37
    38
    for i in range(n):
39
        active_prefix[i + 1] = active_prefix[i] + (server_string[i] == '1')
40
        idle_prefix[i + 1] = idle_prefix[i] + (server_string[i] == '0')
41
    42
    min_cost = n  # Worst case cost
43
    44
    # For each possible remaining substring (from i to j-1)
45
    for i in range(n + 1):
46
        for j in range(i, n + 1):
47
            # Idle servers in remaining substring
48
            idle_remaining = idle_prefix[j] - idle_prefix[i]
49
            50
            # Active servers removed (from left and right)
51
            active_removed = active_prefix[n] - (active_prefix[j] - active_prefix[i])
52
            53
            cost = max(idle_remaining, active_removed)
54
            min_cost = min(min_cost, cost)
55
    56
    return min_cost
57
58
def main():
59
    t = int(input().strip())
60
    61
    for _ in range(t):
62
        server_string = input().strip()
63
        result = faster_min_decommission_cost(server_string)
64
        print(result)
65
66
if _name_ == ""_main_"":
67
    main()",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053162
1390053159,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        output = []
8
        dq = deque()
9
        10
        # Process first k elements
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
        15
        # Process remaining elements in a sliding window
16
        for i in range(n - k + 1):
17
            # Add the first faulty element in the current window
18
            if dq:
19
                output.append(arr[dq[0]])
20
            else:
21
                output.append(0)
22
            23
            # Remove elements that are out of this window
24
            if dq and dq[0] == i:
25
                dq.popleft()
26
            27
            # Add next element from the next window
28
            if i + k < n and arr[i + k] < 0:
29
                dq.append(i + k)
30
        31
        results.append("" "".join(map(str, output)))
32
    33
    return ""\n"".join(results)
34
35
# Read input
36
t = int(input().strip())
37
test_cases = []
38
for _ in range(t):
39
    n, k = map(int, input().strip().split())
40
    arr = list(map(int, input().strip().split()))
41
    test_cases.append((n, k, arr))
42
43
# Get results and print
44
print(earliest_faulty_readings(test_cases))
45",150,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053159
1390053148,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static int minDecommissionCost(String s) {
6
        int n = s.length(), minCost = n;
7
8
        for (int start = 0; start <= n; start++) {
9
            for (int end = 0; end <= n - start; end++) {
10
                int idle = 0, active = 0;
11
12
                for (int i = 0; i < n; i++) {
13
                    if (i < start || i >= n - end) {
14
                        if (s.charAt(i) == '1') active++;
15
                    } else {
16
                        if (s.charAt(i) == '0') idle++;
17
                    }
18
                }
19
                20
                minCost = Math.min(minCost, Math.max(idle, active));
21
            }
22
        }
23
        return minCost;
24
    }
25
    public static void main(String[] args) {
26
        Scanner sc = new Scanner(System.in);
27
        int t = sc.nextInt();
28
        sc.nextLine();
29
        while (t-- > 0) System.out.println(minDecommissionCost(sc.nextLine().trim()));
30
        sc.close();
31
    }
32
}",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053148
1390053152,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053152
1390053156,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053156
1390053139,unknown,unknown,unknown,"1
function processData(input) {
2
    let lines = input.trim().split(""\n"");
3
    let t = parseInt(lines[0]);
4
    let testCases = [];
5
    let index = 1;
6
    7
    for (let i = 0; i < t; i++) {
8
        let [n, k] = lines[index].split("" "").map(Number);
9
        let arr = lines[index + 1].split("" "").map(Number);
10
        testCases.push([n, k, arr]);
11
        index += 2;
12
    }
13
    14
    function earliestFaultyReadings(testCases) {
15
        let results = [];
16
        17
        for (let [n, k, arr] of testCases) {
18
            let dq = [];
19
            let output = [];
20
            21
            // Process first k elements
22
            for (let i = 0; i < k; i++) {
23
                if (arr[i] < 0) {
24
                    dq.push(i);
25
                }
26
            }
27
            28
            // Process remaining elements
29
            for (let i = 0; i <= n - k; i++) {
30
                // Append first negative if exists, else 0
31
                output.push(dq.length ? arr[dq[0]] : 0);
32
                33
                // Remove elements that are out of the current window
34
                if (dq.length && dq[0] === i) {
35
                    dq.shift();
36
                }
37
                38
                // Add next element from the array if it's negative
39
                if (i + k < n && arr[i + k] < 0) {
40
                    dq.push(i + k);
41
                }
42
            }
43
            44
            results.push(output.join("" ""));
45
        }
46
        47
        console.log(results.join(""\n""));
48
    }
49
    50
    earliestFaultyReadings(testCases);
51
}
52
53
process.stdin.resume();
54
process.stdin.setEncoding(""ascii"");
55
let _input = """";
56
process.stdin.on(""data"", function (input) {
57
    _input += input;
58
});
59
60
process.stdin.on(""end"", function () {
61
    processData(_input);
62
});
63",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053139
1390053140,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
    public static List<Integer> earliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>();
7
8
        for (int i = 0; i < arr.length; i++) {
9
            // Remove out-of-window elements
10
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
11
                deque.poll();
12
            }
13
14
            // Add new faulty readings
15
            if (arr[i] < 0) {
16
                deque.offer(i);
17
            }
18
19
            // Collect results for valid windows
20
            if (i >= k - 1) {
21
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
22
            }
23
        }
24
        return result;
25
    }
26
27
    public static void main(String[] args) {
28
        Scanner scanner = new Scanner(System.in);
29
        int t = scanner.nextInt(); // Number of test cases
30
31
        while (t-- > 0) {
32
            int n = scanner.nextInt(); // Array size
33
            int k = scanner.nextInt(); // Batch size
34
            int[] arr = new int[n];
35
36
            for (int i = 0; i < n; i++) {
37
                arr[i] = scanner.nextInt();
38
            }
39
40
            // Compute and print results
41
            List<Integer> faults = earliestFaults(arr, k);
42
            for (int val : faults) {
43
                System.out.print(val + "" "");
44
            }
45
            System.out.println();
46
        }
47
        scanner.close();
48
    }
49
}",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053140
1390053142,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053142
1390053137,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053137
1390053138,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        Scanner sc=new Scanner(System.in);
11
        int t=sc.nextInt();
12
        while(t>0){
13
            int n=sc.nextInt();
14
            int k=sc.nextInt();
15
            int arr[]=new int[n];
16
            int i,j;
17
            for(i=0;i<n;i++){
18
                arr[i]=sc.nextInt();
19
            }
20
            for(i=0;i<=n-k;i++){
21
                int res=0;
22
                for(j=i;j<=i+k-1;j++){
23
                    if(arr[j]<0){
24
                        res=arr[j];
25
                        break;
26
                    }
27
                }
28
                System.out.print(res+"" "");
29
            }
30
            System.out.println();
31
            t--;
32
        }
33
    }
34
}",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053138
1390053136,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void findEarliestFaultyReadings(int *arr, int n, int k) {
5
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
6
    int front = 0, rear = 0;
7
    int queue[n];
8
    9
    // Process the first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) {
12
            queue[rear++] = i;
13
        }
14
    }
15
    16
    // Store result for the first batch
17
    result[0] = (front < rear) ? arr[queue[front]] : 0;
18
    19
    // Process the remaining windows
20
    for (int i = k; i < n; i++) {
21
        // Remove elements not within the window
22
        while (front < rear && queue[front] <= i - k) {
23
            front++;
24
        }
25
        26
        // Add new element if it's faulty
27
        if (arr[i] < 0) {
28
            queue[rear++] = i;
29
        }
30
        31
        // Store result for current batch
32
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
33
    }
34
    35
    // Print the result
36
    for (int i = 0; i < n - k + 1; i++) {
37
        printf(""%d "", result[i]);
38
    }
39
    printf(""\n"");
40
    41
    free(result);
42
}
43
44
int main() {
45
    int t;
46
    scanf(""%d"", &t);
47
    48
    while (t--) {
49
        int n, k;
50
        scanf(""%d %d"", &n, &k);
51
        int arr[n];
52
        53
        for (int i = 0; i < n; i++) {
54
            scanf(""%d"", &arr[i]);
55
        }
56
        57
        findEarliestFaultyReadings(arr, n, k);
58
    }
59
    60
    return 0;
61
}",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053136
1390053135,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
    5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    dp[0][0] = 0
7
    8
    for i in range(1, n + 1):
9
        for j in range(min(i, k) + 1):
10
            if j > 0:
11
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
12
            13
            if dp[i-1][j] != float('inf'):
14
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
15
    16
    return min(dp[n])
17
18
def solve():
19
    t = int(input().strip())
20
    results = []
21
    22
    for _ in range(t):
23
        n, k = map(int, input().strip().split())
24
        strengths = list(map(int, input().strip().split()))
25
        results.append(str(min_effort_to_breach(n, k, strengths)))
26
    27
    print(""\n"".join(results))
28
29
solve()",151,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053135
1390053132,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # If we can skip all firewalls, the answer is 0
3
    if k >= n:
4
        return 0
5
    6
    # Calculate the cost of skipping a firewall at position i
7
    # This includes the original firewall strength plus the penalty it would add to future firewalls
8
    impact = []
9
    for i in range(n):
10
        # Impact = strength of firewall + number of non-skipped firewalls after this one
11
        # We're assuming all firewalls after i are NOT skipped (we'll adjust this later)
12
        firewall_impact = strengths[i] + (n - i - 1)
13
        impact.append((firewall_impact, i))
14
    15
    # Sort by impact (high to low)
16
    impact.sort(reverse=True)
17
    18
    # Select firewalls to skip (those with highest impact)
19
    to_skip = set()
20
    for i in range(min(k, n)):
21
        to_skip.add(impact[i][1])
22
    23
    # Calculate final effort
24
    total_effort = 0
25
    skipped_count = 0
26
    27
    for i in range(n):
28
        if i in to_skip:
29
            skipped_count += 1
30
        else:
31
            # Add firewall strength plus penalty for each previously skipped firewall
32
            total_effort += strengths[i] + skipped_count
33
    34
    return total_effort
35
36
def solve_all_subsets(n, k, strengths):
37
    # Try all possible subsets of firewalls to skip
38
    # This is an exhaustive approach for when n is small
39
    min_effort = float('inf')
40
    41
    # 2^n possible subsets of firewalls
42
    for mask in range(1 << n):
43
        # Count bits to ensure we're skipping at most k firewalls
44
        skipped = bin(mask).count('1')
45
        if skipped > k:
46
            continue
47
            48
        effort = 0
49
        skip_count = 0
50
        51
        for i in range(n):
52
            if (mask >> i) & 1:  # This firewall is skipped
53
                skip_count += 1
54
            else:
55
                effort += strengths[i] + skip_count
56
                57
        min_effort = min(min_effort, effort)
58
    59
    return min_effort
60
61
def main():
62
    t = int(input().strip())
63
    64
    for _ in range(t):
65
        n, k = map(int, input().strip().split())
66
        strengths = list(map(int, input().strip().split()))
67
        68
        # For small n, use exhaustive approach
69
        if n <= 20:
70
            result = solve_all_subsets(n, k, strengths)
71
        else:
72
            # For larger n, use greedy approach
73
            result = min_effort_to_breach(n, k, strengths)
74
            75
        print(result)
76
77
if __name__ == ""__main__"":
78
    main()",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053132
1390053133,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
5
int main() {
6
    int t;
7
    cin>>t;
8
    9
    while(t--)
10
    {
11
        int n,k;
12
        cin>>n>>k;
13
        14
        vector<int> input(n);
15
        for(int i=0;i<n;i++)
16
        {
17
            int ele;
18
            cin>>ele;
19
            20
            input[i]=ele;
21
        }
22
        23
        vector<int> ans;
24
        25
        int i=0;
26
        int j=0;
27
        28
        queue<int> q;//would store indices of -ve
29
        30
        while(j<k)
31
        {
32
            if(input[j]<0)
33
                q.push(j);
34
            35
            j++;
36
        }
37
        j--;
38
    39
        while(j<n)
40
        {   
41
            if(q.empty())
42
                ans.push_back(0);
43
            44
            else
45
            ans.push_back(input[q.front()]);
46
            47
            48
            if(!q.empty() && q.front()==i)
49
                q.pop();
50
            51
            i++;
52
            j++;
53
            54
            if(j<n && input[j]<0)
55
                q.push(j);
56
        }
57
        58
        for(auto &el:ans)
59
            cout<<el<<"" "";
60
        61
        cout<<endl;
62
        63
    }
64
    return 0;
65
}",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053133
1390053130,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class EarliestFaultyBatch {
4
    public static List<Integer> earliestFaultyReadings(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> dq = new LinkedList<>();
7
        8
        for (int i = 0; i < k; i++) {
9
            if (arr[i] < 0) {
10
                dq.add(i);
11
            }
12
        }
13
        result.add(dq.isEmpty() ? 0 : arr[dq.peekFirst()]);
14
        15
        for (int i = k; i < arr.length; i++) {
16
            if (!dq.isEmpty() && dq.peekFirst() < i - k + 1) {
17
                dq.pollFirst();
18
            }
19
            if (arr[i] < 0) {
20
                dq.add(i);
21
            }
22
            result.add(dq.isEmpty() ? 0 : arr[dq.peekFirst()]);
23
        }
24
        25
        return result;
26
    }
27
28
    public static void main(String[] args) {
29
        Scanner sc = new Scanner(System.in);
30
        int t = sc.nextInt();
31
        while (t-- > 0) {
32
            int n = sc.nextInt();
33
            int k = sc.nextInt();
34
            int[] arr = new int[n];
35
            for (int i = 0; i < n; i++) {
36
                arr[i] = sc.nextInt();
37
            }
38
            List<Integer> result = earliestFaultyReadings(arr, k);
39
            for (int num : result) {
40
                System.out.print(num + "" "");
41
            }
42
            System.out.println();
43
        }
44
        sc.close();
45
    }
46
}",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053130
1390053128,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    ans = float('inf')
5
    for i in range(n + 1):
6
        for j in range(n - i + 1):
7
            temp = s[i:n - j]
8
            idle = temp.count('0')
9
            active = s[:i].count('1') + s[n - j:].count('1')
10
            ans = min(ans, max(idle, active))
11
    print(ans)
12
13
t = int(input())
14
for _ in range(t):
15
    solve()",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053128
1390053125,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053125
1390053129,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
// Comparator function for sorting in descending order
5
int compare(const void *a, const void *b) {
6
    return (*(int *)b - *(int *)a);
7
}
8
9
void minimum_effort(int test_cases) {
10
    for (int t = 0; t < test_cases; t++) {
11
        int n, k;
12
        scanf(""%d %d"", &n, &k);
13
        int *arr = (int *)malloc(n * sizeof(int));
14
        for (int i = 0; i < n; i++) {
15
            scanf(""%d"", &arr[i]);
16
        }
17
        18
        // Edge case: If k >= n, the minimum effort is 0
19
        if (k >= n) {
20
            printf(""0\n"");
21
            free(arr);
22
            continue;
23
        }
24
        25
        // Calculate the potential reduction for each firewall if skipped
26
        int *reduction = (int *)malloc(n * sizeof(int));
27
        for (int i = 0; i < n; i++) {
28
            reduction[i] = arr[i] - (n - i - 1);
29
        }
30
        31
        // Sort the reduction array in descending order
32
        qsort(reduction, n, sizeof(int), compare);
33
        34
        // Calculate the minimum effort
35
        long long total_effort = 0;
36
        for (int i = 0; i < n; i++) {
37
            total_effort += arr[i];
38
        }
39
        40
        // Subtract the top k reductions
41
        for (int i = 0; i < k; i++) {
42
            total_effort -= reduction[i];
43
        }
44
        45
        printf(""%lld\n"", total_effort);
46
        free(arr);
47
        free(reduction);
48
    }
49
}
50
51
int main() {
52
    int test_cases;
53
    scanf(""%d"", &test_cases);
54
    minimum_effort(test_cases);
55
    return 0;
56
}",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053129
1390053111,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053111
1390053117,unknown,unknown,unknown,"1
import java.util.Arrays;
2
import java.util.Scanner;
3
4
public class FirewallBreachOptimized {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int t = scanner.nextInt();
9
10
        while (t-- > 0) {
11
            int n = scanner.nextInt();
12
            int k = scanner.nextInt();
13
            long[] a = new long[n];
14
            for (int i = 0; i < n; i++) {
15
                a[i] = scanner.nextLong();
16
            }
17
18
            long minEffort = solveOptimized(a, k);
19
            System.out.println(minEffort);
20
        }
21
        scanner.close();
22
    }
23
24
    private static long solveOptimized(long[] a, int k) {
25
        long minEffort = Long.MAX_VALUE;
26
        long[][] dp = new long[a.length + 1][k + 1];
27
28
        for (int i = 0; i <= a.length; i++) {
29
            Arrays.fill(dp[i], Long.MAX_VALUE);
30
        }
31
32
        dp[0][0] = 0;
33
34
        for (int i = 1; i <= a.length; i++) {
35
            for (int j = 0; j <= k; j++) {
36
                // Option 1: Don't skip the current firewall
37
                if (dp[i - 1][j] != Long.MAX_VALUE) {
38
                    long currentEffort = dp[i - 1][j];
39
                    for (int l = 0; l < j; l++) {
40
                        currentEffort += 1;
41
                    }
42
                    dp[i][j] = Math.min(dp[i][j], currentEffort + a[i - 1]);
43
                }
44
45
                // Option 2: Skip the current firewall
46
                if (j > 0 && dp[i - 1][j - 1] != Long.MAX_VALUE) {
47
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j - 1]);
48
                }
49
            }
50
        }
51
52
        for (int j = 0; j <= k; j++) {
53
            minEffort = Math.min(minEffort, dp[a.length][j]);
54
        }
55
56
        return minEffort;
57
    }
58
}",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053117
1390053122,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_first_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
    8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    result.append(arr[dq[0]] if dq else 0)
13
    14
    for i in range(k, n):
15
        if dq and dq[0] < i - k + 1:
16
            dq.popleft()
17
        18
        if arr[i] < 0:
19
            dq.append(i)
20
        21
        result.append(arr[dq[0]] if dq else 0)
22
    23
    return result
24
25
t = int(input())
26
for _ in range(t):
27
    n, k = map(int, input().split())
28
    arr = list(map(int, input().split()))
29
    print(*find_first_faulty_readings(arr, k))
30",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053122
1390053109,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class ServerDecommission {
4
5
    public static int minCostDecommissioning(String rack) {
6
        int n = rack.length();
7
        int totalOnes = 0;
8
9
        // Count total number of 1's in the rack
10
        for (char c : rack.toCharArray()) {
11
            if (c == '1') {
12
                totalOnes++;
13
            }
14
        }
15
16
        int minCost = Integer.MAX_VALUE;
17
18
        // Try all possible removals from left and right
19
        for (int left = 0; left <= n; left++) {
20
            for (int right = 0; right <= n - left; right++) {
21
                String remaining = rack.substring(left, n - right);
22
23
                int remainingZeros = 0, remainingOnes = 0;
24
                for (char c : remaining.toCharArray()) {
25
                    if (c == '0') {
26
                        remainingZeros++;
27
                    } else {
28
                        remainingOnes++;
29
                    }
30
                }
31
32
                int removedOnes = totalOnes - remainingOnes;
33
                int cost = Math.max(remainingZeros, removedOnes);
34
35
                minCost = Math.min(minCost, cost);
36
            }
37
        }
38
39
        return minCost;
40
    }
41
42
    public static void main(String[] args) {
43
        Scanner scanner = new Scanner(System.in);
44
        int T = scanner.nextInt();
45
        scanner.nextLine(); // Consume newline
46
47
        for (int i = 0; i < T; i++) {
48
            String rack = scanner.nextLine();
49
            System.out.println(minCostDecommissioning(rack));
50
        }
51
52
        scanner.close();
53
    }
54
}
55",152,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053109
1390053106,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()  # Stores indices of negative values
6
7
    # Process first window of size k
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
12
    # Store result for first window
13
    result.append(arr[dq[0]] if dq else 0)
14
15
    # Process rest of the windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the window
18
        if dq and dq[0] <= i - k:
19
            dq.popleft()
20
21
        # Add current element if negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
25
        # Store the result
26
        result.append(arr[dq[0]] if dq else 0)
27
28
    return result
29
30
# Input Handling
31
T = int(input())  # Number of test cases
32
for _ in range(T):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    print(*earliest_faulty_readings(arr, k))  # Print result space-separated
36",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053106
1390053107,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Main {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();
7
        while (T-- > 0) {
8
            int n = sc.nextInt();
9
            int k = sc.nextInt();
10
            int[] a = new int[n];
11
            long sum_a = 0;
12
            for (int i = 0; i < n; i++) {
13
                a[i] = sc.nextInt();
14
                sum_a += a[i];
15
            }
16
            List<Long> values = new ArrayList<>();
17
            for (int i = 0; i < n; i++) {
18
                long val = a[i] - (n - i - 1L);
19
                values.add(val);
20
            }
21
            values.sort((x, y) -> Long.compare(y, x));
22
            long[] prefixSum = new long[n + 1];
23
            prefixSum[0] = 0;
24
            for (int i = 1; i <= n; i++) {
25
                prefixSum[i] = prefixSum[i - 1] + values.get(i - 1);
26
            }
27
            int max_m = Math.min(k, n);
28
            long maxTotal = Long.MIN_VALUE;
29
            for (int m = 0; m <= max_m; m++) {
30
                long current = prefixSum[m] + ((long) m * (m - 1)) / 2;
31
                if (current > maxTotal) {
32
                    maxTotal = current;
33
                }
34
            }
35
            long minEffort = sum_a - maxTotal;
36
            System.out.println(minEffort);
37
        }
38
        sc.close();
39
    }
40
}
41",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053107
1390053108,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
3
    n = len(servers)
4
5
    6
7
    # Create prefix sums for 1's to optimize counting
8
9
    prefix_ones = [0] * (n + 1)
10
11
    for i in range(n):
12
13
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
14
15
    16
17
    # Create prefix sums for 0's
18
19
    prefix_zeros = [0] * (n + 1)
20
21
    for i in range(n):
22
23
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
24
25
    26
27
    min_cost = float('inf')
28
29
    30
31
    # Try all possible substrings (start, end)
32
33
    for start in range(n + 1):
34
35
        for end in range(start, n + 1):
36
37
            # Active servers removed = ones before start + ones after end
38
39
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
40
41
            # Idle servers remaining = zeros between start and end
42
43
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
44
45
            46
47
            cost = max(idle_remaining, active_removed)
48
49
            min_cost = min(min_cost, cost)
50
51
    52
53
    return min_cost
54
55
# Process test cases
56
57
t = int(input())
58
59
for _ in range(t):
60
61
    servers = input().strip()
62
63
    print(min_decommissioning_cost(servers))",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053108
1390053095,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053095
1390053096,unknown,unknown,unknown,"1
from collections import deque 
2
3
def neginteger(arr_NeelJ, k_NeelJ):
4
    ans_NeelJ=[]
5
    queue_NeelJ=deque()
6
    i_NeelJ, j_NeelJ=0,0
7
    n_NeelJ= len(arr_NeelJ)
8
    while j_NeelJ<n_NeelJ:
9
        if arr_NeelJ[j_NeelJ]<0:
10
            queue_NeelJ.append(arr_NeelJ[j_NeelJ])
11
        if j_NeelJ- i_NeelJ + 1< k_NeelJ:
12
            j_NeelJ+=1
13
        elif j_NeelJ -i_NeelJ+1 == k_NeelJ:
14
            if not queue_NeelJ:
15
                ans_NeelJ.append(0)
16
            else:
17
                ans_NeelJ.append(queue_NeelJ[0])
18
                if arr_NeelJ[i_NeelJ]== queue_NeelJ[0]:
19
                    queue_NeelJ.popleft()
20
            i_NeelJ+=1
21
            j_NeelJ+=1
22
    return ans_NeelJ
23
if __name__ == ""__main__"":
24
    t_NeelJ = int(input())
25
    for _ in range(t_NeelJ):
26
        n_NeelJ, k_NeelJ = map(int, input().split())
27
        arr_NeelJ = list(map(int, input().split()))
28
        result_NeelJ = neginteger(arr_NeelJ, k_NeelJ)
29
        print(*result_NeelJ)
30",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053096
1390053102,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053102
1390053091,unknown,unknown,unknown,"1
function processData(input) {
2
    let lines = input.trim().split(""\n"");
3
    let t = parseInt(lines[0]); 
4
    let index = 1;
5
    let output = [];
6
7
    for (let test = 0; test < t; test++) {
8
        let [n, k] = lines[index].split("" "").map(Number);
9
        let arr = lines[index + 1].split("" "").map(Number);
10
        index += 2; // Move to next test case
11
        12
        let res = [];
13
    14
        for(let i = 0; i <= n - k; i++){
15
            let batch = arr.slice(i,i+k)
16
            let faulty = false;
17
18
            for(let val of batch){
19
                if(val < 0){
20
                    res.push(val)
21
                    faulty = true
22
                    break;
23
                }
24
            }
25
26
            if(!faulty) res.push(0)
27
28
        }
29
30
        output.push(res.join("" ""))        
31
    }
32
    33
    console.log(output.join(""\n""));
34
} 
35
36
process.stdin.resume();
37
process.stdin.setEncoding(""ascii"");
38
_input = """";
39
process.stdin.on(""data"", function (input) {
40
    _input += input;
41
});
42
43
process.stdin.on(""end"", function () {
44
   processData(_input);
45
});",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053091
1390053093,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
5
    results = []
6
7
    8
9
    for test in test_cases:
10
11
        n, k, arr = test
12
13
        dq = deque()
14
15
        res = []
16
17
        18
19
        for i in range(k):
20
21
            if arr[i] < 0:
22
23
                dq.append(i)
24
25
        26
27
        res.append(arr[dq[0]] if dq else 0)
28
29
        30
31
        for i in range(k, n):
32
33
            if dq and dq[0] < i - k + 1:
34
35
                dq.popleft()
36
37
            38
39
            if arr[i] < 0:
40
41
                dq.append(i)
42
43
            44
45
            res.append(arr[dq[0]] if dq else 0)
46
47
        48
49
        results.append("" "".join(map(str, res)))
50
51
    52
53
    print(""\n"".join(results))
54
55
t = int(input())
56
57
test_cases = []
58
59
for _ in range(t):
60
61
    n, k = map(int, input().split())
62
63
    arr = list(map(int, input().split()))
64
65
    test_cases.append((n, k, arr))
66
67
earliest_faulty_readings(test_cases)",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053093
1390053094,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
def min_effort_to_breach(n, k, firewalls):
3
    firewalls.sort() 
4
  5
    if k >= n:
6
        return 0
7
    8
   9
    return sum(firewalls[k:])
10
11
12
t = int(input())
13
for _ in range(t):
14
    n, k = map(int, input().split())
15
    firewalls = list(map(int, split()))
16
    17
    18
    print(min_effort_to_breach(n, k, firewalls))
19",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053094
1390053090,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
5
    int n = arr.size();
6
    vector<int> result;
7
    deque<int> dq;  // Stores indices of negative numbers
8
9
    // Process first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) dq.push_back(i);
12
    }
13
14
    // Process the sliding window
15
    for (int i = k; i <= n; i++) {
16
        // Append first negative number in the window
17
        if (!dq.empty()) 
18
            result.push_back(arr[dq.front()]);  // First negative in the deque
19
        else 
20
            result.push_back(0);  // No negative number
21
22
        // Remove elements that are out of the current window
23
        while (!dq.empty() && dq.front() < i - k + 1) {
24
            dq.pop_front();
25
        }
26
27
        // Add the next element if negative
28
        if (i < n && arr[i] < 0) {
29
            dq.push_back(i);
30
        }
31
    }
32
33
    return result;
34
}
35
36
int main() {
37
    int t;
38
    cin >> t;  // Number of test cases
39
    while (t--) {
40
        int n, k;
41
        cin >> n >> k;  // Size of array and batch size
42
        vector<int> arr(n);
43
        for (int i = 0; i < n; i++) {
44
            cin >> arr[i];
45
        }
46
        47
        vector<int> result = earliest_faulty_readings(arr, k);
48
        for (int num : result) {
49
            cout << num << "" "";
50
        }
51
        cout << endl;
52
    }
53
    return 0;
54
}",153,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053090
1390053086,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053086
1390053087,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053087
1390053088,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    ans = float('inf')
5
    6
    total_ones = s.count('1')
7
8
    for i in range(n + 1):
9
        remaining = s[i:]
10
        zeros_remaining = remaining.count('0')
11
        ones_removed = total_ones - remaining.count('1')
12
        ans = min(ans, max(zeros_remaining, ones_removed))
13
14
    for j in range(n + 1):
15
        remaining = s[:n-j]
16
        zeros_remaining = remaining.count('0')
17
        ones_removed = total_ones - remaining.count('1')
18
        ans = min(ans, max(zeros_remaining, ones_removed))
19
20
    for i in range(n + 1):
21
        for j in range(n - i + 1):
22
            remaining = s[i:n-j]
23
24
            zeros_remaining = remaining.count('0')
25
            ones_removed = total_ones - remaining.count('1')
26
27
            ans = min(ans, max(zeros_remaining, ones_removed))
28
29
    print(ans)
30
31
32
t = int(input())
33
for _ in range(t):
34
    solve()",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053088
1390053083,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053083
1390053085,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <deque>
4
using namespace std;
5
6
vector<int> earliestFaultyReadings(vector<int>& arr, int n, int k) {
7
    vector<int> result;
8
    deque<int> dq;  
9
 10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) {
12
            dq.push_back(i);
13
        }
14
    }
15
     16
    result.push_back(dq.empty() ? 0 : arr[dq.front()]);
17
     18
    for (int i = k; i < n; i++) { 
19
        if (!dq.empty() && dq.front() <= i - k) {
20
            dq.pop_front();
21
        }
22
         23
        if (arr[i] < 0) {
24
            dq.push_back(i);
25
        }
26
         27
        result.push_back(dq.empty() ? 0 : arr[dq.front()]);
28
    }
29
    30
    return result;
31
}
32
33
int main() {
34
    int t;
35
    cin >> t;
36
    while (t--) {
37
        int n, k;
38
        cin >> n >> k;
39
        vector<int> arr(n);
40
        for (int i = 0; i < n; i++) {
41
            cin >> arr[i];
42
        }
43
        44
        vector<int> output = earliestFaultyReadings(arr, n, k);
45
        46
        for (int val : output) {
47
            cout << val << "" "";
48
        }
49
        cout << endl;
50
    }
51
    return 0;
52
}
53",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053085
1390053081,unknown,unknown,unknown,1,154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053081
1390053075,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053075
1390053079,unknown,unknown,unknown,"1
def find_earliest_faults(arr, k):
2
    result = []
3
    for i in range(len(arr) - k + 1):
4
        batch = arr[i:i + k]
5
        earliest_fault = 0
6
        for j, reading in enumerate(batch):
7
            if reading < 0:
8
                earliest_fault = reading
9
                break
10
        result.append(earliest_fault)
11
    return result
12
13
def solve():
14
    t = int(input())
15
    for _ in range(t):
16
        n, k = map(int, input().split())
17
        arr = list(map(int, input().split()))
18
        result = find_earliest_faults(arr, k)
19
        print(*result)
20
21
solve()",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053079
1390053080,unknown,unknown,unknown,"1
def minimum_effort(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n, k = test_cases[t][0]
6
        strengths = test_cases[t][1]
7
        8
        if k == n:
9
            results.append(0)
10
            continue
11
        12
        total_effort = sum(strengths)
13
        min_effort = total_effort
14
        15
        for i in range(n):
16
            skip_effort = total_effort - strengths[i]
17
            for j in range(1, k + 1):
18
                if i + j < n:
19
                    skip_effort += 1  # Adding penalty for skipping next k firewalls
20
            min_effort = min(min_effort, skip_effort)
21
        22
        results.append(min_effort)
23
    24
    return results
25
26
# Input processing
27
def main():
28
    T = int(input().strip())
29
    test_cases = []
30
    31
    for _ in range(T):
32
        n, k = map(int, input().split())
33
        strengths = list(map(int, input().split()))
34
        test_cases.append(((n, k), strengths))
35
    36
    results = minimum_effort(T, test_cases)
37
    for res in results:
38
        print(res)
39
40
if __name__ == ""__main__"":
41
    main()
42",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053080
1390053073,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    servers = [int(c) for c in server_string]
4
    5
    # Total number of ones and zeros
6
    total_ones = sum(servers)
7
    total_zeros = n - total_ones
8
    9
    # Pre-compute prefix sums
10
    prefix_ones = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_ones[i+1] = prefix_ones[i] + servers[i]
13
    14
    min_cost = float('inf')
15
    16
    # For each number of servers to keep (not remove)
17
    for keep_len in range(1, n):
18
        # For each possible starting position of the kept segment
19
        for start in range(n - keep_len + 1):
20
            end = start + keep_len
21
            22
            # Calculate ones removed
23
            ones_removed = total_ones - (prefix_ones[end] - prefix_ones[start])
24
            25
            # Calculate zeros kept
26
            zeros_kept = keep_len - (prefix_ones[end] - prefix_ones[start])
27
            28
            # Calculate cost
29
            cost = max(zeros_kept, ones_removed)
30
            min_cost = min(min_cost, cost)
31
    32
    return min_cost
33
34
def optimize_by_sliding_window(server_string):
35
   36
    n = len(server_string)
37
    total_ones = server_string.count('1')
38
    39
    min_cost = float('inf')
40
    41
    # For each possible continuous segment to keep
42
    for length in range(1, n):
43
        # Compute initial window
44
        window = server_string[:length]
45
        ones_in_window = window.count('1')
46
        zeros_in_window = length - ones_in_window
47
        ones_removed = total_ones - ones_in_window
48
        cost = max(zeros_in_window, ones_removed)
49
        min_cost = min(min_cost, cost)
50
        51
        # Slide the window
52
        for i in range(1, n - length + 1):
53
            # Remove leftmost character from window
54
            if server_string[i-1] == '1':
55
                ones_in_window -= 1
56
            else:
57
                zeros_in_window -= 1
58
                59
            # Add rightmost character to window
60
            if server_string[i+length-1] == '1':
61
                ones_in_window += 1
62
            else:
63
                zeros_in_window += 1
64
                65
            ones_removed = total_ones - ones_in_window
66
            cost = max(zeros_in_window, ones_removed)
67
            min_cost = min(min_cost, cost)
68
    69
    return min_cost
70
71
def optimize_further(server_string):
72
  73
    n = len(server_string)
74
    75
    # Precompute ones count
76
    ones = []
77
    for c in server_string:
78
        ones.append(1 if c == '1' else 0)
79
    80
    total_ones = sum(ones)
81
    min_cost = n  # worst case is keeping all zeros
82
    83
    # For each possible length of servers to keep
84
    for length in range(1, n):
85
        # Initialize window sum
86
        ones_in_window = sum(ones[:length])
87
        zeros_in_window = length - ones_in_window
88
        89
        # Check cost for this window
90
        ones_removed = total_ones - ones_in_window
91
        cost = max(zeros_in_window, ones_removed)
92
        min_cost = min(min_cost, cost)
93
        94
        # Slide window
95
        for i in range(length, n):
96
            # Add new element, remove old element
97
            ones_in_window += ones[i] - ones[i-length]
98
            zeros_in_window = length - ones_in_window
99
            100
            ones_removed = total_ones - ones_in_window
101
            cost = max(zeros_in_window, ones_removed)
102
            min_cost = min(min_cost, cost)
103
    104
    return min_cost
105
106
def solve():
107
    t = int(input())
108
    109
    for _ in range(t):
110
        server_string = input().strip()
111
        # Use the most optimized solution
112
        result = optimize_further(server_string)
113
        print(result)
114
115
# Execute the solution
116
solve()",154,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053073
1390053069,unknown,unknown,unknown,"1
def find_earliest_faults(test_cases):
2
    output = []
3
    4
    for case in test_cases:
5
        size, batch_size, readings = case
6
        batch_faults = []
7
        8
        for start in range(size - batch_size + 1):
9
            current_batch = readings[start:start + batch_size]
10
            fault = next((value for value in current_batch if value < 0), 0)
11
            batch_faults.append(fault)
12
        13
        output.append(batch_faults)
14
    15
    return output
16
17
def main():
18
    import sys
19
    input = sys.stdin.read
20
    lines = input().splitlines()
21
    22
    index = 0
23
    num_cases = int(lines[index])
24
    index += 1
25
    cases = []
26
    27
    for _ in range(num_cases):
28
        size, batch_size = map(int, lines[index].split())
29
        index += 1
30
        readings = list(map(int, lines[index].split()))
31
        index += 1
32
        cases.append((size, batch_size, readings))
33
    34
    results = find_earliest_faults(cases)
35
    36
    for result in results:
37
        print("" "".join(map(str, result)))
38
39
if __name__ == ""__main__"":
40
    main()",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053069
1390053071,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053071
1390053072,unknown,unknown,unknown,"1
def findMinEffort():
2
    n,k = map(int,input().split())
3
    a = list(map(int,input().split()))   
4
    ans = float('inf')
5
    for i in range(1<<n):
6
        skipped=[]
7
        efforts=[]
8
        for j in range(n):
9
            if(i>>j) & 1:
10
                skipped.append(j)
11
            else:
12
                efforts.append(j)
13
                14
        if len(skipped)<=k:
15
            current_effort=0
16
            skipped_count=0
17
            for j in range(n):
18
                if j in skipped:
19
                    skipped_count+=1
20
                else:
21
                    current_effort+= a[j] + skipped_count
22
            ans = min(ans,current_effort)
23
    print(ans)
24
    25
t = int(input())
26
for _ in range(t):
27
    findMinEffort()",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053072
1390053057,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt();
7
        while (t-- > 0) {
8
            int n = sc.nextInt(), k = sc.nextInt();
9
            int[] arr = new int[n];
10
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
11
            Deque<Integer> dq = new LinkedList<>();
12
            for (int i = 0; i < n; i++) {
13
                if (arr[i] < 0) dq.addLast(i);
14
                if (i >= k - 1) {
15
                    while (!dq.isEmpty() && dq.peekFirst() < i - k + 1) dq.pollFirst();
16
                    System.out.print((dq.isEmpty() ? 0 : arr[dq.peekFirst()]) + "" "");
17
                }
18
            }
19
            System.out.println();
20
        }
21
        sc.close();
22
    }
23
}",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053057
1390053064,unknown,unknown,unknown,"1
T=int(input())
2
for i in range(T):
3
    n,k=map(int,input().split())
4
    arr=list(map(int,input().split()))
5
    result=[]
6
    for x in range(n-k+1):
7
        faulty=0
8
        for y in range(x,x+k):
9
            if arr[y]<0:
10
                faulty=arr[y]
11
                break
12
        result.append(faulty)
13
    print(*result)
14
    15
            16",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053064
1390053067,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    for _ in range(test_cases):
6
        n, k = map(int, input().split())
7
        arr = list(map(int, input().split()))
8
        9
        res = []
10
        dq = deque()
11
        12
        13
        for i in range(k):
14
            if arr[i] < 0:
15
                dq.append(i)
16
        17
      18
        if dq:
19
            res.append(arr[dq[0]])
20
        else:
21
            res.append(0)
22
        23
      24
        for i in range(k, n):
25
          26
            if dq and dq[0] <= i - k:
27
                dq.popleft()
28
            29
            30
            if arr[i] < 0:
31
                dq.append(i)
32
            33
          34
            if dq:
35
                res.append(arr[dq[0]])
36
            else:
37
                res.append(0)
38
        39
        results.append(' '.join(map(str, res)))
40
    41
    42
    print('\n'.join(results))
43
44
45
if __name__ == ""__main__"":
46
    t = int(input())
47
    earliest_faulty_readings(t)
48",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053067
1390053051,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    min_effort = total_effort
4
    5
    for i in range(n):
6
        effort = 0
7
        skipped = 0
8
        increased_security = 0
9
        10
        for j in range(n):
11
            if skipped < k and j >= i:
12
                skipped += 1
13
                increased_security += 1
14
            else:
15
                effort += firewalls[j] + increased_security
16
        17
        min_effort = min(min_effort, effort)
18
    19
    return min_effort
20
21
T = int(input())
22
for _ in range(T):
23
    n, k = map(int, input().split())
24
    firewalls = list(map(int, input().split()))
25
    print(min_effort_to_breach(n, k, firewalls))",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053051
1390053054,unknown,unknown,unknown,"1
def minimize_breach_effort(n, k, strengths):
2
    # We need to determine which k firewalls to skip to minimize total effort
3
    4
    # We'll try all possible combinations using dynamic programming
5
    6
    # dp[i][j] represents the minimum effort needed to breach through i firewalls
7
    # using at most j skips
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    dp[0][0] = 0  # Base case: no firewalls, no skips, zero effort
10
    11
    for i in range(1, n + 1):
12
        firewall_idx = i - 1  # Convert to 0-indexed
13
        14
        for j in range(k + 1):
15
            # Option 1: Don't skip current firewall
16
            if j <= i - 1:  # Ensure we have processed enough firewalls
17
                # Current strength is original strength + number of skipped firewalls so far
18
                strength_increase = j  # j firewalls have been skipped so far
19
                current_strength = strengths[firewall_idx] + strength_increase
20
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength)
21
            22
            # Option 2: Skip current firewall (if we have skips available)
23
            if j > 0:
24
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
25
    26
    # Return minimum effort using at most k skips for all firewalls
27
    return dp[n][k]
28
29
def main():
30
    # Read the number of test cases
31
    t = int(input())
32
    33
    for _ in range(t):
34
        # Read n (number of firewalls) and k (max skips)
35
        n, k = map(int, input().split())
36
        37
        # Read the strengths of n firewalls
38
        firewall_strengths = list(map(int, input().split()))
39
        40
        # Calculate and print the minimum effort required
41
        min_effort = minimize_breach_effort(n, k, firewall_strengths)
42
        print(min_effort)
43
44
if __name__ == ""__main__"":
45
    main()",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053054
1390053052,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
3
    n = len(firewalls)
4
5
    6
7
    if k >= n:
8
9
        return 0
10
11
    12
13
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
14
15
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
16
17
    18
19
    # Base case: when we've processed all firewalls
20
21
    for j in range(k + 1):
22
23
        dp[n][j] = 0
24
25
    26
27
    # Fill DP table from right to left
28
29
    for i in range(n - 1, -1, -1):
30
31
        for j in range(k + 1):
32
33
            # Option 1: Skip this firewall (if skips remain)
34
35
            if j < k:
36
37
                dp[i][j] = dp[i + 1][j + 1]
38
39
            40
41
            # Option 2: Don't skip this firewall
42
43
            effort = firewalls[i] + j  # Current firewall + skips used before
44
45
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
46
47
    48
49
    return dp[0][0]
50
51
# Handle automatic input
52
53
t = int(input())
54
55
for _ in range(t):
56
57
    n, k = map(int, input().split())
58
59
    firewalls = list(map(int, input().split()))
60
61
    result = min_effort(firewalls, k)
62
63
    print(result)",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053052
1390053050,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",155,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053050
1390053044,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
5
    public static void main(String[] args) {
6
7
        Scanner sc = new Scanner(System.in);
8
9
        int T = sc.nextInt();
10
11
        while (T-- > 0) {
12
13
            int n = sc.nextInt();
14
15
            int k = sc.nextInt();
16
17
            int[] arr = new int[n];
18
19
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
20
21
            long minEffort = Long.MAX_VALUE;
22
23
            // Case when skipping 0 to k firewalls
24
25
            if (k >= n) {
26
27
                // Skip all firewalls
28
29
                System.out.println(0);
30
31
                continue;
32
33
            }
34
35
            // Try all combinations where we skip up to k firewalls
36
37
            // For k=1, try skipping each firewall one by one
38
39
            // General approach:
40
41
            boolean[] skip = new boolean[n];
42
43
            // Priority Queue to skip k largest firewalls
44
45
            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);
46
47
            for (int i = 0; i < n; i++) {
48
49
                pq.add(new int[]{arr[i], i});
50
51
            }
52
53
            for (int s = 0; s <= k; s++) {
54
55
                Arrays.fill(skip, false);
56
57
                PriorityQueue<int[]> temp = new PriorityQueue<>(pq);
58
59
                // Skip 's' largest firewalls
60
61
                for (int j = 0; j < s; j++) {
62
63
                    int[] top = temp.poll();
64
65
                    skip[top[1]] = true;
66
67
                }
68
69
                long effort = 0;
70
71
                int skipped = 0;
72
73
                for (int i = 0; i < n; i++) {
74
75
                    if (skip[i]) {
76
77
                        skipped++;
78
79
                    } else {
80
81
                        effort += arr[i] + skipped;
82
83
                    }
84
85
                }
86
87
                minEffort = Math.min(minEffort, effort);
88
89
            }
90
91
            System.out.println(minEffort);
92
93
        }
94
95
        sc.close();
96
97
    }
98
99
}",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053044
1390053047,unknown,unknown,unknown,"1
import java.util.Arrays;
2
import java.util.Scanner;
3
4
public class FirewallBreach {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int t = scanner.nextInt();
9
10
        while (t-- > 0) {
11
            int n = scanner.nextInt();
12
            int k = scanner.nextInt();
13
            long[] a = new long[n];
14
            for (int i = 0; i < n; i++) {
15
                a[i] = scanner.nextLong();
16
            }
17
18
            long minEffort = solve(a, k);
19
            System.out.println(minEffort);
20
        }
21
        scanner.close();
22
    }
23
24
    private static long solve(long[] a, int k) {
25
        long minEffort = Long.MAX_VALUE;
26
        for (int i = 0; i <= (1 << a.length) -1; i++) {
27
            if(Integer.bitCount(i) > k) continue;
28
29
            long currentEffort = 0;
30
            long[] tempA = Arrays.copyOf(a, a.length);
31
            int skipped = 0;
32
33
            for(int j = 0; j < a.length; j++){
34
                if((i & (1 << j)) != 0){
35
                    skipped++;
36
                }
37
                else{
38
                    currentEffort += tempA[j];
39
                }
40
            }
41
42
            if(skipped <= k){
43
                long currentEffort2 = 0;
44
                long[] tempA2 = Arrays.copyOf(a, a.length);
45
                int skipped2 = 0;
46
47
                for(int j = 0; j < a.length; j++){
48
                    if((i & (1 << j)) != 0){
49
                        skipped2++;
50
                    }
51
                    else{
52
                        currentEffort2 += tempA2[j];
53
                    }
54
                    for(int l = j+1; l < a.length; l++){
55
                        if((i & (1 << j)) != 0){
56
                            tempA2[l]+=1;
57
                        }
58
                    }
59
60
                }
61
62
                minEffort = Math.min(minEffort, currentEffort2);
63
            }
64
65
        }
66
67
        return minEffort;
68
    }
69
}",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053047
1390053049,unknown,unknown,unknown,"1
def min_firewall_effort(n, k, firewalls):
2
    prefix_sum = [0] * (n + 1)
3
    4
    for i in range(1, n + 1):
5
        prefix_sum[i] = prefix_sum[i - 1] + firewalls[i - 1]
6
    7
    min_effort = float('inf')
8
9
    for i in range(n - k + 1):
10
        effort = prefix_sum[i] + (prefix_sum[n] - prefix_sum[i + k]) + k * (n - (i + k))
11
        min_effort = min(min_effort, effort)
12
13
    return min_effort
14
15
t = int(input())
16
for _ in range(t):
17
    n, k = map(int, input().split())
18
    firewalls = list(map(int, input().split()))
19
    print(min_firewall_effort(n, k, firewalls))
20",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053049
1390053042,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    servers = [int(c) for c in server_string]
4
    5
    # Total number of ones and zeros
6
    total_ones = sum(servers)
7
    total_zeros = n - total_ones
8
    9
    # Pre-compute prefix sums
10
    prefix_ones = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_ones[i+1] = prefix_ones[i] + servers[i]
13
    14
    min_cost = float('inf')
15
    16
    # For each number of servers to keep (not remove)
17
    for keep_len in range(1, n):
18
        # For each possible starting position of the kept segment
19
        for start in range(n - keep_len + 1):
20
            end = start + keep_len
21
            22
            # Calculate ones removed
23
            ones_removed = total_ones - (prefix_ones[end] - prefix_ones[start])
24
            25
            # Calculate zeros kept
26
            zeros_kept = keep_len - (prefix_ones[end] - prefix_ones[start])
27
            28
            # Calculate cost
29
            cost = max(zeros_kept, ones_removed)
30
            min_cost = min(min_cost, cost)
31
    32
    return min_cost
33
34
def optimize_by_sliding_window(server_string):
35
    """"""
36
    Optimize using sliding window to reduce time complexity to O(n)
37
    but with much fewer operations
38
    """"""
39
    n = len(server_string)
40
    total_ones = server_string.count('1')
41
    42
    min_cost = float('inf')
43
    44
    # For each possible continuous segment to keep
45
    for length in range(1, n):
46
        # Compute initial window
47
        window = server_string[:length]
48
        ones_in_window = window.count('1')
49
        zeros_in_window = length - ones_in_window
50
        ones_removed = total_ones - ones_in_window
51
        cost = max(zeros_in_window, ones_removed)
52
        min_cost = min(min_cost, cost)
53
        54
        # Slide the window
55
        for i in range(1, n - length + 1):
56
            # Remove leftmost character from window
57
            if server_string[i-1] == '1':
58
                ones_in_window -= 1
59
            else:
60
                zeros_in_window -= 1
61
                62
            # Add rightmost character to window
63
            if server_string[i+length-1] == '1':
64
                ones_in_window += 1
65
            else:
66
                zeros_in_window += 1
67
                68
            ones_removed = total_ones - ones_in_window
69
            cost = max(zeros_in_window, ones_removed)
70
            min_cost = min(min_cost, cost)
71
    72
    return min_cost
73
74
def optimize_further(server_string):
75
    """"""
76
    Even more optimized solution with better constant factors
77
    """"""
78
    n = len(server_string)
79
    80
    # Precompute ones count
81
    ones = []
82
    for c in server_string:
83
        ones.append(1 if c == '1' else 0)
84
    85
    total_ones = sum(ones)
86
    min_cost = n  # worst case is keeping all zeros
87
    88
    # For each possible length of servers to keep
89
    for length in range(1, n):
90
        # Initialize window sum
91
        ones_in_window = sum(ones[:length])
92
        zeros_in_window = length - ones_in_window
93
        94
        # Check cost for this window
95
        ones_removed = total_ones - ones_in_window
96
        cost = max(zeros_in_window, ones_removed)
97
        min_cost = min(min_cost, cost)
98
        99
        # Slide window
100
        for i in range(length, n):
101
            # Add new element, remove old element
102
            ones_in_window += ones[i] - ones[i-length]
103
            zeros_in_window = length - ones_in_window
104
            105
            ones_removed = total_ones - ones_in_window
106
            cost = max(zeros_in_window, ones_removed)
107
            min_cost = min(min_cost, cost)
108
    109
    return min_cost
110
111
def solve():
112
    t = int(input())
113
    114
    for _ in range(t):
115
        server_string = input().strip()
116
        # Use the most optimized solution
117
        result = optimize_further(server_string)
118
        print(result)
119
120
# Execute the solution
121
solve()",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053042
1390053038,unknown,unknown,unknown,"1
def minimum_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        if k >= n:
6
            results.append(0)
7
            continue
8
        9
        # Calculate the total effort if no firewalls are skipped
10
        total_effort = sum(a)
11
        12
        # Calculate the reduction for each firewall if it were skipped
13
        # The reduction is a[i] - (number of firewalls after it)
14
        # Because each skipped firewall increases the strength of all subsequent firewalls by 1
15
        reduction = []
16
        for i in range(n):
17
            reduction.append(a[i] - (n - i - 1))
18
        19
        # Sort the reduction values in descending order
20
        reduction.sort(reverse=True)
21
        22
        # Sum the top k reductions
23
        max_reduction = sum(reduction[:k])
24
        25
        # Subtract the maximum reduction from the total effort
26
        results.append(total_effort - max_reduction)
27
    return results
28
29
def main():
30
    import sys
31
    input = sys.stdin.read
32
    data = input().split()
33
    idx = 0
34
    T = int(data[idx])
35
    idx += 1
36
    test_cases = []
37
    for _ in range(T):
38
        n, k = int(data[idx]), int(data[idx + 1])
39
        idx += 2
40
        a = list(map(int, data[idx:idx + n]))
41
        idx += n
42
        test_cases.append((n, k, a))
43
    results = minimum_effort(test_cases)
44
    for res in results:
45
        print(res)
46
47
if __name__ == ""__main__"":
48
    main()",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053038
1390053031,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
         Scanner sc = new Scanner(System.in);
11
        int t = sc.nextInt();
12
        13
        while (t-- > 0) {
14
            int n = sc.nextInt(); 
15
            int k = sc.nextInt();
16
            int[] arr = new int[n];
17
18
            for (int i = 0; i < n; i++) {
19
                arr[i] = sc.nextInt();
20
            }
21
            List<Integer> result = findEarliestFaults(arr, k);
22
            23
            for (int num : result) {
24
                System.out.print(num + "" "");
25
            }
26
            System.out.println(); 
27
        }
28
        sc.close();
29
    }
30
31
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
32
        List<Integer> output = new ArrayList<>();
33
        Deque<Integer> deque = new LinkedList<>();
34
35
        for (int i = 0; i < k; i++) {
36
            if (arr[i] < 0) {
37
                deque.add(i);
38
            }
39
        }
40
41
        output.add(deque.isEmpty() ? 0 : arr[deque.peekFirst()]);
42
43
        for (int i = k; i < arr.length; i++) {
44
45
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
46
                deque.pollFirst();
47
            }
48
49
            if (arr[i] < 0) {
50
                deque.add(i);
51
            }
52
            output.add(deque.isEmpty() ? 0 : arr[deque.peekFirst()]);
53
        }
54
55
        return output;
56
    }
57
}",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053031
1390053035,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <algorithm>
4
#include <climits>
5
#include <string>
6
7
using namespace std;
8
9
int main() {
10
    int T;
11
    cin >> T;
12
    for (int t = 0; t < T; t++) {
13
        string s;
14
        cin >> s;
15
        int n = s.size();
16
17
        // Compute prefix sums
18
        vector<int> prefix0(n + 1, 0);
19
        vector<int> prefix1(n + 1, 0);
20
        for (int i = 0; i < n; i++) {
21
            prefix0[i + 1] = prefix0[i] + (s[i] == '0' ? 1 : 0);
22
            prefix1[i + 1] = prefix1[i] + (s[i] == '1' ? 1 : 0);
23
        }
24
25
        // Initialize minimum cost with the case of removing everything
26
        int min_cost = prefix1[n];
27
28
        // Iterate over all possible ending indices b
29
        for (int b = 0; b < n; b++) {
30
            int k = prefix0[b + 1];               // '0's up to b
31
            int c = prefix1[n] - prefix1[b + 1];  // '1's from b+1 to n-1
32
33
            // Define cost function h(a)
34
            auto h = [&](int a) {
35
                int zeros_remaining = k - prefix0[a];
36
                int ones_removed = prefix1[a] + c;
37
                return max(zeros_remaining, ones_removed);
38
            };
39
40
            // Ternary search for optimal a in [0, b]
41
            int left = 0, right = b;
42
            while (right - left > 2) {
43
                int m1 = left + (right - left) / 3;
44
                int m2 = right - (right - left) / 3;
45
                if (h(m1) < h(m2)) {
46
                    right = m2;
47
                } else {
48
                    left = m1;
49
                }
50
            }
51
52
            // Check remaining points for exact minimum
53
            int local_min = INT_MAX;
54
            for (int a = left; a <= right; a++) {
55
                local_min = min(local_min, h(a));
56
            }
57
            min_cost = min(min_cost, local_min);
58
        }
59
60
        cout << min_cost << endl;
61
    }
62
    return 0;
63
}",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053035
1390053037,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    ans = float('inf')
5
6
    for i in range(n + 1):
7
        for j in range(n - i + 1):
8
            remaining = s[i:n-j]
9
            10
            zeros = 0
11
            for char in remaining:
12
                if char == '0':
13
                    zeros += 1
14
                    15
            ones_removed = 0
16
            for k in range(i):
17
                if s[k] == '1':
18
                    ones_removed += 1
19
            for k in range(n - j, n):
20
                if s[k] == '1':
21
                    ones_removed += 1
22
            23
            ans = min(ans, max(zeros, ones_removed))
24
            25
    print(ans)
26
27
t = int(input())
28
for _ in range(t):
29
    solve()",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053037
1390053025,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",156,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053025
1390053019,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_faulty_readings(sensor_data, batch_size):
4
    faulty_readings = []
5
    fault_indices = deque()
6
    7
    for index in range(len(sensor_data)):
8
        if fault_indices and fault_indices[0] < index - batch_size + 1:
9
            fault_indices.popleft()
10
        11
        if sensor_data[index] < 0:
12
            fault_indices.append(index)
13
        14
        if index >= batch_size - 1:
15
            faulty_readings.append(sensor_data[fault_indices[0]] if fault_indices else 0)
16
    17
    return faulty_readings
18
19
num_tests = int(input())
20
for _ in range(num_tests):
21
    array_size, batch_size = map(int, input().split())
22
    sensor_data = list(map(int, input().split()))
23
    24
    print(*find_faulty_readings(sensor_data, batch_size))",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053019
1390053017,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
3
using namespace std;
4
5
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
6
7
    int n = arr.size();
8
9
    vector<int> result;
10
11
    deque<int> dq;  // Stores indices of negative numbers
12
13
    // Process first window
14
15
    for (int i = 0; i < k; i++) {
16
17
        if (arr[i] < 0) dq.push_back(i);
18
19
    }
20
21
    // Process the sliding window
22
23
    for (int i = k; i <= n; i++) {
24
25
        // Append first negative number in the window
26
27
        if (!dq.empty()) 
28
29
            result.push_back(arr[dq.front()]);  // First negative in the deque
30
31
        else 
32
33
            result.push_back(0);  // No negative number
34
35
        // Remove elements that are out of the current window
36
37
        while (!dq.empty() && dq.front() < i - k + 1) {
38
39
            dq.pop_front();
40
41
        }
42
43
        // Add the next element if negative
44
45
        if (i < n && arr[i] < 0) {
46
47
            dq.push_back(i);
48
49
        }
50
51
    }
52
53
    return result;
54
55
}
56
57
int main() {
58
59
    int t;
60
61
    cin >> t;  // Number of test cases
62
63
    while (t--) {
64
65
        int n, k;
66
67
        cin >> n >> k;  // Size of array and batch size
68
69
        vector<int> arr(n);
70
71
        for (int i = 0; i < n; i++) {
72
73
            cin >> arr[i];
74
75
        }
76
77
        78
79
        vector<int> result = earliest_faulty_readings(arr, k);
80
81
        for (int num : result) {
82
83
            cout << num << "" "";
84
85
        }
86
87
        cout << endl;
88
89
    }
90
91
    return 0;
92
93
}",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053017
1390053022,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053022
1390053010,unknown,unknown,unknown,"1
def min_cost(server_str):
2
    n = len(server_str)
3
    prefix_1 = [0] * (n + 1)  # prefix count of 1s
4
    prefix_0 = [0] * (n + 1)  # prefix count of 0s
5
6
    for i in range(n):
7
        prefix_1[i + 1] = prefix_1[i] + (1 if server_str[i] == '1' else 0)
8
        prefix_0[i + 1] = prefix_0[i] + (1 if server_str[i] == '0' else 0)
9
10
    total_1 = prefix_1[n]
11
    total_0 = prefix_0[n]
12
13
    min_cost = float('inf')
14
15
    # Try removing l elements from the front
16
    for l in range(n + 1):
17
        # Try removing r elements from the back
18
        for r in range(n - l + 1):
19
            left = l
20
            right = n - r
21
            remaining_0 = prefix_0[right] - prefix_0[left]
22
            removed_1 = prefix_1[left] + (total_1 - prefix_1[right])
23
            cost = max(remaining_0, removed_1)
24
            min_cost = min(min_cost, cost)
25
26
    return min_cost
27
28
# Main driver
29
T = int(input())
30
for _ in range(T):
31
    server_str = input().strip()
32
    print(min_cost(server_str))
33",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390053010
1390053014,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053014
1390053016,unknown,unknown,unknown,"1
from collections import deque
2
import sys
3
4
def faculty(arr,kq):
5
    rs =[]
6
    dq= deque()
7
    8
    for i in range(len(arr)):
9
        if dq and dq[0] < i - kq + 1:
10
            dq.popleft()
11
        if arr[i]<0:
12
            dq.append(i)
13
        if i >= kq -1:
14
            rs.append(str(arr[dq[0]])if dq else ""0"")
15
    return "" "".join(rs)
16
17
if __name__==""__main__"":
18
    t=int(sys.stdin.readline().strip())
19
    20
    for _ in range(t):
21
        nm, kq = map(int, sys.stdin.readline().strip().split())
22
        arr=list(map(int,sys.stdin.readline().strip().split()))
23
        24
        print(faculty(arr,kq))",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053016
1390053006,unknown,unknown,unknown,"1
def earliest_faulty_reading():
2
    # Read number of test cases
3
    t = int(input().strip())
4
    results = []
5
6
    for _ in range(t):
7
        # Read size of array and batch size
8
        n, k = map(int, input().strip().split())
9
10
        # Read the array elements
11
        arr = list(map(int, input().strip().split()))
12
13
        # Result list for this test case
14
        result = []
15
16
        # Process each batch
17
        for i in range(n - k + 1):
18
            batch = arr[i:i + k]
19
            faulty = next((x for x in batch if x < 0), 0)
20
            result.append(faulty)
21
22
        # Store result as space-separated string
23
        results.append("" "".join(map(str, result)))
24
25
    # Print all results
26
    print(""\n"".join(results))
27
28
# Call the function to take input from user
29
earliest_faulty_reading()
30",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053006
1390053009,unknown,unknown,unknown,"1
import java.util.*;
2
import java.io.*;
3
4
public class FaultySensorReadings {
5
    public static void main(String[] args) throws IOException {
6
        Scanner sc = new Scanner(System.in);
7
        int t =sc.nextInt();
8
        9
        while(t--> 0) {
10
            int n = sc.nextInt();
11
            int k = sc.nextInt();
12
            13
            int[] arr = new int[n];
14
            for(int i = 0; i<n; i++) {
15
                arr[i] = sc.nextInt();
16
            }
17
            18
            List<Integer> result = findEarliestFaultyReadings(arr, n, k);
19
            for (int val:result) {
20
                System.out.print(val + "" "");
21
            }
22
            System.out.println();
23
        }
24
        sc.close();
25
    }
26
    27
    public static List<Integer> findEarliestFaultyReadings(int[] arr, int n, int k) {
28
        List<Integer> result = new ArrayList<>();
29
        Deque<Integer> deque = new LinkedList<>();
30
        31
        for (int i = 0; i<k; i++) {
32
            if (arr[i]<0){
33
                deque.addLast(i);
34
            }
35
        }
36
        37
        for (int i = k; i<=n; i++) {
38
            if (!deque.isEmpty()) {
39
                result.add(arr[deque.peekFirst()]);
40
            } else {
41
                result.add(0);
42
            }
43
            44
            while (!deque.isEmpty()  && deque.peekFirst() < i - k + 1) {
45
                deque.pollFirst();
46
            }
47
            48
            if (i<n && arr[i] < 0) {
49
                deque.addLast(i);
50
            }
51
        }
52
        53
        return result;
54
    }
55
}",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053009
1390053007,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    for n, k, arr in test_cases:
6
        dq = deque()
7
        res = []
8
        9
        # Process first k elements
10
        for i in range(k):
11
            if arr[i] < 0:
12
                dq.append(i)
13
        14
        # Process rest of the elements
15
        for i in range(n - k + 1):
16
            # Append the first negative number in the current window
17
            if dq:
18
                res.append(arr[dq[0]])
19
            else:
20
                res.append(0)
21
            22
            # Remove elements that are out of this window
23
            if dq and dq[0] == i:
24
                dq.popleft()
25
            26
            # Add next element if it's negative
27
            if i + k < n and arr[i + k] < 0:
28
                dq.append(i + k)
29
        30
        results.append("" "".join(map(str, res)))
31
    32
    return ""\n"".join(results)
33
34
# Read input
35
t = int(input().strip())
36
test_cases = []
37
for _ in range(t):
38
    n, k = map(int, input().strip().split())
39
    arr = list(map(int, input().strip().split()))
40
    test_cases.append((n, k, arr))
41
42
# Process and print output
43
print(earliest_faulty_readings(test_cases))",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390053007
1390053003,unknown,unknown,unknown,"1
defmin_effort_to_breach(n,firewalls):
2
    total_effort=sum(firewall)
3
    min_effort=total_effort
4
    for i in range(n):
5
        skipped_effort=total_effort-firealls[i]
6
        min_effort=min(min_effort,skipped_effort)
7
    return min_effort
8
t=int(raw_input(""enter number of testcae ""))
9
result=[]
10
for_in range(t):
11
    n=int(raw_input(""/nEnter number of firewalls:""))
12
    result.append(min_effort_to_breach(n,firewalls))
13
print""/noutput""
14
for res in result:
15
    print res",157,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390053003
1390052987,unknown,unknown,unknown,"1
def main():
2
    t = int(input())
3
    4
    for _ in range(t):
5
        n, k = map(int, input().split())
6
        strengths = list(map(int, input().split()))
7
        8
        if k >= n:
9
            print(0)
10
            continue
11
        12
        prev = [float('inf')] * (k + 1)
13
        prev[0] = 0
14
        15
        for i in range(n):
16
            curr = [float('inf')] * (k + 1)
17
            18
            for j in range(k + 1):
19
                if j > 0 and prev[j-1] != float('inf'):
20
                    curr[j] = min(curr[j], prev[j-1])
21
                22
                if prev[j] != float('inf'):
23
                    curr[j] = min(curr[j], prev[j] + strengths[i] + j)
24
            25
            prev = curr
26
        27
        print(min(prev))
28
29
if __name__ == ""__main__"":
30
    main()",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052987
1390052996,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    """"""
3
    Calculate the minimum effort needed to breach the network.
4
    5
    Args:
6
        n (int): Number of firewalls
7
        k (int): Maximum number of firewalls that can be skipped
8
        strengths (list): List of firewall strengths
9
    10
    Returns:
11
        int: Minimum effort required
12
    """"""
13
    # Edge case: if we can skip all firewalls
14
    if k >= n:
15
        return 0
16
        17
    # We need to find the optimal firewalls to skip
18
    # This is a combinatorial problem
19
    20
    # First, let's calculate the impact of skipping each firewall
21
    # Impact = firewall's strength - penalty to subsequent firewalls
22
    impacts = []
23
    24
    for i in range(n):
25
        # If we skip this firewall, we save its strength
26
        # But we impose a penalty of +1 on (n-i-1) remaining firewalls
27
        impact = strengths[i] - (n - i - 1)
28
        impacts.append((impact, i))
29
    30
    # Sort by impact in descending order
31
    impacts.sort(reverse=True)
32
    33
    # Select the k firewalls with the highest impact to skip
34
    to_skip = set(impacts[i][1] for i in range(k))
35
    36
    # Calculate the total effort
37
    total_effort = 0
38
    penalty = 0
39
    40
    for i in range(n):
41
        if i in to_skip:
42
            # Skip this firewall
43
            penalty += 1
44
        else:
45
            # Breach this firewall (with penalty applied)
46
            total_effort += strengths[i] + penalty
47
    48
    return total_effort
49
50
def solve_test_cases():
51
    """"""
52
    Process all test cases and return the minimum effort for each.
53
    """"""
54
    t = int(input())  # Number of test cases
55
    results = []
56
    57
    for _ in range(t):
58
        n, k = map(int, input().split())
59
        strengths = list(map(int, input().split()))
60
        results.append(min_effort_to_breach(n, k, strengths))
61
    62
    return results
63
64
# Main function to run the solution
65
def main():
66
    results = solve_test_cases()
67
    68
    # Print the results
69
    for result in results:
70
        print(result)
71
72
if __name__ == ""__main__"":
73
    main()",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052996
1390052997,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052997
1390052978,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, n, k):
4
    result = []
5
    dq = deque()  # Store indices of negative numbers
6
7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Process remaining windows
13
    for i in range(n - k + 1):
14
        # If deque is not empty, the front of the queue is the earliest negative
15
        if dq:
16
            result.append(arr[dq[0]])
17
        else:
18
            result.append(0)
19
20
        # Remove elements that are out of this window
21
        if dq and dq[0] == i:
22
            dq.popleft()
23
24
        # Add the next element of the window
25
        if i + k < n and arr[i + k] < 0:
26
            dq.append(i + k)
27
28
    print(*result)  # Print space-separated output
29
30
# Read input
31
t = int(input())  # Number of test cases
32
for _ in range(t):
33
    n, k = map(int, input().split())  # Size of array and batch size
34
    arr = list(map(int, input().split()))  # Array elements
35
    earliest_faulty_readings(arr, n, k)",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052978
1390052980,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc=new Scanner(System.in);
7
        int T=sc.nextInt();
8
9
        while(T-- > 0) {
10
            int n=sc.nextInt(),k=sc.nextInt();
11
            int[] a=new int[n];
12
            for(int i=0;i<n;i++) a[i]=sc.nextInt();
13
14
            List<Integer> idx=new ArrayList<>();
15
            for(int i=0;i<n;i++) idx.add(i);
16
            idx.sort((x,y)->Integer.compare(a[y],a[x]));
17
18
            Set<Integer> skip=new HashSet<>();
19
            for(int i=0;i<k;i++) skip.add(idx.get(i));
20
21
            long effort=0;
22
            int skipped=0;
23
            for(int i=0;i<n;i++) {
24
                if(skip.contains(i)) skipped++;
25
                else effort+=a[i]+skipped;
26
            }
27
            System.out.println(effort);
28
        }
29
        sc.close();
30
    }
31
}",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052980
1390052981,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first k elements
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process the remaining elements
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the current window
18
        while dq and dq[0] <= i - k:
19
            dq.popleft()
20
        21
        # Add the current element if it is faulty
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the result for this window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Read input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    print(*earliest_faulty_readings(arr, k))",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052981
1390052971,unknown,unknown,unknown,"1
t = int(input())  
2
3
for _ in range(t):
4
    n, k = map(int, input().split()) 
5
    arr = list(map(int, input().split()))  
6
    7
    for i in range(n - k + 1):  
8
        found = 0  
9
        for j in range(i, i + k):  
10
            if arr[j] < 0:
11
                found = arr[j]  
12
                break
13
        print(found, end="" "") 
14
    print() ",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052971
1390052976,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052976
1390052968,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  
7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    result.append(arr[dq[0]] if dq else 0)
12
    13
    for i in range(k, n):
14
        if dq and dq[0] < i - k + 1:
15
            dq.popleft()
16
        17
        if arr[i] < 0:
18
            dq.append(i)
19
20
        result.append(arr[dq[0]] if dq else 0)
21
    22
    return result
23
24
t = int(input())  # Number of test cases
25
for _ in range(t):
26
    n, k = map(int, input().split())
27
    arr = list(map(int, input().split()))
28
    print(*earliest_faulty_readings(arr, k))",158,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052968
1390052964,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
5
    results = []
6
7
    for n, k, arr in test_cases:
8
9
        dq = deque()
10
11
        res = []
12
13
        # Process first window
14
15
        for i in range(k):
16
17
            if arr[i] < 0:
18
19
                dq.append(i)
20
21
        # Store result for first window
22
23
        res.append(arr[dq[0]] if dq else 0)
24
25
        # Process remaining windows
26
27
        for i in range(k, n):
28
29
            # Remove elements not in the current window
30
31
            while dq and dq[0] < i - k + 1:
32
33
                dq.popleft()
34
35
            # Add new element if it's negative
36
37
            if arr[i] < 0:
38
39
                dq.append(i)
40
41
            # Store result for this batch
42
43
            res.append(arr[dq[0]] if dq else 0)
44
45
        results.append("" "".join(map(str, res)))
46
47
    return results
48
49
# Reading input
50
51
t = int(input())  # Number of test cases
52
53
test_cases = []
54
55
for _ in range(t):
56
57
    n, k = map(int, input().split())
58
59
    arr = list(map(int, input().split()))
60
61
    test_cases.append((n, k, arr))
62
63
# Processing and printing output
64
65
for result in earliest_faulty_readings(test_cases):
66
67
    print(result)",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052964
1390052965,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052965
1390052963,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
23
        # Create a list of tuples (a[i], i)
24
        firewall_indices = [(a[i], i) for i in range(n)]
25
        # Sort by a[i] - (n - i - 1) in descending order
26
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
27
        28
        # Select the top k firewalls to skip
29
        skip_indices = set()
30
        for i in range(min(k, n)):
31
            skip_indices.add(firewall_indices[i][1])
32
        33
        # Calculate the total effort
34
        total_effort = 0
35
        increase = 0
36
        for i in range(n):
37
            if i in skip_indices:
38
                increase += 1
39
            else:
40
                total_effort += a[i] + increase
41
        42
        results.append(total_effort)
43
    return results
44
45
# Read input
46
T = int(input())
47
test_cases = []
48
for _ in range(T):
49
    n, k = map(int, input().split())
50
    a = list(map(int, input().split()))
51
    test_cases.append((n, k, a))
52
53
# Compute results
54
results = min_effort(test_cases)
55
56
# Output results
57
for res in results:
58
    print(res)",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052963
1390052953,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
using ll = long long;
5
6
int main() {
7
    // Optimize input/output
8
    ios::sync_with_stdio(false);
9
    cin.tie(0);
10
11
    int T;
12
    cin >> T;
13
    for (int t = 0; t < T; t++) {
14
        int n, k;
15
        cin >> n >> k;
16
        vector<ll> a(n);
17
        for (int i = 0; i < n; i++) {
18
            cin >> a[i];
19
        }
20
21
        // INF for impossible states , really tough one to solved actually 
22
        const ll INF = 1e18;
23
24
        vector<ll> prev(k + 1, INF);
25
        prev[0] = 0; 
26
27
    28
        for (int i = 0; i < n; i++) {
29
            vector<ll> curr(k + 1, INF);
30
            for (int s = 0; s <= k; s++) {
31
                // Don't skip i
32
                curr[s] = prev[s] + a[i] + s;
33
                // Skip i (if possible)
34
                if (s > 0) {
35
                    curr[s] = min(curr[s], prev[s - 1]);
36
                }
37
            }
38
            prev = curr; 
39
        }
40
41
42
        ll ans = *min_element(prev.begin(), prev.end());
43
        cout << ans << '\n';
44
    }
45
    return 0;
46
}",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052953
1390052958,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052958
1390052961,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().strip().split())
3
    a = list(map(int, input().strip().split()))
4
5
    min_effort = float('inf')
6
7
    for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
8
        skipped_indices = []
9
        skipped_count = 0
10
        current_effort = 0
11
        current_a = a[:]  # Create a copy to avoid modifying the original list
12
13
        for j in range(n):
14
            if (i >> j) & 1:
15
                skipped_indices.append(j)
16
                skipped_count += 1
17
18
        if skipped_count <= k:
19
            skipped_indices.sort()
20
            offset = 0
21
            22
            for j in range(n):
23
                if j in skipped_indices:
24
                    offset += 1
25
                    continue
26
                else:
27
                    current_effort += current_a[j] + offset
28
29
            min_effort = min(min_effort, current_effort)
30
31
    print(min_effort)
32
33
T = int(input().strip())
34
for _ in range(T):
35
    solve()
36",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052961
1390052947,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner scanner=new Scanner(System.in);
6
        int testCases=scanner.nextInt();
7
        8
        for(int t=0;t<testCases;t++) {
9
            int n=scanner.nextInt();
10
            int k=scanner.nextInt();
11
            int[] arr=new int[n];
12
            13
            for(int i=0;i<n;i++) arr[i]=scanner.nextInt();
14
            15
            List<Integer> result=new ArrayList<>();
16
            for(int i=0;i<=n-k;i++) {
17
                int earliestFault=0;
18
                for(int j=i;j<i+k;j++) {
19
                    if(arr[j]<0) {
20
                        earliestFault=arr[j];
21
                        break;
22
                    }
23
                }
24
                result.add(earliestFault);
25
            }
26
            27
            for(int res:result) System.out.print(res+"" "");
28
            System.out.println();
29
        }
30
        31
        scanner.close();
32
    }
33
}",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052947
1390052944,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    result = []
3
    4
    for i in range(len(arr) - k + 1):
5
        # Check each batch of size k
6
        batch = arr[i:i+k]
7
        fault_found = False
8
        9
        # Find the earliest fault in the current batch
10
        for num in batch:
11
            if num < 0:
12
                result.append(num)
13
                fault_found = True
14
                break
15
        16
        # If no fault is found in the batch, append 0
17
        if not fault_found:
18
            result.append(0)
19
    20
    return result
21
22
# Process the input
23
t = int(input())  # Number of test cases
24
25
for _ in range(t):
26
    n, k = map(int, input().split())  # Array size and batch size
27
    arr = list(map(int, input().split()))  # Array elements
28
    29
    result = earliest_fault(arr, k)
30
    print(*result)  # Print the result",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052944
1390052951,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner sc=new Scanner(System.in);
8
        int tCase = sc.nextInt();
9
10
        l1: 
11
        while (tCase-- > 0) {
12
13
            14
            int n=sc.nextInt();
15
            int k=sc.nextInt();
16
            int[] arr=new int[n];
17
            long sum=0;
18
            for(int i=0; i<n; i++){
19
                arr[i]=sc.nextInt();
20
            }
21
            Arrays.sort(arr);
22
23
            for(int i=0; i<n-k; i++){
24
                sum+=(long)arr[i];
25
            }
26
            if(k!=n)sum+=k;
27
            System.out.println(sum);
28
            29
            30
            31
32
        }
33
    }
34
}",159,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052951
1390052934,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # If there is a negative element, record it; otherwise, record 0
13
    if dq:
14
        result.append(arr[dq[0]])
15
    else:
16
        result.append(0)
17
    18
    # Process the remaining windows
19
    for i in range(k, len(arr)):
20
        # Remove elements that are out of the current window
21
        if dq and dq[0] <= i - k:
22
            dq.popleft()
23
        24
        # Add current element if it's negative
25
        if arr[i] < 0:
26
            dq.append(i)
27
        28
        # Append the earliest negative or 0
29
        if dq:
30
            result.append(arr[dq[0]])
31
        else:
32
            result.append(0)
33
    34
    return result
35
36
# Input and Output Handling
37
t = int(input())
38
for _ in range(t):
39
    n, k = map(int, input().split())
40
    arr = list(map(int, input().split()))
41
    result = earliest_faulty_reading(arr, k)
42
    print(' '.join(map(str, result)))
43",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052934
1390052935,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
5
int main() {
6
    int t;
7
    cin>>t;
8
    9
    while(t--)
10
    {
11
        int n,k;
12
        cin>>n>>k;
13
        14
        vector<int> input(n);
15
        for(int i=0;i<n;i++)
16
        {
17
            int ele;
18
            cin>>ele;
19
            20
            input[i]=ele;
21
        }
22
        23
        vector<int> ans;
24
        25
        int i=0;
26
        int j=0;
27
        28
        queue<int> q;//would store indices of -ve
29
        30
        while(j<k)
31
        {
32
            if(input[j]<0)
33
                q.push(j);
34
            35
            j++;
36
        }
37
        j--;
38
    39
        while(j<n)
40
        {   
41
            if(q.empty())
42
                ans.push_back(0);
43
            44
            else
45
            ans.push_back(input[q.front()]);
46
            47
            48
            if(q.front()==i)
49
                q.pop();
50
            51
            i++;
52
            j++;
53
            54
            if(j<n && input[j]<0)
55
                q.push(j);
56
        }
57
        58
        for(auto &el:ans)
59
            cout<<el<<"" "";
60
        61
        cout<<endl;
62
        63
    }
64
    return 0;
65
}",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052935
1390052939,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
vector<int> faults(vector<int>& arr, int n, int k){
9
    vector<int> ans;
10
    for(int i=0; i<=n-k; i++){
11
        int eFault = 0;
12
        for(int j=i; j<i+k; j++){
13
            if(arr[j]<0){
14
                eFault = arr[j];
15
                break;
16
            }
17
        }
18
        ans.push_back(eFault);
19
    }
20
    return ans;
21
}
22
23
int main() {
24
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */  
25
    int t;
26
    cin>>t;
27
    while(t--){
28
        int n, k;
29
        cin>>n>>k;
30
        vector<int> arr(n);
31
        for(int i=0; i<n; i++){
32
            cin>>arr[i];
33
        }
34
        vector<int> ans;
35
        ans = faults(arr, n, k);
36
        for(int val: ans){
37
            cout<<val<<"" "";
38
        }
39
        cout<<endl;
40
    }
41
    return 0;
42
}",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052939
1390052930,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
3
t = int(input())
4
5
while t:
6
    a, b = map(int, input().split())
7
    c = list(map(int, input().split()))
8
    ans = []
9
    for i in range(0, len(c)-int(b)+1):
10
        for j in c[i:i+b]:
11
            if j < 0:
12
                ans.append(j)
13
                break
14
        else:
15
            ans.append(0)
16
    for i in ans:
17
        print(i, end="" "")
18
    print()
19
    t -= 1",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052930
1390052932,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    int T;
10
    cin >> T;
11
    while (T--) {
12
        string s;
13
        cin >> s;
14
        int n = s.length();
15
16
        // Count total active servers (1s) and idle servers (0s)
17
        int totalOnes = 0, totalZeros = 0;
18
        for (char c : s) {
19
            if (c == '1') totalOnes++;
20
            else totalZeros++;
21
        }
22
23
        int minCost = n; // Worst case
24
25
        // Try all combinations of prefix (left) and suffix (right) removals
26
        // Prefix i = number of characters removed from start
27
        for (int prefix = 0; prefix <= n; prefix++) {
28
            int onesRemovedLeft = 0;
29
            int zerosRemovedLeft = 0;
30
            for (int i = 0; i < prefix; i++) {
31
                if (s[i] == '1') onesRemovedLeft++;
32
                else zerosRemovedLeft++;
33
            }
34
35
            // Now, try all possible suffix removals
36
            for (int suffix = 0; suffix <= n - prefix; suffix++) {
37
                int onesRemovedRight = 0;
38
                int zerosRemovedRight = 0;
39
                for (int i = n - suffix; i < n; i++) {
40
                    if (s[i] == '1') onesRemovedRight++;
41
                    else zerosRemovedRight++;
42
                }
43
44
                int totalOnesRemoved = onesRemovedLeft + onesRemovedRight;
45
                int totalZerosRemoved = zerosRemovedLeft + zerosRemovedRight;
46
                int remainingZeros = totalZeros - totalZerosRemoved;
47
48
                int cost = max(remainingZeros, totalOnesRemoved);
49
                minCost = min(minCost, cost);
50
            }
51
        }
52
53
        cout << minCost << endl;
54
    }
55
    return 0;
56
}
57",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052932
1390052931,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static long minEffort(int[] f, int n, int k) {
6
        long[] dp=new long[n+1];
7
        Arrays.fill(dp,Long.MAX_VALUE);
8
        dp[n]=0;
9
        10
        for(int i=n-1;i>=0;i--) {
11
            long str=f[i];
12
            for(int j=0;j<=k && i+j<=n;j++) {
13
                if(j==0) dp[i]=Math.min(dp[i],str+dp[i+1]);
14
                else {
15
                    long e=(i+j<n)?dp[i+j+1]+j:0;
16
                    for(int m=i+j;m<n;m++) e+=f[m];
17
                    dp[i]=Math.min(dp[i],e);
18
                }
19
            }
20
        }
21
        return dp[0];
22
    }
23
    public static void main(String[] args) {
24
        Scanner sc=new Scanner(System.in);
25
        int t=sc.nextInt();
26
        while(t-- > 0) {
27
            int n=sc.nextInt(),k=sc.nextInt();
28
            int[] f=new int[n];
29
            for(int i=0;i<n;i++) f[i]=sc.nextInt();
30
            System.out.println(minEffort(f,n,k));
31
        }
32
        sc.close();
33
    }
34
}",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052931
1390052927,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_fault_in_batches(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    for i in range(len(arr) - k + 1):
12
        if dq:
13
            result.append(arr[dq[0]])
14
        else:
15
            result.append(0)
16
        17
        while dq and dq[0] < i + 1:
18
            dq.popleft()
19
        20
        if i + k < len(arr) and arr[i + k] < 0:
21
            dq.append(i + k)
22
    23
    return result
24
25
# Read input
26
t = int(input())
27
for _ in range(t):
28
    n, k = map(int, input().split())
29
    arr = list(map(int, input().split()))
30
    print(*earliest_fault_in_batches(arr, k))",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052927
1390052928,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
int main() {
9
    int t;
10
    cin >> t;
11
    12
    while (t--) {
13
        int n, k;
14
        cin >> n >> k;
15
        int arr[n];
16
        for (int i = 0; i < n; i++) {
17
            cin >> arr[i];
18
        }
19
20
        for (int i = 0; i <= n - k; i++) {
21
            int sign = 0;
22
            for (int j = i; j < i + k; j++) {
23
                if (arr[j] < 0) {
24
                    cout << arr[j] << "" "";
25
                    sign = 1;
26
                    break; 
27
                }
28
            }
29
            if (!sign) {
30
                cout << ""0 "";
31
            }
32
        }
33
        cout << endl;  
34
    }
35
36
    return 0;
37
}
38",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052928
1390052929,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(t, test_cases):
4
5
    results = []
6
7
    8
9
    for case in test_cases:
10
11
        n, k, readings = case
12
13
        result = []
14
15
        dq = deque()  # Stores indices of negative numbers
16
17
        # Process the first window
18
19
        for i in range(k):
20
21
            if readings[i] < 0:
22
23
                dq.append(i)
24
25
        # Process the sliding windows
26
27
        for i in range(n - k + 1):
28
29
            # Append the first negative in the deque, or 0 if empty
30
31
            result.append(readings[dq[0]] if dq else 0)
32
33
            # Remove elements that are out of this window
34
35
            if dq and dq[0] == i:
36
37
                dq.popleft()
38
39
            # Add next element (i + k) to the deque if it's negative
40
41
            if i + k < n and readings[i + k] < 0:
42
43
                dq.append(i + k)
44
45
        results.append("" "".join(map(str, result)))  # Convert list to space-separated string
46
47
    48
49
    return ""\n"".join(results)
50
51
# Example Usage
52
53
t = 2
54
55
test_cases = [
56
57
    (5, 2, [-8, 2, 3, -6, 10]),
58
59
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
60
61
]
62
63
print(earliest_faulty_readings(t, test_cases))",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052929
1390052926,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",160,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052926
1390052922,unknown,unknown,unknown,"1
def min_decommissioning_cost(test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        total_zeros = servers.count('0')
7
        total_ones = servers.count('1')
8
        9
        min_cost = float('inf')
10
        11
        for i in range(n + 1):  
12
            for j in range(n + 1):  
13
                if i + j > n:
14
                    continue 
15
                16
                active_decommissioned = servers[:i].count('1') + servers[n-j:].count('1')
17
                18
                remaining_zeros = total_zeros - (servers[:i].count('0') + servers[n-j:].count('0'))
19
                20
                cost = max(active_decommissioned, remaining_zeros)
21
                22
                min_cost = min(min_cost, cost)
23
        24
        results.append(min_cost)
25
    26
    return results
27
28
T = int(input())
29
test_cases = [input().strip() for _ in range(T)]
30
31
results = min_decommissioning_cost(test_cases)
32
33
for result in results:
34
    print(result)",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052922
1390052925,unknown,unknown,unknown,"1
def min_cost(servers):
2
    n = len(servers)
3
    min_cost_val = float('inf')
4
5
    for i in range(n + 1): 
6
        for j in range(n - i + 1):  
7
            remaining_servers = servers[i:n - j]
8
            9
            idle_count = remaining_servers.count('0')
10
            active_removed = servers[:i].count('1') + servers[n - j:].count('1')
11
            12
            cost = max(idle_count, active_removed)
13
            min_cost_val = min(min_cost_val, cost)
14
            15
    return min_cost_val
16
17
if __name__ == ""__main__"":
18
    t = int(input())
19
    for _ in range(t):
20
        servers = input()
21
        print(min_cost(servers))",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052925
1390052921,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
    8
    9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
  14
    result.append(arr[dq[0]] if dq else 0)
15
16
    17
    for i in range(k, n):
18
       19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
def process_test_cases():
32
    t = int(input())  
33
    results = []
34
    35
    for _ in range(t):
36
        n, k = map(int, input().split())  
37
        arr = list(map(int, input().split()))  
38
        39
        results.append(earliest_faulty_readings(arr, k))
40
    41
    42
    for res in results:
43
        print(*res)
44
45
46
process_test_cases()
47",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052921
1390052917,unknown,unknown,unknown,"1
def minimum_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        if k >= n:
6
            results.append(0)
7
            continue
8
        9
        # Calculate the total effort if no firewalls are skipped
10
        total_effort = sum(a)
11
        12
        # Calculate the reduction for each firewall if it were skipped
13
        # The reduction is a[i] - (number of firewalls after it)
14
        # Because each skipped firewall increases the strength of all subsequent firewalls by 1
15
        reduction = []
16
        for i in range(n):
17
            reduction.append(a[i] - (n - i - 1))
18
        19
        # Sort the reduction values in descending order
20
        reduction.sort(reverse=True)
21
        22
        # Sum the top k reductions
23
        max_reduction = sum(reduction[:k])
24
        25
        # Subtract the maximum reduction from the total effort
26
        results.append(total_effort - max_reduction)
27
    return results
28
29
def main():
30
    import sys
31
    input = sys.stdin.read
32
    data = input().split()
33
    idx = 0
34
    T = int(data[idx])
35
    idx += 1
36
    test_cases = []
37
    for _ in range(T):
38
        n, k = int(data[idx]), int(data[idx + 1])
39
        idx += 2
40
        a = list(map(int, data[idx:idx + n]))
41
        idx += n
42
        test_cases.append((n, k, a))
43
    results = minimum_effort(test_cases)
44
    for res in results:
45
        print(res)
46
47
if __name__ == ""__main__"":
48
    main()",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052917
1390052919,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        # Calculate the potential reduction for each firewall if skipped
6
        # Reduction for a[i] is a[i] - (number of firewalls after it) * 1
7
        # Because skipping it increases the strength of all subsequent firewalls by 1
8
        # So, the net reduction is a[i] - (n - i - 1)
9
        reductions = []
10
        for i in range(n):
11
            reductions.append(a[i] - (n - i - 1))
12
        13
        # Select the top k reductions (most positive)
14
        # If a reduction is negative, it's better not to skip that firewall
15
        # So, we only consider positive reductions
16
        positive_reductions = [r for r in reductions if r > 0]
17
        positive_reductions.sort(reverse=True)
18
        19
        # Take the top min(k, len(positive_reductions)) reductions
20
        skip_count = min(k, len(positive_reductions))
21
        total_reduction = sum(positive_reductions[:skip_count])
22
        23
        # Calculate the total effort
24
        # Initial total effort is sum(a)
25
        # After skipping, the total effort is sum(a) - total_reduction
26
        # Because the skipped firewalls are reduced by their a[i], but the subsequent firewalls are increased by skip_count
27
        # Wait, no. The total effort is sum(a) - sum of a[i] for skipped firewalls + skip_count * (number of firewalls after the last skipped firewall)
28
        # This is getting complicated. Let's think differently.
29
        30
        # Alternative approach:
31
        # Sort the firewalls in descending order of a[i] - (n - i - 1)
32
        # Skip the top k firewalls in this order
33
        # Calculate the total effort accordingly
34
        35
        # Let's implement this alternative approach
36
        # Create a list of tuples (a[i], i)
37
        firewall_indices = [(a[i], i) for i in range(n)]
38
        # Sort by a[i] - (n - i - 1) in descending order
39
        firewall_indices.sort(key=lambda x: x[0] - (n - x[1] - 1), reverse=True)
40
        41
        # Select the top k firewalls to skip
42
        skip_indices = set()
43
        for i in range(min(k, n)):
44
            skip_indices.add(firewall_indices[i][1])
45
        46
        # Calculate the total effort
47
        total_effort = 0
48
        increase = 0
49
        for i in range(n):
50
            if i in skip_indices:
51
                increase += 1
52
            else:
53
                total_effort += a[i] + increase
54
        55
        results.append(total_effort)
56
    return results
57
58
# Read input
59
T = int(input())
60
test_cases = []
61
for _ in range(T):
62
    n, k = map(int, input().split())
63
    a = list(map(int, input().split()))
64
    test_cases.append((n, k, a))
65
66
# Compute results
67
results = min_effort(test_cases)
68
69
# Output results
70
for res in results:
71
    print(res)",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052919
1390052920,unknown,unknown,unknown,"1
def solution(n, k, arr):
2
    result = []
3
    4
    for i in range(n - k + 1):  
5
        found_faulty = False
6
        for j in range(k):
7
            if arr[i + j] < 0:
8
                result.append(arr[i + j]) 
9
                found_faulty = True
10
                break
11
        if not found_faulty:
12
            result.append(0)  
13
    14
    return "" "".join(map(str, result))  
15
16
17
t = int(input())
18
for _ in range(t):
19
    n, k = map(int, input().split())
20
    arr = list(map(int, input().split()))
21
    print(solution(n, k, arr))",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052920
1390052906,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of this window
18
        if dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
        21
        # Add new element if it's negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store result for the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Reading input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    36
    print(*earliest_faulty_readings(arr, k))",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052906
1390052908,unknown,unknown,unknown,"1
def calculate_minimum_cost(rack):
2
    n = len(rack)
3
    min_cost = float('inf')
4
    5
    for i in range(n+1):
6
        for j in range(n+1):
7
            if i + j <= n:
8
                remaining_rack = rack[i:n-j]
9
                idle_servers = remaining_rack.count('0')
10
                active_servers_removed = rack[:i].count('1') + rack[n-j:].count('1')
11
                cost = max(idle_servers, active_servers_removed)
12
                min_cost = min(min_cost, cost)
13
    14
    return min_cost
15
16
def process_test_cases():
17
    t = int(input()) 
18
    for _ in range(t):
19
        rack = input().strip()  
20
        print(calculate_minimum_cost(rack))
21
22
23
process_test_cases()
24",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052908
1390052910,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Solution {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
        while (t-- > 0) {
9
            int n = scanner.nextInt();
10
            int k = scanner.nextInt();
11
            int[] a = new int[n];
12
            for (int j = 0; j < n; j++) {
13
                a[j] = scanner.nextInt();
14
            }
15
            solve(n, k, a);
16
        }
17
        scanner.close();
18
    }
19
20
    public static void solve(int n, int k, int[] a) {
21
        long minEffort = Long.MAX_VALUE;
22
23
        // Try all possible combinations of skipping elements
24
        for (int i = 0; i < (1 << n); i++) {
25
            int skippedCount = 0;
26
            // Count how many elements are skipped in this combination
27
            for (int j = 0; j < n; j++) {
28
                if ((i & (1 << j)) != 0) {
29
                    skippedCount++;
30
                }
31
            }
32
33
            // If the number of skipped elements is within the allowed limit
34
            if (skippedCount <= k) {
35
                long effort = 0;
36
                int increasedStrength = 0;
37
                int skippedIndex = 0;
38
                int[] skipped = new int[skippedCount];
39
                int skippedPtr = 0;
40
                //store the indexes of the skipped elements
41
                for (int j = 0; j < n; j++){
42
                    if((i & (1 << j)) != 0){
43
                        skipped[skippedPtr++] = j;
44
                    }
45
                }
46
47
                // Calculate the effort for this combination
48
                for (int j = 0; j < n; j++) {
49
                    // If this element is skipped, increase strength
50
                    if (skippedIndex < skippedCount && skipped[skippedIndex] == j) {
51
                        increasedStrength++;
52
                        skippedIndex++;
53
                    } else {
54
                        // Otherwise, add effort
55
                        effort += (long) a[j] + increasedStrength;
56
                    }
57
                }
58
59
                // Update the minimum effort if this combination is better
60
                minEffort = Math.min(minEffort, effort);
61
            }
62
        }
63
64
        System.out.println(minEffort);
65
    }
66
}",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052910
1390052905,unknown,unknown,unknown,"1
def earliest_faulty_readings(test_cases):
2
    results = []
3
    for _ in range(test_cases):
4
        n, k = map(int, input().split())
5
        arr = list(map(int, input().split()))
6
        result = []
7
        for i in range(n - k + 1):
8
            batch = arr[i:i+k]
9
            faulty = 0
10
            for num in batch:
11
                if num < 0:
12
                    faulty = num
13
                    break
14
            result.append(faulty)
15
        results.append(result)
16
    return results
17
18
# Read the number of test cases
19
test_cases = int(input())
20
results = earliest_faulty_readings(test_cases)
21
22
# Print the results
23
for result in results:
24
    print(' '.join(map(str, result)) + ' ')",161,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052905
1390052899,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store result for first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process remaining windows
17
    for i in range(k, n):
18
        # Remove out-of-window elements
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add new element if it's negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Append the earliest fault or 0 if none
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())
35
    arr = list(map(int, input().split()))
36
    print(*earliest_faulty_readings(arr, k))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052899
1390052902,unknown,unknown,unknown,"1
from collections import deque
2
def faul_read(arr, k):
3
    n = len(arr)
4
    res = []
5
    dq = deque()
6
7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
11
    res.append(arr[dq[0]] if dq else 0)
12
    13
    for i in range(k, n):
14
        if dq and dq[0] < i - k + 1:
15
            dq.popleft()
16
        if arr[i] < 0:
17
            dq.append(i)
18
        res.append(arr[dq[0]] if dq else 0)
19
    20
    return res
21
22
t = int(input())
23
24
for _ in range(t):
25
    n, k = map(int, input().split()) 
26
    arr = list(map(int, input().split())) 
27
28
    print(*faul_read(arr, k))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052902
1390052904,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    result.append(arr[dq[0]] if dq else 0)
12
    13
    for i in range(k, len(arr)):
14
        15
        if dq and dq[0] <= i - k:
16
            dq.popleft()
17
        18
        if arr[i] < 0:
19
            dq.append(i)
20
        21
        22
        result.append(arr[dq[0]] if dq else 0)
23
    24
    print(*result)
25
26
27
t = int(input())
28
for _ in range(t):
29
    n, k = map(int, input().split())
30
    arr = list(map(int, input().split()))
31
    earliest_faulty_readings(arr, k)
32",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052904
1390052898,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include<bits/stdc++.h>
7
using namespace std;
8
9
vector<int> solve(vector<int>& arr, int k){
10
    int n = arr.size();
11
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
12
    13
    for(int i=0; i<n; i++){
14
        if(arr[i]<0) pq.push({i,arr[i]});
15
    }
16
    17
    vector<int> ans;
18
    for(int i=k-1; i<n; i++){
19
        int idx=-1,val=INT_MAX;
20
        if(!pq.empty()){
21
            idx=pq.top().first;
22
            val=pq.top().second;
23
        }
24
        if(idx<=i && val<0) ans.push_back(val);
25
        else ans.push_back(0);
26
        27
        while(!pq.empty() && pq.top().first<=i-k+1){
28
            pq.pop();
29
        }
30
    }
31
    32
    return ans;
33
}
34
35
int main() {
36
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */ 
37
    int t;
38
    cin>>t;
39
    while(t--){
40
        int n,k;
41
        cin>>n>>k;
42
        vector<int> arr(n);
43
        for(int i=0; i<n; i++) cin>>arr[i];
44
        45
        vector<int> ans = solve(arr,k);
46
        47
        for(auto &i : ans) cout<<i<<"" "";
48
        cout<<endl;
49
    }
50
    return 0;
51
}",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052898
1390052893,unknown,unknown,unknown,"1
def minimum_effort(n, k, arr):
2
    total_sum = sum(arr)
3
    4
    if k == n:
5
        return 0
6
    7
    prefix_sum = [0] * (n + 1)
8
    9
    for i in range(1, n + 1):
10
        prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]
11
12
    min_effort = total_sum
13
    14
    for start in range(n - k + 1):
15
        skip_sum = prefix_sum[start + k] - prefix_sum[start]
16
        remaining_effort = total_sum - skip_sum + (n - (start + k))
17
        min_effort = min(min_effort, remaining_effort)
18
    19
    return min_effort
20
21
t = int(input())
22
for _ in range(t):
23
    n, k = map(int, input().split())
24
    arr = list(map(int, input().split()))
25
    result = minimum_effort(n, k, arr)
26
    print(result)",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052893
1390052884,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  
7
    8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    result.append(arr[dq[0]] if dq else 0)
13
    14
    for i in range(k, n):
15
        if dq and dq[0] < i - k + 1:
16
            dq.popleft()
17
        18
        if arr[i] < 0:
19
            dq.append(i)
20
        21
        result.append(arr[dq[0]] if dq else 0)
22
    23
    return result
24
25
t = int(input())  
26
for _ in range(t):
27
    n, k = map(int, input().split())  
28
    arr = list(map(int, input().split()))  
29
    30
    print(*earliest_faulty_readings(arr, k))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052884
1390052885,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
3
    total_effort = sum(firewalls)
4
    5
 6
    if k == n:
7
        return 0
8
9
   10
    min_effort = total_effort  
11
    12
    for i in range(n):
13
        14
        skipped_effort = total_effort - firewalls[i] 
15
        increased_security = (n - i - 1) 
16
        skipped_effort += increased_security  
17
        18
        min_effort = min(min_effort, skipped_effort)
19
    20
    return min_effort
21
22
# Read input
23
T = int(input())
24
for _ in range(T):
25
    n, k = map(int, input().split())
26
    firewalls = list(map(int, input().split()))
27
    print(min_effort_to_breach(n, k, firewalls))
28",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052885
1390052887,unknown,unknown,unknown,"1
def ans(x):
2
    n = len(x)
3
    min_cost = float('inf')
4
    for left in range(n + 1):
5
        for right in range(n + 1):
6
            if left + right > n:
7
                continue
8
            rem = x[left:n - right]
9
            idle_rem = rem.count('0')
10
            act_dec = x[:left].count('1') + x[n - right:].count('1')
11
            cost = max(idle_rem, act_dec)
12
            if cost < min_cost:
13
                min_cost = cost
14
    return min_cost
15
T = int(input())
16
for _ in range(T):
17
    x = input().strip()
18
    print(ans(x))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052887
1390052883,unknown,unknown,unknown,"1
def earliest_faulty_in_batches(arr, n, k):
2
    result = []
3
    for i in range(n - k + 1):
4
        batch = arr[i:i + k]
5
        found_fault = False
6
        for num in batch:
7
            if num < 0:
8
                result.append(num)
9
                found_fault = True
10
                break
11
12
        if not found_fault:
13
            result.append(0)
14
    15
    return result
16
17
t = int(input().strip())
18
outputs = []
19
20
for _ in range(t):
21
    n, k = map(int, input().strip().split())
22
    arr = list(map(int, input().strip().split()))
23
    outputs.append(earliest_faulty_in_batches(arr, n, k))
24
25
for output in outputs:
26
    print("" "".join(map(str, output)))",162,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052883
1390052871,unknown,unknown,unknown,"1
def minimize_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    4
    # Create list of (value + index) for each firewall
5
    skip_value = []
6
    for i in range(n):
7
        skip_value.append((firewalls[i] + i, i))
8
9
    # Sort by descending benefit to skip
10
    skip_value.sort(reverse=True)
11
12
    # Mark which firewalls to skip
13
    skipped = [0] * n
14
    for i in range(k):
15
        _, idx = skip_value[i]
16
        skipped[idx] = 1
17
18
    # Now calculate final effort
19
    effort = 0
20
    penalty = 0
21
    for i in range(n):
22
        if skipped[i]:
23
            penalty += 1
24
        else:
25
            effort += firewalls[i] + penalty
26
27
    return effort
28
29
# Main driver
30
T = int(input())
31
for _ in range(T):
32
    n, k = map(int, input().split())
33
    firewalls = list(map(int, input().split()))
34
    print(minimize_effort(n, k, firewalls))
35
36
    ",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052871
1390052875,unknown,unknown,unknown,"1
def min_firewall_effort(n, k, firewalls):
2
    min_effort = float('inf')
3
4
    for i in range(1 << n):  
5
        skipped_count = bin(i).count('1')
6
        if skipped_count <= k:
7
            current_effort = 0
8
            current_firewalls = firewalls[:]  
9
            skipped_indices = []
10
11
            for j in range(n):
12
                if (i >> j) & 1:
13
                    skipped_indices.append(j)
14
15
            skipped_indices.sort()
16
            17
            for index in skipped_indices:
18
                for l in range(index + 1, n):
19
                    current_firewalls[l] += 1
20
21
            for j in range(n):
22
                if not (i >> j) & 1:
23
                    current_effort += current_firewalls[j]
24
25
            min_effort = min(min_effort, current_effort)
26
27
    return min_effort
28
29
if __name__ == ""__main__"":
30
    t = int(input())
31
    for _ in range(t):
32
        n, k = map(int, input().split())
33
        firewalls = list(map(int, input().split()))
34
        result = min_firewall_effort(n, k, firewalls)
35
        print(result)
36",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052875
1390052880,unknown,unknown,unknown,"1
def min_decommission_cost(test_cases):
2
    results = []
3
    for s in test_cases:
4
        first, last = s.find('1'), s.rfind('1')
5
        if first == -1: 
6
            results.append(0)
7
            continue
8
9
        # Count 0's between the first and last '1'
10
        idle_servers = s[first:last + 1].count('0')
11
12
        # Count 1's outside the range [first, last]
13
        active_removed = s[:first].count('1') + s[last + 1:].count('1')
14
15
        results.append(max(idle_servers, active_removed))
16
17
    return results
18
19
t = int(input())
20
test_cases = [input().strip() for _ in range(t)]
21
22
for output in min_decommission_cost(test_cases):
23
    print(output)
24",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052880
1390052865,unknown,unknown,unknown,"1
def calculate_minimum_cost(rack):
2
    n = len(rack)
3
    min_cost = float('inf')
4
    5
    for i in range(n+1):
6
        for j in range(n+1):
7
            if i + j <= n:
8
                remaining_rack = rack[i:n-j]
9
                idle_servers = remaining_rack.count('0')
10
                active_servers_removed = rack[:i].count('1') + rack[n-j:].count('1')
11
                cost = max(idle_servers, active_servers_removed)
12
                min_cost = min(min_cost, cost)
13
    14
    return min_cost
15
16
def process_test_cases():
17
    t = int(input())  
18
    for _ in range(t):
19
        rack = input().strip()  
20
        print(calculate_minimum_cost(rack))
21
22
23
process_test_cases()
24",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052865
1390052869,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        if k == n:
6
            results.append(""0"")  # If we can skip all firewalls, effort is 0
7
            continue
8
9
        total_effort = sum(firewalls)
10
        min_effort = total_effort
11
12
        # Compute initial window sum of the first k firewalls
13
        window_sum = sum(firewalls[:k])
14
        15
        # Calculate the increasing penalty sum dynamically
16
        penalty_sum = k * (k + 1) // 2  # Sum of first k natural numbers
17
18
        for i in range(n - k + 1):
19
            new_effort = total_effort - window_sum + penalty_sum
20
            min_effort = min(min_effort, new_effort)
21
22
            # Move the sliding window
23
            if i + k < n:
24
                window_sum = window_sum - firewalls[i] + firewalls[i + k]
25
26
        results.append(str(min_effort))
27
28
    return ""\n"".join(results)
29
30
# Read input
31
T = int(input())
32
test_cases = []
33
34
for _ in range(T):
35
    n, k = map(int, input().split())
36
    firewalls = list(map(int, input().split()))
37
    test_cases.append((n, k, firewalls))
38
39
# Compute and print results
40
print(min_effort_to_breach(T, test_cases))
41",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052869
1390052867,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
        Scanner sc = new Scanner(System.in);
9
        int T = sc.nextInt();
10
        while (T-- > 0) {
11
            String rack = sc.next();
12
            int n = rack.length();
13
            int[] prefixZero = new int[n + 1];
14
            int[] prefixOne = new int[n + 1];
15
            for (int i = 0; i < n; i++) {
16
                prefixZero[i + 1] = prefixZero[i] + (rack.charAt(i) == '0' ? 1 : 0);
17
                prefixOne[i + 1] = prefixOne[i] + (rack.charAt(i) == '1' ? 1 : 0);
18
            }
19
20
            int minCost = n;
21
            for (int i = 0; i <= n; i++) {
22
                int onesInPrefix = prefixOne[i];
23
                int zerosBefore = prefixZero[i];
24
                for (int j = 0; j <= n - i; j++) {
25
                    // Remaining segment: from index i to (n-1-j)
26
                    int onesInSuffix = prefixOne[n] - prefixOne[n - j];
27
                    int zerosInSuffix = prefixZero[n] - prefixZero[n - j];
28
                    int idleRemaining = (prefixZero[n] - zerosBefore - zerosInSuffix);
29
                    int activeDecommissioned = onesInPrefix + onesInSuffix;
30
                    int cost = Math.max(idleRemaining, activeDecommissioned);
31
                    minCost = Math.min(minCost, cost);
32
                }
33
            }
34
            // Special case: must decommission at least from the beginning
35
            if (minCost == prefixOne[n] && prefixOne[n] > 0) {
36
                minCost = Math.min(minCost, Math.max(prefixZero[n], prefixOne[n] - prefixOne[1]));
37
            }
38
            System.out.println(minCost);
39
        }
40
        sc.close();
41
    }
42
}",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052867
1390052861,unknown,unknown,unknown,"1
def min_effort_to_breach(test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        min_effort = sum(firewalls)  # Default case: No skips
6
        7
        for i in range(n - k + 1):  # Try skipping from each valid position
8
            effort = sum(firewalls[:i])  # Effort before skipped firewalls
9
            extra_security = 0
10
            11
            for j in range(i, n):
12
                if j - i < k:  # Skip up to k firewalls
13
                    extra_security += 1
14
                else:
15
                    effort += firewalls[j] + extra_security  # Apply increment effect
16
            17
            min_effort = min(min_effort, effort)
18
        19
        results.append(min_effort)
20
    21
    return ""\n"".join(map(str, results))
22
23
# Read input
24
t = int(input())
25
test_cases = []
26
for _ in range(t):
27
    n, k = map(int, input().split())
28
    firewalls = list(map(int, input().split()))
29
    test_cases.append((n, k, firewalls))
30
31
# Compute and print results
32
print(min_effort_to_breach(test_cases))
33",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052861
1390052862,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner s = new Scanner(System.in);
6
        int t = s.nextInt();  // Number of test cases
7
        8
        while (t-- > 0) {
9
            int n = s.nextInt();
10
            int k = s.nextInt();
11
            int[] arr = new int[n];
12
13
            for (int i = 0; i < n; i++) {
14
                arr[i] = s.nextInt();
15
            }
16
17
            // Using a queue to track the index of negative numbers
18
            Queue<Integer> queue = new LinkedList<>();
19
            int i = 0;
20
21
            // Process first window
22
            for (i = 0; i < k; i++) {
23
                if (arr[i] < 0) {
24
                    queue.add(i);
25
                }
26
            }
27
28
            // Process remaining windows
29
            for (; i < n; i++) {
30
                // Print first negative number of previous window
31
                if (!queue.isEmpty()) {
32
                    System.out.print(arr[queue.peek()] + "" "");
33
                } else {
34
                    System.out.print(""0 "");
35
                }
36
37
                // Remove elements that are out of this window
38
                while (!queue.isEmpty() && queue.peek() <= i - k) {
39
                    queue.poll();
40
                }
41
42
                // Add current element if it's negative
43
                if (arr[i] < 0) {
44
                    queue.add(i);
45
                }
46
            }
47
48
            // Print for last window
49
            if (!queue.isEmpty()) {
50
                System.out.print(arr[queue.peek()] + "" "");
51
            } else {
52
                System.out.print(""0 "");
53
            }
54
55
            System.out.println();
56
        }
57
        s.close();
58
    }
59
}
60",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052862
1390052863,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    min_cost = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            10
            remaining = s[i:n - j]
11
            12
            idle_remaining = remaining.count('0')
13
            active_removed = s[:i].count('1') + s[n - j:].count('1')
14
            15
            cost = max(idle_remaining, active_removed)
16
            min_cost = min(min_cost, cost)
17
            18
    print(min_cost)
19
20
t = int(input())
21
for _ in range(t):
22
    solve()",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052863
1390052860,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Solution {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
        while (t-- > 0) {
9
            int n = scanner.nextInt();
10
            int k = scanner.nextInt();
11
            int[] a = new int[n];
12
            for (int j = 0; j < n; j++) {
13
                a[j] = scanner.nextInt();
14
            }
15
            solve(n, k, a);
16
        }
17
        scanner.close();
18
    }
19
20
    public static void solve(int n, int k, int[] a) {
21
        long minEffort = Long.MAX_VALUE;
22
23
        for (int i = 0; i < (1 << n); i++) {
24
            int skippedCount = Integer.bitCount(i);
25
26
            if (skippedCount <= k) {
27
                long effort = 0;
28
                int increasedStrength = 0;
29
                int currentSkippedIndex = 0;
30
                int[] skippedIndices = new int[skippedCount];
31
                int skippedIndexPointer = 0;
32
33
                for (int j = 0; j < n; j++) {
34
                    if ((i & (1 << j)) != 0) {
35
                        skippedIndices[skippedIndexPointer++] = j;
36
                    }
37
                }
38
39
                for (int j = 0; j < n; j++) {
40
                    if (currentSkippedIndex < skippedCount && currentSkippedIndex < skippedIndices.length && skippedIndices[currentSkippedIndex] == j) {
41
                        increasedStrength++;
42
                        currentSkippedIndex++;
43
                    } else {
44
                        effort += (long) a[j] + increasedStrength;
45
                    }
46
                }
47
                minEffort = Math.min(minEffort, effort);
48
            }
49
        }
50
        System.out.println(minEffort);
51
    }
52
}",163,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052860
1390052852,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  
7
8
    for i in range(n):
9
        10
        if dq and dq[0] < i - k + 1:
11
            dq.popleft()
12
13
        if arr[i] < 0:
14
            dq.append(i)
15
16
        if i >= k - 1:
17
            if dq:
18
                result.append(arr[dq[0]])  
19
            else:
20
                result.append(0)  
21
22
    return result
23
24
def process_test_cases():
25
    t = int(input())  # number of test cases
26
    for _ in range(t):
27
        n, k = map(int, input().split())  
28
        arr = list(map(int, input().split()))  
29
        result = earliest_faulty_reading(arr, k)
30
        print(' '.join(map(str, result)))
31
32
process_test_cases()",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052852
1390052854,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) {
6
        Scanner sc=new Scanner(System.in);
7
        int T=sc.nextInt();
8
        while(T-- > 0) {
9
            int n=sc.nextInt(),k=sc.nextInt();
10
            int[] a=new int[n];
11
            for(int i=0;i<n;i++) a[i]=sc.nextInt();
12
13
            List<Integer> idx=new ArrayList<>();
14
            for(int i=0;i<n;i++) idx.add(i);
15
            idx.sort((x,y)->Integer.compare(a[y],a[x]));
16
17
            Set<Integer> skip=new HashSet<>();
18
            for(int i=0;i<k;i++) skip.add(idx.get(i));
19
20
            long effort=0;
21
            int skips=0;
22
            for(int i=0;i<n;i++) {
23
                if(skip.contains(i)) skips++;
24
                else effort+=a[i]+skips;
25
            }
26
            System.out.println(effort);
27
        }
28
        sc.close();
29
    }
30
}
31",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052854
1390052856,unknown,unknown,unknown,"1
# Enter your code here. Read input from STDIN. Print output to STDOUT
2
from collections import deque
3
4
def earliest_faulty_readings(arr, k):
5
    result = []
6
    dq = deque()
7
    8
    # Process the first window of size k
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the first result
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, len(arr)):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the new element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
def main():
32
    t = int(input().strip())  # Number of test cases
33
    for _ in range(t):
34
        n, k = map(int, input().split())  # Read n and k
35
        arr = list(map(int, input().split()))  # Read array elements
36
        37
        # Get the earliest faulty readings
38
        output = earliest_faulty_readings(arr, k)
39
        40
        # Print result as space-separated values
41
        print("" "".join(map(str, output)))
42
43
if __name__ == ""__main__"":
44
    main()
45",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052856
1390052842,unknown,unknown,unknown,"1
from collections import deque
2
import sys
3
4
def find_earliest_faults(n, k, arr):
5
    result = []
6
    dq = deque()
7
8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
13
    # Iterate through all possible windows
14
    for i in range(n - k + 1):
15
        # Get the earliest faulty reading in the window
16
        result.append(arr[dq[0]] if dq else 0)
17
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] == i:
20
            dq.popleft()
21
22
        # Add the next element from the upcoming window
23
        if i + k < n and arr[i + k] < 0:
24
            dq.append(i + k)
25
26
    return result
27
28
# Read input
29
t = int(sys.stdin.readline())  # Number of test cases
30
output = []
31
32
for _ in range(t):
33
    n, k = map(int, sys.stdin.readline().split())
34
    arr = map(int, sys.stdin.readline().split())
35
    output.append("" "".join(map(str, find_earliest_faults(n, k, arr))))
36
37
# Print the final output
38
sys.stdout.write(""\n"".join(output) + ""\n"")
39",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052842
1390052845,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
int main() {
6
    int t; 
7
    cin >> t;
8
    while(t--){
9
        int n, k;
10
        cin >> n >> k;
11
        vector<int> arr(n);
12
        for (int i = 0; i < n; i++){
13
            cin >> arr[i];
14
        }
15
        16
        if(n < k) {
17
            cout << -1 << endl;
18
            continue;
19
        }
20
        21
        vector<int> ans;
22
        int negIndex = 0;
23
        for (int i = 0; i <= n - k; i++){
24
            if(negIndex < i) 
25
                negIndex = i;
26
            27
            while(negIndex < i + k && arr[negIndex] >= 0)
28
                negIndex++;
29
            30
            if(negIndex < i + k) 
31
                ans.push_back(arr[negIndex]);
32
            else 
33
                ans.push_back(0);
34
        }
35
        36
        for (int num : ans)
37
            cout << num << "" "";
38
        cout << endl;
39
    }
40
    return 0;
41
}
42",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052845
1390052850,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Try all possible combinations of removing servers from beginning and end
5
    min_cost = float('inf')
6
    7
    # Convert to list of integers for easier processing
8
    servers = [int(c) for c in server_string]
9
    10
    # Precompute prefix and suffix sums for ones
11
    prefix_ones = [0] * (n + 1)
12
    for i in range(n):
13
        prefix_ones[i+1] = prefix_ones[i] + servers[i]
14
    15
    # Total ones in the string
16
    total_ones = prefix_ones[n]
17
    18
    for i in range(n + 1):  # i servers removed from beginning
19
        for j in range(n + 1 - i):  # j servers removed from end
20
            if i + j == n:  # Skip if removing all servers
21
                continue
22
                23
            # Calculate ones removed from beginning and end
24
            ones_removed_left = prefix_ones[i]
25
            ones_removed_right = total_ones - prefix_ones[n-j]
26
            total_ones_removed = ones_removed_left + ones_removed_right
27
            28
            # Calculate zeros remaining in the middle portion
29
            middle_length = n - i - j
30
            middle_ones = prefix_ones[n-j] - prefix_ones[i]
31
            middle_zeros = middle_length - middle_ones
32
            33
            # Calculate cost
34
            cost = max(middle_zeros, total_ones_removed)
35
            min_cost = min(min_cost, cost)
36
    37
    return min_cost
38
39
def solve():
40
    t = int(input())
41
    42
    for _ in range(t):
43
        server_string = input().strip()
44
        result = min_decommission_cost(server_string)
45
        print(result)
46
47
# Execute the solution
48
solve()",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052850
1390052838,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052838
1390052839,unknown,unknown,unknown,"1
def min_decommission_cost(servers):
2
    n = len(servers)
3
    min_cost = float('inf')
4
    5
    for i in range(n):
6
        for j in range(i, n):
7
            kept_substr = servers[i:j+1]
8
            idle_remaining = kept_substr.count('0')
9
            active_removed = servers[:i].count('1') + servers[j+1:].count('1')
10
            cost = max(idle_remaining, active_removed)
11
            min_cost = min(min_cost, cost)
12
    13
    return min_cost
14
15
def solve():
16
    t = int(input())
17
    18
    for _ in range(t):
19
        servers = input().strip()
20
        result = min_decommission_cost(servers)
21
        print(result)
22
23
if __name__ == ""__main__"":
24
    solve()",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052839
1390052840,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    if k >= n:
3
        return 0
4
    5
    prefix_sum = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_sum[i + 1] = prefix_sum[i] + strengths[i]
8
    9
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
10
    dp[0][0] = 0
11
    12
    for i in range(1, n + 1):
13
        for j in range(k + 1):
14
            if dp[i-1][j] != float('inf'):
15
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
16
        17
        for j in range(k):
18
            if dp[i-1][j] != float('inf'):
19
                dp[i][j+1] = min(dp[i][j+1], dp[i-1][j])
20
    21
    return min(dp[n])
22
23
def main():
24
    t = int(input())
25
    26
    for _ in range(t):
27
        n, k = map(int, input().split())
28
        strengths = list(map(int, input().split()))
29
        print(min_effort_to_breach(n, k, strengths))
30
31
if __name__ == ""__main__"":
32
    main()",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052840
1390052832,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void findEarliestFaults(int[] arr, int k) {
7
        List<Integer> result = new ArrayList<>();
8
        Deque<Integer> deque = new LinkedList<>(); 
9
10
        for (int i = 0; i < arr.length; i++) {
11
            12
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
13
                deque.poll();
14
            }
15
16
           17
            if (arr[i] < 0) {
18
                deque.offer(i);
19
            }
20
21
           22
            if (i >= k - 1) {
23
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
24
            }
25
        }
26
27
       28
        for (int num : result) {
29
            System.out.print(num + "" "");
30
        }
31
        System.out.println();
32
    }
33
34
    public static void main(String[] args) {
35
        Scanner scanner = new Scanner(System.in);
36
        int t = scanner.nextInt(); 
37
38
        while (t-- > 0) {
39
            int n = scanner.nextInt();
40
            int k = scanner.nextInt(); 
41
            int[] arr = new int[n];
42
43
            for (int i = 0; i < n; i++) {
44
                arr[i] = scanner.nextInt();
45
            }
46
47
            findEarliestFaults(arr, k);
48
        }
49
50
        scanner.close();
51
    }
52
}
53",164,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052832
1390052819,unknown,unknown,unknown,"1
def min_decommissioning_cost(t, test_cases):
2
    results = []
3
    4
    for servers in test_cases:
5
        n = len(servers)
6
        7
        # Count total idle and active servers
8
        total_idle = servers.count('0')
9
        total_active = servers.count('1')
10
        11
        # If there are no active servers, cost is 0
12
        if total_active == 0:
13
            results.append(0)
14
            continue
15
        16
        min_cost = float('inf')
17
        18
        left_idle = 0  # Idle servers removed from the left
19
        left_active = 0  # Active servers removed from the left
20
        21
        for i in range(n + 1):  # Try removing from the left
22
            right_idle = total_idle - left_idle
23
            right_active = total_active - left_active
24
            25
            # Try removing from the right as well
26
            for j in range(n + 1 - i):
27
                remaining_idle = right_idle - servers[n - j:].count('0')
28
                removed_active = left_active + servers[n - j:].count('1')
29
                30
                # Cost is max of remaining idle and removed active
31
                cost = max(remaining_idle, removed_active)
32
                min_cost = min(min_cost, cost)
33
            34
            # Update left counters if we haven't processed all characters
35
            if i < n:
36
                if servers[i] == '0':
37
                    left_idle += 1
38
                else:
39
                    left_active += 1
40
        41
        results.append(min_cost)
42
    43
    return results
44
45
# Reading input
46
t = int(input().strip())
47
test_cases = [input().strip() for _ in range(t)]
48
49
# Compute results
50
results = min_decommissioning_cost(t, test_cases)
51
52
# Output results
53
for res in results:
54
    print(res)",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052819
1390052827,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
5
    public static void main(String[] args) {
6
7
        Scanner sc = new Scanner(System.in);
8
9
        int t = sc.nextInt();
10
11
        while (t-- > 0) {
12
13
            int n = sc.nextInt(), k = sc.nextInt();
14
15
            int[] arr = new int[n];
16
17
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
18
19
            Deque<Integer> dq = new LinkedList<>();
20
21
            for (int i = 0; i < n; i++) {
22
23
                if (arr[i] < 0) dq.addLast(i);
24
25
                if (i >= k - 1) {
26
27
                    while (!dq.isEmpty() && dq.peekFirst() < i - k + 1) dq.pollFirst();
28
29
                    System.out.print((dq.isEmpty() ? 0 : arr[dq.peekFirst()]) + "" "");
30
31
                }
32
33
            }
34
35
            System.out.println();
36
37
        }
38
39
        sc.close();
40
41
    }
42
43
}",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052827
1390052826,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()  # Stores indices of negative numbers in the current window
6
7
    # Process first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
12
    # Store the result for the first window
13
    result.append(arr[dq[0]] if dq else 0)
14
15
    # Process the remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the current window
18
        while dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
21
        # Add the new element if it's negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
25
        # Store the result for the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
28
    return result
29
30
31
# Reading input
32
t = int(input().strip())
33
for _ in range(t):
34
    n, k = map(int, input().strip().split())
35
    arr = list(map(int, input().strip().split()))
36
    37
    # Get the result and print it
38
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))
39",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052826
1390052807,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
5
    int n = arr.size();
6
    vector<int> result;
7
    deque<int> dq;  // Stores indices of negative numbers
8
9
    // Process first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) dq.push_back(i);
12
    }
13
14
    // Process the sliding window
15
    for (int i = k; i <= n; i++) {
16
        // Append first negative number in the window
17
        if (!dq.empty()) 
18
            result.push_back(arr[dq.front()]);  // First negative in the deque
19
        else 
20
            result.push_back(0);  // No negative number
21
22
        // Remove elements that are out of the current window
23
        while (!dq.empty() && dq.front() < i - k + 1) {
24
            dq.pop_front();
25
        }
26
27
        // Add the next element if negative
28
        if (i < n && arr[i] < 0) {
29
            dq.push_back(i);
30
        }
31
    }
32
33
    return result;
34
}
35
36
int main() {
37
    int t;
38
    cin >> t;  // Number of test cases
39
    while (t--) {
40
        int n, k;
41
        cin >> n >> k;  // Size of array and batch size
42
        vector<int> arr(n);
43
        for (int i = 0; i < n; i++) {
44
            cin >> arr[i];
45
        }
46
        47
        vector<int> result = earliest_faulty_readings(arr, k);
48
        for (int num : result) {
49
            cout << num << "" "";
50
        }
51
        cout << endl;
52
    }
53
    return 0;
54
}",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052807
1390052811,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()  # To store indices of negative values
6
    7
    for i in range(len(arr)):
8
        # Remove elements that are out of the current window
9
        if dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
12
        # If the current element is faulty, add it to the deque
13
        if arr[i] < 0:
14
            dq.append(i)
15
        16
        # If we have processed at least k elements, find the earliest fault
17
        if i >= k - 1:
18
            result.append(arr[dq[0]] if dq else 0)
19
    20
    return result
21
22
# Read input
23
t = int(input())  # Number of test cases
24
25
for _ in range(t):
26
    n, k = map(int, input().split())  # Read n and k
27
    arr = list(map(int, input().split()))  # Read array elements
28
    29
    # Get the result and print it
30
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052811
1390052816,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Solution {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
        while (t-- > 0) {
9
            int n = scanner.nextInt();
10
            int k = scanner.nextInt();
11
            int[] a = new int[n];
12
            for (int j = 0; j < n; j++) {
13
                a[j] = scanner.nextInt();
14
            }
15
            solve(n, k, a);
16
        }
17
        scanner.close();
18
    }
19
20
    public static void solve(int n, int k, int[] a) {
21
        long minEffort = Long.MAX_VALUE;
22
23
        for (int i = 0; i < (1 << n); i++) {
24
            int skippedCount = Integer.bitCount(i);
25
26
            if (skippedCount <= k) {
27
                long effort = 0;
28
                int increasedStrength = 0;
29
                int currentSkippedIndex = 0;
30
                int[] skippedIndices = new int[skippedCount];
31
                int skippedIndexPointer = 0;
32
33
                for (int j = 0; j < n; j++) {
34
                    if ((i & (1 << j)) != 0) {
35
                        skippedIndices[skippedIndexPointer++] = j;
36
                    }
37
                }
38
39
                for (int j = 0; j < n; j++) {
40
                    if (currentSkippedIndex < skippedCount && skippedIndices[currentSkippedIndex] == j) {
41
                        increasedStrength++;
42
                        currentSkippedIndex++;
43
                    } else {
44
                        effort += (long) a[j] + increasedStrength;
45
                    }
46
                }
47
                minEffort = Math.min(minEffort, effort);
48
            }
49
        }
50
        System.out.println(minEffort);
51
    }
52
}",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052816
1390052801,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    min_cost = float('inf')
4
    best_left = 0
5
    best_right = 0
6
    7
    # Try all possible combinations of removing servers from left and right
8
    for left in range(n + 1):  # Number of servers to remove from left
9
        for right in range(n + 1 - left):  # Number of servers to remove from right
10
            # The remaining servers after decommissioning
11
            remaining = server_string[left:n-right]
12
            13
            if not remaining:  # If all servers are decommissioned
14
                idle_remaining = 0
15
                active_removed = server_string.count('1')
16
            else:
17
                idle_remaining = remaining.count('0')
18
                19
                # Calculate active servers removed
20
                left_part = server_string[:left]
21
                right_part = server_string[n-right:]
22
                active_removed = left_part.count('1') + right_part.count('1')
23
            24
            # Cost is the maximum of idle remaining and active removed
25
            cost = max(idle_remaining, active_removed)
26
            27
            if cost < min_cost:
28
                min_cost = cost
29
                best_left = left
30
                best_right = right
31
    32
    return min_cost
33
34
def main():
35
    t = int(input().strip())
36
    37
    for _ in range(t):
38
        server_string = input().strip()
39
        result = min_decommission_cost(server_string)
40
        print(result)
41
42
if __name__ == ""__main__"":
43
    main()",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052801
1390052802,unknown,unknown,unknown,"1
def solve():
2
    n, k = map(int, input().split())
3
    a = list(map(int, input().split()))
4
5
    min_effort = float('inf')
6
7
    for i in range(1 << n):  
8
        skipped_indices = []
9
        skipped_count = 0
10
        current_effort = 0
11
        current_a = a[:]  
12
13
        for j in range(n):
14
            if (i >> j) & 1:
15
                skipped_indices.append(j)
16
                skipped_count += 1
17
18
        if skipped_count <= k:
19
            skipped_indices.sort()
20
            offset = 0
21
            22
            for j in range(n):
23
                if j in skipped_indices:
24
                    offset+=1
25
                    continue;
26
                else:
27
                    current_effort += current_a[j] + offset;
28
29
            min_effort = min(min_effort, current_effort)
30
31
    print(min_effort)
32
33
T = int(input())
34
for _ in range(T):
35
    solve()",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052802
1390052797,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_faulty_readings(test_cases):
4
    results = []
5
    6
    for case in test_cases:
7
        n, k, arr = case
8
        result = []
9
        10
        for i in range(n - k + 1):
11
            batch = arr[i:i+k]
12
            found_fault = False
13
            for num in batch:
14
                if num < 0: 
15
                    result.append(num)
16
                    found_fault = True
17
                    break
18
            if not found_fault:
19
                result.append(0)  
20
        results.append(result)
21
    22
    return results
23
24
t = int(input()) 
25
test_cases = []
26
for _ in range(t):
27
    n, k = map(int, input().split())  
28
    arr = list(map(int, input().split())) 
29
    test_cases.append((n, k, arr))
30
31
32
results = find_faulty_readings(test_cases)
33
for result in results:
34
    print("" "".join(map(str, result)))
35",165,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052797
1390052793,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    for n, k, arr in test_cases:
6
        dq = deque()
7
        res = []
8
        9
        for i in range(n):
10
            if arr[i] < 0:
11
                dq.append(i)
12
13
            if i >= k - 1:
14
                while dq and dq[0] < i - k + 1:
15
                    dq.popleft()
16
17
                res.append(arr[dq[0]] if dq else 0)
18
19
        results.append("" "".join(map(str, res)))
20
    21
    print(""\n"".join(results))
22
23
# Read input
24
t = int(input())
25
test_cases = []
26
for _ in range(t):
27
    n, k = map(int, input().split())
28
    arr = list(map(int, input().split()))
29
    test_cases.append((n, k, arr))
30
31
earliest_faulty_readings(test_cases)
32",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052793
1390052794,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faculty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
    8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
            12
    for i in range(n - k + 1):
13
        result.append(arr[dq[0]] if dq else 0)
14
        15
        if dq and dq[0] == i:
16
            dq.popleft()
17
            18
        if i + k < n and arr[i + k] < 0:
19
            dq.append(i + k)
20
            21
    return result
22
23
t = int(input())
24
for _ in range(t):
25
    n, k = map(int, input().split())
26
    arr = list(map(int,input().split()))
27
    print(*earliest_faculty_readings(arr, k))",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052794
1390052795,unknown,unknown,unknown,"1
def minimum_effort(n, k, arr):
2
    total_sum = sum(arr)
3
    4
    if k == n:
5
        return 0
6
    7
    current_window_sum = sum(arr[:k])
8
    min_effort = total_sum - current_window_sum + (n - k)
9
    10
    for i in range(1, n - k + 1):
11
        current_window_sum += arr[i + k - 1] - arr[i - 1]
12
        effort = total_sum - current_window_sum + (n - (i + k))
13
        min_effort = min(min_effort, effort)
14
    15
    return min_effort
16
17
t = int(input())
18
for _ in range(t):
19
    n, k = map(int, input().split())
20
    arr = list(map(int, input().split()))
21
    result = minimum_effort(n, k, arr)
22
    print(result)",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052795
1390052786,unknown,unknown,unknown,"1
def min_effort(test_cases):
2
    results = []
3
    for n, k, arr in test_cases:
4
        if k == n:
5
            results.append(0)
6
            continue
7
8
        total_effort = sum(arr)
9
        min_effort = total_effort
10
11
        for i in range(n):
12
            effort = total_effort - arr[i] + (n - 1) * k
13
            min_effort = min(min_effort, effort)
14
15
        results.append(min_effort)
16
17
    return results
18
19
t = int(input())
20
test_cases = [(lambda n, k, arr: (n, k, arr))(*map(int, input().split()), list(map(int, input().split()))) for _ in range(t)]
21
22
for output in min_effort(test_cases):
23
    print(output)
24",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052786
1390052787,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
11
        Scanner scanner = new Scanner(System.in);
12
        int t = scanner.nextInt(); 
13
        while (t-- > 0) {
14
            int n = scanner.nextInt(); 
15
            int k = scanner.nextInt(); 
16
            int[] arr = new int[n];
17
            for (int i = 0; i < n; i++) {
18
                arr[i] = scanner.nextInt();
19
            }
20
            21
            List<Integer> result = findEarliestFaults(arr, k);
22
            for (int num : result) {
23
                System.out.print(num + "" "");
24
            }
25
            System.out.println();
26
        }
27
        scanner.close();
28
    }
29
    30
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
31
        List<Integer> result = new ArrayList<>();
32
        Deque<Integer> deque = new LinkedList<>(); 
33
        34
        for (int i = 0; i < k; i++) {
35
            if (arr[i] < 0) {
36
                deque.addLast(i);
37
            }
38
        }
39
        40
        result.add(deque.isEmpty() ? 0 : arr[deque.peekFirst()]);
41
        42
        for (int i = k; i < arr.length; i++) {
43
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
44
                deque.pollFirst();
45
            }
46
            47
            if (arr[i] < 0) {
48
                deque.addLast(i);
49
            }
50
            51
            result.add(deque.isEmpty() ? 0 : arr[deque.peekFirst()]);
52
        }
53
        54
        return result;
55
    }
56
57
}",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052787
1390052791,unknown,unknown,unknown,"1
def minimum_effort(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, a = case
5
        if k >= n:
6
            results.append(0)
7
            continue
8
        total_effort = sum(a)
9
        reduction = []
10
        for i in range(n):
11
            reduction.append(a[i] - (n - i - 1))
12
        reduction.sort(reverse=True)
13
        max_reduction = sum(reduction[:k])
14
        results.append(total_effort - max_reduction)
15
    return results
16
17
def main():
18
    import sys
19
    input = sys.stdin.read
20
    data = input().split()
21
    idx = 0
22
    T = int(data[idx])
23
    idx += 1
24
    test_cases = []
25
    for _ in range(T):
26
        n, k = int(data[idx]), int(data[idx + 1])
27
        idx += 2
28
        a = list(map(int, data[idx:idx + n]))
29
        idx += n
30
        test_cases.append((n, k, a))
31
    results = minimum_effort(test_cases)
32
    for res in results:
33
        print(res)
34
35
if __name__ == ""__main__"":
36
    main()",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052791
1390052777,unknown,unknown,unknown,"1
t = int(input())
2
3
for _ in range(t):
4
    n, k = map(int, input().split())
5
    a = list(map(int, input().split()))
6
    result = []
7
    neg = []
8
9
    for i in range(k):
10
        if a[i] < 0:
11
            neg.append(i)
12
13
    result.append(a[neg[0]] if neg else 0)
14
15
    for i in range(k, n):
16
        if neg and neg[0] < i - k + 1:
17
            neg.pop(0)
18
        if a[i] < 0:
19
            neg.append(i)
20
        result.append(a[neg[0]] if neg else 0)
21
22
    print("" "".join(str(x) for x in result))",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052777
1390052780,unknown,unknown,unknown,"1
import java.util.ArrayList;
2
import java.util.List;
3
import java.util.Scanner;
4
5
public class Solution {
6
7
    public static void main(String[] args) {
8
        Scanner scanner = new Scanner(System.in);
9
        int t = scanner.nextInt();
10
        while (t-- > 0) {
11
            int n = scanner.nextInt();
12
            int k = scanner.nextInt();
13
            int[] a = new int[n];
14
            for (int j = 0; j < n; j++) {
15
                a[j] = scanner.nextInt();
16
            }
17
            solve(n, k, a);
18
        }
19
        scanner.close();
20
    }
21
22
    public static void solve(int n, int k, int[] a) {
23
        long minEffort = Long.MAX_VALUE;
24
25
        for (int i = 0; i < (1 << n); i++) {
26
            int skippedCount = 0;
27
            for (int j = 0; j < n; j++) {
28
                if ((i & (1 << j)) != 0) {
29
                    skippedCount++;
30
                }
31
            }
32
33
            if (skippedCount <= k) {
34
                long effort = 0;
35
                int increasedStrength = 0;
36
                int currentSkippedIndex = 0;
37
                List<Integer> skippedIndices = new ArrayList<>();
38
39
                for (int j = 0; j < n; j++) {
40
                    if ((i & (1 << j)) != 0) {
41
                        skippedIndices.add(j);
42
                    }
43
                }
44
45
                for (int j = 0; j < n; j++) {
46
                    if (currentSkippedIndex < skippedIndices.size() && skippedIndices.get(currentSkippedIndex) == j) {
47
                        increasedStrength++;
48
                        currentSkippedIndex++;
49
                    } else {
50
                        effort += (long) a[j] + increasedStrength;
51
                    }
52
                }
53
                minEffort = Math.min(minEffort, effort);
54
            }
55
        }
56
        System.out.println(minEffort);
57
    }
58
}",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052780
1390052781,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void earliest_faulty_readings(int test_cases) {
5
    for (int t = 0; t < test_cases; t++) {
6
        int n, k;
7
        scanf(""%d %d"", &n, &k);
8
        int *arr = (int *)malloc(n * sizeof(int));
9
        for (int i = 0; i < n; i++) {
10
            scanf(""%d"", &arr[i]);
11
        }
12
        13
        for (int i = 0; i <= n - k; i++) {
14
            int fault = 0;
15
            for (int j = i; j < i + k; j++) {
16
                if (arr[j] < 0) {
17
                    fault = arr[j];
18
                    break;
19
                }
20
            }
21
            printf(""%d "", fault);
22
        }
23
        printf(""\n"");
24
        free(arr);
25
    }
26
}
27
28
int main() {
29
    int test_cases;
30
    scanf(""%d"", &test_cases);
31
    earliest_faulty_readings(test_cases);
32
    return 0;
33
}",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052781
1390052772,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    min_total_effort = float('inf')
3
4
    for i in range(1 << n):  
5
        skipped_count = 0
6
        current_effort = 0
7
        current_firewalls = firewalls[:] 
8
9
        skipped_indices = []
10
        for j in range(n):
11
            if (i >> j) & 1:
12
                skipped_count += 1
13
                skipped_indices.append(j)
14
15
        if skipped_count <= k:
16
            skipped_indices.sort()
17
            18
            for skip_index in skipped_indices:
19
                for idx in range(skip_index + 1, n):
20
                    current_firewalls[idx] += 1
21
            22
            non_skipped_indices = [idx for idx in range(n) if idx not in skipped_indices]
23
            24
            for idx in non_skipped_indices:
25
                current_effort += current_firewalls[idx]
26
            27
            min_total_effort = min(min_total_effort, current_effort)
28
29
    return min_total_effort
30
31
if __name__ == ""__main__"":
32
    t = int(input())
33
    for _ in range(t):
34
        n, k = map(int, input().split())
35
        firewalls = list(map(int, input().split()))
36
        print(min_effort(n, k, firewalls))",166,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052772
1390052768,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Create a dp array to store minimum effort
3
    # dp[i][j] represents minimum effort to breach i-th firewall using j skips
4
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
5
    6
    # Base case: no firewalls, no effort
7
    for j in range(k + 1):
8
        dp[0][j] = 0
9
    10
    for i in range(1, n + 1):
11
        for j in range(k + 1):
12
            # Option 1: Don't skip the current firewall
13
            # If we've skipped j firewalls so far, the current firewall's strength 
14
            # increases by j
15
            if j <= i - 1:  # Ensure we have firewalls to process
16
                dp[i][j] = dp[i-1][j] + (strengths[i-1] + j)
17
            18
            # Option 2: Skip the current firewall (if we have skips left)
19
            if j > 0:
20
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
21
    22
    # Find the minimum effort across all possible numbers of skips
23
    return min(dp[n])
24
25
def solve():
26
    t = int(input())
27
    28
    for _ in range(t):
29
        n, k = map(int, input().split())
30
        strengths = list(map(int, input().split()))
31
        result = min_effort_to_breach(n, k, strengths)
32
        print(result)
33
34
# Run the solution
35
solve()",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052768
1390052771,unknown,unknown,unknown,"1
#include <iostream>
2
#include <string>
3
#include <vector>
4
#include <algorithm>
5
6
using namespace std;
7
8
int minCost(const string& servers) {
9
    int n = servers.length();
10
    11
    int totalActive = 0;
12
    int totalIdle = 0;
13
    14
    for (char c : servers) {
15
        if (c == '1') totalActive++;
16
        else totalIdle++;
17
    }
18
    19
    int minCost = max(totalIdle, 0); // Initial cost if we keep all servers
20
    21
    // Arrays to track running counts
22
    vector<int> activePrefixSum(n + 1, 0);
23
    vector<int> idlePrefixSum(n + 1, 0);
24
    25
    for (int i = 0; i < n; i++) {
26
        activePrefixSum[i + 1] = activePrefixSum[i] + (servers[i] == '1');
27
        idlePrefixSum[i + 1] = idlePrefixSum[i] + (servers[i] == '0');
28
    }
29
    30
    // Try removing different numbers of servers from beginning and end
31
    for (int leftRemove = 0; leftRemove <= n; leftRemove++) {
32
        for (int rightRemove = 0; leftRemove + rightRemove <= n; rightRemove++) {
33
            // Calculate metrics for this configuration
34
            int activeRemoved = activePrefixSum[leftRemove] + 
35
                               (activePrefixSum[n] - activePrefixSum[n - rightRemove]);
36
            37
            int idleRemaining = totalIdle - (idlePrefixSum[leftRemove] + 
38
                               (idlePrefixSum[n] - idlePrefixSum[n - rightRemove]));
39
            40
            int cost = max(idleRemaining, activeRemoved);
41
            minCost = min(minCost, cost);
42
        }
43
    }
44
    45
    return minCost;
46
}
47
48
int main() {
49
    ios_base::sync_with_stdio(false);
50
    cin.tie(NULL);
51
    52
    int t;
53
    cin >> t;
54
    55
    while (t--) {
56
        string servers;
57
        cin >> servers;
58
        59
        cout << minCost(servers) << endl;
60
    }
61
    62
    return 0;
63
}",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052771
1390052769,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []  # To store the output
5
    dq = deque()  # To store indices of negative numbers
6
7
    # Process the first batch of size k
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)  # Store index of negative number
11
    12
    # Process the remaining batches
13
    for i in range(len(arr) - k + 1):
14
        # Add the earliest negative number from the deque
15
        if dq:
16
            result.append(arr[dq[0]])  # Front of the deque is the earliest fault
17
        else:
18
            result.append(0)  # No negative number in this batch
19
        20
        # Remove elements that move out of the window
21
        if dq and dq[0] == i:
22
            dq.popleft()
23
        24
        # Add the next element to the window
25
        if i + k < len(arr) and arr[i + k] < 0:
26
            dq.append(i + k)
27
    28
    return result
29
30
# Read input
31
t = int(input())  # Number of test cases
32
for _ in range(t):
33
    n, k = map(int, input().split())  # Size of array and batch size
34
    arr = list(map(int, input().split()))  # Array elements
35
    36
    # Get the earliest faulty readings and print result
37
    print(*earliest_faulty_readings(arr, k))
38",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052769
1390052765,unknown,unknown,unknown,"1
def earliest_faulty_reading(test_case):
2
    results = []
3
    for case in test_cases:
4
        n, k, arr = case['n'], case['k'], case['arr']
5
        batch_result = []
6
        for i in range(n - k + 1):
7
            batch = arr[i:i + k]
8
            fault = next((x for x in batch if x < 0), 0)
9
            batch_result.append(fault)
10
        results.append(batch_result)
11
    return results
12
t = int(input())
13
test_cases = []
14
15
for _ in range(t):
16
    n, k = map(int, input().split())
17
    arr = list(map(int, input().split()))
18
    test_cases.append({'n':n, 'k':k, 'arr':arr})
19
results = earliest_faulty_reading(test_cases)
20
for result in results:
21
    print("" "".join(map(str, result)))",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052765
1390052766,unknown,unknown,unknown,"1
def min_firewall_effort(n, k, firewalls):
2
    """"""
3
    Calculates the minimum effort needed to breach the network.
4
5
    Args:
6
        n: The number of firewalls.
7
        k: The maximum number of firewalls that can be skipped.
8
        firewalls: A list of firewall strengths.
9
10
    Returns:
11
        The minimum effort needed.
12
    """"""
13
    min_effort = float('inf')
14
15
    for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
16
        skipped_count = bin(i).count('1')
17
        if skipped_count <= k:
18
            current_effort = 0
19
            skipped = 0
20
            current_firewalls = firewalls[:]  # Create a copy to avoid modifying the original list
21
22
            skipped_indices = []
23
            for j in range(n):
24
                if (i >> j) & 1:
25
                    skipped_indices.append(j)
26
27
            skipped_indices.sort()
28
            29
            j = 0
30
            for index in skipped_indices:
31
                for l in range(index+1,n):
32
                    current_firewalls[l] +=1
33
34
            for j in range(n):
35
                if (i >> j) & 1:
36
                    continue
37
                else:
38
                    current_effort += current_firewalls[j]
39
40
            min_effort = min(min_effort, current_effort)
41
42
    return min_effort
43
44
if __name__ == ""__main__"":
45
    t = int(input())
46
    for _ in range(t):
47
        n, k = map(int, input().split())
48
        firewalls = list(map(int, input().split()))
49
        result = min_firewall_effort(n, k, firewalls)
50
        print(result)",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052766
1390052767,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # If we can skip all firewalls, the answer is 0
3
    if k >= n:
4
        return 0
5
    6
    # Calculate the cost of skipping a firewall at position i
7
    # This includes the original firewall strength plus the penalty it would add to future firewalls
8
    impact = []
9
    for i in range(n):
10
        # Impact = strength of firewall + number of non-skipped firewalls after this one
11
        # We're assuming all firewalls after i are NOT skipped (we'll adjust this later)
12
        firewall_impact = strengths[i] + (n - i - 1)
13
        impact.append((firewall_impact, i))
14
    15
    # Sort by impact (high to low)
16
    impact.sort(reverse=True)
17
    18
    # Select firewalls to skip (those with highest impact)
19
    to_skip = set()
20
    for i in range(min(k, n)):
21
        to_skip.add(impact[i][1])
22
    23
    # Calculate final effort
24
    total_effort = 0
25
    skipped_count = 0
26
    27
    for i in range(n):
28
        if i in to_skip:
29
            skipped_count += 1
30
        else:
31
            # Add firewall strength plus penalty for each previously skipped firewall
32
            total_effort += strengths[i] + skipped_count
33
    34
    return total_effort
35
36
def solve_all_subsets(n, k, strengths):
37
    # Try all possible subsets of firewalls to skip
38
    # This is an exhaustive approach for when n is small
39
    min_effort = float('inf')
40
    41
    # 2^n possible subsets of firewalls
42
    for mask in range(1 << n):
43
        # Count bits to ensure we're skipping at most k firewalls
44
        skipped = bin(mask).count('1')
45
        if skipped > k:
46
            continue
47
            48
        effort = 0
49
        skip_count = 0
50
        51
        for i in range(n):
52
            if (mask >> i) & 1:  # This firewall is skipped
53
                skip_count += 1
54
            else:
55
                effort += strengths[i] + skip_count
56
                57
        min_effort = min(min_effort, effort)
58
    59
    return min_effort
60
61
def main():
62
    t = int(input().strip())
63
    64
    for _ in range(t):
65
        n, k = map(int, input().strip().split())
66
        strengths = list(map(int, input().strip().split()))
67
        68
        # For small n, use exhaustive approach
69
        if n <= 20:
70
            result = solve_all_subsets(n, k, strengths)
71
        else:
72
            # For larger n, use greedy approach
73
            result = min_effort_to_breach(n, k, strengths)
74
            75
        print(result)
76
77
if __name__ == ""__main__"":
78
    main()",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052767
1390052759,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    4
    for t in range(T):
5
        n, k = test_cases[t][0]
6
        firewalls = test_cases[t][1]
7
8
        if k >= n:  # If we can skip all firewalls, effort is 0
9
            results.append(0)
10
            continue
11
12
        min_effort = float('inf')
13
14
        for i in range(n):  # Try skipping each firewall one by one
15
            effort = 0
16
            skipped = 0
17
            18
            for j in range(n):
19
                if j == i and skipped < k:  # Skip this firewall
20
                    skipped += 1
21
                else:
22
                    effort += firewalls[j] + skipped  # Increase strength for remaining ones
23
24
            min_effort = min(min_effort, effort)
25
26
        results.append(min_effort)
27
28
    return results
29
30
# Input Handling
31
T = int(input())
32
test_cases = []
33
for _ in range(T):
34
    n, k = map(int, input().split())
35
    firewalls = list(map(int, input().split()))
36
    test_cases.append(((n, k), firewalls))
37
38
# Process and Output Results
39
for res in min_effort_to_breach(T, test_cases):
40
    print(res)
41",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052759
1390052761,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        dq = deque()
8
        output = []
9
        10
        for i in range(k):
11
            if arr[i] < 0:
12
                dq.append(i)
13
        14
        output.append(arr[dq[0]] if dq else 0)
15
        16
        for i in range(k, n):
17
            while dq and dq[0] < i - k + 1:
18
                dq.popleft()
19
            20
            if arr[i] < 0:
21
                dq.append(i)
22
            23
            output.append(arr[dq[0]] if dq else 0)
24
        25
        results.append("" "".join(map(str, output)))
26
    27
    return results
28
29
t = int(input())
30
test_cases = []
31
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    test_cases.append((n, k, arr))
36
37
for result in earliest_faulty_readings(test_cases):
38
    print(result)",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052761
1390052762,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    if k >= n:
5
        return 0
6
    7
    # dp[i][j] represents min effort for firewalls[i:] with j skips used
8
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
9
    10
    # Base case: when we've processed all firewalls
11
    for j in range(k + 1):
12
        dp[n][j] = 0
13
    14
    # Fill DP table from right to left
15
    for i in range(n - 1, -1, -1):
16
        for j in range(k + 1):
17
            # Option 1: Skip this firewall (if skips remain)
18
            if j < k:
19
                dp[i][j] = dp[i + 1][j + 1]
20
            21
            # Option 2: Don't skip this firewall
22
            effort = firewalls[i] + j  # Current firewall + skips used before
23
            dp[i][j] = min(dp[i][j], effort + dp[i + 1][j])
24
    25
    return dp[0][0]
26
27
# Handle automatic input
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    firewalls = list(map(int, input().split()))
32
    result = min_effort(firewalls, k)
33
    print(result)",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052762
1390052758,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        if k == n:
6
            results.append(""0"")  # If all firewalls can be skipped, effort is 0
7
            continue
8
9
        total_effort = sum(firewalls)
10
        min_effort = total_effort
11
12
        # Sliding window to track sum of k skipped firewalls
13
        window_sum = sum(firewalls[:k])
14
        15
        for i in range(n - k + 1):
16
            # Compute the increased security penalty dynamically
17
            penalty = sum(range(1, min(k, n - i) + 1))
18
            new_effort = total_effort - window_sum + penalty
19
            min_effort = min(min_effort, new_effort)
20
21
            # Move the window forward
22
            if i + k < n:
23
                window_sum = window_sum - firewalls[i] + firewalls[i + k]
24
25
        results.append(str(min_effort))
26
27
    return ""\n"".join(results)
28
29
# Read input
30
T = int(input())
31
test_cases = []
32
33
for _ in range(T):
34
    n, k = map(int, input().split())
35
    firewalls = list(map(int, input().split()))
36
    test_cases.append((n, k, firewalls))
37
38
# Compute and print results
39
print(min_effort_to_breach(T, test_cases))
40",167,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052758
1390052749,unknown,unknown,unknown,"1
from collections import deque
2
3
t = int(input()) 
4
5
6
for _ in range(t):
7
    n, k = map(int, input().split())  
8
    arr = list(map(int, input().split()))  
9
    dq = deque()  
10
    11
    12
    13
    results = [] 
14
    15
    #check1
16
    for i in range(n):
17
        18
        if arr[i] < 0:
19
            dq.append(i)
20
            21
        if i >= k - 1:
22
            23
            while dq and dq[0] < i - k + 1:
24
                25
                26
                dq.popleft()
27
                28
                #do
29
                30
                31
            results.append(arr[dq[0]] if dq else 0)
32
            33
            34
            35
            36
    print(' '.join(map(str, results)))",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052749
1390052755,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(t, test_cases):
4
5
    results = []
6
7
    8
9
    for case in test_cases:
10
11
        n, k, readings = case
12
13
        result = []
14
15
        dq = deque()  # Stores indices of negative numbers
16
17
        # Initialize the deque with indices of negative numbers in the first window
18
19
        for i in range(k):
20
21
            if readings[i] < 0:
22
23
                dq.append(i)
24
25
        # Process sliding windows
26
27
        for i in range(n - k + 1):
28
29
            # The first negative number in the window is at dq[0], if it exists
30
31
            if dq:
32
33
                result.append(readings[dq[0]])
34
35
            else:
36
37
                result.append(0)
38
39
            # Remove elements that are out of the current window
40
41
            if dq and dq[0] == i:
42
43
                dq.popleft()
44
45
            # Add the next element (i + k) if it's negative
46
47
            if i + k < n and readings[i + k] < 0:
48
49
                dq.append(i + k)
50
51
        # Store results as a space-separated string for each test case
52
53
        results.append("" "".join(map(str, result)))
54
55
    56
57
    return ""\n"".join(results)
58
59
# Example Usage
60
61
t = 2
62
63
test_cases = [
64
65
    (5, 2, [-8, 2, 3, -6, 10]),
66
67
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
68
69
]
70
71
print(earliest_faulty_readings(t, test_cases))",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052755
1390052751,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
    8
  9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    for i in range(k, n):
17
        if dq and dq[0] < i - k + 1:
18
            dq.popleft()
19
        20
        if arr[i] < 0:
21
            dq.append(i)
22
        23
        result.append(arr[dq[0]] if dq else 0)
24
    25
    return result
26
27
28
t = int(input())  # Number of test cases
29
for _ in range(t):
30
    n, k = map(int, input().split())  # Size of array and batch size
31
    arr = list(map(int, input().split()))  # Array elements
32
    33
    print(*earliest_faulty_readings(arr, k))",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052751
1390052741,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultyComponentDetector {
4
5
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
6
        List<Integer> result = new ArrayList<>();
7
        Deque<Integer> deque = new LinkedList<>();
8
9
        for (int i = 0; i < arr.length; i++) {
10
            // Remove elements that are out of the current window
11
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
12
                deque.poll();
13
            }
14
15
            // Add current element index if it's a negative number
16
            if (arr[i] < 0) {
17
                deque.offer(i);
18
            }
19
20
            // Once we reach the window size, record the result
21
            if (i >= k - 1) {
22
                if (!deque.isEmpty()) {
23
                    result.add(arr[deque.peek()]); // Earliest fault in the current window
24
                } else {
25
                    result.add(0); // No fault in the current window
26
                }
27
            }
28
        }
29
30
        return result;
31
    }
32
33
    public static void main(String[] args) {
34
        Scanner scanner = new Scanner(System.in);
35
        int t = scanner.nextInt(); // Number of test cases
36
37
        while (t-- > 0) {
38
            int n = scanner.nextInt(); // Size of array
39
            int k = scanner.nextInt(); // Batch size
40
            int[] arr = new int[n];
41
42
            for (int i = 0; i < n; i++) {
43
                arr[i] = scanner.nextInt();
44
            }
45
46
            List<Integer> result = findEarliestFaults(arr, k);
47
            for (int val : result) {
48
                System.out.print(val + "" "");
49
            }
50
            System.out.println();
51
        }
52
53
        scanner.close();
54
    }
55
}
56",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052741
1390052746,unknown,unknown,unknown,"1
def minimize_effort(n, k, firewalls):
2
    # Each skip at index i adds (n - i - 1) penalty to total
3
    # So total extra penalty = total number of skipped firewalls * (average of positions after the skip)
4
    5
    total_effort = sum(firewalls)
6
7
    # Calculate cost of skipping each firewall (how much total cost increases due to penalty if we skip this one)
8
    penalties = []
9
    for i in range(n):
10
        # If we skip this firewall, we save a[i], but add (n - i - 1) penalty to the rest
11
        cost_diff = firewalls[i] + (n - i - 1)
12
        penalties.append((cost_diff, i))
13
14
    # Pick k firewalls with the **highest cost_diff**, i.e., best to skip (highest saving)
15
    penalties.sort(reverse=True)
16
17
    skipped = [0] * n
18
    for i in range(k):
19
        _, idx = penalties[i]
20
        skipped[idx] = 1
21
22
    # Now calculate final effort
23
    effort = 0
24
    penalty = 0
25
26
    for i in range(n):
27
        if skipped[i]:
28
            penalty += 1
29
        else:
30
            effort += firewalls[i] + penalty
31
32
    return effort
33
34
# Main driver
35
T = int(input())
36
for _ in range(T):
37
    n, k = map(int, input().split())
38
    firewalls = list(map(int, input().split()))
39
    print(minimize_effort(n, k, firewalls))
40",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052746
1390052748,unknown,unknown,unknown,"1
def min_effort(arr, k):
2
    n = len(arr)
3
    4
    if k >= n:
5
        return 0
6
    7
    # Calculate total effort without skipping
8
    total_effort = sum(arr)
9
    10
    # Calculate impact of skipping each firewall
11
    impacts = []
12
    for i in range(n):
13
        # If we skip this firewall:
14
        # - We save its strength
15
        # - We add +1 penalty to each non-skipped firewall that comes after it
16
        firewall_strength = arr[i]
17
        penalty = n - i - 1 - k + 1  # Remaining firewalls minus skipped ones after this one
18
        19
        # We need to adjust the penalty:
20
        # We can skip at most k firewalls, and we're skipping this one
21
        # So we can skip at most (k-1) more firewalls after this one
22
        penalty = max(0, penalty)  # If we can skip all remaining firewalls, no penalty
23
        24
        net_impact = firewall_strength - penalty
25
        impacts.append((net_impact, i))
26
    27
    # Sort impacts in descending order
28
    impacts.sort(reverse=True)
29
    30
    # Skip k firewalls with highest impact
31
    skipped = 0
32
    skip_indices = []
33
    34
    for impact, idx in impacts:
35
        if skipped < k:
36
            skip_indices.append(idx)
37
            skipped += 1
38
    39
    # Calculate final effort
40
    final_effort = 0
41
    skipped_so_far = 0
42
    43
    for i in range(n):
44
        if i in skip_indices:
45
            skipped_so_far += 1
46
        else:
47
            final_effort += arr[i] + skipped_so_far
48
    49
    return final_effort
50
51
def solve():
52
    t = int(input())
53
    54
    for _ in range(t):
55
        n, k = map(int, input().split())
56
        arr = list(map(int, input().split()))
57
        result = min_effort(arr, k)
58
        print(result)
59
60
if __name__ == ""__main__"":
61
    solve()",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052748
1390052727,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <limits.h>  // For INT_MAX
7
8
using namespace std;
9
10
int minEffort(vector<int>& firewalls, int k) {
11
    int totalEffort = 0, n = firewalls.size();
12
13
    // Compute total effort without skipping any firewall
14
    for (int effort : firewalls) {
15
        totalEffort += effort;
16
    }
17
18
    // If we can skip all firewalls, the minimum effort is 0
19
    if (k == n) return 0;
20
21
    int minEffort = totalEffort;  // Initialize with no skipping
22
23
    // Check the effort when skipping each firewall
24
    for (int i = 0; i < n; i++) {
25
        int currentEffort = totalEffort - firewalls[i] + k;
26
        minEffort = min(minEffort, currentEffort);
27
    }
28
29
    return minEffort;
30
}
31
32
int main() {
33
    int T;
34
    cin >> T;
35
36
    while (T--) {
37
        int n, k;
38
        cin >> n >> k;
39
40
        vector<int> firewalls(n);
41
        for (int i = 0; i < n; i++) {
42
            cin >> firewalls[i];
43
        }
44
45
        cout << minEffort(firewalls, k) << endl;
46
    }
47
48
    return 0;
49
}",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052727
1390052729,unknown,unknown,unknown,"1
def faulty_sensor_readings(arr, k):
2
    """"""
3
    Determines the earliest faulty reading for each consecutive batch of size k.
4
5
    Args:
6
        arr: A list of sensor readings.
7
        k: The batch size.
8
9
    Returns:
10
        A list containing the earliest faulty reading for each batch.
11
    """"""
12
    result = []
13
    for i in range(len(arr) - k + 1):
14
        batch = arr[i:i + k]
15
        fault = 0
16
        for num in batch:
17
            if num < 0:
18
                fault = num
19
                break
20
        result.append(fault)
21
    return result
22
23
if __name__ == ""__main__"":
24
    t = int(input())
25
    for _ in range(t):
26
        n, k = map(int, input().split())
27
        arr = list(map(int, input().split()))
28
        result = faulty_sensor_readings(arr, k)
29
        print(*result)",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052729
1390052740,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_faulty_readings(t, test_cases):
4
    results = []
5
    6
    for i in range(t):
7
        n, k = test_cases[i][0], test_cases[i][1]
8
        arr = test_cases[i][2]
9
        10
       11
        result = []
12
        13
        14
        dq = deque()
15
        16
        17
        for j in range(k):
18
            if arr[j] < 0:
19
                dq.append(j)
20
        21
       22
        if dq:
23
            result.append(arr[dq[0]])
24
        else:
25
            result.append(0)
26
        27
 28
        for j in range(k, n):
29
           30
            if dq and dq[0] <= j - k:
31
                dq.popleft()
32
            33
          34
            if arr[j] < 0:
35
                dq.append(j)
36
            37
           38
            if dq:
39
                result.append(arr[dq[0]])
40
            else:
41
                result.append(0)
42
        43
        results.append(result)
44
    45
    return results
46
47
48
49
t = int(input())  
50
test_cases = []
51
52
for _ in range(t):
53
    n, k = map(int, input().split())  
54
    arr = list(map(int, input().split()))  
55
    test_cases.append((n, k, arr))
56
57
58
results = find_faulty_readings(t, test_cases)
59
60
61
for result in results:
62
    print("" "".join(map(str, result)))
63",168,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052740
1390052719,unknown,unknown,unknown,"1
from collections import deque
2
def earliest_faults(t, test_cases):
3
    result = []
4
    for n, k, arr in test_cases:
5
        dq = deque()
6
        res = []
7
        for i in range(k):
8
            if arr[i]<0:
9
                dq.append(i)
10
        for i in range(n-k+1):
11
            if dq:
12
                res.append(arr[dq[0]])
13
            else:
14
                res.append(0)
15
            if dq and dq[0]==i:
16
                dq.popleft()
17
            if i+k<n and arr[i+k]<0:
18
                dq.append(i+k)
19
        result.append(res)
20
    return result
21
t = int(input().strip())
22
test_cases = []
23
for _ in range(t):
24
    n, k = map(int, input().strip().split())
25
    arr = list(map(int, input().strip().split()))
26
    test_cases.append((n, k, arr))
27
result = earliest_faults(t, test_cases)
28
for res in result:
29
    print("" "".join(map(str, res)))
30",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052719
1390052717,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
    public static void faultyComponent(int arr[], int k) {
9
        int n = arr.length;
10
        List<Integer> result = new ArrayList<>();
11
12
        for (int i = 0; i <= n - k; i++) {
13
            boolean found = false;
14
            for (int j = i; j < i + k; j++) {
15
                if (arr[j] < 0) {
16
                    result.add(arr[j]);
17
                    found = true;
18
                    break;
19
                }
20
            }
21
            if (!found) {
22
                result.add(0);
23
            }
24
        }
25
26
        for (int num : result) {
27
            System.out.print(num + "" "");
28
        }
29
        System.out.println();
30
    }
31
32
    public static void main(String[] args) {
33
        Scanner scanner = new Scanner(System.in);
34
35
        int t = scanner.nextInt();
36
        while (t-- > 0) {
37
            int n = scanner.nextInt();
38
            int k = scanner.nextInt();
39
40
            int[] arr = new int[n];
41
            for (int i = 0; i < n; i++) {
42
                arr[i] = scanner.nextInt();
43
            }
44
45
            faultyComponent(arr, k);
46
        }
47
48
        scanner.close();
49
    }
50
}",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052717
1390052721,unknown,unknown,unknown,"1
from collections import deque
2
3
t = int(input())
4
for _ in range(t):
5
    n, k = map(int, input().split())
6
    arr = list(map(int, input().split()))
7
    8
    result = []
9
    dq = deque()
10
11
    for i in range(k):
12
        if arr[i] < 0:
13
            dq.append(i)
14
15
    for i in range(n - k + 1):
16
        result.append(arr[dq[0]] if dq else 0)
17
18
        if dq and dq[0] == i:
19
            dq.popleft()
20
        21
        if i + k < n and arr[i + k] < 0:
22
            dq.append(i + k)
23
    24
    print(*result)
25",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052721
1390052703,unknown,unknown,unknown,"1
def earliest_faulty_readings(arr, k):
2
    n = len(arr)
3
    result = []
4
    5
    for i in range(n - k + 1):
6
        batch = arr[i:i + k]
7
        earliest_fault = next((x for x in batch if x < 0), 0)
8
        result.append(earliest_fault)
9
    10
    return result
11
12
t = int(input())
13
for _ in range(t):
14
    n, k = map(int, input().split())
15
    arr = list(map(int, input().split()))
16
    17
    print(*earliest_faulty_readings(arr, k))
18",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052703
1390052705,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
   8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
   13
    for i in range(len(arr) - k + 1):
14
     15
        if dq:
16
            result.append(arr[dq[0]])
17
        else:
18
            result.append(0)
19
        20
        while dq and dq[0] < i + 1:
21
            dq.popleft()
22
        23
        if i + k < len(arr) and arr[i + k] < 0:
24
            dq.append(i + k)
25
    26
    return result
27
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    arr = list(map(int, input().split()))
32
    33
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052705
1390052714,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    if k >= n:
3
        return 0
4
    5
    min_effort = sum(firewalls)
6
    7
    for i in range(n - k + 1):
8
        skipped = 0
9
        total_effort = 0
10
        11
        for j in range(n):
12
            if skipped < k and i <= j < i + k:
13
                skipped += 1
14
            else:
15
                total_effort += firewalls[j] + skipped
16
        17
        min_effort = min(min_effort, total_effort)
18
    19
    return min_effort
20
21
t = int(input())
22
for i in range(t):
23
    n, k = map(int, input().split())
24
    firewalls = list(map(int, input().split()))
25
    print(min_effort(n, k, firewalls))",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052714
1390052701,unknown,unknown,unknown,"1
def fr(arr, k):
2
    res = []
3
    4
    for i in range(len(arr) - k + 1):
5
        batch = arr[i:i + k]
6
        found = False
7
        8
        for num in batch:
9
            if num < 0:
10
                res.append(num)
11
                found = True
12
                break
13
        14
        if not found:
15
            res.append(0)
16
    17
    return res
18
19
t = int(input())
20
for _ in range(t):
21
    n, k = map(int, input().split())
22
    arr = list(map(int, input().split()))
23
    print(*fr(arr, k))",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052701
1390052702,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    min_cost = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            remaining = s[i:n-j]
10
            11
            idle_remaining = remaining.count('0')
12
            active_removed = s[:i].count('1') + s[n-j:].count('1')
13
            14
            cost = max(idle_remaining, active_removed)
15
            min_cost = min(min_cost, cost)
16
            17
    print(min_cost)
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052702
1390052699,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  
7
8
    9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
13
    14
    result.append(arr[dq[0]] if dq else 0)
15
16
    17
    for i in range(k, n):
18
        19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
22
        23
        if arr[i] < 0:
24
            dq.append(i)
25
26
        27
        result.append(arr[dq[0]] if dq else 0)
28
29
    return result
30
31
32
t = int(input())  
33
for _ in range(t):
34
    n, k = map(int, input().split()) 
35
    arr = list(map(int, input().split()))  
36
37
    38
    print(*earliest_faulty_readings(arr, k))
39",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052699
1390052698,unknown,unknown,unknown,"1
def min_effort_to_breach_firewalls(test_cases):
2
    results = []
3
    4
    for n, k, strengths in test_cases:
5
        # Sort the strengths in ascending order
6
        strengths.sort()
7
        8
        # Calculate the total effort after skipping the k weakest firewalls
9
        total_effort = 0
10
        11
        # Iterate over the remaining firewalls
12
        for i in range(n - k):
13
            total_effort += strengths[i] + k  # Each remaining firewall's strength increases by k
14
        15
        results.append(total_effort)
16
    17
    return results
18
19
# Input reading
20
T = int(input())
21
test_cases = []
22
23
for _ in range(T):
24
    n, k = map(int, input().split())
25
    strengths = list(map(int, input().split()))
26
    test_cases.append((n, k, strengths))
27
28
# Get results
29
results = min_effort_to_breach_firewalls(test_cases)
30
31
# Output results
32
for result in results:
33
    print(result)",169,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052698
1390052694,unknown,unknown,unknown,"1
def min_effort(arr, k):
2
    n = len(arr)
3
    4
    if k >= n:
5
        return 0
6
    7
    total = sum(arr)
8
    9
    impact = []
10
    for i, strength in enumerate(arr):
11
        remaining_firewalls = n - i - 1
12
        net_impact = strength - remaining_firewalls
13
        impact.append((net_impact, i))
14
    15
    impact.sort(reverse=True)
16
    17
    for i in range(k):
18
        if i < len(impact):
19
            net_impact, idx = impact[i]
20
            if net_impact > 0:
21
                total -= net_impact
22
    23
    return total
24
25
def solve():
26
    t = int(input())
27
    28
    for _ in range(t):
29
        n, k = map(int, input().split())
30
        arr = list(map(int, input().split()))
31
        result = min_effort(arr, k)
32
        print(result)
33
34
if __name__ == ""__main__"":
35
    solve()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052694
1390052695,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        if k == n:
6
            results.append(""0"")  # If we can skip all firewalls, effort is 0
7
            continue
8
9
        total_effort = sum(firewalls)
10
        min_effort = total_effort
11
12
        # Sliding window to track k skipped firewalls' effort
13
        window_sum = sum(firewalls[:k])
14
        15
        for i in range(n - k + 1):
16
            increased_security = k  # Each skipped firewall increases later firewalls' strength
17
            new_effort = total_effort - window_sum + increased_security
18
            min_effort = min(min_effort, new_effort)
19
20
            # Move the window forward
21
            if i + k < n:
22
                window_sum = window_sum - firewalls[i] + firewalls[i + k]
23
24
        results.append(str(min_effort))
25
26
    return ""\n"".join(results)
27
28
# Read input
29
T = int(input())
30
test_cases = []
31
32
for _ in range(T):
33
    n, k = map(int, input().split())
34
    firewalls = list(map(int, input().split()))
35
    test_cases.append((n, k, firewalls))
36
37
# Compute and print results
38
print(min_effort_to_breach(T, test_cases))
39",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052695
1390052696,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of faulty readings (negative values)
7
8
    for i in range(n):
9
        # Remove indices that are out of the current window
10
        if dq and dq[0] < i - k + 1:
11
            dq.popleft()
12
13
        # Add the current element's index if it's a negative value (faulty)
14
        if arr[i] < 0:
15
            dq.append(i)
16
17
        # If the window is large enough (i >= k - 1), we check the result
18
        if i >= k - 1:
19
            if dq:
20
                result.append(arr[dq[0]])  # The earliest faulty reading in the window
21
            else:
22
                result.append(0)  # No faulty reading in this window
23
24
    return result
25
26
def process_test_cases():
27
    t = int(input())  # number of test cases
28
    for _ in range(t):
29
        n, k = map(int, input().split())  # size of array and batch size
30
        arr = list(map(int, input().split()))  # the array of sensor readings
31
        result = earliest_faulty_reading(arr, k)
32
        print(' '.join(map(str, result)))
33
34
# Call the function to process test cases
35
process_test_cases()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052696
1390052692,unknown,unknown,unknown,"1
def solve_firewall_problem():
2
    t = int(input())
3
    4
    for _ in range(t):
5
        n, k = map(int, input().split())
6
        strengths = list(map(int, input().split()))
7
        8
        min_effort = float('inf')
9
        10
        for mask in range(1 << n):
11
            if bin(mask).count('1') <= k:
12
                effort = 0
13
                skipped = 0
14
                15
                for i in range(n):
16
                    if (mask >> i) & 1:
17
                        skipped += 1
18
                    else:
19
                        effort += strengths[i] + skipped
20
                21
                min_effort = min(min_effort, effort)
22
        23
        print(min_effort)
24
25
if __name__ == ""__main__"":
26
    solve_firewall_problem()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052692
1390052693,unknown,unknown,unknown,"1
def find_faulty_readings(arr, k):
2
    ans = []
3
    for i in range(len(arr)-k+1):
4
        batch = arr[i: i+k]
5
        fault = 0
6
        for reading in batch:
7
            if reading < 0:
8
                fault=reading
9
                break
10
        ans.append(fault)
11
    return ans
12
def solve():
13
    m = int(input())
14
    for _ in range(m):
15
        n,k = map(int,input().split())
16
        arr = list(map(int,input().split()))
17
        ans = find_faulty_readings(arr,k)
18
        print(*ans)
19
solve()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052693
1390052684,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_earliest_faults(arr, n, k):
4
    result = []
5
    dq = deque()  
6
7
    8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    16
    for i in range(k, n):
17
        18
        if dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
        21
        22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
def main():
31
    t = int(input())
32
    results = []
33
    34
    for _ in range(t):
35
        n, k = map(int, input().split())
36
        arr = list(map(int, input().split()))
37
        38
        39
        result = find_earliest_faults(arr, n, k)
40
        41
        42
        results.append("" "".join(map(str, result)))
43
    44
    45
    print(""\n"".join(results))
46
47
if __name__ == ""__main__"":
48
    main()
49",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052684
1390052685,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Create prefix sums for 1's to optimize counting
5
    prefix_ones = [0] * (n + 1)
6
    for i in range(n):
7
        prefix_ones[i + 1] = prefix_ones[i] + (1 if servers[i] == '1' else 0)
8
    9
    # Create prefix sums for 0's
10
    prefix_zeros = [0] * (n + 1)
11
    for i in range(n):
12
        prefix_zeros[i + 1] = prefix_zeros[i] + (1 if servers[i] == '0' else 0)
13
    14
    min_cost = float('inf')
15
    16
    # Try all possible substrings (start, end)
17
    for start in range(n + 1):
18
        for end in range(start, n + 1):
19
            # Active servers removed = ones before start + ones after end
20
            active_removed = prefix_ones[start] + (prefix_ones[n] - prefix_ones[end])
21
            # Idle servers remaining = zeros between start and end
22
            idle_remaining = prefix_zeros[end] - prefix_zeros[start]
23
            24
            cost = max(idle_remaining, active_removed)
25
            min_cost = min(min_cost, cost)
26
    27
    return min_cost
28
29
# Process test cases
30
t = int(input())
31
for _ in range(t):
32
    servers = input().strip()
33
    print(min_decommissioning_cost(servers))",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052685
1390052687,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total numbers of ones and zeros
5
    total_ones = server_string.count('1')
6
    total_zeros = n - total_ones
7
    8
    # Precompute prefix/suffix counts
9
    prefix_ones = [0] * (n + 1)
10
    prefix_zeros = [0] * (n + 1)
11
    12
    for i in range(n):
13
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_string[i] == '1' else 0)
14
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_string[i] == '0' else 0)
15
    16
    min_cost = float('inf')
17
    18
    # For each possible prefix length
19
    for left in range(n + 1):
20
        # Ones removed from the left
21
        left_ones_removed = prefix_ones[left]
22
        23
        # Remaining zeros after removing left prefix
24
        remaining_zeros_after_left = total_zeros - prefix_zeros[left]
25
        26
        # Optimize right side removal using the fact that we want to minimize
27
        # both remaining zeros and removed ones
28
        right_ones_to_remove = 0
29
        right_zeros_removed = 0
30
        31
        # Binary search approach to find optimal right side removal
32
        lo, hi = 0, n - left
33
        while lo < hi:
34
            mid = (lo + hi) // 2
35
            36
            # If removing up to mid characters from right
37
            ones_right = prefix_ones[n] - prefix_ones[n - mid]
38
            zeros_right = prefix_zeros[n] - prefix_zeros[n - mid]
39
            40
            # Remaining zeros
41
            remaining_zeros = remaining_zeros_after_left - zeros_right
42
            # Total ones removed
43
            removed_ones = left_ones_removed + ones_right
44
            45
            # Current cost
46
            cost = max(remaining_zeros, removed_ones)
47
            48
            # Update minimum
49
            if cost < min_cost:
50
                min_cost = cost
51
                right_ones_to_remove = ones_right
52
                right_zeros_removed = zeros_right
53
            54
            # Decide which direction to continue search
55
            if remaining_zeros > removed_ones:
56
                # Need to remove more zeros
57
                lo = mid + 1
58
            else:
59
                # Need to remove fewer ones
60
                hi = mid
61
    62
    # Handle the special case when binary search didn't find optimal solution
63
    # Check all possible right removals for the best left prefix
64
    for right in range(n - left + 1):
65
        if left + right == n:  # Skip if removing everything
66
            continue
67
            68
        ones_right = prefix_ones[n] - prefix_ones[n - right]
69
        zeros_right = prefix_zeros[n] - prefix_zeros[n - right]
70
        71
        remaining_zeros = remaining_zeros_after_left - zeros_right
72
        removed_ones = left_ones_removed + ones_right
73
        74
        cost = max(remaining_zeros, removed_ones)
75
        min_cost = min(min_cost, cost)
76
    77
    return min_cost
78
79
def linear_solution(server_string):
80
    """"""
81
    O(n) solution that's simpler and more reliable
82
    """"""
83
    n = len(server_string)
84
    total_ones = server_string.count('1')
85
    86
    # Precompute prefix sums
87
    prefix_ones = [0] * (n + 1)
88
    prefix_zeros = [0] * (n + 1)
89
    90
    for i in range(n):
91
        prefix_ones[i+1] = prefix_ones[i] + (1 if server_string[i] == '1' else 0)
92
        prefix_zeros[i+1] = prefix_zeros[i] + (1 if server_string[i] == '0' else 0)
93
    94
    min_cost = float('inf')
95
    96
    # Try all possibilities of where to cut from left (i) and right (j)
97
    for i in range(n + 1):  # left cut position
98
        left_ones_removed = prefix_ones[i]
99
        100
        for j in range(n + 1):  # right cut position
101
            # Skip if we're removing everything
102
            if i + j >= n:
103
                continue
104
                105
            # Ones removed from right
106
            right_ones_removed = total_ones - prefix_ones[n-j]
107
            108
            # Total ones removed
109
            ones_removed = left_ones_removed + right_ones_removed
110
            111
            # Zeros remaining in the middle section
112
            zeros_remaining = prefix_zeros[n-j] - prefix_zeros[i]
113
            114
            # Cost is max of ones removed and zeros remaining
115
            cost = max(ones_removed, zeros_remaining)
116
            117
            min_cost = min(min_cost, cost)
118
    119
    return min_cost
120
121
def solve():
122
    t = int(input())
123
    124
    for _ in range(t):
125
        server_string = input().strip()
126
        # Use linear solution for reliable results
127
        result = linear_solution(server_string)
128
        print(result)
129
130
# Execute the solution
131
solve()",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052687
1390052676,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
        Scanner sc = new Scanner(System.in);
9
        int T = sc.nextInt();
10
        while (T-- > 0) {
11
            int n = sc.nextInt();
12
            int k = sc.nextInt();
13
            long[] a = new long[n];
14
            for (int i = 0; i < n; i++) {
15
                a[i] = sc.nextLong();
16
            }
17
            18
            long[][] dp = new long[n + 1][k + 1];
19
            for (int i = 0; i <= n; i++) {
20
                for (int j = 0; j <= k; j++) {
21
                    dp[i][j] = Long.MAX_VALUE / 2; // Avoid overflow in min operations
22
                }
23
            }
24
            dp[0][0] = 0;
25
            26
            for (int i = 0; i < n; i++) {
27
                for (int j = 0; j <= k; j++) {
28
                    if (dp[i][j] >= Long.MAX_VALUE / 2) continue;
29
                    // Don't skip current firewall
30
                    if (dp[i + 1][j] > dp[i][j] + a[i] + j) {
31
                        dp[i + 1][j] = dp[i][j] + a[i] + j;
32
                    }
33
                    // Skip current firewall
34
                    if (j + 1 <= k && dp[i + 1][j + 1] > dp[i][j]) {
35
                        dp[i + 1][j + 1] = dp[i][j];
36
                    }
37
                }
38
            }
39
            40
            long minEffort = Long.MAX_VALUE;
41
            for (int j = 0; j <= k; j++) {
42
                if (dp[n][j] < minEffort) {
43
                    minEffort = dp[n][j];
44
                }
45
            }
46
            System.out.println(minEffort == Long.MAX_VALUE / 2 ? 0 : minEffort);
47
        }
48
        sc.close();
49
    }
50
}",170,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052676
1390052670,unknown,unknown,unknown,"1
def min_effort(n, k, strengths):
2
    total_effort = sum(strengths)  
3
    4
    for i in range(n - k + 1):  
5
        skipped_effort = sum(strengths[i:i + k])  
6
        increased_effort = sum(strengths[:i]) + sum(strengths[i + k:]) + (n - (i + k)) * k
7
        8
        total_effort = min(total_effort, increased_effort)
9
    10
    return total_effort
11
12
13
T = int(input())
14
for _ in range(T):
15
    n, k = map(int, input().split())
16
    strengths = list(map(int, input().split()))
17
    print(min_effort(n, k, strengths))
18
19",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052670
1390052672,unknown,unknown,unknown,"1
def solve():
2
    s = input()
3
    n = len(s)
4
    5
    min_cost = float('inf')
6
    7
    for i in range(n + 1):
8
        for j in range(n - i + 1):
9
            remaining = s[i:n-j]
10
            11
            idle_remaining = remaining.count('0')
12
            active_removed = s[:i].count('1') + s[n-j:].count('1')
13
            14
            cost = max(idle_remaining, active_removed)
15
            min_cost = min(min_cost, cost)
16
            17
    print(min_cost)
18
19
t = int(input())
20
for _ in range(t):
21
    solve()",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052672
1390052673,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
#include <algorithm>
4
5
using namespace std;
6
7
long long minEffort(vector<int>& firewalls, int n, int k) {
8
    // If we can skip all firewalls, return 0
9
    if (k >= n) return 0;
10
    11
    // Calculate the total cost of skipping each firewall
12
    vector<long long> skipCost(n, 0);
13
    14
    for (int i = 0; i < n; i++) {
15
        // If we skip firewall i, all subsequent firewalls (n-i-1 of them) increase by 1
16
        skipCost[i] = firewalls[i] - (n - i - 1);
17
    }
18
    19
    // Sort firewalls by their skip cost
20
    vector<pair<long long, int>> indexedCosts(n);
21
    for (int i = 0; i < n; i++) {
22
        indexedCosts[i] = {skipCost[i], i};
23
    }
24
    25
    sort(indexedCosts.begin(), indexedCosts.end());
26
    27
    // Mark which firewalls to skip (those with the highest skip cost)
28
    vector<bool> skip(n, false);
29
    for (int i = n - 1; i >= max(0, n - k); i--) {
30
        skip[indexedCosts[i].second] = true;
31
    }
32
    33
    // Calculate the total effort
34
    long long totalEffort = 0;
35
    int penaltyCount = 0;
36
    37
    for (int i = 0; i < n; i++) {
38
        if (skip[i]) {
39
            // Skip this firewall
40
            penaltyCount++;
41
        } else {
42
            // Don't skip - add the current strength plus penalty
43
            totalEffort += firewalls[i] + penaltyCount;
44
        }
45
    }
46
    47
    return totalEffort;
48
}
49
50
int main() {
51
    ios_base::sync_with_stdio(false);
52
    cin.tie(NULL);
53
    54
    int t;
55
    cin >> t;
56
    57
    while (t--) {
58
        int n, k;
59
        cin >> n >> k;
60
        61
        vector<int> firewalls(n);
62
        for (int i = 0; i < n; i++) {
63
            cin >> firewalls[i];
64
        }
65
        66
        cout << minEffort(firewalls, n, k) << endl;
67
    }
68
    69
    return 0;
70
}",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052673
1390052663,unknown,unknown,unknown,"1
2
import java.util.*;
3
4
public class FaultySensorReadings {
5
    public static void main(String[] args) {
6
        Scanner sc = new Scanner(System.in);
7
        int t = sc.nextInt(); // Number of test cases
8
9
        while (t-- > 0) {
10
            int n = sc.nextInt(); // Size of array
11
            int k = sc.nextInt(); // Batch size
12
            int[] arr = new int[n];
13
14
            for (int i = 0; i < n; i++) {
15
                arr[i] = sc.nextInt();
16
            }
17
18
            List<Integer> result = findEarliestFaultyReadings(arr, k);
19
            for (int num : result) {
20
                System.out.print(num + "" "");
21
            }
22
            System.out.println();
23
        }
24
        sc.close();
25
    }
26
27
    public static List<Integer> findEarliestFaultyReadings(int[] arr, int k) {
28
        List<Integer> result = new ArrayList<>();
29
        Deque<Integer> deque = new LinkedList<>();
30
31
        for (int i = 0; i < arr.length; i++) {
32
            // Remove elements that are out of the current window
33
            if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
34
                deque.pollFirst();
35
            }
36
37
            // Add current element index if it's faulty (negative)
38
            if (arr[i] < 0) {
39
                deque.offerLast(i);
40
            }
41
42
            // Collect result once the first batch is formed
43
            if (i >= k - 1) {
44
                if (!deque.isEmpty()) {
45
                    result.add(arr[deque.peekFirst()]);
46
                } else {
47
                    result.add(0);
48
                }
49
            }
50
        }
51
        return result;
52
    }
53
}
54",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052663
1390052665,unknown,unknown,unknown,"1
def find_earliest_faulty(arr, k):
2
    result = []
3
    n = len(arr)
4
    for i in range(n - k + 1):
5
        batch = arr[i:i + k]
6
        faulty = 0
7
        for num in batch:
8
            if num < 0:
9
                faulty = num
10
                break
11
        result.append(faulty)
12
    return result
13
14
def main():
15
    import sys
16
    input = sys.stdin.read
17
    data = input().split()
18
    idx = 0
19
    t = int(data[idx])
20
    idx += 1
21
    for _ in range(t):
22
        n, k = int(data[idx]), int(data[idx + 1])
23
        idx += 2
24
        arr = list(map(int, data[idx:idx + n]))
25
        idx += n
26
        result = find_earliest_faulty(arr, k)
27
        print(' '.join(map(str, result)))
28
29
if __name__ == ""__main__"":
30
    main()",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052665
1390052669,unknown,unknown,unknown,"1
def min_firewall_effort(n, k, firewalls):
2
    """"""
3
    Calculates the minimum effort needed to breach the network.
4
5
    Args:
6
        n: The number of firewalls.
7
        k: The maximum number of firewalls that can be skipped.
8
        firewalls: A list of firewall strengths.
9
10
    Returns:
11
        The minimum effort needed.
12
    """"""
13
    min_effort = float('inf')
14
15
    for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
16
        skipped_count = bin(i).count('1')
17
        if skipped_count <= k:
18
            current_effort = 0
19
            skipped = 0
20
            current_firewalls = firewalls[:]  # Create a copy to avoid modifying the original list
21
22
            skipped_indices = []
23
            for j in range(n):
24
                if (i >> j) & 1:
25
                    skipped_indices.append(j)
26
27
            skipped_indices.sort()
28
            29
            j = 0
30
            for index in skipped_indices:
31
                for l in range(index+1,n):
32
                    current_firewalls[l] +=1
33
34
            for j in range(n):
35
                if (i >> j) & 1:
36
                    continue
37
                else:
38
                    current_effort += current_firewalls[j]
39
40
            min_effort = min(min_effort, current_effort)
41
42
    return min_effort
43
44
if __name__ == ""__main__"":
45
    t = int(input())
46
    for _ in range(t):
47
        n, k = map(int, input().split())
48
        firewalls = list(map(int, input().split()))
49
        result = min_firewall_effort(n, k, firewalls)
50
        print(result)",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052669
1390052655,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # If we can skip all firewalls, return 0
3
    if k >= n:
4
        return 0
5
        6
    # Create an array to track the minimum effort to breach the network
7
    # dp[i][j] = min effort to process first i firewalls with j skips
8
    dp = [[float('inf')] * (min(k, n) + 1) for _ in range(n + 1)]
9
    dp[0][0] = 0  # Base case: no firewalls, no skips, no effort
10
    11
    for i in range(1, n + 1):
12
        for j in range(min(i, k) + 1):  # We can't skip more firewalls than we've seen
13
            # Option 1: Don't skip current firewall
14
            if j <= i - 1:
15
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[i-1] + j)
16
            17
            # Option 2: Skip current firewall (if we have skips left)
18
            if j > 0:
19
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
20
    21
    # Find minimum effort across all possible skip counts
22
    return min(dp[n])
23
24
def main():
25
    try:
26
        t = int(input().strip())
27
        28
        for _ in range(t):
29
            line = input().strip().split()
30
            n, k = int(line[0]), int(line[1])
31
            32
            strengths = list(map(int, input().strip().split()))
33
            34
            # Ensure we have the right number of strengths
35
            if len(strengths) != n:
36
                # Handle case where input is malformed
37
                continue
38
                39
            result = min_effort_to_breach(n, k, strengths)
40
            print(result)
41
    except Exception as e:
42
        # Fallback for any unexpected errors
43
        print(0)  # Default answer if something goes wrong
44
45
if __name__ == ""__main__"":
46
    main()",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052655
1390052660,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
11
        Scanner sc = new Scanner(System.in);
12
        int t = sc.nextInt();
13
        while (t-- > 0) {
14
            int n = sc.nextInt(), k = sc.nextInt();
15
            int[] arr = new int[n];
16
            for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
17
            Deque<Integer> dq = new LinkedList<>();
18
            for (int i = 0; i < n; i++) {
19
                if (arr[i] < 0) dq.addLast(i);
20
                if (i >= k - 1) {
21
                    while (!dq.isEmpty() && dq.peekFirst() < i - k + 1) dq.pollFirst();
22
                    System.out.print((dq.isEmpty() ? 0 : arr[dq.peekFirst()]) + "" "");
23
                }
24
            }
25
            System.out.println();
26
        }
27
        sc.close();
28
    }
29
}",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052660
1390052650,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
6
7
public class Solution {
8
    public static void main(String[] args) {
9
        Scanner sc = new Scanner(System.in);
10
        int t = sc.nextInt(); 
11
        while (t-- > 0) {
12
            int n = sc.nextInt(); 
13
            int k = sc.nextInt();
14
            int[] a = new int[n]; 
15
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
16
17
            findFaulty(a, n, k); 
18
        }
19
    }
20
21
    public static void findFaulty(int[] a, int n, int k) {
22
        int fn = 0, i = 0, j = 0; 
23
24
        while (j < n) {
25
            if (j - i + 1 < k) j++; 
26
            else {
27
                28
                while (fn < i || (fn <= j && a[fn] >= 0)) fn++;
29
30
                31
                if (fn >= i && fn <= j) System.out.print(a[fn] + "" "");
32
                else System.out.print(""0 "");
33
34
                i++; j++; 
35
            }
36
        }
37
        System.out.println();
38
    }
39
}",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052650
1390052645,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int T = sc.nextInt();  // Number of test cases
7
        sc.nextLine(); // Consume newline
8
9
        while (T-- > 0) {
10
            String servers = sc.nextLine();
11
            System.out.println(minimumPruningCost(servers));
12
        }
13
        sc.close();
14
    }
15
16
    public static int minimumPruningCost(String servers) {
17
    int n = servers.length();
18
    int firstOne = servers.indexOf('1');
19
    int lastOne = servers.lastIndexOf('1');
20
    21
    // If no active servers exist, the cost is 0
22
    if (firstOne == -1) return 0;
23
    24
    // Count groups of zeros
25
    int zeroGroups = 0;
26
    boolean inZeroGroup = false;
27
    28
    for (int i = firstOne; i <= lastOne; i++) {
29
        if (servers.charAt(i) == '0') {
30
            if (!inZeroGroup) {
31
                // Start of a new group of zeros
32
                zeroGroups++;
33
                inZeroGroup = true;
34
            }
35
        } else {
36
            // We found a '1', so we're no longer in a zero group
37
            inZeroGroup = false;
38
        }
39
    }
40
    41
    return zeroGroups;
42
}
43
}
44",171,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052645
1390052632,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
4
using namespace std;
5
6
void findnegative(vector<int>& arr, int n, int k) {
7
    for (int i = 0; i <= n - k; i++) {
8
        int tempans = 0;
9
    for (int j = i; j < i + k; j++) {
10
           if (arr[j] < 0) {
11
            tempans = arr[j];
12
                break;
13
            }
14
        }
15
  cout << tempans<<"" "";
16
    }
17
    cout << endl;
18
}
19
20
int main() {
21
    int t;
22
cin >> t;
23
24
    while (t--) {
25
        int n, k;
26
         cin >> n >> k;
27
28
    vector<int> arr(n);
29
        for (int i = 0; i < n; i++) {
30
           cin >> arr[i];
31
        }
32
         findnegative(arr, n, k);
33
    }
34
35
    return 0;
36
}",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052632
1390052635,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Process the remaining windows
13
    for i in range(len(arr) - k + 1):
14
        # If deque is not empty, the first element is the earliest negative
15
        if dq:
16
            result.append(arr[dq[0]])
17
        else:
18
            result.append(0)
19
        20
        # Remove elements that are out of the current window
21
        while dq and dq[0] < i + 1:
22
            dq.popleft()
23
        24
        # Add the next element (end of the new window)
25
        if i + k < len(arr) and arr[i + k] < 0:
26
            dq.append(i + k)
27
    28
    return result
29
30
# Read input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    print(*earliest_faulty_readings(arr, k))
36",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052635
1390052637,unknown,unknown,unknown,"1
def find_earliest_faults(arr, k):
2
    result = []
3
    for i in range(len(arr) - k + 1):
4
        batch = arr[i:i + k]
5
        fault_found = False
6
        for reading in batch:
7
            if reading < 0:
8
                result.append(reading)
9
                fault_found = True
10
                break
11
        if not fault_found:
12
            result.append(0)
13
    return result
14
15
def process_testcases(testcases):
16
    results = []
17
    for arr, k in testcases:
18
        results.append(find_earliest_faults(arr, k))
19
    return results
20
21
if __name__ == ""__main__"":
22
    num_testcases = int(input())
23
    testcases = []
24
    for _ in range(num_testcases):
25
        n, k = map(int, input().split())
26
        arr = list(map(int, input().split()))
27
        testcases.append((arr, k))
28
29
    results = process_testcases(testcases)
30
    for result in results:
31
        print(*result)",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052637
1390052628,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_faulty_readings(test_cases):
4
    results = []
5
    6
    for case in test_cases:
7
        n, k, arr = case
8
        faulty_indices = deque()
9
        result = []
10
        11
        for i in range(n):
12
            13
            if faulty_indices and faulty_indices[0] < i - k + 1:
14
                faulty_indices.popleft()
15
            if arr[i] < 0:
16
                faulty_indices.append(i)
17
            18
            if i >= k - 1:
19
                if faulty_indices:
20
                    result.append(arr[faulty_indices[0]])
21
                else:
22
                    result.append(0)
23
        24
        results.append(result)
25
    26
    return results
27
28
t = int(input())  
29
test_cases = []
30
for _ in range(t):
31
    n, k = map(int, input().split()) 
32
    arr = list(map(int, input().split()))
33
    test_cases.append((n, k, arr))
34
35
results = find_faulty_readings(test_cases)
36
for result in results:
37
    print("" "".join(map(str, result)))
38",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052628
1390052630,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
11
        Scanner sc = new Scanner(System.in);
12
        int t = sc.nextInt();
13
        while(t-->0){
14
            int n = sc.nextInt();
15
            int k = sc.nextInt();
16
            int []arr = new int [n];
17
            ArrayList<Integer> list = new ArrayList<>();
18
            for(int i=0;i<n;i++){
19
                arr[i] = sc.nextInt();
20
            }
21
            22
            for (int i=0;i<=n-k;i++){
23
                int value = 0;
24
                for(int j=i;j<k+i;j++){
25
                    if(arr[j]<0){
26
                        value = arr[j];
27
                        break;
28
                    }
29
                }
30
                 list.add(value);
31
            }
32
            33
            for (int num : list) {
34
                System.out.print(num + "" "");
35
            }
36
            37
            System.out.println();
38
            39
            40
        }
41
        42
    }
43
}",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052630
1390052631,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    result = []
3
    4
    for i in range(len(arr) - k + 1):
5
        6
        batch = arr[i:i+k]
7
        fault_found = False
8
        9
        10
        for num in batch:
11
            if num < 0:
12
                result.append(num)
13
                fault_found = True
14
                break
15
        16
        17
        if not fault_found:
18
            result.append(0)
19
    20
    return result
21
22
23
t = int(input())  
24
25
for _ in range(t):
26
    n, k = map(int, input().split())  
27
    arr = list(map(int, input().split()))  
28
    29
    result = earliest_fault(arr, k)
30
    print(*result)  ",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052631
1390052622,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
       Scanner sc = new Scanner(System.in);
11
        int t = sc.nextInt(); 
12
        13
        while (t-- > 0) {
14
            int n = sc.nextInt();  
15
            int k = sc.nextInt(); 
16
            int[] arr = new int[n];
17
            for (int i = 0; i < n; i++) {
18
                arr[i] = sc.nextInt();
19
            }
20
            for (int i = 0; i <= n - k; i++) {
21
                int firstfa = 0; 
22
                for (int j = i; j < i + k; j++) {
23
                    if (arr[j] < 0) {
24
                        firstfa = arr[j];  
25
                        break; 
26
                    }
27
                }
28
            System.out.print(firstfa + "" "");  
29
            }
30
            System.out.println(); 
31
            }
32
        sc.close();
33
    }
34
}",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052622
1390052626,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()  
6
7
    8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    13
    result.append(arr[dq[0]] if dq else 0)
14
15
    16
    for i in range(k, len(arr)):
17
        18
        while dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
        21
        22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        26
        result.append(arr[dq[0]] if dq else 0)
27
28
    return result
29
30
31
t = int(input().strip())
32
33
for _ in range(t):
34
    n, k = map(int, input().split())
35
    arr = list(map(int, input().split()))
36
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))
37",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052626
1390052621,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(t, test_cases):
4
5
    results = []
6
7
    8
9
    for case in test_cases:
10
11
        n, k, readings = case
12
13
        result = []
14
15
        dq = deque()  # Stores indices of negative numbers
16
17
        # Process the first window
18
19
        for i in range(k):
20
21
            if readings[i] < 0:
22
23
                dq.append(i)
24
25
        # Process the sliding windows
26
27
        for i in range(n - k + 1):
28
29
            # Append the first negative in the deque, or 0 if empty
30
31
            result.append(readings[dq[0]] if dq else 0)
32
33
            # Remove elements that are out of this window
34
35
            if dq and dq[0] == i:
36
37
                dq.popleft()
38
39
            # Add next element (i + k) to the deque if it's negative
40
41
            if i + k < n and readings[i + k] < 0:
42
43
                dq.append(i + k)
44
45
        results.append("" "".join(map(str, result)))  # Convert list to space-separated string
46
47
    48
49
    return ""\n"".join(results)
50
51
# Example Usage
52
53
t = 2
54
55
test_cases = [
56
57
    (5, 2, [-8, 2, 3, -6, 10]),
58
59
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
60
61
]
62
63
print(earliest_faulty_readings(t, test_cases))",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052621
1390052615,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        result = []
8
        dq = deque()
9
        10
        # Process first window
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
        15
        # Store the first result
16
        result.append(arr[dq[0]] if dq else 0)
17
        18
        # Process remaining windows
19
        for i in range(k, n):
20
            # Remove elements no longer in window
21
            if dq and dq[0] <= i - k:
22
                dq.popleft()
23
            24
            # Add new element if it's faulty
25
            if arr[i] < 0:
26
                dq.append(i)
27
            28
            # Store result for current window
29
            result.append(arr[dq[0]] if dq else 0)
30
        31
        results.append("" "".join(map(str, result)))
32
    33
    return results
34
35
# Read input
36
t = int(input())
37
test_cases = []
38
for _ in range(t):
39
    n, k = map(int, input().split())
40
    arr = list(map(int, input().split()))
41
    test_cases.append((n, k, arr))
42
43
# Compute and print output
44
for res in earliest_faulty_readings(test_cases):
45
    print(res)
46",172,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052615
1390052609,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, strengths):
2
    # Initialize array to store minimum effort for each possible combination
3
    # dp[i][j] = min effort to process first i firewalls using j skips
4
    dp = [[float('inf') for _ in range(k+1)] for _ in range(n+1)]
5
    dp[0][0] = 0  # Base case: no firewalls, no skips, no effort
6
    7
    for i in range(1, n+1):
8
        firewall_idx = i-1  # Convert to 0-indexed for strengths array
9
        10
        for j in range(k+1):
11
            # Option 1: Don't skip current firewall
12
            if j <= i-1:  # Can only have used j skips on previous i-1 firewalls
13
                # Current strength + penalty of j for j previously skipped firewalls
14
                dp[i][j] = min(dp[i][j], dp[i-1][j] + strengths[firewall_idx] + j)
15
            16
            # Option 2: Skip current firewall (if we have skips left)
17
            if j > 0:
18
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
19
    20
    # Return minimum effort after processing all firewalls with any number of skips
21
    return min(dp[n])
22
23
def main():
24
    t = int(input().strip())
25
    26
    for _ in range(t):
27
        n, k = map(int, input().strip().split())
28
        strengths = list(map(int, input().strip().split()))
29
        30
        result = min_effort_to_breach(n, k, strengths)
31
        print(result)
32
33
if __name__ == ""__main__"":
34
    main()",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052609
1390052611,unknown,unknown,unknown,"1
def min_effort_to_breach(count, max_skip, values):
2
    if max_skip >= count:
3
        return 0
4
    5
    effort = [[float('inf')] * (max_skip + 1) for _ in range(count + 1)]
6
    effort[0][0] = 0
7
    8
    for i in range(1, count + 1):
9
        for j in range(max_skip + 1):
10
            if j > 0:
11
                current_value = values[i-1] + j
12
            else:
13
                current_value = values[i-1]
14
            15
            if effort[i-1][j] != float('inf'):
16
                effort[i][j] = min(effort[i][j], effort[i-1][j] + current_value)
17
            18
            if j < max_skip:
19
                effort[i][j+1] = min(effort[i][j+1], effort[i-1][j])
20
    21
    return min(effort[count])
22
23
def solve():
24
    test_cases = int(input().strip())
25
    results = []
26
    27
    for _ in range(test_cases):
28
        count, max_skip = map(int, input().strip().split())
29
        values = list(map(int, input().strip().split()))
30
        results.append(min_effort_to_breach(count, max_skip, values))
31
    32
    for result in results:
33
        print(result)
34
35
if __name__ == ""__main__"":
36
    solve()",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052611
1390052613,unknown,unknown,unknown,1,173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052613
1390052601,unknown,unknown,unknown,1,173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052601
1390052605,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        if k == n:
6
            results.append(""0"")  # If all firewalls can be skipped, effort is 0
7
            continue
8
9
        total_effort = sum(firewalls)
10
        min_effort = total_effort
11
12
        # Compute the initial window sum (sum of first k firewalls)
13
        window_sum = sum(firewalls[:k])
14
15
        # Iterate through possible skip windows
16
        for i in range(n - k + 1):
17
            skipped_firewalls = k
18
            increased_security = sum(range(1, skipped_firewalls + 1))  # Penalty for skipping
19
            20
            new_effort = total_effort - window_sum + increased_security
21
            min_effort = min(min_effort, new_effort)
22
23
            # Move the sliding window
24
            if i + k < n:
25
                window_sum = window_sum - firewalls[i] + firewalls[i + k]
26
27
        results.append(str(min_effort))
28
29
    return ""\n"".join(results)
30
31
# Read input
32
T = int(input())
33
test_cases = []
34
35
for _ in range(T):
36
    n, k = map(int, input().split())
37
    firewalls = list(map(int, input().split()))
38
    test_cases.append((n, k, firewalls))
39
40
# Compute and print results
41
print(min_effort_to_breach(T, test_cases))
42",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052605
1390052607,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string)
3
    4
    # Count total active and idle servers
5
    total_active = server_string.count('1')
6
    total_idle = server_string.count('0')
7
    8
    min_cost = float('inf')
9
    10
    # Try all possible combinations of removing servers from beginning and end
11
    for left in range(n + 1):  # Servers to remove from left (including 0)
12
        for right in range(n + 1 - left):  # Servers to remove from right (including 0)
13
            # Skip if we're removing all servers
14
            if left + right == n:
15
                continue
16
                17
            # Calculate remaining substring
18
            remaining = server_string[left:n-right]
19
            20
            # Count remaining idle servers
21
            remaining_idle = remaining.count('0')
22
            23
            # Count active servers removed
24
            active_removed = total_active - remaining.count('1')
25
            26
            # Calculate cost
27
            cost = max(remaining_idle, active_removed)
28
            29
            # Update minimum cost
30
            min_cost = min(min_cost, cost)
31
    32
    return min_cost
33
34
def solve():
35
    t = int(input())
36
    37
    for _ in range(t):
38
        server_string = input().strip()
39
        result = min_decommission_cost(server_string)
40
        print(result)
41
42
# Execute the solution
43
solve()",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052607
1390052590,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
5
    int n = arr.size();
6
    vector<int> result;
7
    deque<int> dq;  // Stores indices of negative numbers
8
9
    // Process first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) dq.push_back(i);
12
    }
13
14
    // Process the sliding window
15
    for (int i = k; i <= n; i++) {
16
        // Append first negative number in the window
17
        if (!dq.empty()) 
18
            result.push_back(arr[dq.front()]);  // First negative in the deque
19
        else 
20
            result.push_back(0);  // No negative number
21
22
        // Remove elements that are out of the current window
23
        while (!dq.empty() && dq.front() < i - k + 1) {
24
            dq.pop_front();
25
        }
26
27
        // Add the next element if negative
28
        if (i < n && arr[i] < 0) {
29
            dq.push_back(i);
30
        }
31
    }
32
33
    return result;
34
}
35
36
int main() {
37
    int t;
38
    cin >> t;  // Number of test cases
39
    while (t--) {
40
        int n, k;
41
        cin >> n >> k;  // Size of array and batch size
42
        vector<int> arr(n);
43
        for (int i = 0; i < n; i++) {
44
            cin >> arr[i];
45
        }
46
        47
        vector<int> result = earliest_faulty_readings(arr, k);
48
        for (int num : result) {
49
            cout << num << "" "";
50
        }
51
        cout << endl;
52
    }
53
    return 0;
54
}",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052590
1390052592,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        dq = deque()
8
        res = []
9
        10
 11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
        15
        16
        res.append(arr[dq[0]] if dq else 0)
17
        18
 19
        for i in range(k, n):
20
     21
            if dq and dq[0] < i - k + 1:
22
                dq.popleft()
23
            24
          25
            if arr[i] < 0:
26
                dq.append(i)
27
            28
           29
            res.append(arr[dq[0]] if dq else 0)
30
        31
        results.append(res)
32
    33
    return results
34
35
36
t = int(input())
37
test_cases = []
38
for _ in range(t):
39
    n, k = map(int, input().split())
40
    arr = list(map(int, input().split()))
41
    test_cases.append((n, k, arr))
42
43
44
output = earliest_faulty_readings(test_cases)
45
for res in output:
46
    print(*res)
47",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052592
1390052596,unknown,unknown,unknown,"1
def minimize_effort(test_cases):
2
    results = []
3
    4
    for n, k, strengths in test_cases:
5
        # Sort the strengths array to prioritize skipping the most costly firewalls
6
        strengths.sort()
7
        8
        # Skip up to k strongest firewalls, which are now the last k elements in the sorted list
9
        total_effort = sum(strengths[:-k]) if k < n else 0
10
        11
        results.append(total_effort)
12
    13
    return results
14
15
# Input reading
16
T = int(input())
17
test_cases = []
18
19
for _ in range(T):
20
    n, k = map(int, input().split())
21
    strengths = list(map(int, input().split()))
22
    test_cases.append((n, k, strengths))
23
24
# Get results
25
results = minimize_effort(test_cases)
26
27
# Output results
28
for res in results:
29
    print(res)",173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052596
1390052588,unknown,unknown,unknown,1,173,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052588
1390052579,unknown,unknown,unknown,"1
def minimize_effort(test_cases):
2
    results = []
3
    4
    for case in test_cases:
5
        n, k, firewalls = case
6
        7
        min_effort = float('inf')
8
        9
        for i in range(1 << n):
10
            skipped_count = 0
11
            current_effort = 0
12
            13
            skipped = []
14
            for j in range(n):
15
                if (i >> j) & 1:
16
                    skipped_count += 1
17
                    skipped.append(j)
18
                    19
            if skipped_count <= k:
20
                effort = 0
21
                increase = 0
22
                23
                for j in range(n):
24
                    if j in skipped:
25
                        increase += 1
26
                    else:
27
                        effort += firewalls[j]
28
                        29
                min_effort = min(min_effort, effort + increase * k)  # Correct effort calculation
30
        31
        results.append(min_effort)
32
    33
    return results
34
35
# Input reading and processing
36
def main():
37
    t = int(input())  # Number of test cases
38
    test_cases = []
39
    40
    for _ in range(t):
41
        n, k = map(int, input().split())  # Number of firewalls and max skips
42
        firewalls = list(map(int, input().split()))  # Strength of each firewall
43
        test_cases.append((n, k, firewalls))
44
    45
    results = minimize_effort(test_cases)
46
    47
    for result in results:
48
        print(result)
49
50
# Run the program
51
if __name__ == ""__main__"":
52
    main()
53",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052579
1390052580,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt();
7
8
        while (t-- > 0) {
9
            int n = sc.nextInt();
10
            int k = sc.nextInt();
11
            int[] arr = new int[n];
12
13
            for (int i = 0; i < n; i++) {
14
                arr[i] = sc.nextInt();
15
            }
16
17
            List<Integer> result = new ArrayList<>();
18
            19
            for (int i = 0; i <= n - k; i++) {
20
                boolean foundFault = false;
21
                for (int j = i; j < i + k; j++) {
22
                    if (arr[j] < 0) {
23
                        result.add(arr[j]);
24
                        foundFault = true;
25
                        break;
26
                    }
27
                }
28
                if (!foundFault) {
29
                    result.add(0);
30
                }
31
            }
32
33
            for (int num : result) {
34
                System.out.print(num + "" "");
35
            }
36
            System.out.println();
37
        }
38
39
        sc.close();
40
    }
41
}",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052580
1390052586,unknown,unknown,unknown,"1
def earliest_faulty_reading(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, arr = case
5
        result = []
6
        for i in range(n - k + 1):
7
            batch = arr[i:i + k]
8
            faulty = next((x for x in batch if x < 0), 0)
9
            result.append(faulty)
10
        results.append(result)
11
    return results
12
13
# Example usage
14
test_cases = [
15
    (5, 2, [-8, 2, 3, -6, 10]),
16
    (8, 3, [12, -1, -7, 8, -15, 30, 16, 28])
17
]
18
19
output = earliest_faulty_reading(test_cases)
20
for res in output:
21
    print("" "".join(map(str, res)))
22",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052586
1390052574,unknown,unknown,unknown,"1
def earliest_fault_in_batches(arr, k):
2
    results = []
3
    n = len(arr)
4
    5
    6
    for i in range(n - k + 1):
7
        batch = arr[i:i+k]
8
        9
        10
        fault_found = False
11
        for val in batch:
12
            if val < 0:
13
                results.append(val)
14
                fault_found = True
15
                break
16
        17
        18
        if not fault_found:
19
            results.append(0)
20
    21
    return results
22
23
24
def solve_test_cases():
25
    t = int(input())  
26
    results = []
27
    28
    for _ in range(t):
29
        n, k = map(int, input().split())
30
        arr = list(map(int, input().split()))
31
        32
        batch_results = earliest_fault_in_batches(arr, k)
33
        results.append(batch_results)
34
    35
    36
    for batch_result in results:
37
        print(*batch_result)
38
39
40
if __name__ == ""__main__"":
41
    solve_test_cases()",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052574
1390052577,unknown,unknown,unknown,"1
def minimum_effort(n, k, arr):
2
    total_sum = sum(arr)
3
    4
    if k == n:
5
        return 0
6
    7
    current_window_sum = sum(arr[:k])
8
    min_effort = total_sum - current_window_sum + (n - k)
9
    10
    for i in range(1, n - k + 1):
11
        current_window_sum += arr[i + k - 1] - arr[i - 1]
12
        effort = total_sum - current_window_sum + (n - (i + k))
13
        min_effort = min(min_effort, effort)
14
    15
    return min_effort
16
17
t = int(input())
18
for _ in range(t):
19
    n, k = map(int, input().split())
20
    arr = list(map(int, input().split()))
21
    result = minimum_effort(n, k, arr)
22
    print(result)",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052577
1390052573,unknown,unknown,unknown,"1
def min_decommission_cost(server_string):
2
    n = len(server_string) 
3
    total_active = server_string.count('1')
4
    total_idle = server_string.count('0')
5
    min_cost = float('inf')
6
    for left in range(n + 1):  
7
        for right in range(n + 1 - left):  
8
            if left + right == n:
9
                continue
10
            remaining = server_string[left:n-right]
11
            remaining_idle = remaining.count('0')
12
            active_removed = total_active - remaining.count('1')
13
            cost = max(remaining_idle, active_removed)
14
            min_cost = min(min_cost, cost)
15
    return min_cost
16
17
def solve():
18
    t = int(input())
19
    for _ in range(t):
20
        server_string = input().strip()
21
        result = min_decommission_cost(server_string)
22
        print(result)
23
24
solve()",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052573
1390052566,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)  # Case where no firewall is skipped
3
    4
    if k == n:
5
        return 0  # If we can skip all firewalls, effort is zero
6
    7
    min_effort = total_effort  # Initialize min_effort with total sum
8
    9
    for i in range(n):
10
        skipped_effort = total_effort - firewalls[i] + k  # Skip firewall i
11
        min_effort = min(min_effort, skipped_effort)
12
    13
    return min_effort
14
15
def main():
16
    t = int(input())
17
    for _ in range(t):
18
        n, k = map(int, input().split())
19
        firewalls = list(map(int, input().split()))
20
        print(min_effort(n, k, firewalls))
21
22
if __name__ == ""__main__"":
23
    main()
24",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052566
1390052565,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
12
    for i in range(n - k + 1):
13
        if dq:
14
            result.append(arr[dq[0]])
15
        else:
16
            result.append(0)
17
18
        while dq and dq[0] < i + 1:
19
            dq.popleft()
20
21
        if i + k < n and arr[i + k] < 0:
22
            dq.append(i + k)
23
24
    print(*result)
25
26
27
t = int(input())
28
for _ in range(t):
29
    n, k = map(int, input().split())
30
    arr = list(map(int, input().split()))
31
    earliest_faulty_readings(arr, k)",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052565
1390052571,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of this window
18
        if dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
        21
        # Add new element if it's negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store result for the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Reading input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    36
    print(*earliest_faulty_readings(arr, k))",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052571
1390052561,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
8
        Scanner sc = new Scanner(System.in);
9
        int T = sc.nextInt();
10
        while (T-- > 0) {
11
            int n = sc.nextInt();
12
            int k = sc.nextInt();
13
            int[] a = new int[n];
14
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
15
            16
            long[][] dp = new long[n + 1][k + 1];
17
            for (int i = 0; i <= n; i++) {
18
                for (int j = 0; j <= k; j++) {
19
                    dp[i][j] = Long.MAX_VALUE;
20
                }
21
            }
22
            dp[0][0] = 0;
23
            24
            for (int i = 0; i < n; i++) {
25
                for (int j = 0; j <= k; j++) {
26
                    if (dp[i][j] == Long.MAX_VALUE) continue;
27
                    dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + a[i] + j);
28
                    if (j + 1 <= k) {
29
                        dp[i + 1][j + 1] = Math.min(dp[i + 1][j + 1], dp[i][j]);
30
                    }
31
                }
32
            }
33
            34
            long minEffort = Long.MAX_VALUE;
35
            for (int j = 0; j <= k; j++) {
36
                minEffort = Math.min(minEffort, dp[n][j]);
37
            }
38
            System.out.println(minEffort);
39
        }
40
        sc.close();
41
    }
42
}",174,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052561
1390052547,unknown,unknown,unknown,"1
def solve_breach_problem(n, k, firewall_strengths):
2
    # Create a 2D dp array where:
3
    # dp[i][j] = minimum effort needed to breach first i firewalls 
4
    # after skipping exactly j firewalls
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    7
    # Base case: No firewall, no effort
8
    dp[0][0] = 0
9
    10
    for i in range(1, n + 1):
11
        current_strength = firewall_strengths[i - 1]
12
        13
        for j in range(k + 1):
14
            # Option 1: Don't skip the current firewall (if j firewalls already skipped)
15
            if j <= i - 1:  # We can only skip j firewalls out of i-1 previous ones
16
                # Current firewall strength increases by j (number of previously skipped firewalls)
17
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
18
            19
            # Option 2: Skip the current firewall (if we haven't used all our skips)
20
            if j > 0:
21
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
22
    23
    # Find minimum effort considering all possible numbers of skipped firewalls
24
    return min(dp[n])
25
26
def main():
27
    test_cases = int(input())
28
    29
    for _ in range(test_cases):
30
        n, k = map(int, input().split())
31
        firewall_strengths = list(map(int, input().split()))
32
        33
        min_effort = solve_breach_problem(n, k, firewall_strengths)
34
        print(min_effort)
35
36
if __name__ == ""__main__"":
37
    main()",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052547
1390052552,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void findEarliestFaultyReadings(int *arr, int n, int k) {
5
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
6
    int front = 0, rear = 0;
7
    int queue[n];
8
    for (int i = 0; i < k; i++) {
9
        if (arr[i] < 0) {
10
            queue[rear++] = i;
11
        }
12
    }
13
    result[0] = (front < rear) ? arr[queue[front]] : 0;
14
15
    for (int i = k; i < n; i++) {
16
        while (front < rear && queue[front] <= i - k) {
17
            front++;
18
        }
19
        if (arr[i] < 0) {
20
            queue[rear++] = i;
21
        }
22
23
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
24
    }
25
26
    for (int i = 0; i < n - k + 1; i++) {
27
        printf(""%d "", result[i]);
28
    }
29
    printf(""\n"");
30
    31
    free(result);
32
}
33
34
int main() {
35
    int t;
36
    scanf(""%d"", &t);
37
    38
    while (t--) {
39
        int n, k;
40
        scanf(""%d %d"", &n, &k);
41
        int arr[n];
42
        43
        for (int i = 0; i < n; i++) {
44
            scanf(""%d"", &arr[i]);
45
        }
46
        47
        findEarliestFaultyReadings(arr, n, k);
48
    }
49
    50
    return 0;
51
}",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052552
1390052560,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of faulty readings (negative values)
7
8
    for i in range(n):
9
        # Remove indices that are out of the current window
10
        if dq and dq[0] < i - k + 1:
11
            dq.popleft()
12
13
        # Add the current element's index if it's a negative value (faulty)
14
        if arr[i] < 0:
15
            dq.append(i)
16
17
        # If the window is large enough (i >= k - 1), we check the result
18
        if i >= k - 1:
19
            if dq:
20
                result.append(arr[dq[0]])  # The earliest faulty reading in the window
21
            else:
22
                result.append(0)  # No faulty reading in this window
23
24
    return result
25
26
def process_test_cases():
27
    t = int(input())  # number of test cases
28
    for _ in range(t):
29
        n, k = map(int, input().split())  # size of array and batch size
30
        arr = list(map(int, input().split()))  # the array of sensor readings
31
        result = earliest_faulty_reading(arr, k)
32
        print(' '.join(map(str, result)))
33
34
# Call the function to process test cases
35
process_test_cases()",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052560
1390052538,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
vector<int> earliestFaults(vector<int>& arr, int k) {
9
    vector<int> result;
10
11
    for (int i = 0; i <= arr.size() - k; i++) {
12
        bool found = false;
13
        for (int j = i; j < i + k; j++) {
14
            if (arr[j] < 0) {
15
                result.push_back(arr[j]);
16
                found = true;
17
                break;
18
            }
19
        }
20
        if (!found) result.push_back(0);
21
    }
22
    23
    return result;
24
}
25
26
int main() {
27
    int t;
28
    cin >> t;
29
30
    while (t--) {
31
        int n, k;
32
        cin >> n >> k;
33
        vector<int> arr(n);
34
35
        for (int i = 0; i < n; i++) {
36
            cin >> arr[i];
37
        }
38
39
        vector<int> result = earliestFaults(arr, k);
40
41
        for (int num : result) {
42
            cout << num << "" "";
43
        }
44
        cout << endl;
45
    }
46
47
    return 0;
48
}",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052538
1390052539,unknown,unknown,unknown,"1
def minimum_effort_to_breach_firewalls(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, firewalls = case
5
        min_effort = float('inf')  # Initialize with a large value
6
7
        for i in range(1 << n):  # Iterate through all possible subsets of firewalls to skip
8
            skipped_count = 0
9
            current_effort = 0
10
            temp_firewalls = firewalls[:]  # Create a copy to modify
11
12
            # Determine which firewalls are skipped based on the bits in i
13
            skipped_indices = []
14
            for j in range(n):
15
                if (i >> j) & 1:
16
                    skipped_count += 1
17
                    skipped_indices.append(j)
18
            19
            if skipped_count <= k:
20
                effort = 0
21
                skipped_indices.sort()
22
                23
                #Calculate effort with increased strength for subsequent firewalls
24
                for j in range(n):
25
                    if j in skipped_indices:
26
                        continue
27
                    else:
28
                        increase = 0
29
                        skipped_before = 0
30
                        for skip_idx in skipped_indices:
31
                            if skip_idx < j:
32
                                skipped_before += 1
33
                        effort += firewalls[j] + skipped_before
34
                min_effort = min(min_effort, effort)
35
36
        results.append(min_effort)
37
    return results
38
39
40
# Example Usage (based on the sample input):
41
T = int(input())
42
test_cases = []
43
for _ in range(T):
44
    n, k = map(int, input().split())
45
    firewalls = list(map(int, input().split()))
46
    test_cases.append((n, k, firewalls))
47
48
results = minimum_effort_to_breach_firewalls(test_cases)
49
for result in results:
50
    print(result)
51",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052539
1390052545,unknown,unknown,unknown,"1
def earliest_faulty_reading(arr, k):
2
    n = len(arr)
3
    result = []
4
    first_faulty_index = -1  # Track index of first negative in the current window
5
6
    for i in range(n - k + 1):
7
        # If the previous first_faulty_index is out of the window, find a new one
8
        if first_faulty_index < i:
9
            first_faulty_index = -1
10
            for j in range(i, i + k):
11
                if arr[j] < 0:
12
                    first_faulty_index = j
13
                    break
14
15
        # Append the first negative number in the window, or 0 if none found
16
        if first_faulty_index != -1:
17
            result.append(arr[first_faulty_index])
18
        else:
19
            result.append(0)
20
21
    return result
22
23
# Read input
24
t = int(input())  # Number of test cases
25
for _ in range(t):
26
    n, k = map(int, input().split())  # Array size and batch size
27
    arr = list(map(int, input().split()))  # Sensor readings
28
    29
    # Compute and print results
30
    print(*earliest_faulty_reading(arr, k))  # Print space-separated values
31",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052545
1390052525,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
8
    # Process first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
13
    # Process all sliding windows
14
    for i in range(n - k + 1):
15
        # Append first negative in current window
16
        if dq:
17
            result.append(arr[dq[0]])
18
        else:
19
            result.append(0)
20
21
        # Remove elements that are out of window
22
        while dq and dq[0] < i + 1:
23
            dq.popleft()
24
25
        # Add next element if negative
26
        if i + k < n and arr[i + k] < 0:
27
            dq.append(i + k)
28
29
    print(*result)
30
31
# Reading input
32
t = int(input())
33
for _ in range(t):
34
    n, k = map(int, input().split())
35
    arr = list(map(int, input().split()))
36
    earliest_faulty_readings(arr, k)",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052525
1390052533,unknown,unknown,unknown,"1
from collections import deque
2
def earliest_faults_in_batches(test_cases):
3
    results = []
4
    for n, k, arr in test_cases:
5
        output, dq = [], deque()
6
7
        for i in range(n):
8
            if arr[i] < 0: dq.append(i)
9
            if i >= k and dq and dq[0] <= i - k: dq.popleft()
10
            if i >= k - 1: output.append(arr[dq[0]] if dq else 0)
11
12
        results.append(output)
13
    return results
14
15
t = int(input())
16
test_cases = [(lambda n, k, arr: (n, k, arr))(*map(int, input().split()), list(map(int, input().split()))) for _ in range(t)]
17
18
for output in earliest_faults_in_batches(test_cases):
19
    print(*output)
20",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052533
1390052531,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        output = []
8
        dq = deque()
9
        10
        # Process the first window
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
        15
        # Store the result for the first batch
16
        output.append(arr[dq[0]] if dq else 0)
17
        18
        # Process the remaining windows
19
        for i in range(k, n):
20
            # Remove elements that are out of the current window
21
            if dq and dq[0] <= i - k:
22
                dq.popleft()
23
            24
            # Add the current element if it is negative
25
            if arr[i] < 0:
26
                dq.append(i)
27
            28
            # Store the result for the current batch
29
            output.append(arr[dq[0]] if dq else 0)
30
        31
        results.append("" "".join(map(str, output)))
32
    33
    return ""\n"".join(results)
34
35
# Read input
36
t = int(input())
37
test_cases = []
38
for _ in range(t):
39
    n, k = map(int, input().split())
40
    arr = list(map(int, input().split()))
41
    test_cases.append((n, k, arr))
42
43
# Compute and print results
44
print(earliest_faulty_readings(test_cases))
45",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052531
1390052524,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",175,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052524
1390052517,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052517
1390052519,unknown,unknown,unknown,"1
cases = int(input())
2
for t in range(cases):
3
    n,k = [int(i) for i in input().split()]
4
    array = [int(i) for i in input().split()]
5
    prefix = [0]*len(array)
6
    for i in range(len(array)-k+1):
7
        to_check = array[i:i+k]
8
        for j in to_check:
9
            neg = 0
10
            if j < 0:
11
                neg = j
12
                break
13
        print(neg, end = "" "")
14
    print("""")
15
            16
        17
        ",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052519
1390052522,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
    public static void main(String[] args) throws IOException {
6
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
7
        int t = Integer.parseInt(br.readLine().trim()); // Number of test cases
8
        StringBuilder result = new StringBuilder();
9
        10
        while (t-- > 0) {
11
            String[] nk = br.readLine().trim().split("" "");
12
            int n = Integer.parseInt(nk[0]); // Size of the array
13
            int k = Integer.parseInt(nk[1]); // Batch size
14
            15
            String[] arrStr = br.readLine().trim().split("" "");
16
            int[] arr = new int[n];
17
            for (int i = 0; i < n; i++) {
18
                arr[i] = Integer.parseInt(arrStr[i]);
19
            }
20
            21
            result.append(findEarliestFaults(arr, n, k)).append(""\n"");
22
        }
23
        24
        System.out.print(result);
25
    }
26
    27
    private static String findEarliestFaults(int[] arr, int n, int k) {
28
        StringBuilder sb = new StringBuilder();
29
        Deque<Integer> deque = new LinkedList<>(); // To store indices of negative numbers
30
        31
        // Process first window of size k
32
        for (int i = 0; i < k; i++) {
33
            if (arr[i] < 0) {
34
                deque.add(i);
35
            }
36
        }
37
        38
        // Process remaining windows
39
        for (int i = k; i <= n; i++) {
40
            // Add the earliest fault in the current batch
41
            sb.append(deque.isEmpty() ? ""0"" : arr[deque.peek()]).append("" "");
42
            43
            // Remove elements that are out of the current window
44
            if (!deque.isEmpty() && deque.peek() == i - k) {
45
                deque.poll();
46
            }
47
            48
            // Add the next element if it's negative
49
            if (i < n && arr[i] < 0) {
50
                deque.add(i);
51
            }
52
        }
53
        54
        return sb.toString().trim();
55
    }
56
}
57",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052522
1390052510,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
   5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
     9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052510
1390052511,unknown,unknown,unknown,"1
from collections import deque
2
3
def first_negative_in_window(arr, k):
4
    q = deque() 
5
    result = []
6
7
    for i in range(k):
8
        if arr[i] < 0:
9
            q.append(i)
10
    11
    if q:
12
        result.append(arr[q[0]])
13
    else:
14
        result.append(0)
15
    16
    for i in range(k, len(arr)):
17
        if q and q[0] < i - k + 1:
18
            q.popleft()
19
        20
        if arr[i] < 0:
21
            q.append(i)
22
        23
        if q:
24
            result.append(arr[q[0]])
25
        else:
26
            result.append(0)
27
    28
    return result
29
30
t = int(input())
31
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    ans = first_negative_in_window(arr, k)
36
    print("" "".join(map(str, ans)))
37",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052511
1390052509,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    result.append(arr[dq[0]] if dq else 0)
12
    13
    for i in range(k, len(arr)):
14
        while dq and dq[0] <= i - k:
15
            dq.popleft()
16
        17
        if arr[i] < 0:
18
            dq.append(i)
19
        20
        result.append(arr[dq[0]] if dq else 0)
21
    22
    return result
23
24
t = int(input())
25
for _ in range(t):
26
    n, k = map(int, input().split())
27
    arr = list(map(int, input().split()))
28
    29
    output = earliest_faulty_reading(arr, k)
30
    print("" "".join(map(str, output)))
31",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052509
1390052501,unknown,unknown,unknown,"1
def find_earliest_faults(arr, k):
2
    """"""
3
    Finds the earliest faulty reading for each consecutive batch of size k.
4
5
    Args:
6
        arr: A list of sensor readings (integers).
7
        k: The batch size.
8
9
    Returns:
10
        A list of earliest faulty readings for each batch.
11
    """"""
12
    result = []
13
    for i in range(len(arr) - k + 1):
14
        batch = arr[i:i + k]
15
        earliest_fault = 0
16
        for j, reading in enumerate(batch):
17
            if reading < 0:
18
                earliest_fault = reading
19
                break
20
        result.append(earliest_fault)
21
    return result
22
23
def solve():
24
    t = int(input())
25
    for _ in range(t):
26
        n, k = map(int, input().split())
27
        arr = list(map(int, input().split()))
28
        result = find_earliest_faults(arr, k)
29
        print(*result)
30
31
solve()",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052501
1390052502,unknown,unknown,unknown,"1
def faults(n, k, arr):
2
    output = []
3
    4
    for i in range(n - k + 1):
5
        batch = arr[i:i + k]
6
        first_neg = next((x for x in batch if x < 0), 0)
7
        output.append(first_neg)
8
    print(*output)
9
10
t = int(input())
11
for _ in range(t):
12
    n, k = map(int, input().split())
13
    arr = list(map(int, input().split()))
14
    faults(n, k, arr)
15",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052502
1390052505,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  
7
8
    for i in range(n):
9
        if dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
12
        if arr[i] < 0:
13
            dq.append(i)
14
15
        if i >= k - 1:
16
            if dq:
17
                result.append(arr[dq[0]])  
18
            else:
19
                result.append(0)  
20
21
    return result
22
23
def process_test_cases():
24
    t = int(input())  
25
    for _ in range(t):
26
        n, k = map(int, input().split())  
27
        arr = list(map(int, input().split()))  
28
        result = earliest_faulty_reading(arr, k)
29
        print(' '.join(map(str, result)))
30
31
process_test_cases()",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052505
1390052500,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
    8
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    for i in range(k, n):
17
        if dq and dq[0] <= i - k:
18
            dq.popleft()
19
        20
        if arr[i] < 0:
21
            dq.append(i)
22
        23
        result.append(arr[dq[0]] if dq else 0)
24
    25
    return result
26
27
28
t = int(input())
29
for _ in range(t):
30
    n, k = map(int, input().split())
31
    arr = list(map(int, input().split()))
32
    print(*earliest_faulty_readings(arr, k))
33
34",176,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052500
1390052495,unknown,unknown,unknown,"1
from collections import deque
2
def earliest_faculty_readings(arr,k):
3
    dq,result=deque(),[]
4
    for i in range (len(arr)):
5
        if dq and dq[0]<i-k+1:
6
            dq.popleft()
7
        if arr[i]<0:
8
            dq.append(i)
9
        if i>=k-1:
10
            result.append(arr[dq[0]] if dq else 0)
11
    return result
12
t=int(input())
13
for _ in range(t):
14
    n,k=map(int,input().split())
15
    arr=list(map(int,input().split()))
16
    print(*earliest_faculty_readings(arr,k))
17
        ",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052495
1390052497,unknown,unknown,unknown,"1
def solve_breach_problem(n, k, firewall_strengths):
2
    # Create a 2D dp array where:
3
    # dp[i][j] = minimum effort needed to breach first i firewalls 
4
    # after skipping exactly j firewalls
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    7
    # Base case: No firewall, no effort
8
    dp[0][0] = 0
9
    10
    for i in range(1, n + 1):
11
        current_strength = firewall_strengths[i - 1]
12
        13
        for j in range(k + 1):
14
            # Option 1: Don't skip the current firewall (if j firewalls already skipped)
15
            if j <= i - 1:  # We can only skip j firewalls out of i-1 previous ones
16
                # Current firewall strength increases by j (number of previously skipped firewalls)
17
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
18
            19
            # Option 2: Skip the current firewall (if we haven't used all our skips)
20
            if j > 0:
21
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
22
    23
    # Find minimum effort considering all possible numbers of skipped firewalls
24
    return min(dp[n])
25
26
def main():
27
    test_cases = int(input())
28
    29
    for _ in range(test_cases):
30
        n, k = map(int, input().split())
31
        firewall_strengths = list(map(int, input().split()))
32
        33
        min_effort = solve_breach_problem(n, k, firewall_strengths)
34
        print(min_effort)
35
36
if __name__ == ""__main__"":
37
    main()",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052497
1390052498,unknown,unknown,unknown,"1
import sys
2
3
def min_effort_to_breach(test_cases):
4
    results = []
5
    6
    for n, k, firewalls in test_cases:
7
        total_effort = sum(firewalls)
8
        min_effort = total_effort
9
10
        prefix_sum = [0] * (n + 1)
11
        for i in range(n):
12
            prefix_sum[i + 1] = prefix_sum[i] + firewalls[i]
13
14
        for i in range(n - k + 1):
15
            skipped_sum = prefix_sum[i + k] - prefix_sum[i]  
16
            increased_effort = (n - (i + k)) * k  
17
            min_effort = min(min_effort, total_effort - skipped_sum + increased_effort)
18
19
        results.append(str(min_effort))
20
    21
    return ""\n"".join(results)
22
23
input = sys.stdin.read
24
data = input().split()
25
t = int(data[0])
26
index = 1
27
test_cases = []
28
29
for _ in range(t):
30
    n, k = int(data[index]), int(data[index + 1])
31
    firewalls = list(map(int, data[index + 2: index + 2 + n]))
32
    index += 2 + n
33
    test_cases.append((n, k, firewalls))
34
35
print(min_effort_to_breach(test_cases))
36",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052498
1390052490,unknown,unknown,unknown,"1
def minimum_effort_to_breach_firewalls(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, firewalls = case
5
        min_effort = float('inf')  # Initialize with a large value
6
7
        for i in range(1 << n):  # Iterate through all possible subsets of firewalls to skip
8
            skipped_count = 0
9
            current_effort = 0
10
            temp_firewalls = firewalls[:]  # Create a copy to modify
11
12
            # Determine which firewalls are skipped based on the bits in i
13
            skipped_indices = []
14
            for j in range(n):
15
                if (i >> j) & 1:
16
                    skipped_count += 1
17
                    skipped_indices.append(j)
18
            19
            if skipped_count <= k:
20
                effort = 0
21
                skipped_indices.sort()
22
                23
                #Calculate effort with increased strength for subsequent firewalls
24
                for j in range(n):
25
                    if j in skipped_indices:
26
                        continue
27
                    else:
28
                        increase = 0
29
                        skipped_before = 0
30
                        for skip_idx in skipped_indices:
31
                            if skip_idx < j:
32
                                skipped_before += 1
33
                        effort += firewalls[j] + skipped_before
34
                min_effort = min(min_effort, effort)
35
36
        results.append(min_effort)
37
    return results
38
39
40
# Example Usage (based on the sample input):
41
T = int(input())
42
test_cases = []
43
for _ in range(T):
44
    n, k = map(int, input().split())
45
    firewalls = list(map(int, input().split()))
46
    test_cases.append((n, k, firewalls))
47
48
results = minimum_effort_to_breach_firewalls(test_cases)
49
for result in results:
50
    print(result)
51",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052490
1390052492,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
    public static void main(String[] args) {
9
        Scanner scanner=new Scanner(System.in);
10
        int testCases=scanner.nextInt();
11
        12
        for(int t=0;t<testCases;t++){
13
            int n=scanner.nextInt();
14
            int k=scanner.nextInt();
15
            int[] arr=new int[n];
16
            17
            for(int i=0;i<n;i++) arr[i]=scanner.nextInt();
18
            19
            List<Integer> result=new ArrayList<>();
20
            for(int i=0;i<=n-k;i++) {
21
                int earliestFault=0;
22
                for(int j=i;j<i+k;j++) {
23
                    if(arr[j]<0) {
24
                        earliestFault=arr[j];
25
                        break;
26
                    }
27
                }
28
                result.add(earliestFault);
29
            }
30
            for(int res:result) System.out.print(res+"" "");
31
            System.out.println();
32
        }
33
        scanner.close();
34
    }
35
}
36",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052492
1390052486,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # For each possible remaining substring (after removing prefixes and suffixes)
5
    min_cost = float('inf')
6
    7
    # Try all possible substrings (start, end+1)
8
    for start in range(n + 1):
9
        for end in range(start, n + 1):
10
            # Calculate the substring that remains after decommissioning
11
            remaining = servers[start:end]
12
            13
            # Calculate metrics
14
            active_removed = servers[:start].count('1') + servers[end:].count('1')
15
            idle_remaining = remaining.count('0')
16
            17
            # Cost is the maximum of idle servers remaining and active servers removed
18
            cost = max(idle_remaining, active_removed)
19
            20
            # Update minimum cost
21
            min_cost = min(min_cost, cost)
22
    23
    return min_cost
24
25
# Process test cases
26
t = int(input())
27
for _ in range(t):
28
    servers = input().strip()
29
    print(min_decommissioning_cost(servers))",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052486
1390052476,unknown,unknown,unknown,"1
def min_effort_to_breach(T, test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        if k == n:
6
            results.append(""0"")  # If all firewalls can be skipped, effort is 0
7
            continue
8
        9
        total_effort = sum(firewalls)
10
        min_effort = total_effort
11
        12
        # Compute initial sum of first k firewalls
13
        window_sum = sum(firewalls[:k])
14
        15
        # Iterate through possible skip windows
16
        for i in range(n - k + 1):
17
            skipped_firewalls = k
18
            increased_security = sum(range(1, skipped_firewalls + 1))  # Penalty for skipping
19
            20
            new_effort = total_effort - window_sum + increased_security
21
            min_effort = min(min_effort, new_effort)
22
            23
            # Move the sliding window
24
            if i + k < n:
25
                window_sum = window_sum - firewalls[i] + firewalls[i + k]
26
        27
        results.append(str(min_effort))
28
29
    return ""\n"".join(results)
30
31
# Read input
32
T = int(input())
33
test_cases = []
34
35
for _ in range(T):
36
    n, k = map(int, input().split())
37
    firewalls = list(map(int, input().split()))
38
    test_cases.append((n, k, firewalls))
39
40
# Compute and print results
41
print(min_effort_to_breach(T, test_cases))
42",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052476
1390052479,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
    8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    result.append(arr[dq[0]] if dq else 0)
13
    14
    for i in range(k, n):
15
16
        while dq and dq[0] <= i - k:
17
            dq.popleft()
18
        19
        if arr[i] < 0:
20
            dq.append(i)
21
        22
        result.append(arr[dq[0]] if dq else 0)
23
    24
    return result
25
26
def process_test_cases(t, test_cases):
27
    for n, k, arr in test_cases:
28
        print(*earliest_faulty_readings(arr, k))
29
30
31
t = int(input())
32
test_cases = []
33
for _ in range(t):
34
    n, k = map(int, input().split())
35
    arr = list(map(int, input().split()))
36
    test_cases.append((n, k, arr))
37
38
process_test_cases(t, test_cases)
39",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052479
1390052485,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
5
    public static List<List<Integer>> f(int t, List<int[]> a, List<int[]> s) {
6
        List<List<Integer>> r = new ArrayList<>();
7
8
        for (int i = 0; i < t; i++) {
9
            int n = s.get(i)[0], k = s.get(i)[1];
10
            int[] x = a.get(i);
11
            List<Integer> res = new ArrayList<>();
12
            Deque<Integer> d = new LinkedList<>();
13
14
            for (int j = 0; j < k; j++) {
15
                if (x[j] < 0) d.add(j);
16
            }
17
            res.add(d.isEmpty() ? 0 : x[d.peek()]);
18
19
            for (int j = k; j < n; j++) {
20
                if (!d.isEmpty() && d.peek() <= j - k) d.poll();
21
                if (x[j] < 0) d.add(j);
22
                res.add(d.isEmpty() ? 0 : x[d.peek()]);
23
            }
24
            r.add(res);
25
        }
26
27
        return r;
28
    }
29
30
    public static void main(String[] args) {
31
        Scanner sc = new Scanner(System.in);
32
        int t = sc.nextInt();
33
        List<int[]> a = new ArrayList<>(), s = new ArrayList<>();
34
35
        for (int i = 0; i < t; i++) {
36
            int n = sc.nextInt(), k = sc.nextInt();
37
            s.add(new int[]{n, k});
38
            int[] x = new int[n];
39
            for (int j = 0; j < n; j++) x[j] = sc.nextInt();
40
            a.add(x);
41
        }
42
43
        List<List<Integer>> o = f(t, a, s);
44
        for (List<Integer> l : o) {
45
            for (int v : l) System.out.print(v + "" "");
46
            System.out.println();
47
        }
48
        sc.close();
49
    }
50
}
51",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052485
1390052469,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
4
public class Solution {
5
6
    public static void main(String[] args) {
7
        Scanner scanner = new Scanner(System.in);
8
        int t = scanner.nextInt();  // Number of testcases
9
        10
        // Process each testcase
11
        while (t-- > 0) {
12
            int n = scanner.nextInt();  // Size of array
13
            int k = scanner.nextInt();  // Batch size
14
            int[] arr = new int[n];
15
            16
            // Reading array elements
17
            for (int i = 0; i < n; i++) {
18
                arr[i] = scanner.nextInt();
19
            }
20
            21
            List<Integer> result = earliestFaults(arr, k);
22
            // Printing the result for the current testcase
23
            for (int res : result) {
24
                System.out.print(res + "" "");
25
            }
26
            System.out.println();
27
        }
28
    }
29
30
    // Function to calculate the earliest faults for consecutive batches of size k
31
    private static List<Integer> earliestFaults(int[] arr, int k) {
32
        List<Integer> result = new ArrayList<>();
33
        Deque<Integer> deque = new LinkedList<>();
34
        35
        // Iterating through the array
36
        for (int i = 0; i < arr.length; i++) {
37
            // Remove elements which are no longer in the current window
38
            if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
39
                deque.pollFirst();
40
            }
41
            42
            // Add the current element index to the deque if it's a faulty component
43
            if (arr[i] < 0) {
44
                deque.addLast(i);
45
            }
46
            47
            // For the first batch of size k and onward, calculate the earliest fault
48
            if (i >= k - 1) {
49
                if (!deque.isEmpty()) {
50
                    result.add(arr[deque.peekFirst()]);  // Add the earliest fault in the batch
51
                } else {
52
                    result.add(0);  // No faults in the current batch
53
                }
54
            }
55
        }
56
        57
        return result;
58
    }
59
}
60",177,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052469
1390052461,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
8
    # Process first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
13
    # Process all sliding windows
14
    for i in range(n - k + 1):
15
        # Append first negative in current window
16
        if dq:
17
            result.append(arr[dq[0]])
18
        else:
19
            result.append(0)
20
21
        # Remove elements that are out of window
22
        while dq and dq[0] < i + 1:
23
            dq.popleft()
24
25
        # Add next element if negative
26
        if i + k < n and arr[i + k] < 0:
27
            dq.append(i + k)
28
29
    print(*result)
30
31
# Reading input
32
t = int(input())
33
for _ in range(t):
34
    n, k = map(int, input().split())
35
    arr = list(map(int, input().split()))
36
    earliest_faulty_readings(arr, k)",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052461
1390052462,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    # DP array, initialized with large values
3
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
4
    dp[0][0] = 0  # Base case: No firewalls, no effort
5
6
    # DP Computation
7
    for i in range(1, n + 1):
8
        for j in range(k + 1):
9
            # Case 1: Don't skip this firewall
10
            dp[i][j] = dp[i - 1][j] + firewalls[i - 1] + j
11
12
            # Case 2: Skip this firewall (if skips available)
13
            if j > 0:
14
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
15
16
    # Answer is the minimum effort across all skip possibilities
17
    return min(dp[n])
18
19
# Read input
20
T = int(input())  # Number of test cases
21
for _ in range(T):
22
    n, k = map(int, input().split())  # Read n and k
23
    firewalls = list(map(int, input().split()))  # Firewall strengths
24
25
    # Compute and print the minimum effort
26
    print(min_effort(n, k, firewalls))",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052462
1390052468,unknown,unknown,unknown,"1
import java.util.Scanner;
2
3
public class Solution {
4
5
    public static void main(String[] args) {
6
        Scanner scanner = new Scanner(System.in);
7
        int t = scanner.nextInt();
8
        while (t-- > 0) {
9
            int n = scanner.nextInt();
10
            int k = scanner.nextInt();
11
            int[] a = new int[n];
12
            for (int i = 0; i < n; i++) {
13
                a[i] = scanner.nextInt();
14
            }
15
            System.out.println(solve(n, k, a));
16
        }
17
        scanner.close();
18
    }
19
20
    public static long solve(int n, int k, int[] a) {
21
        long minEffort = Long.MAX_VALUE;
22
23
        for (int i = 0; i <= k; i++) {
24
            long effort = 0;
25
            int skipped = 0;
26
            int increasedStrength = 0;
27
            int remainingSkips = k;
28
29
            for (int j = 0; j < n; j++) {
30
                if (skipped < i && remainingSkips > 0) {
31
                    skipped++;
32
                    remainingSkips--;
33
                    increasedStrength++;
34
                } else {
35
                    effort += a[j] + increasedStrength -1;
36
                    if(a[j] < 0){
37
                      effort +=1;
38
                    }
39
                }
40
            }
41
42
            minEffort = Math.min(minEffort, effort);
43
        }
44
45
        return minEffort;
46
    }
47
}",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052468
1390052454,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        Scanner scanner = new Scanner(System.in);
11
        int t = scanner.nextInt(); // Number of test cases
12
        13
        for (int testCase = 0; testCase < t; testCase++) {
14
            int n = scanner.nextInt(); // Size of array
15
            int k = scanner.nextInt(); // Batch size
16
            17
            int[] arr = new int[n];
18
            for (int i = 0; i < n; i++) {
19
                arr[i] = scanner.nextInt();
20
            }
21
            22
            // Process each batch and find earliest fault
23
            for (int i = 0; i <= n - k; i++) {
24
                int earliestFault = findEarliestFault(arr, i, i + k - 1);
25
                System.out.print(earliestFault + "" "");
26
            }
27
            System.out.println();
28
        }
29
        30
        scanner.close();
31
    }
32
    33
    // Function to find the earliest fault (negative reading) in a batch
34
    private static int findEarliestFault(int[] arr, int start, int end) {
35
        for (int i = start; i <= end; i++) {
36
            if (arr[i] < 0) {
37
                return arr[i]; // Return the first negative reading
38
            }
39
        }
40
        return 0; // No faults found
41
    }
42
}",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052454
1390052456,unknown,unknown,unknown,"1
def faulty_sensor_readings(arr, k):
2
    """"""
3
    Determines the earliest faulty reading for each consecutive batch of size k.
4
5
    Args:
6
        arr: A list of sensor readings.
7
        k: The batch size.
8
9
    Returns:
10
        A list containing the earliest faulty reading for each batch.
11
    """"""
12
    result = []
13
    for i in range(len(arr) - k + 1):
14
        batch = arr[i:i + k]
15
        fault = 0
16
        for num in batch:
17
            if num < 0:
18
                fault = num
19
                break
20
        result.append(fault)
21
    return result
22
23
if __name__ == ""__main__"":
24
    t = int(input())
25
    for _ in range(t):
26
        n, k = map(int, input().split())
27
        arr = list(map(int, input().split()))
28
        result = faulty_sensor_readings(arr, k)
29
        print(*result)",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052456
1390052458,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first k elements
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process the remaining elements
16
    for i in range(k, len(arr)):
17
        # Remove elements not in the current window
18
        while dq and dq[0] <= i - k:
19
            dq.popleft()
20
        21
        # Add the new element if it is negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the result
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Reading input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    36
    # Get the earliest faulty readings for each batch
37
    output = earliest_faulty_reading(arr, k)
38
    print("" "".join(map(str, output)))
39",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052458
1390052443,unknown,unknown,unknown,"1
#include <iostream>
2
#include <vector>
3
using namespace std;
4
5
int main() {
6
    int t;
7
    cin >> t; 
8
    for (int test = 0; test < t; test++) {
9
        int n, k;
10
        cin >> n >> k; 
11
        vector<int> arr(n);
12
        for (int i = 0; i < n; i++) {
13
            cin >> arr[i]; 
14
        }
15
16
        //Compute next_neg array
17
        vector<int> next_neg(n);
18
        for (int i = n - 1; i >= 0; i--) {
19
            if (arr[i] < 0) {
20
                next_neg[i] = i; 
21
            } else {
22
                next_neg[i] = (i + 1 < n) ? next_neg[i + 1] : n; 
23
            }
24
        }
25
26
    27
        for (int i = 0; i <= n - k; i++) {
28
            if (next_neg[i] < i + k) {
29
                cout << arr[next_neg[i]] << "" ""; 
30
            } else {
31
                cout << ""0 ""; 
32
            }
33
        }
34
        cout << endl; 
35
    }
36
    return 0;
37
}",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052443
1390052445,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    result.append(arr[dq[0]] if dq else 0)
12
    13
    for i in range(k, len(arr)):
14
        while dq and dq[0] <= i - k:
15
            dq.popleft()
16
        17
        if arr[i] < 0:
18
            dq.append(i)
19
        20
        result.append(arr[dq[0]] if dq else 0)
21
    22
    return result
23
24
t = int(input())
25
for _ in range(t):
26
    n, k = map(int, input().split())
27
    arr = list(map(int, input().split()))
28
    output = earliest_faulty_reading(arr, k)
29
    print("" "".join(map(str, output)))
30",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052445
1390052451,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(len(arr)):
8
        # Remove elements not part of the current batch
9
        while dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
        12
        # If current element is faulty, add its index to deque
13
        if arr[i] < 0:
14
            dq.append(i)
15
        16
        # Add the first faulty element of the batch to result
17
        if i >= k - 1:
18
            result.append(arr[dq[0]] if dq else 0)
19
    20
    return result
21
22
def main():
23
    t = int(input())
24
    for _ in range(t):
25
        n, k = map(int, input().split())
26
        arr = list(map(int, input().split()))
27
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))
28
29
if __name__ == ""__main__"":
30
    main()
31",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052451
1390052440,unknown,unknown,unknown,"1
def solve_breach_problem(n, k, firewall_strengths):
2
    # Create a 2D dp array where:
3
    # dp[i][j] = minimum effort needed to breach first i firewalls 
4
    # after skipping exactly j firewalls
5
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
6
    7
    # Base case: No firewall, no effort
8
    dp[0][0] = 0
9
    10
    for i in range(1, n + 1):
11
        current_strength = firewall_strengths[i - 1]
12
        13
        for j in range(k + 1):
14
            # Option 1: Don't skip the current firewall (if j firewalls already skipped)
15
            if j <= i - 1:  # We can only skip j firewalls out of i-1 previous ones
16
                # Current firewall strength increases by j (number of previously skipped firewalls)
17
                dp[i][j] = min(dp[i][j], dp[i-1][j] + current_strength + j)
18
            19
            # Option 2: Skip the current firewall (if we haven't used all our skips)
20
            if j > 0:
21
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
22
    23
    # Find minimum effort considering all possible numbers of skipped firewalls
24
    return min(dp[n])
25
26
def main():
27
    test_cases = int(input())
28
    29
    for _ in range(test_cases):
30
        n, k = map(int, input().split())
31
        firewall_strengths = list(map(int, input().split()))
32
        33
        min_effort = solve_breach_problem(n, k, firewall_strengths)
34
        print(min_effort)
35
36
if __name__ == ""__main__"":
37
    main()",178,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052440
1390052429,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <string.h>
3
4
int main() {
5
    int t;
6
    scanf(""%d"", &t);
7
    while (t--) {
8
        char rack[100005];
9
        scanf(""%s"", rack);
10
        int n = strlen(rack);
11
        int first = -1, last = -1;
12
        for (int i = 0; i < n; i++) {
13
            if (rack[i] == '1') {
14
                if (first == -1) {
15
                    first = i;
16
                }
17
                last = i;
18
            }
19
        }
20
        if (first == -1) {
21
            printf(""0\n"");
22
        } else {
23
            int zeroCount = 0;
24
            int oneCount = 0;
25
            for (int i = first; i <= last; i++) {
26
                if (rack[i] == '0') {
27
                    zeroCount++;
28
                } else {
29
                    oneCount++;
30
                }
31
            }
32
            if (zeroCount < oneCount) {
33
                printf(""%d\n"", zeroCount);
34
            } else {
35
                printf(""%d\n"", oneCount);
36
            }
37
        }
38
    }
39
    return 0;
40
}",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052429
1390052430,unknown,unknown,unknown,"1
def min_effort(arr, k):
2
    n = len(arr)
3
    4
    if k >= n:
5
        return 0
6
7
    prev_dp = [float('inf')] * (k + 1)
8
    prev_dp[0] = 0  
9
    10
    for i in range(n):
11
        curr_dp = [float('inf')] * (k + 1)
12
        for j in range(k + 1):
13
            curr_dp[j] = prev_dp[j] + arr[i] + j if j <= i else float('inf')
14
            if j > 0:
15
                curr_dp[j] = min(curr_dp[j], prev_dp[j - 1])
16
        prev_dp = curr_dp
17
    18
    return min(prev_dp)
19
20
def solve():
21
    for _ in range(int(input())):
22
        n, k = map(int, input().split())
23
        arr = list(map(int, input().split()))
24
        print(min_effort(arr, k))
25
26
if __name__ == ""__main__"":
27
    solve()
28",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052430
1390052427,unknown,unknown,unknown,"1
import java.util.ArrayList;
2
import java.util.List;
3
import java.util.Scanner;
4
5
public class Solution {
6
7
    public static void main(String[] args) {
8
        Scanner scanner = new Scanner(System.in);
9
        int t = scanner.nextInt();
10
        for (int i = 0; i < t; i++) {
11
            int n = scanner.nextInt();
12
            int k = scanner.nextInt();
13
            int[] a = new int[n];
14
            for (int j = 0; j < n; j++) {
15
                a[j] = scanner.nextInt();
16
            }
17
            solve(n, k, a);
18
        }
19
        scanner.close();
20
    }
21
22
    public static void solve(int n, int k, int[] a) {
23
        long minEffort = Long.MAX_VALUE;
24
25
        for (int i = 0; i < (1 << n); i++) {
26
            List<Integer> skippedIndices = new ArrayList<>();
27
            for (int j = 0; j < n; j++) {
28
                if ((i >> j) % 2 == 1) {
29
                    skippedIndices.add(j);
30
                }
31
            }
32
33
            if (skippedIndices.size() <= k) {
34
                long effort = 0;
35
                int increasedStrength = 0;
36
                int currentSkippedIndex = 0;
37
38
                for (int j = 0; j < n; j++) {
39
                    if (currentSkippedIndex < skippedIndices.size() && skippedIndices.get(currentSkippedIndex) == j) {
40
                        increasedStrength++;
41
                        currentSkippedIndex++;
42
                    } else {
43
                        effort += a[j] + increasedStrength;
44
                    }
45
                }
46
47
                minEffort = Math.min(minEffort, effort);
48
            }
49
        }
50
        System.out.println(minEffort);
51
    }
52
}",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052427
1390052416,unknown,unknown,unknown,"1
def min_effort(n, k, arr):
2
    arr.sort()  # Sort firewalls in ascending order
3
    total_sum = sum(arr)  # Total strength without skipping
4
    min_effort = total_sum  # Start with no skipping
5
6
    for x in range(k + 1):  # Try skipping from 0 to k firewalls
7
        remaining_sum = sum(arr[x:])  # Sum of remaining firewalls
8
        added_penalty = (n - x) * x  # Every remaining firewall gets increased by x
9
        current_effort = remaining_sum + added_penalty
10
        min_effort = min(min_effort, current_effort)  # Update minimum effort
11
12
    print(min_effort)
13
14
# Read input
15
t = int(input())  # Number of test cases
16
for _ in range(t):
17
    n, k = map(int, input().split())  # Read n and k
18
    arr = list(map(int, input().split()))  # Read firewall strengths
19
    min_effort(n, k, arr)
20",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052416
1390052414,unknown,unknown,unknown,"1
def min_effort_to_breach(t, test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        if k == n:
6
            results.append(""0"")
7
            continue
8
9
        total_effort = sum(firewalls)
10
        min_effort = total_effort
11
12
        # Compute the initial window sum (sum of first k firewalls)
13
        current_sum = sum(firewalls[:k])
14
15
        # Iterate over all possible positions to skip k firewalls
16
        for i in range(n - k + 1):
17
            increased_security = k  # Since each skipped firewall increases the rest by 1
18
            new_effort = total_effort - current_sum + increased_security
19
            min_effort = min(min_effort, new_effort)
20
21
            # Slide the window
22
            if i + k < n:
23
                current_sum = current_sum - firewalls[i] + firewalls[i + k]
24
25
        results.append(str(min_effort))
26
27
    return ""\n"".join(results)
28
29
# Read input
30
t = int(input())
31
test_cases = []
32
33
for _ in range(t):
34
    n, k = map(int, input().split())
35
    firewalls = list(map(int, input().split()))
36
    test_cases.append((n, k, firewalls))
37
38
# Compute and print results
39
print(min_effort_to_breach(t, test_cases))
40",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052414
1390052421,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    result.append(arr[dq[0]] if dq else 0)
13
    14
    for i in range(k, n):
15
        if dq and dq[0] < i - k + 1:
16
            dq.popleft()
17
        18
        if arr[i] < 0:
19
            dq.append(i)
20
        21
        result.append(arr[dq[0]] if dq else 0)
22
    23
    return result
24
25
t = int(input())
26
for _ in range(t):
27
    n, k = map(int, input().split())
28
    arr = list(map(int, input().split()))
29
    print(*earliest_faulty_readings(arr, k))
30",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052421
1390052404,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    result.append(arr[dq[0]] if dq else 0)
12
    13
    for i in range(k, len(arr)):
14
        while dq and dq[0] <= i - k:
15
            dq.popleft()
16
        17
        if arr[i] < 0:
18
            dq.append(i)
19
        20
        result.append(arr[dq[0]] if dq else 0)
21
    22
    return result
23
24
t = int(input())
25
for _ in range(t):
26
    n, k = map(int, input().split())
27
    arr = list(map(int, input().split()))
28
    output = earliest_faulty_reading(arr, k)
29
    print("" "".join(map(str, output)))
30",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052404
1390052407,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
8
    for i in range(n):
9
        # Add current element index to deque if it's negative
10
        if arr[i] < 0:
11
            dq.append(i)
12
        13
        # Remove elements that are out of the current window
14
        if dq and dq[0] < i - k + 1:
15
            dq.popleft()
16
        17
        # Start recording results when we reach the first full batch
18
        if i >= k - 1:
19
            result.append(arr[dq[0]] if dq else 0)
20
    21
    return result
22
23
# Read input
24
t = int(input())  # Number of test cases
25
for _ in range(t):
26
    n, k = map(int, input().split())  # Read array size and batch size
27
    arr = list(map(int, input().split()))  # Read array elements
28
    print(*earliest_faulty_readings(arr, k))  # Print the output as space-separated values
29",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052407
1390052413,unknown,unknown,unknown,"1
def min_decommissioning_cost(servers):
2
    n = len(servers)
3
    4
    # Count total active servers (1's) and idle servers (0's)
5
    total_active = servers.count('1')
6
    total_idle = servers.count('0')
7
    8
    min_cost = float('inf')
9
    10
    # Try all possible combinations of removing servers from the beginning and end
11
    for left in range(n + 1):  # Number of servers to remove from the left
12
        for right in range(n + 1 - left):  # Number of servers to remove from the right
13
            if left + right > n:
14
                continue
15
                16
            # Count active and idle servers in the segments we're removing
17
            active_removed_left = servers[:left].count('1')
18
            active_removed_right = servers[n-right:].count('1')
19
            total_active_removed = active_removed_left + active_removed_right
20
            21
            # Calculate the remaining idle servers
22
            remaining_idle = total_idle - (left - active_removed_left) - (right - active_removed_right)
23
            24
            # Calculate cost
25
            cost = max(remaining_idle, total_active_removed)
26
            27
            # Update minimum cost
28
            min_cost = min(min_cost, cost)
29
    30
    return min_cost
31
32
# Process test cases
33
t = int(input())
34
for _ in range(t):
35
    servers = input().strip()
36
    print(min_decommissioning_cost(servers))",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052413
1390052401,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class SmartFactoryQC {
4
    public static List<Integer> earliestFaultyReadings(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>(); // Stores indices of negative values
7
        8
        int n = arr.length;
9
        for (int i = 0; i < n; i++) {
10
            // Remove indices that are out of the current window
11
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
12
                deque.poll();
13
            }
14
            15
            // Add current element index if it's negative
16
            if (arr[i] < 0) {
17
                deque.offer(i);
18
            }
19
            20
            // Process output once we reach full window size
21
            if (i >= k - 1) {
22
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
23
            }
24
        }
25
        26
        return result;
27
    }
28
    29
    public static void main(String[] args) {
30
        Scanner sc = new Scanner(System.in);
31
        int t = sc.nextInt(); // Number of test cases
32
        33
        while (t-- > 0) {
34
            int n = sc.nextInt(); // Array size
35
            int k = sc.nextInt(); // Batch size
36
            int[] arr = new int[n];
37
            38
            for (int i = 0; i < n; i++) {
39
                arr[i] = sc.nextInt();
40
            }
41
            42
            List<Integer> result = earliestFaultyReadings(arr, k);
43
            44
            // Print output
45
            for (int num : result) {
46
                System.out.print(num + "" "");
47
            }
48
            System.out.println();
49
        }
50
        51
        sc.close();
52
    }
53
}
54",179,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052401
1390052397,unknown,unknown,unknown,"1
from collections import deque
2
3
def faulty_readings(num_testcases, testcases):
4
    results = []
5
6
    for i in range(num_testcases):
7
        n, k = testcases[i][0]  
8
        arr = testcases[i][1]  
9
        10
        dq = deque() 
11
        result = []
12
        for j in range(k):
13
            if arr[j] < 0:
14
                dq.append(j)
15
        result.append(arr[dq[0]] if dq else 0)
16
17
        for j in range(k, n):
18
            while dq and dq[0] < j - k + 1:
19
                dq.popleft()
20
21
            if arr[j] < 0:
22
                dq.append(j)
23
24
            result.append(arr[dq[0]] if dq else 0)
25
26
        results.append(result)
27
28
    return results
29
30
if __name__ == ""__main__"":
31
    num_testcases = int(input().strip())  
32
    testcases = []
33
    for _ in range(num_testcases):
34
        n, k = map(int, input().strip().split())  
35
        arr = list(map(int, input().strip().split()))  
36
        testcases.append(((n, k), arr))  
37
38
    results = faulty_readings(num_testcases, testcases)
39
40
    for result in results:
41
        print("" "".join(map(str, result)))  
42
43",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052397
1390052398,unknown,unknown,unknown,"1
def min_decommission_cost(binary_string):
2
    n = len(binary_string)
3
    4
    # Step 1: Find the first and last occurrence of '1'
5
    first_one = binary_string.find('1')
6
    last_one = binary_string.rfind('1')
7
8
    # If there are no active servers, cost is 0
9
    if first_one == -1:
10
        return 0  
11
12
    # Step 2: Extract the ""core"" part (between first and last '1')
13
    core_section = binary_string[first_one:last_one + 1]
14
15
    # Step 3: Compute values needed for the cost calculation
16
    remaining_idle = core_section.count('0')  # Count of '0's inside the core
17
    removed_active = binary_string[:first_one].count('1') + binary_string[last_one + 1:].count('1')
18
19
    return max(remaining_idle, removed_active)
20
21
# Read input
22
T = int(input())  # Number of test cases
23
for _ in range(T):
24
    binary_string = input().strip()
25
    print(min_decommission_cost(binary_string))
26",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052398
1390052399,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
8
    # Process first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
13
    # Process all sliding windows
14
    for i in range(n - k + 1):
15
        # Append first negative in current window
16
        if dq:
17
            result.append(arr[dq[0]])
18
        else:
19
            result.append(0)
20
21
        # Remove elements that are out of window
22
        while dq and dq[0] < i + 1:
23
            dq.popleft()
24
25
        # Add next element if negative
26
        if i + k < n and arr[i + k] < 0:
27
            dq.append(i + k)
28
29
    print(*result)
30
31
# Reading input
32
t = int(input())
33
for _ in range(t):
34
    n, k = map(int, input().split())
35
    arr = list(map(int, input().split()))
36
    earliest_faulty_readings(arr, k)
37",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052399
1390052388,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <string.h>
3
#include <limits.h>
4
5
int minDecommissionCost(char *rack) {
6
    int n = strlen(rack);
7
    int first = -1, last = -1;
8
    9
    for (int i = 0; i < n; i++) {
10
        if (rack[i] == '1') {
11
            if (first == -1) first = i;
12
            last = i;
13
        }
14
    }
15
    16
    if (first == -1) return 0;
17
    18
    int zeroCount = 0, oneCount = 0;
19
    for (int i = first; i <= last; i++) {
20
        if (rack[i] == '0') zeroCount++;
21
        else oneCount++;
22
    }
23
    24
    return (zeroCount > oneCount) ? oneCount : zeroCount;
25
}
26
27
int main() {
28
    int t;
29
    scanf(""%d"", &t);
30
    while (t--) {
31
        char rack[100005];
32
        scanf(""%s"", rack);
33
        printf(""%d\n"", minDecommissionCost(rack));
34
    }
35
    return 0;
36
}",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052388
1390052394,unknown,unknown,unknown,"1
def faulty_sensor_readings(arr, k):
2
    """"""
3
    Determines the earliest faulty reading for each consecutive batch of size k.
4
5
    Args:
6
        arr: A list of sensor readings.
7
        k: The batch size.
8
9
    Returns:
10
        A list containing the earliest faulty reading for each batch.
11
    """"""
12
    result = []
13
    for i in range(len(arr) - k + 1):
14
        batch = arr[i:i + k]
15
        fault = 0
16
        for num in batch:
17
            if num < 0:
18
                fault = num
19
                break
20
        result.append(fault)
21
    return result
22
23
if __name__ == ""__main__"":
24
    t = int(input())
25
    for _ in range(t):
26
        n, k = map(int, input().split())
27
        arr = list(map(int, input().split()))
28
        result = faulty_sensor_readings(arr, k)
29
        print(*result)",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052394
1390052389,unknown,unknown,unknown,"1
t = int(input())
2
for i in range(t):  
3
    n, k = map(int, input().split())
4
    arr = list(map(int, input().split()))
5
    6
    res = []
7
    for i in range(n - k + 1):
8
        for j in range(i, i + k):
9
            if arr[j] < 0:
10
                res.append(arr[j])
11
                break
12
        else:
13
            res.append(0)
14
    15
    print("" "".join(map(str, res)))
16",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052389
1390052382,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()  # Stores indices of negative numbers
6
7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
12
    # Process each window
13
    for i in range(len(arr) - k + 1):
14
        # If deque is not empty, first element is the first negative in window
15
        if dq:
16
            result.append(arr[dq[0]])
17
        else:
18
            result.append(0)
19
20
        # Slide window: Remove elements out of range
21
        if dq and dq[0] == i:
22
            dq.popleft()
23
24
        # Add next element in the window
25
        if i + k < len(arr) and arr[i + k] < 0:
26
            dq.append(i + k)
27
28
    return result
29
30
# Read input
31
t = int(input())  # Number of test cases
32
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Array size and batch size
35
    arr = list(map(int, input().split()))  # Sensor readings
36
37
    # Process and output result
38
    print(*earliest_faulty_readings(arr, k))
39",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052382
1390052378,unknown,unknown,unknown,"1
def min_effort_to_breach(test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        min_effort = float('inf')
6
7
        for i in range(n - k + 1):
8
            effort = 0
9
            skip_count = 0
10
11
            for j in range(n):
12
                if i <= j < i + k:
13
                    skip_count += 1  # Skipping this firewall
14
                else:
15
                    effort += firewalls[j] + skip_count  # Adding the firewall's strength + penalty
16
            17
            min_effort = min(min_effort, effort)
18
19
        results.append(str(min_effort))
20
    21
    return ""\n"".join(results)
22
23
t = int(input())
24
test_cases = [tuple(map(int, input().split())) + (list(map(int, input().split())),) for _ in range(t)]
25
26
print(min_effort_to_breach(test_cases))
27",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052378
1390052385,unknown,unknown,unknown,"1
def earliest_fault(test_cases):
2
    results = []
3
    for case in test_cases:
4
        n, k, arr = case
5
        batch_results = []
6
        7
        for i in range(n - k + 1):
8
            batch = arr[i:i + k]
9
            fault = next((x for x in batch if x < 0), 0)
10
            batch_results.append(fault)
11
        12
        results.append(batch_results)
13
    14
    return results
15
16
import sys
17
input_data = sys.stdin.read()
18
19
lines = input_data.splitlines()
20
21
t = int(lines[0])
22
test_cases = []
23
24
index = 1
25
for _ in range(t):
26
    27
    n, k = map(int, lines[index].split())
28
    index += 1
29
    30
    arr = list(map(int, lines[index].split()))
31
    index += 1
32
    33
    test_cases.append((n, k, arr))
34
results = earliest_fault(test_cases)
35
for result in results:
36
    print("" "".join(map(str, result)))
37",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052385
1390052374,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
5
    result = []
6
7
    dq = deque()
8
9
    10
11
    for i in range(len(arr)):
12
13
        # Remove indices that are out of the current window
14
15
        while dq and dq[0] < i - k + 1:
16
17
            dq.popleft()
18
19
        20
21
        # Add current element index if it is negative
22
23
        if arr[i] < 0:
24
25
            dq.append(i)
26
27
        28
29
        # Start adding results only when we have a full batch
30
31
        if i >= k - 1:
32
33
            if dq:
34
35
                result.append(arr[dq[0]])  # Earliest fault in the window
36
37
            else:
38
39
                result.append(0)  # No fault found in the window
40
41
    42
43
    return result
44
45
# Read input
46
47
t = int(input())  # Number of test cases
48
49
for _ in range(t):
50
51
    n, k = map(int, input().split())  # Array size and batch size
52
53
    arr = list(map(int, input().split()))  # Sensor readings
54
55
    56
57
    # Get and print results
58
59
    print("" "".join(map(str, earliest_faults(arr, k))))",180,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052374
1390052366,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    for n, k, arr in test_cases:
6
        res = []
7
        dq = deque()
8
        9
        # Process the first k elements
10
        for i in range(k):
11
            if arr[i] < 0:
12
                dq.append(i)
13
        14
        # Store the first result
15
        res.append(arr[dq[0]] if dq else 0)
16
        17
        # Process the remaining elements
18
        for i in range(k, n):
19
            # Remove elements that are out of the current window
20
            while dq and dq[0] < i - k + 1:
21
                dq.popleft()
22
            23
            # Add new element if it is faulty
24
            if arr[i] < 0:
25
                dq.append(i)
26
            27
            # Store result for current window
28
            res.append(arr[dq[0]] if dq else 0)
29
        30
        results.append(res)
31
    32
    return results
33
34
# Read input
35
def main():
36
    t = int(input().strip())
37
    test_cases = []
38
    for _ in range(t):
39
        n, k = map(int, input().split())
40
        arr = list(map(int, input().split()))
41
        test_cases.append((n, k, arr))
42
    43
    # Get results
44
    output = earliest_faulty_readings(test_cases)
45
    46
    # Print results
47
    for res in output:
48
        print("" "".join(map(str, res)))
49
50
if __name__ == ""__main__"":
51
    main()",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052366
1390052367,unknown,unknown,unknown,"1
def solve():
2
    t = int(input())
3
    for _ in range(t):
4
        n, k = map(int, input().split())
5
        a = list(map(int, input().split()))
6
7
        min_effort = float('inf')
8
9
        for i in range(1 << n):  # Iterate through all possible combinations of skipped firewalls
10
            skipped_indices = []
11
            for j in range(n):
12
                if (i >> j) & 1:
13
                    skipped_indices.append(j)
14
15
            if len(skipped_indices) <= k:
16
                effort = 0
17
                increased_strength = 0
18
                current_skipped_index = 0
19
20
                for j in range(n):
21
                    if current_skipped_index < len(skipped_indices) and skipped_indices[current_skipped_index] == j:
22
                        increased_strength += 1
23
                        current_skipped_index += 1
24
                    else:
25
                        effort += a[j] + increased_strength
26
27
                min_effort = min(min_effort, effort)
28
29
        print(min_effort)
30
31
solve()",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052367
1390052363,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    for n, k, arr in test_cases:
6
        dq = deque()
7
        res = []
8
        9
        for i in range(n):
10
            11
            if dq and dq[0] < i - k + 1:
12
                dq.popleft()
13
            14
            if arr[i] < 0:
15
                dq.append(i)
16
            17
            if i >= k - 1:
18
                res.append(arr[dq[0]] if dq else 0)
19
        20
        results.append("" "".join(map(str, res)))
21
    22
    print(""\n"".join(results))
23
24
t = int(input())
25
test_cases = []
26
for _ in range(t):
27
    n, k = map(int, input().split())
28
    arr = list(map(int, input().split()))
29
    test_cases.append((n, k, arr))
30
31
earliest_faulty_readings(test_cases)",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052363
1390052359,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    3
4
    result = []
5
6
7
8
    for i in range(len(arr) - k + 1):
9
10
11
12
        batch = arr[i:i+k]
13
        14
15
        fault_found = False
16
17
        18
19
        20
21
        for num in batch:
22
            23
24
            if num < 0:
25
26
                result.append(num)
27
28
                fault_found = True
29
                30
31
                break
32
33
        34
35
       36
37
        if not fault_found:
38
            39
40
            result.append(0)
41
42
    43
44
    return result
45
46
47
48
t = int(input())  
49
50
51
52
for _ in range(t):
53
54
    55
    n, k = map(int, input().split())  
56
    57
58
    arr = list(map(int, input().split()))  
59
60
    61
62
    result = earliest_fault(arr, k)
63
64
    65
    print(*result)  ",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052359
1390052360,unknown,unknown,unknown,"1
def find_faulty_readings(arr, k):
2
3
    n = len(arr)
4
5
    results = []
6
7
    for i in range(n - k + 1):
8
9
        batch = arr[i:i+k]
10
11
        faulty_index = next((j for j, value in enumerate(batch) if value < 0), None)
12
13
        if faulty_index is not None:
14
15
            results.append(batch[faulty_index])
16
17
        else:
18
19
            results.append(0)
20
21
    return results
22
23
# Read input
24
25
import sys
26
27
input = sys.stdin.read
28
29
data = input().split()
30
31
t = int(data[0])  # Number of test cases
32
33
index = 1
34
35
results = []
36
37
for _ in range(t):
38
39
    n = int(data[index])
40
41
    k = int(data[index + 1])
42
43
    index += 2
44
45
    arr = list(map(int, data[index:index + n]))
46
47
    index += n
48
49
    50
51
    results.append(find_faulty_readings(arr, k))
52
53
# Print results
54
55
for result in results:
56
57
    print("" "".join(map(str, result)))",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052360
1390052362,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
11
        Scanner sc = new Scanner(System.in);
12
        int t = sc.nextInt();
13
        while(t-- > 0){
14
            int n = sc.nextInt();
15
            int k = sc.nextInt();
16
            int [] arr = new int [n];
17
            for(int i = 0 ;i<n ; i++){
18
                arr[i] = sc.nextInt();
19
            }
20
            for(int i = 0 ; i<=n-k ; i++){
21
                int earlyFault = 0;
22
                for(int j = i ; j<i+k ; j++){
23
                    if(arr[j]<0){
24
                        earlyFault = arr[j];
25
                        break;
26
                    }
27
                }
28
                System.out.print(earlyFault+ "" "");
29
            }
30
            System.out.println();
31
        }
32
    }
33
}",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052362
1390052353,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(t, testcases):
4
    results = []
5
    6
    for n, k, arr in testcases:
7
        dq = deque() 
8
        res = []
9
        10
        for i in range(k):
11
            if arr[i] < 0:
12
                dq.append(i)
13
14
        res.append(arr[dq[0]] if dq else 0)
15
        for i in range(k, n):
16
            while dq and dq[0] < i - k + 1:
17
                dq.popleft()
18
            19
            if arr[i] < 0:
20
                dq.append(i)
21
            22
            res.append(arr[dq[0]] if dq else 0)
23
        24
        results.append(res)
25
    26
    return results
27
28
t = int(input().strip())
29
testcases = []
30
for _ in range(t):
31
    n, k = map(int, input().strip().split())
32
    arr = list(map(int, input().strip().split()))
33
    testcases.append((n, k, arr))
34
35
output = earliest_faulty_readings(t, testcases)
36
37
for res in output:
38
    print(*res)
39",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052353
1390052354,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(t, test_cases):
4
    results = []
5
    6
    for case in test_cases:
7
        n, k, arr = case
8
        dq = deque()
9
        output = []
10
        11
        for i in range(n):
12
            13
            if dq and dq[0] < i - k + 1:
14
                dq.popleft()
15
            16
            17
            if arr[i] < 0:
18
                dq.append(i)
19
            20
           21
            if i >= k - 1:
22
                output.append(arr[dq[0]] if dq else 0)
23
        24
        results.append(output)
25
    26
    return results
27
28
29
t = int(input())
30
test_cases = []
31
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    test_cases.append((n, k, arr))
36
37
results = earliest_faulty_readings(t, test_cases)
38
for res in results:
39
    print("" "".join(map(str, res)))",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052354
1390052357,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(len(arr)):
8
        # Remove out-of-window elements from the deque
9
        while dq and dq[0] < i - k + 1:
10
            dq.popleft()
11
        12
        # Add current element if it's negative
13
        if arr[i] < 0:
14
            dq.append(i)
15
        16
        # Once we have a full window, determine the earliest fault
17
        if i >= k - 1:
18
            if dq:
19
                result.append(arr[dq[0]])  # Earliest negative in the window
20
            else:
21
                result.append(0)  # No negative found
22
    23
    return result
24
25
# Input processing
26
t = int(input())
27
for _ in range(t):
28
    n, k = map(int, input().split())
29
    arr = list(map(int, input().split()))
30
    result = earliest_faulty_reading(arr, k)
31
    print(' '.join(map(str, result)))
32
33
    ",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052357
1390052345,unknown,unknown,unknown,"1
def min_effort_to_breach(test_cases):
2
    results = []
3
4
    for n, k, arr in test_cases:
5
        if k >= n:
6
            results.append(0)
7
            continue
8
        9
        min_effort = float('inf')
10
        11
        # Iterate through all possible segments of length k to skip
12
        for i in range(n - k + 1):
13
            skipped = arr[i:i + k]
14
            remaining = arr[:i] + arr[i + k:]
15
            16
            # Calculate the effort after the skip
17
            effort = sum(remaining) + sum(range(1, len(skipped) + 1))
18
            min_effort = min(min_effort, effort)
19
        20
        results.append(min_effort)
21
22
    return results
23
24
25
if __name__ == ""__main__"":
26
    t = int(input())
27
    test_cases = []
28
    29
    for _ in range(t):
30
        n, k = map(int, input().strip().split())
31
        arr = list(map(int, input().strip().split()))
32
        test_cases.append((n, k, arr))
33
34
    results = min_effort_to_breach(test_cases)
35
    36
    for res in results:
37
        print(res)
38",181,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052345
1390052341,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process first k elements
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process rest of the elements
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the window
18
        while dq and dq[0] <= i - k:
19
            dq.popleft()
20
        21
        # Add new element if it's negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the result
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
def process_test_cases():
31
    t = int(input())
32
    for _ in range(t):
33
        n, k = map(int, input().split())
34
        arr = list(map(int, input().split()))
35
        print(*earliest_faulty_readings(arr, k))
36
37
if __name__ == ""__main__"":
38
    process_test_cases()",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052341
1390052343,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <deque>
7
using namespace std;
8
9
int main() {
10
    int t;
11
    cin >> t;
12
    while (t--) {
13
        int n, k;
14
        cin >> n >> k;
15
        vector<int> arr(n);
16
        for (int i = 0; i < n; i++) {
17
            cin >> arr[i];
18
        }
19
        20
        deque<int> dq;
21
        vector<int> result;
22
        23
        for (int i = 0; i < n; i++) {
24
            // Add current element if it's a fault (negative)
25
            if (arr[i] < 0) {
26
                dq.push_back(i);
27
            }
28
29
            // Remove elements that are out of current window
30
            if (i >= k && !dq.empty() && dq.front() <= i - k) {
31
                dq.pop_front();
32
            }
33
34
            // Start recording result once we have a complete window
35
            if (i >= k - 1) {
36
                if (!dq.empty()) {
37
                    result.push_back(arr[dq.front()]);
38
                } else {
39
                    result.push_back(0);
40
                }
41
            }
42
        }
43
44
        // Print the result for this test case
45
        for (int i = 0; i < result.size(); i++) {
46
            cout << result[i];
47
            if (i != result.size() - 1) cout << "" "";
48
        }
49
        cout << endl;
50
    }
51
    return 0;
52
}
53",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052343
1390052340,unknown,unknown,unknown,"1
def min_cost(servers):
2
    n = len(servers)
3
    4
    # Try all possible combinations of prefix and suffix removal
5
    min_cost = float('inf')
6
    7
    # i represents number of servers to remove from start
8
    for i in range(n + 1):
9
        # j represents number of servers to remove from end
10
        for j in range(n - i + 1):
11
            # Get the remaining substring
12
            remaining = servers[i:n-j]
13
            14
            if not remaining:  # If we remove everything
15
                ones_removed = servers.count('1')
16
                cost = max(0, ones_removed)
17
            else:
18
                # Count remaining zeros (idle servers)
19
                zeros_remaining = remaining.count('0')
20
                # Count ones removed from start and end
21
                ones_removed = servers[:i].count('1') + servers[n-j:].count('1')
22
                cost = max(zeros_remaining, ones_removed)
23
            24
            min_cost = min(min_cost, cost)
25
    26
    return min_cost
27
28
# Handle automatic input
29
t = int(input())  # Number of test cases
30
for _ in range(t):
31
    servers = input().strip()  # Read the binary string
32
    result = min_cost(servers)
33
    print(result)",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052340
1390052328,unknown,unknown,unknown,"1
def faulty_sensor_readings(arr, k):
2
    """"""
3
    Determines the earliest faulty reading for each consecutive batch of size k.
4
5
    Args:
6
        arr: A list of sensor readings.
7
        k: The batch size.
8
9
    Returns:
10
        A list containing the earliest faulty reading for each batch.
11
    """"""
12
    result = []
13
    for i in range(len(arr) - k + 1):
14
        batch = arr[i:i + k]
15
        fault = 0
16
        for num in batch:
17
            if num < 0:
18
                fault = num
19
                break
20
        result.append(fault)
21
    return result
22
23
if __name__ == ""__main__"":
24
    t = int(input())
25
    for _ in range(t):
26
        n, k = map(int, input().split())
27
        arr = list(map(int, input().split()))
28
        result = faulty_sensor_readings(arr, k)
29
        print(*result)",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052328
1390052330,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
#include <deque>
7
using namespace std;
8
9
int main() {
10
    int t;
11
    cin >> t;
12
    while (t--) {
13
        int n, k;
14
        cin >> n >> k;
15
        vector<int> arr(n);
16
        for (int i = 0; i < n; i++) 
17
            cin >> arr[i];
18
19
        deque<int> dq;
20
        vector<int> result;
21
22
        for (int i = 0; i < n; i++) {
23
            if (!dq.empty() && dq.front() == i - k) 
24
                dq.pop_front();
25
26
            if (arr[i] < 0) 
27
                dq.push_back(i);
28
29
            if (i >= k - 1) 
30
                result.push_back(dq.empty() ? 0 : arr[dq.front()]);
31
        }
32
33
        for (int num : result) 
34
            cout << num << "" "";
35
        cout << endl;
36
    }
37
    return 0;
38
}",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052330
1390052338,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
3
    results = []
4
5
    6
7
    # Loop through each possible batch
8
9
    for i in range(len(arr) - k + 1):
10
11
        fault_found = False
12
13
        14
15
        # Find earliest fault in current batch
16
17
        for j in range(i, i + k):
18
19
            if arr[j] < 0:
20
21
                results.append(arr[j])
22
23
                fault_found = True
24
25
                break
26
27
                28
29
        # If no fault found in batch, append 0
30
31
        if not fault_found:
32
33
            results.append(0)
34
35
    36
37
    return results
38
39
# Process test cases
40
41
t = int(input())
42
43
for _ in range(t):
44
45
    n, k = map(int, input().split())
46
47
    arr = list(map(int, input().split()))
48
49
    50
51
    result = earliest_fault(arr, k)
52
53
    print(*result)",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052338
1390052313,unknown,unknown,unknown,"1
def solve():
2
    t = int(input())
3
    for _ in range(t):
4
        s = input()
5
        n = len(s)
6
7
        min_cost = float('inf')
8
9
        for i in range(n + 1):
10
            removed_start = s[:i]
11
            remaining = s[i:]
12
13
            for j in range(len(remaining) + 1):
14
                idle_remaining = remaining[:len(remaining) - j].count('0')
15
                removed_end = remaining[len(remaining) - j:]
16
17
                active_removed = removed_start.count('1') + removed_end.count('1')
18
19
                cost = max(idle_remaining, active_removed)
20
                min_cost = min(min_cost, cost)
21
22
        print(min_cost)
23
24
solve()",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052313
1390052317,unknown,unknown,unknown,"1
def find_faulty_readings(arr, k):
2
3
    n = len(arr)
4
5
    results = []
6
7
    for i in range(n - k + 1):
8
9
        batch = arr[i:i+k]
10
11
        faulty_index = next((j for j, value in enumerate(batch) if value < 0), None)
12
13
        if faulty_index is not None:
14
15
            results.append(batch[faulty_index])
16
17
        else:
18
19
            results.append(0)
20
21
    return results
22
23
# Read input
24
25
import sys
26
27
input = sys.stdin.read
28
29
data = input().split()
30
31
t = int(data[0])  # Number of test cases
32
33
index = 1
34
35
results = []
36
37
for _ in range(t):
38
39
    n = int(data[index])
40
41
    k = int(data[index + 1])
42
43
    index += 2
44
45
    arr = list(map(int, data[index:index + n]))
46
47
    index += n
48
49
    50
51
    results.append(find_faulty_readings(arr, k))
52
53
# Print results
54
55
for result in results:
56
57
    print("" "".join(map(str, result)))",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052317
1390052315,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
    8
    # Process first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Append result for first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process remaining windows
17
    for i in range(k, n):
18
        # Remove elements not in the current window
19
        while dq and dq[0] <= i - k:
20
            dq.popleft()
21
        22
        # Add new element if faulty
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Append result for current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
def process_test_cases(t, test_cases):
32
    results = []
33
    for n, k, arr in test_cases:
34
        results.append("" "".join(map(str, earliest_faults(arr, k))))
35
    return ""\n"".join(results)
36
37
# Reading input
38
t = int(input())
39
test_cases = []
40
for _ in range(t):
41
    n, k = map(int, input().split())
42
    arr = list(map(int, input().split()))
43
    test_cases.append((n, k, arr))
44
45
# Output results
46
print(process_test_cases(t, test_cases))",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052315
1390052312,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    result = []
3
    4
    for i in range(len(arr) - k + 1):
5
        batch = arr[i:i+k]
6
        fault_found = False
7
        8
        for num in batch:
9
            if num < 0:
10
                result.append(num)
11
                fault_found = True
12
                break
13
        14
        if not fault_found:
15
            result.append(0)
16
    17
    return result
18
19
t = int(input())
20
21
for _ in range(t):
22
    n, k = map(int, input().split())
23
    arr = list(map(int, input().split()))
24
    25
    result = earliest_fault(arr, k)
26
    print(*result)
27",182,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052312
1390052305,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of this window
18
        if dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
        21
        # Add new element if it's negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store result for the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Reading input
31
t = int(input())
32
for _ in range(t):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    36
    print(*earliest_faulty_readings(arr, k))",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052305
1390052306,unknown,unknown,unknown,"1
def min_effort_to_breach(test_cases):
2
    results = []
3
    4
    for n, k, firewalls in test_cases:
5
        if k == n:
6
            results.append(""0"")
7
            continue
8
        9
        total_effort = sum(firewalls)
10
        min_effort = total_effort
11
        12
        current_sum = sum(firewalls[:k])
13
        for i in range(n - k + 1):
14
            increased_security = sum(range(1, min(k, n - i) + 1))
15
            new_effort = total_effort - current_sum + increased_security
16
            min_effort = min(min_effort, new_effort)
17
            18
            if i + k < n:
19
                current_sum = current_sum - firewalls[i] + firewalls[i + k]
20
        21
        results.append(str(min_effort))
22
    23
    return ""\n"".join(results)
24
25
# Read input
26
t = int(input())
27
test_cases = []
28
for _ in range(t):
29
    n, k = map(int, input().split())
30
    firewalls = list(map(int, input().split()))
31
    test_cases.append((n, k, firewalls))
32
33
# Get output and print
34
print(min_effort_to_breach(test_cases))",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052306
1390052310,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <string.h>
3
#include <limits.h>
4
5
int minDecommissionCost(char *rack) {
6
    int n = strlen(rack);
7
    int first = -1, last = -1;
8
    9
    for (int i = 0; i < n; i++) {
10
        if (rack[i] == '1') {
11
            if (first == -1) first = i;
12
            last = i;
13
        }
14
    }
15
    16
    if (first == -1) return 0;
17
    18
    int zeroCount = 0, oneCount = 0;
19
    for (int i = first; i <= last; i++) {
20
        if (rack[i] == '0') zeroCount++;
21
        else oneCount++;
22
    }
23
    24
    return zeroCount < oneCount ? zeroCount : oneCount;
25
}
26
27
int main() {
28
    int t;
29
    scanf(""%d"", &t);
30
    while (t--) {
31
        char rack[100005];
32
        scanf(""%s"", rack);
33
        printf(""%d\n"", minDecommissionCost(rack));
34
    }
35
    return 0;
36
}",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052310
1390052295,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  
7
    8
   9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    17
    for i in range(k, n):
18
       19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
       23
        if arr[i] < 0:
24
            dq.append(i)
25
        result.append(arr[dq[0]] if dq else 0)
26
    27
    return result
28
29
30
t = int(input()) 
31
for _ in range(t):
32
    n, k = map(int, input().split())
33
    arr = list(map(int, input().split()))
34
    print(*earliest_faulty_readings(arr, k))
35",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052295
1390052300,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()
7
    8
    9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
   14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    17
    for i in range(k, n):
18
        19
        while dq and dq[0] <= i - k:
20
            dq.popleft()
21
        22
       23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
def process_test_cases(t, test_cases):
32
    for n, k, arr in test_cases:
33
        print(*earliest_faults(arr, k))
34
35
36
t = int(input())
37
test_cases = []
38
39
for _ in range(t):
40
    n, k = map(int, input().split())
41
    arr = list(map(int, input().split()))
42
    test_cases.append((n, k, arr))
43
44
process_test_cases(t, test_cases)
45",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052300
1390052304,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_fault_in_batches(sensor_readings, batch_size):
4
    total_readings = len(sensor_readings)
5
    results = []
6
    fault_indices = deque()
7
8
    for idx in range(total_readings):
9
        if fault_indices and fault_indices[0] < idx - batch_size + 1:
10
            fault_indices.popleft()
11
12
        if sensor_readings[idx] < 0:
13
            fault_indices.append(idx)
14
15
        if idx >= batch_size - 1:
16
            if fault_indices:
17
                results.append(sensor_readings[fault_indices[0]])
18
            else:
19
                results.append(0)
20
21
    return results
22
23
def handle_multiple_tests():
24
    test_cases = int(input())
25
    for _ in range(test_cases):
26
        size, batch_size = map(int, input().split())
27
        readings = list(map(int, input().split()))
28
        output = find_fault_in_batches(readings, batch_size)
29
        print(' '.join(map(str, output)))
30
31
handle_multiple_tests()
32",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052304
1390052283,unknown,unknown,unknown,"1
def min_effort_to_breach(test_cases):
2
    results = []
3
4
    for n, k, arr in test_cases:
5
        # Base case: If we can skip all firewalls, the effort is 0
6
        if k == n:
7
            results.append(0)
8
            continue
9
10
        # Calculate prefix sums
11
        prefix = [0] * (n + 1)
12
        for i in range(n):
13
            prefix[i + 1] = prefix[i] + arr[i]
14
15
        # Minimum effort calculation by skipping up to 'k' firewalls
16
        min_effort = float('inf')
17
        for i in range(n - k + 1):
18
            # Effort for current window
19
            effort = prefix[i] + (prefix[n] - prefix[i + k]) + k
20
            min_effort = min(min_effort, effort)
21
22
        results.append(min_effort)
23
24
    return results
25
26
27
if __name__ == ""__main__"":
28
    t = int(input())
29
    test_cases = []
30
    31
    for _ in range(t):
32
        n, k = map(int, input().strip().split())
33
        arr = list(map(int, input().strip().split()))
34
        test_cases.append((n, k, arr))
35
36
    results = min_effort_to_breach(test_cases)
37
    38
    for res in results:
39
        print(res)
40",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052283
1390052286,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    # If we can skip all firewalls
5
    if k >= n:
6
        return 0
7
    8
    memo = {}
9
    10
    def dp(index, skips_used):
11
        if index == n:
12
            return 0
13
            14
        if (index, skips_used) in memo:
15
            return memo[(index, skips_used)]
16
            17
        # Option 1: Skip current firewall
18
        if skips_used < k:
19
            option1 = dp(index + 1, skips_used + 1)
20
        else:
21
            option1 = float('inf')
22
            23
        # Option 2: Don't skip current firewall
24
        option2 = (firewalls[index] + skips_used) + dp(index + 1, skips_used)
25
        26
        memo[(index, skips_used)] = min(option1, option2)
27
        return memo[(index, skips_used)]
28
    29
    return dp(0, 0)
30
31
# Handle automatic input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    # Read n and k from first line
35
    n, k = map(int, input().split())
36
    # Read firewall strengths from second line
37
    firewalls = list(map(int, input().split()))
38
    # Calculate and print result
39
    result = min_effort(firewalls, k)
40
    print(result)",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052286
1390052290,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for case in test_cases:
7
        n, k, arr = case
8
        dq = deque()
9
        res = []
10
        for i in range(k):
11
            if arr[i] < 0:
12
                dq.append(i)
13
        14
        res.append(arr[dq[0]] if dq else 0)
15
        16
        for i in range(k, n):
17
            while dq and dq[0] < i - k + 1:
18
                dq.popleft()
19
            20
            if arr[i] < 0:
21
                dq.append(i)
22
            23
            res.append(arr[dq[0]] if dq else 0)
24
        25
        results.append("" "".join(map(str, res)))
26
    27
    return ""\n"".join(results)
28
29
t = int(input().strip())
30
test_cases = []
31
for _ in range(t):
32
    n, k = map(int, input().split())
33
    arr = list(map(int, input().split()))
34
    test_cases.append((n, k, arr))
35
36
print(earliest_faulty_readings(test_cases))",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052290
1390052281,unknown,unknown,unknown,"1
#include <cmath>
2
#include <cstdio>
3
#include <vector>
4
#include <iostream>
5
#include <algorithm>
6
using namespace std;
7
8
9
int main() {
10
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
11
    int t;
12
    cin >> t;
13
    while(t--) {
14
        int n, k;
15
        cin >> n >> k;
16
        vector<int> arr(n);
17
        for(int i = 0; i < n; i++) {
18
            cin >> arr[i];
19
        }
20
        21
        vector<int> ans;
22
        for(int i = 0; i < n-k+1; i++) {
23
            int neg = 0;
24
            for(int j = 0; j < k; j++) {
25
                if(arr[i+j] < 0) {
26
                    neg = arr[i+j];
27
                    break;
28
                }
29
            }
30
            cout << neg << "" "";
31
        }
32
        33
        cout << endl;
34
    }
35
    return 0;
36
}",183,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052281
1390052275,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    result.append(arr[dq[0]] if dq else 0)
12
    13
    for i in range(k, len(arr)):
14
        while dq and dq[0] <= i - k:
15
            dq.popleft()
16
        17
        if arr[i] < 0:
18
            dq.append(i)
19
        20
        result.append(arr[dq[0]] if dq else 0)
21
    22
    return result
23
24
t = int(input())
25
for _ in range(t):
26
    n, k = map(int, input().split())
27
    arr = list(map(int, input().split()))
28
    print("" "".join(map(str, earliest_faulty_readings(arr, k))))",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052275
1390052274,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    ans = []
5
    6
    for tc in test_cases:
7
        n, k, arr = tc
8
        dq = deque()
9
        sol = []
10
11
        for i in range(k):
12
            if arr[i] < 0:
13
                dq.append(i)
14
15
        sol.append(arr[dq[0]] if dq else 0)
16
17
        for i in range(k, n):
18
            if dq and dq[0] < i - k + 1:
19
                dq.popleft()
20
            21
            if arr[i] < 0:
22
                dq.append(i)
23
24
            sol.append(arr[dq[0]] if dq else 0)
25
        26
        ans.append(sol)
27
    28
    return ans
29
30
t = int(input())  
31
test_cases = []
32
33
for _ in range(t):
34
    n, k = map(int, input().split())
35
    arr = list(map(int, input().split()))
36
    test_cases.append((n, k, arr))
37
    38
for res in earliest_faulty_readings(test_cases):
39
    print(*res)
40",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052274
1390052277,unknown,unknown,unknown,"1
def solve():
2
    t = int(input())
3
    for _ in range(t):
4
        s = input()
5
        n = len(s)
6
        7
        min_cost = float('inf')
8
        9
        for i in range(n + 1):
10
            for j in range(n - i + 1):
11
                removed_start = s[:i]
12
                remaining = s[i:n-j]
13
                removed_end = s[n-j:]
14
                15
                idle_remaining = remaining.count('0')
16
                active_removed = removed_start.count('1') + removed_end.count('1')
17
                18
                cost = max(idle_remaining, active_removed)
19
                min_cost = min(min_cost, cost)
20
        21
        print(min_cost)
22
23
solve()",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052277
1390052262,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_earliest_faults(num_cases, inputs):
4
    all_outputs = []
5
    6
    for data in inputs:
7
        length, window, readings = data
8
        queue = deque()
9
        result = []
10
        11
        for idx in range(length):
12
            while queue and queue[0] < idx - window + 1:
13
                queue.popleft()
14
            15
            if readings[idx] < 0:
16
                queue.append(idx)
17
            18
            if idx >= window - 1:
19
                result.append(readings[queue[0]] if queue else 0)
20
        21
        all_outputs.append(result)
22
    23
    return all_outputs
24
25
num_cases = int(input())
26
inputs = []
27
28
for _ in range(num_cases):
29
    length, window = map(int, input().split())
30
    readings = list(map(int, input().split()))
31
    inputs.append((length, window, readings))
32
33
all_outputs = find_earliest_faults(num_cases, inputs)
34
35
for output in all_outputs:
36
    print("" "".join(map(str, output)))",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052262
1390052264,unknown,unknown,unknown,"1
def find_faulty_readings(arr, k):
2
    n = len(arr)
3
    results = []
4
    for i in range(n - k + 1):
5
        batch = arr[i:i+k]
6
        faulty_index = next((j for j, value in enumerate(batch) if value < 0), None)
7
        if faulty_index is not None:
8
            results.append(batch[faulty_index])
9
        else:
10
            results.append(0)
11
    return results
12
13
# Read input
14
import sys
15
input = sys.stdin.read
16
data = input().split()
17
18
t = int(data[0])  # Number of test cases
19
20
index = 1
21
results = []
22
for _ in range(t):
23
    n = int(data[index])
24
    k = int(data[index + 1])
25
    index += 2
26
    arr = list(map(int, data[index:index + n]))
27
    index += n
28
    29
    results.append(find_faulty_readings(arr, k))
30
31
# Print results
32
for result in results:
33
    print("" "".join(map(str, result)))",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052264
1390052270,unknown,unknown,unknown,"1
def earliest_faulty_reading(test_cases):
2
    results = []
3
    4
    for n, k, arr in test_cases:
5
        batch_results = []
6
        7
        for i in range(n - k + 1):
8
            batch = arr[i:i + k]
9
            faulty = next((x for x in batch if x < 0), 0)
10
            batch_results.append(faulty)
11
        12
        results.append(batch_results)
13
    14
    return results
15
16
17
if __name__==""__main__"":
18
    t = int(input())
19
    test_cases = []
20
    21
    for _ in range(t):
22
        n, k = map(int, input().strip().split())
23
        arr = list(map(int, input().strip().split()))
24
        test_cases.append((n, k, arr))
25
26
    results = earliest_faulty_reading(test_cases)
27
    28
    for res in results:
29
        print(*res)",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052270
1390052252,unknown,unknown,unknown,"1
def earliest_faulty_reading(test_cases):
2
    results = []
3
    4
    for n, k, arr in test_cases:
5
        batch_results = []
6
        7
        for i in range(n - k + 1):
8
            batch = arr[i:i + k]
9
            faulty = next((x for x in batch if x < 0), 0)
10
            batch_results.append(faulty)
11
        12
        results.append(batch_results)
13
    14
    return results
15
16
17
if __name__ == ""__main__"":
18
    t = int(input())
19
    test_cases = []
20
    21
    for _ in range(t):
22
        n, k = map(int, input().strip().split())
23
        arr = list(map(int, input().strip().split()))
24
        test_cases.append((n, k, arr))
25
26
    results = earliest_faulty_reading(test_cases)
27
    28
    for res in results:
29
        print(*res)",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052252
1390052257,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
#include <limits.h>
4
5
int main() {
6
    int T;
7
    scanf(""%d"", &T);
8
9
    while (T--) {
10
        int n, k;
11
        scanf(""%d %d"", &n, &k);
12
13
        int a[n];
14
        for (int i = 0; i < n; i++) {
15
            scanf(""%d"", &a[i]);
16
        }
17
18
        long long min_effort = LLONG_MAX;
19
20
        for (int i = 0; i < (1 << n); i++) {
21
            if (__builtin_popcount(i) == k) {
22
                long long current_effort = 0;
23
                int prev_skipped = 0;
24
                for (int j = 0; j < n; j++) {
25
                    if ((i >> j) & 1) {
26
                        continue;
27
                    } else {
28
                        current_effort += a[j];
29
                        if (prev_skipped>0) {
30
                            current_effort += prev_skipped;
31
                        }
32
                        prev_skipped = 1;
33
34
                    }
35
36
                }
37
                min_effort = (current_effort < min_effort) ? current_effort : min_effort;
38
            }
39
        }
40
        if(k == n){
41
            printf(""0\n"");
42
        }
43
        else{
44
            printf(""%lld\n"", min_effort);
45
        }
46
47
    }
48
49
    return 0;
50
}",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052257
1390052256,unknown,unknown,unknown,"1
def find_earliest_faulty(arr, k):
2
    result = []
3
    for i in range(len(arr) - k + 1):
4
        batch = arr[i:i+k]
5
        for num in batch:
6
            if num < 0:
7
                result.append(num)
8
                break
9
        else:
10
            result.append(0)
11
    return result
12
13
def main():
14
    t = int(input())
15
    for _ in range(t):
16
        n, k = map(int, input().split())
17
        arr = list(map(int, input().split()))
18
        output = find_earliest_faulty(arr, k)
19
        print(' '.join(map(str, output)))
20
21
if __name__ == ""__main__"":
22
    main()",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052256
1390052249,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
4
    if k == 0:
5
        return total_effort
6
    if k >= n:
7
        return 0  # If we can skip all firewalls, effort is 0
8
9
    min_effort = total_effort
10
    for i in range(n - k + 1):  # Sliding window for skipping `k` firewalls
11
        skipped = sum(firewalls[i:i + k])  # Sum of k skipped firewalls
12
        penalty = sum(range(1, k + 1))  # Security increase for remaining firewalls
13
        remaining_effort = total_effort - skipped + penalty
14
        min_effort = min(min_effort, remaining_effort)
15
16
    return min_effort
17
18
def process_test_cases():
19
    T = int(input())
20
    for _ in range(T):
21
        n, k = map(int, input().split())
22
        firewalls = list(map(int, input().split()))
23
        print(min_effort_to_breach(n, k, firewalls))
24
25
if __name__ == ""__main__"":
26
    process_test_cases()
27",184,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052249
1390052231,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    # Base case: if we can skip all firewalls, effort is 0
5
    if k >= n:
6
        return 0
7
    8
    # Initialize memoization dictionary
9
    memo = {}
10
    11
    def dp(index, skips_used):
12
        # Base case: processed all firewalls
13
        if index == n:
14
            return 0
15
        16
        # Check if already computed
17
        if (index, skips_used) in memo:
18
            return memo[(index, skips_used)]
19
        20
        # Option 1: Skip this firewall if we have skips left
21
        if skips_used < k:
22
            option1 = dp(index + 1, skips_used + 1)
23
        else:
24
            option1 = float('inf')
25
        26
        # Option 2: Don't skip this firewall
27
        # Its strength increases by skips_used
28
        option2 = (firewalls[index] + skips_used) + dp(index + 1, skips_used)
29
        30
        # Store and return the minimum effort
31
        memo[(index, skips_used)] = min(option1, option2)
32
        return memo[(index, skips_used)]
33
    34
    return dp(0, 0)
35
36
# Process test cases
37
t = int(input(""Enter number of test cases: ""))
38
for _ in range(t):
39
    # Get n (number of firewalls) and k (number of skips allowed)
40
    n, k = map(int, input(""Enter n and k (space-separated): "").split())
41
    # Get firewall strengths
42
    firewalls = list(map(int, input(""Enter firewall strengths (space-separated): "").split()))
43
    result = min_effort(firewalls, k)
44
    print(f""Minimum effort required: {result}"")",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052231
1390052243,unknown,unknown,unknown,"1
t=int(input())
2
for _ in range(t):
3
    n,k=list(map(int,input().split()))
4
    arr=list(map(int,input().split()))
5
    ans=[]
6
    for i in range(n-k+1):
7
        for j in range(i,i+k):
8
            if arr[j]<0:
9
                ans.append(arr[j])
10
                break
11
        else:ans.append(0)
12
    for i in ans:print(i,end=' ')
13
    print()",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052243
1390052233,unknown,unknown,unknown,"1
def earliest_faulty_in_batches(arr, n, k):
2
    result = []
3
    4
    # Traverse the array in batches of size k
5
    for i in range(n - k + 1):
6
        batch = arr[i:i + k]
7
        found_fault = False
8
        9
        # Find the first negative number in the batch
10
        for num in batch:
11
            if num < 0:
12
                result.append(num)
13
                found_fault = True
14
                break
15
        16
        # If no negative number is found, append 0
17
        if not found_fault:
18
            result.append(0)
19
    20
    return result
21
22
# Reading input
23
t = int(input().strip())
24
outputs = []
25
26
for _ in range(t):
27
    n, k = map(int, input().strip().split())
28
    arr = list(map(int, input().strip().split()))
29
    outputs.append(earliest_faulty_in_batches(arr, n, k))
30
31
# Print results
32
for output in outputs:
33
    print("" "".join(map(str, output)))
34",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052233
1390052226,unknown,unknown,unknown,"1
def earliest_faulty_readings(t, test_cases):
2
    results = []
3
    for n, k, arr in test_cases:
4
        output = []
5
        for i in range(n - k + 1):
6
            found = 0
7
            for j in range(i, i + k):
8
                if arr[j] < 0:
9
                    found = arr[j]
10
                    break
11
            output.append(found)
12
        13
        results.append(output)
14
    15
    return results
16
17
t = int(input())
18
test_cases = []
19
20
for _ in range(t):
21
    n, k = map(int, input().split())
22
    arr = list(map(int, input().split()))
23
    test_cases.append((n, k, arr))
24
25
for res in earliest_faulty_readings(t, test_cases):
26
    print(*res)
27",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052226
1390052225,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
5
    results = []
6
7
    for n, k, arr in test_cases:
8
9
        result = []
10
11
        dq = deque()
12
13
        14
15
        # Process first k elements
16
17
        for i in range(k):
18
19
            if arr[i] < 0:
20
21
                dq.append(i)
22
23
        24
25
        # Check first window
26
27
        result.append(arr[dq[0]] if dq else 0)
28
29
        30
31
        # Process remaining windows
32
33
        for i in range(k, n):
34
35
            # Remove elements that are out of the window
36
37
            if dq and dq[0] <= i - k:
38
39
                dq.popleft()
40
41
            42
43
            # Add new element if it is negative
44
45
            if arr[i] < 0:
46
47
                dq.append(i)
48
49
            50
51
            # Get earliest faulty reading
52
53
            result.append(arr[dq[0]] if dq else 0)
54
55
        56
57
        results.append("" "".join(map(str, result)))
58
59
    60
61
    return ""\n"".join(results)
62
63
# Read input
64
65
t = int(input())
66
67
test_cases = []
68
69
for _ in range(t):
70
71
    n, k = map(int, input().split())
72
73
    arr = list(map(int, input().split()))
74
75
    test_cases.append((n, k, arr))
76
77
# Get results and print
78
79
print(earliest_faulty_readings(test_cases))
80
81",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052225
1390052228,unknown,unknown,unknown,"1
def solve():
2
    t = int(input())
3
    for _ in range(t):
4
        s = input()
5
        n = len(s)
6
        7
        min_cost = float('inf')
8
        9
        for i in range(n + 1):
10
            for j in range(n - i + 1):
11
                removed_start = s[:i]
12
                remaining = s[i:n-j]
13
                removed_end = s[n-j:]
14
                15
                idle_remaining = remaining.count('0')
16
                active_removed = removed_start.count('1') + removed_end.count('1')
17
                18
                cost = max(idle_remaining, active_removed)
19
                min_cost = min(min_cost, cost)
20
        21
        print(min_cost)
22
23
solve()",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390052228
1390052216,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void findEarliestFaultyReadings(int *arr, int n, int k) {
5
    int *result = (int *)malloc((n - k + 1) * sizeof(int));
6
    int front = 0, rear = 0;
7
    int queue[n];
8
    9
    // Process the first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) {
12
            queue[rear++] = i;
13
        }
14
    }
15
    16
    // Store result for the first batch
17
    result[0] = (front < rear) ? arr[queue[front]] : 0;
18
    19
    // Process the remaining windows
20
    for (int i = k; i < n; i++) {
21
        // Remove elements not within the window
22
        while (front < rear && queue[front] <= i - k) {
23
            front++;
24
        }
25
        26
        // Add new element if it's faulty
27
        if (arr[i] < 0) {
28
            queue[rear++] = i;
29
        }
30
        31
        // Store result for current batch
32
        result[i - k + 1] = (front < rear) ? arr[queue[front]] : 0;
33
    }
34
    35
    // Print the result
36
    for (int i = 0; i < n - k + 1; i++) {
37
        printf(""%d "", result[i]);
38
    }
39
    printf(""\n"");
40
    41
    free(result);
42
}
43
44
int main() {
45
    int t;
46
    scanf(""%d"", &t);
47
    48
    while (t--) {
49
        int n, k;
50
        scanf(""%d %d"", &n, &k);
51
        int arr[n];
52
        53
        for (int i = 0; i < n; i++) {
54
            scanf(""%d"", &arr[i]);
55
        }
56
        57
        findEarliestFaultyReadings(arr, n, k);
58
    }
59
    60
    return 0;
61
}
62",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052216
1390052217,unknown,unknown,unknown,"1
def min_effort(arr, k):
2
    n = len(arr)
3
    4
    # If we can skip all firewalls, minimum effort is 0
5
    if k >= n:
6
        return 0
7
    8
    # Try all configurations of which firewalls to skip
9
    min_effort_value = float('inf')
10
    11
    # Generate all possible configurations of k skips from n firewalls
12
    # This would be combinatorial explosion for large n and k
13
    # We need a more efficient approach
14
15
    # Dynamic programming approach
16
    # dp[i][j] = minimum effort to handle first i firewalls with j skips
17
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
18
    19
    # Base case: 0 effort for 0 firewalls
20
    dp[0][0] = 0
21
    22
    for i in range(1, n + 1):
23
        curr_firewall = arr[i - 1]
24
        25
        for j in range(k + 1):
26
            # Option 1: Don't skip the current firewall
27
            if j <= i - 1:
28
                dp[i][j] = dp[i - 1][j] + curr_firewall + j
29
            30
            # Option 2: Skip the current firewall (if we have skips left)
31
            if j > 0:
32
                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1])
33
    34
    # Find minimum across all possible numbers of skips
35
    return min(dp[n])
36
37
def solve():
38
    t = int(input())
39
    results = []
40
    41
    for _ in range(t):
42
        n, k = map(int, input().split())
43
        arr = list(map(int, input().split()))
44
        results.append(min_effort(arr, k))
45
    46
    for result in results:
47
        print(result)
48
49
if __name__ == ""__main__"":
50
    solve()",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052217
1390052224,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    for n, k, arr in test_cases:
6
        res = []
7
        dq = deque()
8
        9
        # Process the first k elements
10
        for i in range(k):
11
            if arr[i] < 0:
12
                dq.append(i)
13
        14
        # Store the first result
15
        res.append(arr[dq[0]] if dq else 0)
16
        17
        # Process the remaining elements
18
        for i in range(k, n):
19
            # Remove elements that are out of the current window
20
            while dq and dq[0] < i - k + 1:
21
                dq.popleft()
22
            23
            # Add new element if it is faulty
24
            if arr[i] < 0:
25
                dq.append(i)
26
            27
            # Store result for current window
28
            res.append(arr[dq[0]] if dq else 0)
29
        30
        results.append(res)
31
    32
    return results
33
34
# Read input
35
def main():
36
    t = int(input().strip())
37
    test_cases = []
38
    for _ in range(t):
39
        n, k = map(int, input().split())
40
        arr = list(map(int, input().split()))
41
        test_cases.append((n, k, arr))
42
    43
    # Get results
44
    output = earliest_faulty_readings(test_cases)
45
    46
    # Print results
47
    for res in output:
48
        print("" "".join(map(str, res)))
49
50
if __name__ == ""__main__"":
51
    main()",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052224
1390052209,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class FaultySensor {
4
    public static List<Integer> earliestFaults(int[] arr, int k) {
5
        List<Integer> result = new ArrayList<>();
6
        Deque<Integer> deque = new LinkedList<>();
7
8
        for (int i = 0; i < arr.length; i++) {
9
   10
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
11
                deque.poll();
12
            }
13
14
            if (arr[i] < 0) {
15
                deque.offer(i);
16
            }
17
18
            if (i >= k - 1) {
19
                result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
20
            }
21
        }
22
        return result;
23
    }
24
25
    public static void main(String[] args) {
26
        Scanner scanner = new Scanner(System.in);
27
        int t = scanner.nextInt(); 
28
29
        while (t-- > 0) {
30
            int n = scanner.nextInt(); 
31
            int k = scanner.nextInt(); 
32
            int[] arr = new int[n];
33
34
            for (int i = 0; i < n; i++) {
35
                arr[i] = scanner.nextInt();
36
            }
37
38
           39
            List<Integer> faults = earliestFaults(arr, k);
40
            for (int val : faults) {
41
                System.out.print(val + "" "");
42
            }
43
            System.out.println();
44
        }
45
        scanner.close();
46
    }
47
}
48",185,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052209
1390052197,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052197
1390052198,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <limits.h>
3
4
int findMinEffort(int arr[], int n, int k) {
5
    int total_effort = 0;
6
    for (int i = 0; i < n; i++) {
7
        total_effort += arr[i];
8
    }
9
    10
    if (k == n) {
11
        return 0;
12
    }
13
    14
    int min_effort = total_effort;
15
    for (int i = 0; i < n; i++) {
16
        int effort = total_effort - arr[i] + (i + 1);
17
        if (effort < min_effort) {
18
            min_effort = effort;
19
        }
20
    }
21
    22
    return min_effort;
23
}
24
25
int main() {
26
    int t;
27
    scanf(""%d"", &t);
28
    while (t--) {
29
        int n, k;
30
        scanf(""%d %d"", &n, &k);
31
        int arr[n];
32
        for (int i = 0; i < n; i++) {
33
            scanf(""%d"", &arr[i]);
34
        }
35
        printf(""%d\n"", findMinEffort(arr, n, k));
36
    }
37
    return 0;
38
}
39",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052198
1390052205,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))
39",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052205
1390052186,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the result for the first window
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process the remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of this window
18
        if dq and dq[0] < i - k + 1:
19
            dq.popleft()
20
        21
        # Add the new element if it's negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the first negative number in the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
def process_test_cases():
31
    t = int(input().strip())  # Number of test cases
32
    for _ in range(t):
33
        n, k = map(int, input().strip().split())  # Read n (size) and k (batch size)
34
        arr = list(map(int, input().strip().split()))  # Read array elements
35
        print("" "".join(map(str, earliest_faulty_readings(arr, k))))  # Output result
36
37
process_test_cases()
38",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052186
1390052193,unknown,unknown,unknown,"1
def min_effort(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    if k >= n:
4
        return 0
5
    min_effort = total_effort
6
    7
    for i in range(n):
8
        skipped_effort = total_effort - firewalls[i] + k
9
        min_effort = min(min_effort, skipped_effort)
10
    11
    return min_effort
12
13
# Read input
14
t = int(input())
15
for _ in range(t):
16
    n, k = map(int, input().split())
17
    firewalls = list(map(int, input().split()))
18
    print(min_effort(n, k, firewalls))
19",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052193
1390052195,unknown,unknown,unknown,"1
from collections import deque
2
3
def identify_faulty_readings(test_cases):
4
    results = []
5
6
    for case in test_cases:
7
        n, k, arr = case['n'], case['k'], case['arr']
8
        faulty_readings = []
9
        queue = deque()
10
11
        # Process the initial window of size k
12
        for i in range(k):
13
            if arr[i] < 0:
14
                queue.append(i)
15
16
        # Add the first result for the initial window
17
        faulty_readings.append(arr[queue[0]] if queue else 0)
18
19
        # Slide the window over the rest of the array
20
        for i in range(k, n):
21
            # Remove elements that are outside the current window
22
            while queue and queue[0] < i - k + 1:
23
                queue.popleft()
24
25
            # Add the current element if it is negative
26
            if arr[i] < 0:
27
                queue.append(i)
28
29
            # Add the result for the current window
30
            faulty_readings.append(arr[queue[0]] if queue else 0)
31
32
        results.append(faulty_readings)
33
34
    return results
35
36
# Function to read input data
37
def read_input():
38
    t = int(input())
39
    test_cases = []
40
41
    for _ in range(t):
42
        n, k = map(int, input().split())
43
        arr = list(map(int, input().split()))
44
        test_cases.append({'n': n, 'k': k, 'arr': arr})
45
46
    return test_cases
47
48
# Main function to produce output
49
def main():
50
    test_cases = read_input()
51
    results = identify_faulty_readings(test_cases)
52
53
    for res in results:
54
        print("" "".join(map(str, res)))
55
56
if __name__ == ""__main__"":
57
    main()
58",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052195
1390052174,unknown,unknown,unknown,"1
def min_effort_to_breach(n, k, firewalls):
2
    total_effort = sum(firewalls)
3
    4
    if k >= n:
5
        return 0  # If we can skip all firewalls, effort is 0
6
    7
    min_effort = total_effort
8
    9
    for i in range(n):
10
        temp_effort = total_effort
11
        skipped = 0
12
        13
        for j in range(i, n):
14
            if skipped < k:
15
                temp_effort -= firewalls[j]  # Skip this firewall
16
                skipped += 1
17
            else:
18
                temp_effort += skipped  # Increase due to previous skips
19
        20
        min_effort = min(min_effort, temp_effort)
21
    22
    return min_effort
23
24
def process_test_cases():
25
    T = int(input())
26
    for _ in range(T):
27
        n, k = map(int, input().split())
28
        firewalls = list(map(int, input().split()))
29
        print(min_effort_to_breach(n, k, firewalls))
30
31
if __name__ == ""__main__"":
32
    process_test_cases()
33
    ",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052174
1390052176,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process the remaining windows
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of this window
18
        while dq and dq[0] <= i - k:
19
            dq.popleft()
20
        21
        # Add new element if it's negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the result for the current window
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
# Read input
31
t = int(input())  # Number of test cases
32
for _ in range(t):
33
    n, k = map(int, input().split())  # Array size and batch size
34
    arr = list(map(int, input().split()))
35
    36
    # Get earliest faulty readings for batches
37
    output = earliest_faulty_reading(arr, k)
38
    39
    # Print result
40
    print("" "".join(map(str, output)))",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052176
1390052180,unknown,unknown,unknown,"1
import java.util.*;
2
3
public class Solution {
4
    public static void main(String[] args) {
5
        Scanner sc = new Scanner(System.in);
6
        int t = sc.nextInt(); // Number of test cases
7
        8
        while (t-- > 0) {
9
            int n = sc.nextInt(); // Size of array
10
            int k = sc.nextInt(); // Batch size
11
            int[] arr = new int[n];
12
            13
            for (int i = 0; i < n; i++) {
14
                arr[i] = sc.nextInt();
15
            }
16
            17
            List<Integer> result = findEarliestFaults(arr, k);
18
            for (int num : result) {
19
                System.out.print(num + "" "");
20
            }
21
            System.out.println();
22
        }
23
        24
        sc.close();
25
    }
26
    27
    public static List<Integer> findEarliestFaults(int[] arr, int k) {
28
        List<Integer> result = new ArrayList<>();
29
        Deque<Integer> deque = new LinkedList<>(); // Stores indices of negative values
30
        31
        // Process first window
32
        for (int i = 0; i < k; i++) {
33
            if (arr[i] < 0) {
34
                deque.addLast(i);
35
            }
36
        }
37
        38
        // Traverse the array in sliding window manner
39
        for (int i = k; i <= arr.length; i++) {
40
            // If there is any negative number in the current window
41
            if (!deque.isEmpty()) {
42
                result.add(arr[deque.peekFirst()]); // Earliest faulty reading
43
            } else {
44
                result.add(0); // No faults in this window
45
            }
46
            47
            // Remove elements that are out of this window
48
            if (!deque.isEmpty() && deque.peekFirst() <= i - k) {
49
                deque.pollFirst();
50
            }
51
            52
            // Add new element to deque (next window's last element)
53
            if (i < arr.length && arr[i] < 0) {
54
                deque.addLast(i);
55
            }
56
        }
57
        58
        return result;
59
    }
60
}",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052180
1390052167,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",186,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052167
1390052153,unknown,unknown,unknown,"1
from collections import deque
2
3
def solve():
4
    x = int(input())
5
    for _ in range(x):
6
        y, z = map(int, input().split())
7
        w = list(map(int, input().split()))
8
9
        d = deque()
10
        r = []
11
        12
        for i in range(y):
13
            while d and d[0] < i - z + 1:
14
                d.popleft()
15
            16
            if w[i] < 0:
17
                d.append(i)
18
            19
            if i >= z - 1:
20
                r.append(w[d[0]] if d else 0)
21
        22
        print(*r)
23
solve()",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052153
1390052160,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faults(arr, k):
4
    result = []
5
    q = deque()
6
    7
    for i in range(len(arr)):
8
        # Add current element if it is a faulty reading
9
        if arr[i] < 0:
10
            q.append(i)
11
12
        # Remove elements that are out of the current window
13
        while q and q[0] < i - k + 1:
14
            q.popleft()
15
16
        # Only start recording results after the first full window
17
        if i >= k - 1:
18
            if q:
19
                result.append(arr[q[0]])
20
            else:
21
                result.append(0)
22
    23
    return result
24
25
# Main driver code
26
t = int(input())
27
for _ in range(t):
28
    n, k = map(int, input().split())
29
    arr = list(map(int, input().split()))
30
    res = earliest_faults(arr, k)
31
    print(*res)
32",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052160
1390052166,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    # Base case: if we can skip all firewalls, effort is 0
5
    if k >= n:
6
        return 0
7
    8
    # Use dynamic programming to solve the problem
9
    # dp[i][j] = minimum effort to breach until firewall i having used j skips
10
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
11
    dp[0][0] = 0  # Base case: no firewalls, no skips, 0 effort
12
    13
    for i in range(1, n + 1):
14
        for j in range(k + 1):
15
            # Calculate the increased strength due to skips
16
            strength_increase = min(j, i - 1)
17
            18
            # Option 1: Don't skip the current firewall (if j skips used so far)
19
            if j <= i - 1:
20
                dp[i][j] = dp[i-1][j] + (firewalls[i-1] + strength_increase)
21
            22
            # Option 2: Skip the current firewall (if j > 0)
23
            if j > 0:
24
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
25
    26
    return min(dp[n])
27
28
# Process test cases
29
t = int(input())
30
for _ in range(t):
31
    n, k = map(int, input().split())
32
    firewalls = list(map(int, input().split()))
33
    34
    print(min_effort(firewalls, k))",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052166
1390052149,unknown,unknown,unknown,"1
import java.io.*;
2
import java.util.*;
3
import java.text.*;
4
import java.math.*;
5
import java.util.regex.*;
6
7
public class Solution {
8
9
    public static void main(String[] args) {
10
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
11
        Scanner scanner = new Scanner(System.in);
12
        int t = scanner.nextInt();
13
        14
        while (t-- > 0) {
15
            int n = scanner.nextInt();
16
            int k = scanner.nextInt();
17
            int[] arr = new int[n];
18
            19
            for (int i = 0; i < n; i++) {
20
                arr[i] = scanner.nextInt();
21
            }
22
            23
            List<Integer> result = new ArrayList<>();
24
            Deque<Integer> deque = new LinkedList<>();
25
            26
            for (int i = 0; i < n; i++) {
27
                if (!deque.isEmpty() && deque.peek() < i - k + 1) {
28
                    deque.poll();
29
                }
30
                if (arr[i] < 0) {
31
                    deque.offer(i);
32
                }
33
                if (i >= k - 1) {
34
                    result.add(deque.isEmpty() ? 0 : arr[deque.peek()]);
35
                }
36
            }
37
            38
            for (int num : result) {
39
                System.out.print(num + "" "");
40
            }
41
            System.out.println();
42
        }
43
        44
        scanner.close();
45
    }
46
}",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052149
1390052152,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_fault_in_batches(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    for i in range(len(arr) - k + 1):
12
        if dq:
13
            result.append(arr[dq[0]])
14
        else:
15
            result.append(0)
16
        17
        while dq and dq[0] < i + 1:
18
            dq.popleft()
19
        20
        if i + k < len(arr) and arr[i + k] < 0:
21
            dq.append(i + k)
22
    23
    return result
24
25
# Read input
26
t = int(input())
27
for _ in range(t):
28
    n, k = map(int, input().split())
29
    arr = list(map(int, input().split()))
30
    print(*earliest_fault_in_batches(arr, k))",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052152
1390052150,unknown,unknown,unknown,"1
#include <stdio.h>
2
3
void findEarliestFaults(int arr[], int n, int k) {
4
    for (int i = 0; i <= n - k; i++) {
5
        int found = 0;
6
        for (int j = i; j < i + k; j++) {
7
            if (arr[j] < 0) {
8
                printf(""%d "", arr[j]);
9
                found = 1;
10
                break;
11
            }
12
        }
13
        if (!found) {
14
            printf(""0 "");
15
        }
16
    }
17
    printf(""\n"");
18
}
19
20
int main() {
21
    int t;
22
    scanf(""%d"", &t);
23
    while (t--) {
24
        int n, k;
25
        scanf(""%d %d"", &n, &k);
26
        int arr[n];
27
        for (int i = 0; i < n; i++) {
28
            scanf(""%d"", &arr[i]);
29
        }
30
        findEarliestFaults(arr, n, k);
31
    }
32
    return 0;
33
}
34",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052150
1390052137,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(array, k):
4
    n = len(array)
5
    result = []
6
    dq = deque()
7
8
    for i in range(k):
9
        if array[i] < 0:
10
            dq.append(i)
11
12
    for i in range(n - k + 1):
13
        result.append(array[dq[0]] if dq else 0)
14
15
        if dq and dq[0] == i:
16
            dq.popleft()
17
18
        if i + k < n and array[i + k] < 0:
19
            dq.append(i + k)
20
21
    return result
22
t = int(input().strip())
23
for _ in range(t):
24
    n, k = map(int, input().strip().split())
25
    array = list(map(int, input().strip().split()))
26
    27
    print("" "".join(map(str, earliest_faulty_readings(array, k))))",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052137
1390052147,unknown,unknown,unknown,"1
def min_effort(firewalls, k):
2
    n = len(firewalls)
3
    4
    # Base case: if we can skip all firewalls, effort is 0
5
    if k >= n:
6
        return 0
7
    8
    # Use dynamic programming to solve the problem
9
    # dp[i][j] = minimum effort to breach until firewall i having used j skips
10
    dp = [[float('inf')] * (k + 1) for _ in range(n + 1)]
11
    dp[0][0] = 0  # Base case: no firewalls, no skips, 0 effort
12
    13
    for i in range(1, n + 1):
14
        for j in range(k + 1):
15
            # Calculate the increased strength due to skips
16
            strength_increase = min(j, i - 1)
17
            18
            # Option 1: Don't skip the current firewall (if j skips used so far)
19
            if j <= i - 1:
20
                dp[i][j] = dp[i-1][j] + (firewalls[i-1] + strength_increase)
21
            22
            # Option 2: Skip the current firewall (if j > 0)
23
            if j > 0:
24
                dp[i][j] = min(dp[i][j], dp[i-1][j-1])
25
    26
    return min(dp[n])
27
28
# Process test cases
29
t = int(input())
30
for _ in range(t):
31
    n, k = map(int, input().split())
32
    firewalls = list(map(int, input().split()))
33
    34
    print(min_effort(firewalls, k))",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390052147
1390052148,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        res = []
8
        dq = deque()
9
        10
        for i in range(n):
11
            # Remove elements that are out of the current window
12
            if dq and dq[0] < i - k + 1:
13
                dq.popleft()
14
            15
            # Add the new element if it's faulty (negative)
16
            if arr[i] < 0:
17
                dq.append(i)
18
            19
            # Start recording results once we reach the batch size k
20
            if i >= k - 1:
21
                res.append(arr[dq[0]] if dq else 0)
22
        23
        results.append("" "".join(map(str, res)))
24
    25
    return ""\n"".join(results)
26
27
# Read input
28
t = int(input())
29
test_cases = []
30
for _ in range(t):
31
    n, k = map(int, input().split())
32
    arr = list(map(int, input().split()))
33
    test_cases.append((n, k, arr))
34
35
# Get output and print
36
print(earliest_faulty_readings(test_cases))",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052148
1390052130,unknown,unknown,unknown,"1
def earliest_faulty_reading(test_cases):
2
    results = []
3
    4
    for n, k, arr in test_cases:
5
        batch_results = []
6
        7
        for i in range(n - k + 1):
8
            batch = arr[i:i + k]
9
            faulty = next((x for x in batch if x < 0), 0)
10
            batch_results.append(faulty)
11
        12
        results.append(batch_results)
13
    14
    return results
15
16
17
if __name__ == ""__main__"":
18
    t = int(input())
19
    test_cases = []
20
    21
    for _ in range(t):
22
        n, k = map(int, input().strip().split())
23
        arr = list(map(int, input().strip().split()))
24
        test_cases.append((n, k, arr))
25
26
    results = earliest_faulty_reading(test_cases)
27
    28
    for res in results:
29
        print(*res)
30",187,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052130
1390052102,unknown,unknown,unknown,"1
def find_earliest_faults(arr, k):
2
   3
    result = []
4
    for i in range(len(arr) - k + 1):
5
        batch = arr[i:i + k]
6
        earliest_fault = 0
7
        for j, reading in enumerate(batch):
8
            if reading < 0:
9
                earliest_fault = reading
10
                break
11
        result.append(earliest_fault)
12
    return result
13
14
def solve():
15
    t = int(input())
16
    for _ in range(t):
17
        n, k = map(int, input().split())
18
        arr = list(map(int, input().split()))
19
        result = find_earliest_faults(arr, k)
20
        print(*result)
21
22
solve()",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052102
1390052105,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
3
    results = []
4
5
    6
7
    # Loop through each possible batch
8
9
    for i in range(len(arr) - k + 1):
10
11
        fault_found = False
12
13
        14
15
        # Find earliest fault in current batch
16
17
        for j in range(i, i + k):
18
19
            if arr[j] < 0:
20
21
                results.append(arr[j])
22
23
                fault_found = True
24
25
                break
26
27
                28
29
        # If no fault found in batch, append 0
30
31
        if not fault_found:
32
33
            results.append(0)
34
35
    36
37
    return results
38
39
# Process test cases
40
41
t = int(input())
42
43
for _ in range(t):
44
45
    n, k = map(int, input().split())
46
47
    arr = list(map(int, input().split()))
48
49
    50
51
    result = earliest_fault(arr, k)
52
53
    print(*result)",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052105
1390052112,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    result = []
3
    4
    for i in range(len(arr) - k + 1):
5
        # Check each batch of size k
6
        batch = arr[i:i+k]
7
        fault_found = False
8
        9
        # Find the earliest fault in the current batch
10
        for num in batch:
11
            if num < 0:
12
                result.append(num)
13
                fault_found = True
14
                break
15
        16
        # If no fault is found in the batch, append 0
17
        if not fault_found:
18
            result.append(0)
19
    20
    return result
21
22
# Process the input
23
t = int(input())  # Number of test cases
24
25
for _ in range(t):
26
    n, k = map(int, input().split())  # Array size and batch size
27
    arr = list(map(int, input().split()))  # Array elements
28
    29
    result = earliest_fault(arr, k)
30
    print(*result)  # Print the result",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052112
1390052084,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_fault_in_batches(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    for i in range(k):
8
        if arr[i] < 0:
9
            dq.append(i)
10
    11
    for i in range(len(arr) - k + 1):
12
        if dq:
13
            result.append(arr[dq[0]])
14
        else:
15
            result.append(0)
16
        17
        while dq and dq[0] < i + 1:
18
            dq.popleft()
19
        20
        if i + k < len(arr) and arr[i + k] < 0:
21
            dq.append(i + k)
22
    23
    return result
24
25
# Read input
26
t = int(input())
27
for _ in range(t):
28
    n, k = map(int, input().split())
29
    arr = list(map(int, input().split()))
30
    print(*earliest_fault_in_batches(arr, k))
31",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052084
1390052086,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_reading(n, k, arr):
4
    result = []
5
    window = deque()
6
7
    for i in range(n):
8
        if window and window[0] <= i - k:
9
            window.popleft()
10
        11
        if arr[i] < 0:
12
            window.append(i)
13
        14
        if i >= k - 1:
15
            if window:
16
                result.append(arr[window[0]])
17
            else:
18
                result.append(0)
19
    20
    return result
21
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    result = earliest_faulty_reading(n, k, arr)
27
    print("" "".join(map(str, result)))",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052086
1390052095,unknown,unknown,unknown,"1
from collections import deque
2
3
def find_earliest_faults(test_cases):
4
    results = []
5
    6
    for n, k, arr in test_cases:
7
        fault_indices = deque()
8
        batch_results = []
9
        10
        for i in range(k):
11
            if arr[i] < 0:
12
                fault_indices.append(i)
13
        14
        batch_results.append(arr[fault_indices[0]] if fault_indices else 0)
15
        16
        for i in range(k, n):
17
            if fault_indices and fault_indices[0] <= i - k:
18
                fault_indices.popleft()
19
            20
            if arr[i] < 0:
21
                fault_indices.append(i)
22
            23
            batch_results.append(arr[fault_indices[0]] if fault_indices else 0)
24
        25
        results.append("" "".join(map(str, batch_results)))
26
    27
    return ""\n"".join(results)
28
29
test_count = int(input())
30
test_cases = []
31
32
for _ in range(test_count):
33
    n, k = map(int, input().split())
34
    arr = list(map(int, input().split()))
35
    test_cases.append((n, k, arr))
36
37
print(find_earliest_faults(test_cases))
38",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052095
1390052064,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    result = []
5
    dq = deque()
6
    7
    # Process first k elements
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Store the first result
13
    result.append(arr[dq[0]] if dq else 0)
14
    15
    # Process rest of the elements
16
    for i in range(k, len(arr)):
17
        # Remove elements that are out of the window
18
        while dq and dq[0] <= i - k:
19
            dq.popleft()
20
        21
        # Add new element if it's negative
22
        if arr[i] < 0:
23
            dq.append(i)
24
        25
        # Store the result
26
        result.append(arr[dq[0]] if dq else 0)
27
    28
    return result
29
30
def process_test_cases():
31
    t = int(input())
32
    for _ in range(t):
33
        n, k = map(int, input().split())
34
        arr = list(map(int, input().split()))
35
        print(*earliest_faulty_readings(arr, k))
36
37
if __name__ == ""__main__"":
38
    process_test_cases()",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052064
1390052073,unknown,unknown,unknown,"1
#include <stdio.h>
2
#include <stdlib.h>
3
4
void find_earliest_faulty(int arr[], int n, int k) {
5
    for (int i = 0; i <= n - k; i++) {
6
        int found = 0;
7
        for (int j = i; j < i + k; j++) {
8
            if (arr[j] < 0) {
9
                printf(""%d "", arr[j]);
10
                found = 1;
11
                break;
12
            }
13
        }
14
        if (!found) {
15
            printf(""0 "");
16
        }
17
    }
18
    printf(""\n"");
19
}
20
21
int main() {
22
    int t;
23
    scanf(""%d"", &t); // Read number of test cases
24
25
    while (t--) {
26
        int n, k;
27
        scanf(""%d %d"", &n, &k); // Read array size and batch size
28
        29
        int *arr = (int *)malloc(n * sizeof(int)); // Allocate memory for array
30
        for (int i = 0; i < n; i++) {
31
            scanf(""%d"", &arr[i]); // Read array elements
32
        }
33
34
        find_earliest_faulty(arr, n, k); // Process the array
35
36
        free(arr); // Free allocated memory
37
    }
38
39
    return 0;
40
}
41",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052073
1390052079,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
vector<int> earliest_faulty_readings(vector<int>& arr, int k) {
5
    int n = arr.size();
6
    vector<int> result;
7
    deque<int> dq;  // Stores indices of negative numbers
8
9
    // Process first window
10
    for (int i = 0; i < k; i++) {
11
        if (arr[i] < 0) dq.push_back(i);
12
    }
13
14
    // Process the sliding window
15
    for (int i = k; i <= n; i++) {
16
        // Append first negative number in the window
17
        if (!dq.empty()) 
18
            result.push_back(arr[dq.front()]);  // First negative in the deque
19
        else 
20
            result.push_back(0);  // No negative number
21
22
        // Remove elements that are out of the current window
23
        while (!dq.empty() && dq.front() < i - k + 1) {
24
            dq.pop_front();
25
        }
26
27
        // Add the next element if negative
28
        if (i < n && arr[i] < 0) {
29
            dq.push_back(i);
30
        }
31
    }
32
33
    return result;
34
}
35
36
int main() {
37
    int t;
38
    cin >> t;  // Number of test cases
39
    while (t--) {
40
        int n, k;
41
        cin >> n >> k;  // Size of array and batch size
42
        vector<int> arr(n);
43
        for (int i = 0; i < n; i++) {
44
            cin >> arr[i];
45
        }
46
        47
        vector<int> result = earliest_faulty_readings(arr, k);
48
        for (int num : result) {
49
            cout << num << "" "";
50
        }
51
        cout << endl;
52
    }
53
    return 0;
54
}
55",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052079
1390052061,unknown,unknown,unknown,"1
def earliest_fault(arr, k):
2
    results = []
3
    4
    # Loop through each possible batch
5
    for i in range(len(arr) - k + 1):
6
        fault_found = False
7
        8
        # Find earliest fault in current batch
9
        for j in range(i, i + k):
10
            if arr[j] < 0:
11
                results.append(arr[j])
12
                fault_found = True
13
                break
14
                15
        # If no fault found in batch, append 0
16
        if not fault_found:
17
            results.append(0)
18
    19
    return results
20
21
# Process test cases
22
t = int(input())
23
for _ in range(t):
24
    n, k = map(int, input().split())
25
    arr = list(map(int, input().split()))
26
    27
    result = earliest_fault(arr, k)
28
    print(*result)",188,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052061
1390046296,unknown,unknown,unknown,"1
def solve(s):
2
    pos = [i for i, ch in enumerate(s) if ch == '1']
3
    n = len(pos)
4
5
    if n == 0 or pos[-1] - pos[0] == n - 1:
6
        print(0)
7
        return
8
9
    left, right = 0, n
10
11
    while right - left > 1:
12
        mid = (left + right) // 2
13
        x = n - mid
14
15
        possible = False
16
        for i in range(mid + 1):
17
            l = pos[i]
18
            r = pos[i + x - 1]
19
            if (r - l + 1) - x <= mid:
20
                possible = True
21
                break
22
23
        if possible:
24
            right = mid
25
        else:
26
            left = mid
27
28
    print(right)
29
30
if __name__ == ""__main__"":
31
    t = int(input().strip())
32
33
    for _ in range(t):
34
        s = input().strip()
35
        solve(s)",189,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390046296
1390052056,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, k):
4
    n = len(arr)
5
    result = []
6
    dq = deque()  # To store indices of negative numbers
7
    8
    # Process the first window
9
    for i in range(k):
10
        if arr[i] < 0:
11
            dq.append(i)
12
    13
    # Store the result for the first window
14
    result.append(arr[dq[0]] if dq else 0)
15
    16
    # Process the remaining windows
17
    for i in range(k, n):
18
        # Remove elements that are out of the current window
19
        if dq and dq[0] < i - k + 1:
20
            dq.popleft()
21
        22
        # Add the current element if it is negative
23
        if arr[i] < 0:
24
            dq.append(i)
25
        26
        # Store the result for the current window
27
        result.append(arr[dq[0]] if dq else 0)
28
    29
    return result
30
31
# Reading input
32
t = int(input())  # Number of test cases
33
for _ in range(t):
34
    n, k = map(int, input().split())  # Size of array and batch size
35
    arr = list(map(int, input().split()))  # Array elements
36
    37
    # Get the results and print as space-separated values
38
    print(*earliest_faulty_readings(arr, k))
39",189,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052056
1390052059,unknown,unknown,unknown,"1
from collections import deque
2
3
def earliest_faulty_readings(arr, n, k):
4
    result = []
5
    dq = deque()  # Store indices of negative numbers
6
7
    # Process the first window
8
    for i in range(k):
9
        if arr[i] < 0:
10
            dq.append(i)
11
    12
    # Process remaining windows
13
    for i in range(n - k + 1):
14
        # If deque is not empty, the front of the queue is the earliest negative
15
        if dq:
16
            result.append(arr[dq[0]])
17
        else:
18
            result.append(0)
19
20
        # Remove elements that are out of this window
21
        if dq and dq[0] == i:
22
            dq.popleft()
23
24
        # Add the next element of the window
25
        if i + k < n and arr[i + k] < 0:
26
            dq.append(i + k)
27
28
    print(*result)  # Print space-separated output
29
30
# Read input
31
t = int(input())  # Number of test cases
32
for _ in range(t):
33
    n, k = map(int, input().split())  # Size of array and batch size
34
    arr = list(map(int, input().split()))  # Array elements
35
    earliest_faulty_readings(arr, n, k)
36",189,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/faulty-sensor-readings/submissions/code/1390052059
1390046257,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
#define ll long long
5
#define ld long double
6
7
void solve() {
8
  string s;
9
  cin >> s;
10
11
  vector<int> pos;
12
  int n = s.length();
13
14
  for (int i = 0; i < n; ++i) {
15
    if (s[i] == '1') {
16
      pos.push_back(i);
17
    }
18
  }
19
20
  int lf = 0, rg = pos.size();
21
22
  while (rg - lf > 1) {
23
    int mid = (lf + rg) / 2;
24
    int k = pos.size();
25
    int x = k - mid;
26
27
    bool possible = false;
28
    for (int i = 0; i <= mid; ++i) {
29
      int l = pos[i];
30
      int r = pos[i + x - 1];
31
      if (r - l + 1 - x <= mid) {
32
        possible = true;
33
        break;
34
      }
35
    }
36
37
    if (possible) {
38
      rg = mid;
39
    } else {
40
      lf = mid;
41
    }
42
  }
43
44
  if (pos.empty() || pos.back() - pos[0] == pos.size() - 1) {
45
    cout << 0 << endl;
46
  } else {
47
    cout << rg << endl;
48
  }
49
}
50
51
int main() {
52
  ios::sync_with_stdio(0);
53
  cin.tie(0);
54
55
  ll t;
56
  cin >> t;
57
58
  while (t--) {
59
    solve();
60
  }
61
62
  return 0;
63
}
64",189,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/server-pruning/submissions/code/1390046257
1390046239,unknown,unknown,unknown,"1
#include <bits/stdc++.h>
2
using namespace std;
3
4
#define ll long long
5
#define ld long double
6
7
void solve() {
8
  ll n, k;
9
  cin >> n >> k;
10
11
  vector<ll> strengths(n);
12
  ll tot = 0;
13
  for (ll i = 0; i < n; i++) {
14
    cin >> strengths[i];
15
    tot += strengths[i];
16
  }
17
18
  vector<ll> skip(n);
19
  for (ll i = 0; i < n; i++) {
20
    skip[i] = strengths[i] - (n - i - 1);
21
  }
22
  sort(skip.rbegin(), skip.rend());
23
24
  for (ll i = 0; i < k; i++) {
25
    tot -= skip[i];
26
  }
27
  tot -= k * (k - 1) / 2;
28
29
  cout << tot << '\n';
30
}
31
32
int main() {
33
  ios::sync_with_stdio(0);
34
  cin.tie(0);
35
36
  ll t;
37
  cin >> t;
38
39
  while (t--) {
40
    solve();
41
  }
42
43
  return 0;
44
}",189,https://www.hackerrank.com/contests/tcet-shastra-coding-contest-13-a/challenges/breach-firewall/submissions/code/1390046239
